public class LwjglDebugStarter { public static void main ( String [ ] argv ) { new SharedLibraryLoader ( "../../extensions/gdx-audio/libs/gdx-audio-natives.jar" ) . load ( "gdx-audio" ) ; new SharedLibraryLoader ( "../../extensions/gdx-image/libs/gdx-image-natives.jar" ) . load ( "gdx-image" ) ; new SharedLibraryLoader ( "../../extensions/gdx-freetype/libs/gdx-freetype-natives.jar" ) . load ( "gdx-freetype" ) ; new SharedLibraryLoader ( "../../extensions/gdx-controllers/gdx-controllers-desktop/libs/gdx-controllers-desktop-natives.jar" ) . load ( "gdx-controllers-desktop" ) ; new SharedLibraryLoader ( "../../gdx/libs/gdx-natives.jar" ) . load ( "gdx" ) ; <START_BUG> GdxTest test = new BatchRenderTest ( ) ; <END_BUG> LwjglApplicationConfiguration config = new LwjglApplicationConfiguration ( ) ; config . useGL20 = test . needsGL20 ( ) ; new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( test , config ) ; } }
 GdxTest test = new BatchRenderTest ( ) ; 
<BUG2FIX>
GdxTest test = new JsonModelLoaderTest ( ) ;

public class TextureDataTest extends GdxTest { private SpriteBatch spriteBatch ; private Sprite sprite ; public void create ( ) { spriteBatch = new SpriteBatch ( ) ; sprite = new Sprite ( new Texture ( new TextureData ( ) { int width = 0 ; int height = 0 ; public void load ( ) { <START_BUG> Pixmap pixmap = new Pixmap ( files . internal ( "data/badlogicsmall.jpg" ) ) ; <END_BUG> gl . glTexImage2D ( GL_TEXTURE_2D , 0 , pixmap . getGLInternalFormat ( ) , pixmap . getWidth ( ) , pixmap . getHeight ( ) , 0 , pixmap . getGLFormat ( ) , pixmap . getGLType ( ) , pixmap . getPixels ( ) ) ; width = pixmap . getWidth ( ) ; height = pixmap . getHeight ( ) ; pixmap . dispose ( ) ; } public int getWidth ( ) { return width ; } public int getHeight ( ) { return height ; } } ) ) ; } public void render ( ) { } public boolean needsGL20 ( ) { } }
 Pixmap pixmap = new Pixmap ( files . internal ( "data/badlogicsmall.jpg" ) ) ; 
<BUG2FIX>
Pixmap pixmap = new Pixmap ( files . internal ( "data/stone2.png" ) ) ;

public class MissileAI { private float MAX_LIFETIME = 5 ; private Ship target ; private Missile missile ; Vector2 relativeVel = new Vector2 ( ) ; Vector2 toTarget = new Vector2 ( ) ; public MissileAI ( Missile missile ) { } public void retarget ( ) { } public void selfDestruct ( ) { } public Vector2 predict ( ) { relativeVel . set ( missile . velocity ) . sub ( target . velocity ) ; toTarget . set ( target . collisionCenter ) . sub ( missile . collisionCenter ) ; if ( ( missile . velocity . dot ( toTarget ) ) != 0 ) { float time_to_target = ( toTarget . dot ( toTarget ) ) / ( relativeVel . dot ( toTarget ) ) ; <START_BUG> return new Vector2 ( target . collisionCenter ) . sub ( relativeVel . scl ( Math . max ( 0 , time_to_target ) ) ) ; <END_BUG> } else { return target . collisionCenter ; } } public void update ( ) { } }
 return new Vector2 ( target . collisionCenter ) . sub ( relativeVel . scl ( Math . max ( 0 , time_to_target ) ) ) ; 
<BUG2FIX>
return new Vector2 ( target . collisionCenter ) . sub ( relativeVel . mul ( Math . max ( 0 , time_to_target ) ) ) ;

public class TransportBenchmark { static enum Type { LOCAL ( ) { @ Override public Transport newTransport ( Settings settings , ThreadPool threadPool ) { } } , NETTY ( ) { @ Override public Transport newTransport ( Settings settings , ThreadPool threadPool ) { } } ; public abstract Transport newTransport ( Settings settings , ThreadPool threadPool ) { } } public static void main ( String [ ] args ) { <START_BUG> final String executor = Names . CACHED ; <END_BUG> final boolean waitForRequest = true ; final ByteSizeValue payloadSize = new ByteSizeValue ( 100 , ByteSizeUnit . BYTES ) ; final int NUMBER_OF_CLIENTS = 1 ; final int NUMBER_OF_ITERATIONS = 100000 ; final byte [ ] payload = new byte [ ( ( int ) ( payloadSize . bytes ( ) ) ) ] ; final AtomicLong idGenerator = new AtomicLong ( ) ; final TransportBenchmark . Type type = TransportBenchmark . Type . NETTY ; Settings settings = ImmutableSettings . settingsBuilder ( ) . build ( ) ; final ThreadPool serverThreadPool = new ThreadPool ( ) ; final TransportService serverTransportService = new TransportService ( type . newTransport ( settings , serverThreadPool ) , serverThreadPool ) . start ( ) ; final ThreadPool clientThreadPool = new ThreadPool ( ) ; final TransportService clientTransportService = new TransportService ( type . newTransport ( settings , clientThreadPool ) , clientThreadPool ) . start ( ) ; final DiscoveryNode node = new DiscoveryNode ( "server" , serverTransportService . boundAddress ( ) . publishAddress ( ) ) ; serverTransportService . registerHandler ( "benchmark" , new BaseTransportRequestHandler < BenchmarkMessage > ( ) { @ Override public BenchmarkMessage newInstance ( ) { return new BenchmarkMessage ( ) ; } @ Override public String executor ( ) { return executor ; } @ Override public void messageReceived ( BenchmarkMessage request , TransportChannel channel ) throws Exception { channel . sendResponse ( request ) ; } } ) ; clientTransportService . connectToNode ( node ) ; for ( int i = 0 ; i < 10000 ; i ++ ) { BenchmarkMessage message = new BenchmarkMessage ( 1 , payload ) ; clientTransportService . submitRequest ( node , "benchmark" , message , new BaseTransportResponseHandler < BenchmarkMessage > ( ) { @ Override public BenchmarkMessage newInstance ( ) { return new BenchmarkMessage ( ) ; } @ Override public String executor ( ) { return Names . SAME ; } @ Override public void handleResponse ( BenchmarkMessage response ) { } @ Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; } } ) . txGet ( ) ; } Thread [ ] clients = new Thread [ NUMBER_OF_CLIENTS ] ; final CountDownLatch latch = new CountDownLatch ( ( NUMBER_OF_CLIENTS * NUMBER_OF_ITERATIONS ) ) ; for ( int i = 0 ; i < NUMBER_OF_CLIENTS ; i ++ ) { clients [ i ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( int j = 0 ; j < NUMBER_OF_ITERATIONS ; j ++ ) { final long id = idGenerator . incrementAndGet ( ) ; BenchmarkMessage message = new BenchmarkMessage ( id , payload ) ; BaseTransportResponseHandler < BenchmarkMessage > handler = new BaseTransportResponseHandler < BenchmarkMessage > ( ) { @ Override public BenchmarkMessage newInstance ( ) { return new BenchmarkMessage ( ) ; } @ Override public String executor ( ) { return executor ; } @ Override public void handleResponse ( BenchmarkMessage response ) { if ( ( response . id ) != id ) { System . out . println ( ( ( ( ( "NO<seq2seq4repair_space>ID<seq2seq4repair_space>MATCH<seq2seq4repair_space>[" + ( response . id ) ) + "]<seq2seq4repair_space>and<seq2seq4repair_space>[" ) + id ) + "]" ) ) ; } latch . countDown ( ) ; } @ Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; latch . countDown ( ) ; } } ; if ( waitForRequest ) { clientTransportService . submitRequest ( node , "benchmark" , message , handler ) . txGet ( ) ; } else { clientTransportService . sendRequest ( node , "benchmark" , message , handler ) ; } } } } ) ; } StopWatch stopWatch = new StopWatch ( ) . start ( ) ; for ( int i = 0 ; i < NUMBER_OF_CLIENTS ; i ++ ) { clients [ i ] . start ( ) ; } try { latch . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } stopWatch . stop ( ) ; System . out . println ( ( ( ( ( ( ( ( ( ( "Ran<seq2seq4repair_space>[" + NUMBER_OF_CLIENTS ) + "],<seq2seq4repair_space>each<seq2seq4repair_space>with<seq2seq4repair_space>[" ) + NUMBER_OF_ITERATIONS ) + "]<seq2seq4repair_space>iterations,<seq2seq4repair_space>payload<seq2seq4repair_space>[" ) + payloadSize ) + "]:<seq2seq4repair_space>took<seq2seq4repair_space>[" ) + ( stopWatch . totalTime ( ) ) ) + "],<seq2seq4repair_space>TPS:<seq2seq4repair_space>" ) + ( ( NUMBER_OF_CLIENTS * NUMBER_OF_ITERATIONS ) / ( stopWatch . totalTime ( ) . secondsFrac ( ) ) ) ) ) ; clientTransportService . close ( ) ; clientThreadPool . shutdownNow ( ) ; serverTransportService . close ( ) ; serverThreadPool . shutdownNow ( ) ; } }
 final String executor = Names . CACHED ; 
<BUG2FIX>
final String executor = Names . GENERIC ;

@ Test public class SimpleIndexQueryParserTests { private IndexQueryParserService queryParser ; @ BeforeClass public void setupQueryParser ( ) throws IOException { } private XContentIndexQueryParser queryParser ( ) throws IOException { } @ Test public void testQueryStringBuilder ( ) throws Exception { } @ Test public void testQueryString ( ) throws Exception { } @ Test public void testQueryStringFields1Builder ( ) throws Exception { } @ Test public void testQueryStringFields1 ( ) throws Exception { } @ Test public void testQueryStringFields2Builder ( ) throws Exception { } @ Test public void testQueryStringFields2 ( ) throws Exception { } @ Test public void testQueryStringFields3Builder ( ) throws Exception { } @ Test public void testQueryStringFields3 ( ) throws Exception { } @ Test public void testMatchAllBuilder ( ) throws Exception { } @ Test public void testMatchAll ( ) throws Exception { } @ Test public void testDisMaxBuilder ( ) throws Exception { } @ Test public void testDisMax ( ) throws Exception { } @ Test public void testTermQueryBuilder ( ) throws IOException { } @ Test public void testTermQuery ( ) throws IOException { } @ Test public void testFuzzyQueryBuilder ( ) throws IOException { } @ Test public void testFuzzyQuery ( ) throws IOException { } @ Test public void testFuzzyQueryWithFieldsBuilder ( ) throws IOException { } @ Test public void testFuzzyQueryWithFields ( ) throws IOException { } @ Test public void testFieldQueryBuilder1 ( ) throws IOException { } @ Test public void testFieldQuery1 ( ) throws IOException { } @ Test public void testFieldQuery2 ( ) throws IOException { } @ Test public void testFieldQuery3 ( ) throws IOException { } @ Test public void testTermWithBoostQueryBuilder ( ) throws IOException { } @ Test public void testTermWithBoostQuery ( ) throws IOException { } @ Test public void testPrefixQueryBuilder ( ) throws IOException { } @ Test public void testPrefixQuery ( ) throws IOException { } @ Test public void testPrefixFilteredQueryBuilder ( ) throws IOException { } @ Test public void testPrefixFilteredQuery ( ) throws IOException { } @ Test public void testPrefixNamedFilteredQuery ( ) throws IOException { } @ Test public void testPrefixQueryBoostQueryBuilder ( ) throws IOException { } @ Test public void testPrefixQueryBoostQuery ( ) throws IOException { } @ Test public void testWildcardQueryBuilder ( ) throws IOException { } @ Test public void testWildcardQuery ( ) throws IOException { } @ Test public void testRangeQueryBuilder ( ) throws IOException { } @ Test public void testRangeQuery ( ) throws IOException { } @ Test public void testRange2Query ( ) throws IOException { } @ Test public void testRangeFilteredQueryBuilder ( ) throws IOException { } @ Test public void testRangeFilteredQuery ( ) throws IOException { } @ Test public void testRangeNamedFilteredQuery ( ) throws IOException { } @ Test public void testBoolFilteredQuery ( ) throws IOException { IndexQueryParser queryParser = queryParser ( ) ; String query = copyToStringFromClasspath ( "/org/elasticsearch/index/query/xcontent/bool-filter.json" ) ; Query parsedQuery = queryParser . parse ( query ) . query ( ) ; assertThat ( parsedQuery , instanceOf ( FilteredQuery . class ) ) ; FilteredQuery filteredQuery = ( ( FilteredQuery ) ( parsedQuery ) ) ; <START_BUG> BooleanFilter booleanFilter = ( ( BooleanFilter ) ( filteredQuery . getFilter ( ) ) ) ; <END_BUG> } @ Test public void testAndFilteredQueryBuilder ( ) throws IOException { } @ Test public void testAndFilteredQuery ( ) throws IOException { } @ Test public void testAndNamedFilteredQuery ( ) throws IOException { } @ Test public void testAndFilteredQuery2 ( ) throws IOException { } @ Test public void testOrFilteredQueryBuilder ( ) throws IOException { } @ Test public void testOrFilteredQuery ( ) throws IOException { } @ Test public void testOrFilteredQuery2 ( ) throws IOException { } @ Test public void testNotFilteredQueryBuilder ( ) throws IOException { } @ Test public void testNotFilteredQuery ( ) throws IOException { } @ Test public void testBoolQueryBuilder ( ) throws IOException { } @ Test public void testBoolQuery ( ) throws IOException { } @ Test public void testFilteredQueryBuilder ( ) throws IOException { } @ Test public void testFilteredQuery ( ) throws IOException { } @ Test public void testFilteredQuery2 ( ) throws IOException { } @ Test public void testFilteredQuery3 ( ) throws IOException { } @ Test public void testFilteredQuery4 ( ) throws IOException { } @ Test public void testTermFilterQuery ( ) throws Exception { } @ Test public void testTermNamedFilterQuery ( ) throws Exception { } @ Test public void testTermsFilterQueryBuilder ( ) throws Exception { } @ Test public void testTermsFilterQuery ( ) throws Exception { } @ Test public void testTermsWithNameFilterQuery ( ) throws Exception { } @ Test public void testConstantScoreQueryBuilder ( ) throws IOException { } @ Test public void testConstantScoreQuery ( ) throws IOException { } @ Test public void testCustomScoreQuery1 ( ) throws IOException { } @ Test public void testCustomBoostFactorQueryBuilder ( ) throws IOException { } @ Test public void testCustomBoostFactorQuery ( ) throws IOException { } @ Test public void testSpanTermQueryBuilder ( ) throws IOException { } @ Test public void testSpanTermQuery ( ) throws IOException { } @ Test public void testSpanNotQueryBuilder ( ) throws IOException { } @ Test public void testSpanNotQuery ( ) throws IOException { } @ Test public void testSpanFirstQueryBuilder ( ) throws IOException { } @ Test public void testSpanFirstQuery ( ) throws IOException { } @ Test public void testSpanNearQueryBuilder ( ) throws IOException { } @ Test public void testSpanNearQuery ( ) throws IOException { } @ Test public void testSpanOrQueryBuilder ( ) throws IOException { } @ Test public void testSpanOrQuery ( ) throws IOException { } @ Test public void testQueryFilterBuilder ( ) throws Exception { } @ Test public void testQueryFilter ( ) throws Exception { } @ Test public void testFQueryFilter ( ) throws Exception { } @ Test public void testMoreLikeThisBuilder ( ) throws Exception { } @ Test public void testMoreLikeThis ( ) throws Exception { }
 BooleanFilter booleanFilter = ( ( BooleanFilter ) ( filteredQuery . getFilter ( ) ) ) ; 
<BUG2FIX>
XBooleanFilter booleanFilter = ( ( XBooleanFilter ) ( filteredQuery . getFilter ( ) ) ) ;

public class PercolatorTests extends ElasticsearchIntegrationTest { @ Test public void testSimple1 ( ) throws Exception { } @ Test public void testSimple2 ( ) throws Exception { } @ Test public void testRangeFilterThatUsesFD ( ) throws Exception { } @ Test public void testPercolateQueriesWithRouting ( ) throws Exception { } @ Test public void percolateOnRecreatedIndex ( ) throws Exception { } @ Test public void percolateCustomAnalyzer ( ) throws Exception { } @ Test public void createIndexAndThenRegisterPercolator ( ) throws Exception { } @ Test public void multiplePercolators ( ) throws Exception { } @ Test public void dynamicAddingRemovingQueries ( ) throws Exception { } @ Test public void percolateWithSizeField ( ) throws Exception { } @ Test public void testPercolateStatistics ( ) throws Exception { } @ Test public void testPercolatingExistingDocs ( ) throws Exception { } @ Test public void testPercolatingExistingDocs_routing ( ) throws Exception { } @ Test public void testPercolatingExistingDocs_versionCheck ( ) throws Exception { } @ Test public void testPercolateMultipleIndicesAndAliases ( ) throws Exception { } @ Test public void testCountPercolation ( ) throws Exception { } @ Test public void testCountPercolatingExistingDocs ( ) throws Exception { } @ Test public void testPercolateSizingWithQueryAndFilter ( ) throws Exception { } @ Test public void testPercolateScoreAndSorting ( ) throws Exception { } @ Test public void testPercolateSortingWithNoSize ( ) throws Exception { } @ Test public void testPercolateSorting_unsupportedField ( ) throws Exception { } @ Test public void testPercolateOnEmptyIndex ( ) throws Exception { } @ Test public void testPercolateNotEmptyIndexButNoRefresh ( ) throws Exception { } @ Test public void testPercolatorWithHighlighting ( ) throws Exception { } @ Test @ TestLogging ( "action.admin.indices.mapping.delete:TRACE" ) public void testDeletePercolatorType ( ) throws Exception { } public static String [ ] convertFromTextArray ( PercolateResponse [ ] matches , String index ) { } @ Test public void percolateNonMatchingConstantScoreQuery ( ) throws Exception { } @ Test public void testNestedPercolation ( ) throws IOException { } @ Test public void testNestedPercolationOnExistingDoc ( ) throws IOException { } @ Test public void testPercolationWithDynamicTemplates ( ) throws Exception { <START_BUG> assertAcked ( prepareCreate ( "idx" ) . addMapping ( "type" , jsonBuilder ( ) . startObject ( ) . startObject ( "type" ) . field ( "dynamic" , false ) . startObject ( "properties" ) . startObject ( "custom" ) . field ( "dynamic" , true ) . field ( "type" , "object" ) . field ( "incude_in_all" , false ) . endObject ( ) . endObject ( ) . startArray ( "dynamic_template" ) . startObject ( ) . startObject ( "custom_fields" ) . field ( "path_match" , "custom.*" ) . startObject ( "mapping" ) . field ( "index" , "not_analyzed" ) . endObject ( ) . endObject ( ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) ) ) ; <END_BUG> client ( ) . prepareIndex ( "idx" , TYPE_NAME , "1" ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( "query" , QueryBuilders . queryString ( "color:red" ) ) . endObject ( ) ) . get ( ) ; client ( ) . prepareIndex ( "idx" , TYPE_NAME , "2" ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( "query" , QueryBuilders . queryString ( "color:blue" ) ) . endObject ( ) ) . get ( ) ; PercolateResponse percolateResponse = client ( ) . preparePercolate ( ) . setDocumentType ( "type" ) . setPercolateDoc ( new PercolateSourceBuilder . DocBuilder ( ) . setDoc ( jsonBuilder ( ) . startObject ( ) . startObject ( "custom" ) . field ( "color" , "blue" ) . endObject ( ) . endObject ( ) ) ) . get ( ) ; assertMatchCount ( percolateResponse , 0L ) ; assertThat ( percolateResponse . getMatches ( ) , arrayWithSize ( 0 ) ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( LANGUID ) . execute ( ) . actionGet ( ) ; awaitBusy ( new Predicate < Object > ( ) { @ Override public boolean apply ( Object input ) { PendingClusterTasksResponse pendingTasks = client ( ) . admin ( ) . cluster ( ) . preparePendingClusterTasks ( ) . get ( ) ; return pendingTasks . pendingTasks ( ) . isEmpty ( ) ; } } ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( LANGUID ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( "idx" , TYPE_NAME , "2" ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( "query" , QueryBuilders . queryString ( "color:blue" ) ) . endObject ( ) ) . get ( ) ; percolateResponse = client ( ) . preparePercolate ( ) . setDocumentType ( "type" ) . setPercolateDoc ( new PercolateSourceBuilder . DocBuilder ( ) . setDoc ( jsonBuilder ( ) . startObject ( ) . startObject ( "custom" ) . field ( "color" , "blue" ) . endObject ( ) . endObject ( ) ) ) . get ( ) ; assertMatchCount ( percolateResponse , 1L ) ; assertThat ( percolateResponse . getMatches ( ) [ 0 ] . getId ( ) . string ( ) , equalTo ( "2" ) ) ; } @ Test public void testUpdateMappingDynamicallyWhilePercolating ( ) throws Exception { } @ Test public void testDontReportDeletedPercolatorDocs ( ) throws Exception { } void initNestedIndexAndPercolation ( ) throws IOException { } XContentBuilder getMatchingNestedDoc ( ) throws IOException { } XContentBuilder getNotMatchingNestedDoc ( ) throws IOException { } }
 assertAcked ( prepareCreate ( "idx" ) . addMapping ( "type" , jsonBuilder ( ) . startObject ( ) . startObject ( "type" ) . field ( "dynamic" , false ) . startObject ( "properties" ) . startObject ( "custom" ) . field ( "dynamic" , true ) . field ( "type" , "object" ) . field ( "incude_in_all" , false ) . endObject ( ) . endObject ( ) . startArray ( "dynamic_template" ) . startObject ( ) . startObject ( "custom_fields" ) . field ( "path_match" , "custom.*" ) . startObject ( "mapping" ) . field ( "index" , "not_analyzed" ) . endObject ( ) . endObject ( ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) ) ) ; 
<BUG2FIX>
assertAcked ( prepareCreate ( "idx" ) . addMapping ( "type" , jsonBuilder ( ) . startObject ( ) . startObject ( "type" ) . field ( "dynamic" , false ) . startObject ( "properties" ) . startObject ( "custom" ) . field ( "dynamic" , true ) . field ( "type" , "object" ) . field ( "incude_in_all" , false ) . endObject ( ) . endObject ( ) . startArray ( "dynamic_templates" ) . startObject ( ) . startObject ( "custom_fields" ) . field ( "path_match" , "custom.*" ) . startObject ( "mapping" ) . field ( "index" , "not_analyzed" ) . endObject ( ) . endObject ( ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) ) ) ;

public class JoglDebugStarter { public static void main ( String [ ] argv ) { <START_BUG> new com . badlogic . gdx . backends . jogl . JoglApplication ( new com . badlogic . gdx . tests . MultiTouchActorTest ( ) , "Debug<seq2seq4repair_space>Test" , 480 , 320 , false ) ; <END_BUG> } }
 new com . badlogic . gdx . backends . jogl . JoglApplication ( new com . badlogic . gdx . tests . MultiTouchActorTest ( ) , "Debug<seq2seq4repair_space>Test" , 480 , 320 , false ) ; 
<BUG2FIX>
new com . badlogic . gdx . backends . jogl . JoglApplication ( new com . badlogic . gdx . tests . SimpleStageCullingTest ( ) , "Debug<seq2seq4repair_space>Test" , 480 , 320 , false ) ;

public class TransportNodesListShardStoreMetaData extends TransportNodesOperationAction < TransportNodesListShardStoreMetaData . Request , TransportNodesListShardStoreMetaData . NodesStoreFilesMetaData , TransportNodesListShardStoreMetaData . NodeRequest , TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData > { private final IndicesService indicesService ; private final NodeEnvironment nodeEnv ; @ Inject public TransportNodesListShardStoreMetaData ( Settings settings , ClusterName clusterName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , IndicesService indicesService , NodeEnvironment nodeEnv ) { } public ActionFuture < TransportNodesListShardStoreMetaData . NodesStoreFilesMetaData > list ( ShardId shardId , boolean onlyUnallocated , Set < String > nodesIds , @ Nullable TimeValue timeout ) { } @ Override protected String executor ( ) { <START_BUG> return Names . CACHED ; <END_BUG> } @ Override protected String transportAction ( ) { } @ Override protected TransportNodesListShardStoreMetaData . Request newRequest ( ) { } @ Override protected TransportNodesListShardStoreMetaData . NodeRequest newNodeRequest ( ) { } @ Override protected TransportNodesListShardStoreMetaData . NodeRequest newNodeRequest ( String nodeId , TransportNodesListShardStoreMetaData . Request request ) { } @ Override protected TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData newNodeResponse ( ) { } @ Override protected TransportNodesListShardStoreMetaData . NodesStoreFilesMetaData newResponse ( TransportNodesListShardStoreMetaData . Request request , AtomicReferenceArray responses ) { } @ Override protected TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData nodeOperation ( TransportNodesListShardStoreMetaData . NodeRequest request ) throws ElasticSearchException { } private TransportNodesListShardStoreMetaData . StoreFilesMetaData listStoreMetaData ( ShardId shardId ) throws IOException { } @ Override protected boolean accumulateExceptions ( ) { } public static class StoreFilesMetaData implements Iterable < StoreFileMetaData > , Streamable { private boolean allocated ; private ShardId shardId ; private Map < String , StoreFileMetaData > files ; StoreFilesMetaData ( ) { } public StoreFilesMetaData ( boolean allocated , ShardId shardId , Map < String , StoreFileMetaData > files ) { } public boolean allocated ( ) { } public ShardId shardId ( ) { } public long totalSizeInBytes ( ) { } @ Override public Iterator < StoreFileMetaData > iterator ( ) { } public boolean fileExists ( String name ) { } public StoreFileMetaData file ( String name ) { } public static TransportNodesListShardStoreMetaData . StoreFilesMetaData readStoreFilesMetaData ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } static class Request extends NodesOperationRequest { private ShardId shardId ; private boolean unallocated ; public Request ( ) { } public Request ( ShardId shardId , boolean unallocated , Set < String > nodesIds ) { } public Request ( ShardId shardId , boolean unallocated , String ... nodesIds ) { } @ Override public TransportNodesListShardStoreMetaData . Request timeout ( TimeValue timeout ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } public static class NodesStoreFilesMetaData extends NodesOperationResponse < TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData > { private FailedNodeException [ ] failures ; NodesStoreFilesMetaData ( ) { } public NodesStoreFilesMetaData ( ClusterName clusterName , TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData [ ] nodes , FailedNodeException [ ] failures ) { } public FailedNodeException [ ] failures ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } static class NodeRequest extends NodeOperationRequest { private ShardId shardId ; private boolean unallocated ; NodeRequest ( ) { } NodeRequest ( String nodeId , ShardId shardId , boolean unallocated ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } public static class NodeStoreFilesMetaData extends NodeOperationResponse { private TransportNodesListShardStoreMetaData . StoreFilesMetaData storeFilesMetaData ; NodeStoreFilesMetaData ( ) { } public NodeStoreFilesMetaData ( DiscoveryNode node , TransportNodesListShardStoreMetaData . StoreFilesMetaData storeFilesMetaData ) { } public TransportNodesListShardStoreMetaData . StoreFilesMetaData storeFilesMetaData ( ) { } public static TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData readListShardStoreNodeOperationResponse ( StreamInput in ) throws IOException { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
 return Names . CACHED ; 
<BUG2FIX>
return Names . GENERIC ;

public class LwjglDebugStarter { public static void main ( String [ ] argv ) { <START_BUG> GdxTest test = new MusicTest ( ) ; <END_BUG> LwjglApplicationConfiguration config = new LwjglApplicationConfiguration ( ) ; config . r = config . g = config . b = config . a = 8 ; config . width = 960 ; config . height = 600 ; new com . badlogic . gdx . backends . lwjgl . LwjglApplication ( test , config ) ; } }
 GdxTest test = new MusicTest ( ) ; 
<BUG2FIX>
GdxTest test = new TimerTest ( ) ;

public final class OrthographicCamera { public enum Side { FRONT , BACK , TOP , BOTTOM , LEFT , RIGHT ; } private OrthographicCamera . Side side ; private Vector3 position = new Vector3 ( ) ; private Vector3 direction = new Vector3 ( 0 , 0 , ( - 1 ) ) ; private Vector3 up = new Vector3 ( 0 , 0 , ( - 1 ) ) ; private Vector3 axis = new Vector3 ( 0 , 1 , 0 ) ; private float near = - 1000 ; private float far = 1000 ; private float scale = 1.0F ; private float viewportWidth = 0 ; private float viewportHeight = 0 ; private final Matrix4 proj = new Matrix4 ( ) ; private final Matrix4 model = new Matrix4 ( ) ; private final Matrix4 combined = new Matrix4 ( ) ; private final Matrix4 rotationMatrix = new Matrix4 ( ) ; public OrthographicCamera ( ) { } public OrthographicCamera . Side getSide ( ) { } public void setSide ( OrthographicCamera . Side side ) { } public float getNear ( ) { } public void setNear ( float near ) { } public float getFar ( ) { } public void setFar ( float far ) { } public float getScale ( ) { } public void setScale ( float scale ) { } public Vector3 getPosition ( ) { } public void setViewport ( float width , float height ) { } Vector3 tmp = new Vector3 ( ) ; public void update ( ) { } public void setMatrices ( ) { update ( ) ; <START_BUG> GL10 gl = graphics . getGL10 ( ) ; <END_BUG> gl . glMatrixMode ( GL_PROJECTION ) ; gl . glLoadMatrixf ( getCombinedMatrix ( ) . val , 0 ) ; gl . glMatrixMode ( GL_MODELVIEW ) ; gl . glLoadIdentity ( ) ; } private Matrix4 calculateRotationMatrix ( ) { } public void getScreenToWorld ( float screenX , float screenY , Vector2 world ) { } public void getWorldToScreen ( float worldX , float worldY , Vector2 screen ) { } public float getScreenToWorldX ( float screenX ) { } public int getWorldToScreenX ( float worldX ) { } public float getScreenToWorldY ( float screenY ) { } public int getWorldToScreenY ( float worldY ) { } Ray ray = new Ray ( new Vector3 ( ) , new Vector3 ( ) ) ; Vector3 tmp2 = new Vector3 ( ) ; public Ray getPickRay ( int screenX , int screenY ) { } public Matrix4 getCombinedMatrix ( ) { } }
 GL10 gl = graphics . getGL10 ( ) ; 
<BUG2FIX>
GL10 gl = Gdx . gl10 ;

public class GistsActivity extends RoboSherlockFragmentActivity { @ InjectView ( id . tpi_header ) private TitlePageIndicator indicator ; @ InjectView ( id . vp_pages ) private ViewPager pager ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; <START_BUG> setContentView ( gists ) ; <END_BUG> setTitle ( getString ( gists_title ) ) ; getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; pager . setAdapter ( new GistsPagerAdapter ( getResources ( ) , getSupportFragmentManager ( ) ) ) ; indicator . setViewPager ( pager ) ; } public boolean onOptionsItemSelected ( MenuItem item ) { } }
 setContentView ( gists ) ; 
<BUG2FIX>
setContentView ( pager_with_title ) ;

public class TopChildrenQueryParser extends AbstractIndexComponent implements XContentQueryParser { public static final String NAME = "top_children" ; @ Inject public TopChildrenQueryParser ( Index index , @ IndexSettings Settings settings ) { } @ Override public String [ ] names ( ) { } @ Override public Query parse ( QueryParseContext parseContext ) throws IOException , QueryParsingException { XContentParser parser = parseContext . parser ( ) ; Query query = null ; float boost = 1.0F ; String childType = null ; String scope = null ; TopChildrenQuery . ScoreType scoreType = ScoreType . MAX ; int factor = 5 ; int incrementalFactor = 2 ; String currentFieldName = null ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) != ( Token . END_OBJECT ) ) { if ( token == ( Token . FIELD_NAME ) ) { currentFieldName = parser . currentName ( ) ; } else if ( token == ( Token . START_OBJECT ) ) { if ( "query" . equals ( currentFieldName ) ) { query = parseContext . parseInnerQuery ( ) ; } } else if ( token . isValue ( ) ) { if ( "type" . equals ( currentFieldName ) ) { childType = parser . text ( ) ; } else <START_BUG> if ( "scope" . equals ( currentFieldName ) ) { <END_BUG> scope = parser . text ( ) ; } else if ( "score" . equals ( currentFieldName ) ) { scoreType = ScoreType . fromString ( parser . text ( ) ) ; } else if ( "boost" . equals ( currentFieldName ) ) { boost = parser . floatValue ( ) ; } else if ( "factor" . equals ( currentFieldName ) ) { factor = parser . intValue ( ) ; } else if ( ( "incremental_factor" . equals ( currentFieldName ) ) || ( "incrementalFactor" . equals ( currentFieldName ) ) ) { incrementalFactor = parser . intValue ( ) ; } } } if ( query == null ) { throw new QueryParsingException ( index , "[child]<seq2seq4repair_space>requires<seq2seq4repair_space>'query'<seq2seq4repair_space>field" ) ; } if ( childType == null ) { throw new QueryParsingException ( index , "[child]<seq2seq4repair_space>requires<seq2seq4repair_space>'type'<seq2seq4repair_space>field" ) ; } DocumentMapper childDocMapper = parseContext . mapperService ( ) . documentMapper ( childType ) ; if ( childDocMapper == null ) { throw new QueryParsingException ( index , ( ( "No<seq2seq4repair_space>mapping<seq2seq4repair_space>for<seq2seq4repair_space>for<seq2seq4repair_space>type<seq2seq4repair_space>[" + childType ) + "]" ) ) ; } if ( ( childDocMapper . parentFieldMapper ( ) ) == null ) { throw new QueryParsingException ( index , ( ( "Type<seq2seq4repair_space>[" + childType ) + "]<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>have<seq2seq4repair_space>parent<seq2seq4repair_space>mapping" ) ) ; } String parentType = childDocMapper . parentFieldMapper ( ) . type ( ) ; query . setBoost ( boost ) ; query = new org . apache . lucene . search . FilteredQuery ( query , parseContext . cacheFilter ( childDocMapper . typeFilter ( ) ) ) ; TopChildrenQuery childQuery = new TopChildrenQuery ( query , scope , childType , parentType , scoreType , factor , incrementalFactor ) ; parseContext . addScopePhase ( childQuery ) ; return childQuery ; } }
 if ( "scope" . equals ( currentFieldName ) ) { 
<BUG2FIX>
if ( "_scope" . equals ( currentFieldName ) ) {

public class MatchAllQueryParser implements QueryParser { public static final String NAME = "match_all" ; @ Inject public MatchAllQueryParser ( ) { } @ Override public String [ ] names ( ) { } @ Override public Query parse ( QueryParseContext parseContext ) throws IOException , QueryParsingException { XContentParser parser = parseContext . parser ( ) ; float boost = 1.0F ; String normsField = null ; String currentFieldName = null ; XContentParser . Token token ; <START_BUG> while ( ( token = parser . nextToken ( ) ) != ( Token . END_OBJECT ) ) { <END_BUG> if ( token == ( Token . FIELD_NAME ) ) { currentFieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( "boost" . equals ( currentFieldName ) ) { boost = parser . floatValue ( ) ; } else if ( ( "norms_field" . equals ( currentFieldName ) ) || ( "normsField" . equals ( currentFieldName ) ) ) { normsField = parseContext . indexName ( parser . text ( ) ) ; } else { throw new QueryParsingException ( parseContext . index ( ) , ( ( "[match_all]<seq2seq4repair_space>query<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>support<seq2seq4repair_space>[" + currentFieldName ) + "]" ) ) ; } } } if ( ( boost == 1.0F ) && ( normsField == null ) ) { return Queries . MATCH_ALL_QUERY ; } MatchAllDocsQuery query = new MatchAllDocsQuery ( ) ; query . setBoost ( boost ) ; return query ; } }
 while ( ( token = parser . nextToken ( ) ) != ( Token . END_OBJECT ) ) { 
<BUG2FIX>
while ( ( ( token = parser . nextToken ( ) ) != ( Token . END_OBJECT ) ) && ( token != ( Token . END_ARRAY ) ) ) {

public class AnalyzeActionTests extends AbstractNodesTests { private Client client ; @ BeforeClass public void createNodes ( ) throws Exception { } @ AfterClass public void closeNodes ( ) { } protected Client getClient ( ) { } @ Test public void simpleAnalyzerTests ( ) throws Exception { } @ Test public void analyzerWithFieldOrTypeTests ( ) throws Exception { try { client . admin ( ) . indices ( ) . prepareDelete ( "test" ) . execute ( ) . actionGet ( ) ; } catch ( Exception e ) { } client . admin ( ) . indices ( ) . prepareCreate ( "test" ) . execute ( ) . actionGet ( ) ; client . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForGreenStatus ( ) . execute ( ) . actionGet ( ) ; client . admin ( ) . indices ( ) . preparePutMapping ( "test" ) . setType ( "document" ) . setSource ( ( "{\n" + ( ( ( ( ( ( ( ( "<seq2seq4repair_space>\"document\":{\n" + "<seq2seq4repair_space>\"properties\":{\n" ) + "<seq2seq4repair_space>\"simple\":{\n" ) + "<seq2seq4repair_space>\"type\":\"string\",\n" ) + "<seq2seq4repair_space>\"analyzer\":<seq2seq4repair_space>\"simple\"\n" ) + "<seq2seq4repair_space>}\n" ) + "<seq2seq4repair_space>}\n" ) + "<seq2seq4repair_space>}\n" ) + "}" ) ) ) . execute ( ) . actionGet ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { final AnalyzeRequestBuilder requestBuilder = client . admin ( ) . indices ( ) . prepareAnalyze ( "test" , "THIS<seq2seq4repair_space>IS<seq2seq4repair_space>A<seq2seq4repair_space>TEST" ) ; <START_BUG> requestBuilder . field ( "document.simple" ) ; <END_BUG> AnalyzeResponse analyzeResponse = requestBuilder . execute ( ) . actionGet ( ) ; assertThat ( analyzeResponse . tokens ( ) . size ( ) , equalTo ( 4 ) ) ; AnalyzeResponse . AnalyzeToken token = analyzeResponse . tokens ( ) . get ( 3 ) ; assertThat ( token . term ( ) , equalTo ( "test" ) ) ; assertThat ( token . startOffset ( ) , equalTo ( 10 ) ) ; assertThat ( token . endOffset ( ) , equalTo ( 14 ) ) ; } } }
 requestBuilder . field ( "document.simple" ) ; 
<BUG2FIX>
requestBuilder . setField ( "document.simple" ) ;

public class DragAndDrop { static final Vector2 tmpVector = new Vector2 ( ) ; DragAndDrop . Payload payload ; Actor dragActor ; DragAndDrop . Target target ; boolean isValidTarget ; Array < DragAndDrop . Target > targets = new Array ( ) ; ObjectMap < DragAndDrop . Source , DragListener > sourceListeners = new ObjectMap ( ) ; private float tapSquareSize = 8 ; private int button ; float dragActorX = 14 ; float dragActorY = - 20 ; float touchOffsetX ; float touchOffsetY ; long dragStartTime ; int dragTime = 250 ; int activePointer = - 1 ; boolean cancelTouchFocus = true ; public void addSource ( final DragAndDrop . Source source ) { DragListener listener = new DragListener ( ) { public void dragStart ( InputEvent event , float x , float y , int pointer ) { if ( ( activePointer ) != ( - 1 ) ) { event . stop ( ) ; return ; } activePointer = pointer ; dragStartTime = System . currentTimeMillis ( ) ; payload = source . dragStart ( event , getTouchDownX ( ) , getTouchDownY ( ) , pointer ) ; event . stop ( ) ; if ( ( cancelTouchFocus ) && ( ( payload ) != null ) ) <START_BUG> source . getActor ( ) . getStage ( ) . cancelTouchFocus ( this , source . getActor ( ) ) ; <END_BUG> } public void drag ( InputEvent event , float x , float y , int pointer ) { if ( ( payload ) == null ) return ; if ( pointer != ( activePointer ) ) return ; Stage stage = event . getStage ( ) ; Touchable dragActorTouchable = null ; if ( ( dragActor ) != null ) { dragActorTouchable = dragActor . getTouchable ( ) ; dragActor . setTouchable ( disabled ) ; } DragAndDrop . Target newTarget = null ; isValidTarget = false ; float stageX = ( event . getStageX ( ) ) + ( touchOffsetX ) ; float stageY = ( event . getStageY ( ) ) + ( touchOffsetY ) ; Actor hit = event . getStage ( ) . hit ( stageX , stageY , true ) ; if ( hit == null ) hit = event . getStage ( ) . hit ( stageX , stageY , false ) ; if ( hit != null ) { for ( int i = 0 , n = targets . size ; i < n ; i ++ ) { DragAndDrop . Target target = targets . get ( i ) ; if ( ! ( target . actor . isAscendantOf ( hit ) ) ) continue ; newTarget = target ; target . actor . stageToLocalCoordinates ( DragAndDrop . tmpVector . set ( stageX , stageY ) ) ; isValidTarget = target . drag ( source , payload , DragAndDrop . tmpVector . x , DragAndDrop . tmpVector . y , pointer ) ; break ; } } if ( newTarget != ( target ) ) { if ( ( target ) != null ) target . reset ( source , payload ) ; target = newTarget ; } if ( ( dragActor ) != null ) dragActor . setTouchable ( dragActorTouchable ) ; Actor actor = null ; if ( ( target ) != null ) actor = ( isValidTarget ) ? payload . validDragActor : payload . invalidDragActor ; if ( actor == null ) actor = payload . dragActor ; if ( actor == null ) return ; if ( ( dragActor ) != actor ) { if ( ( dragActor ) != null ) dragActor . remove ( ) ; dragActor = actor ; stage . addActor ( actor ) ; } float actorX = ( event . getStageX ( ) ) + ( dragActorX ) ; float actorY = ( ( event . getStageY ( ) ) + ( dragActorY ) ) - ( actor . getHeight ( ) ) ; if ( actorX < 0 ) actorX = 0 ; if ( actorY < 0 ) actorY = 0 ; if ( ( actorX + ( actor . getWidth ( ) ) ) > ( stage . getWidth ( ) ) ) actorX = ( stage . getWidth ( ) ) - ( actor . getWidth ( ) ) ; if ( ( actorY + ( actor . getHeight ( ) ) ) > ( stage . getHeight ( ) ) ) actorY = ( stage . getHeight ( ) ) - ( actor . getHeight ( ) ) ; actor . setPosition ( actorX , actorY ) ; } public void dragStop ( InputEvent event , float x , float y , int pointer ) { if ( pointer != ( activePointer ) ) return ; activePointer = - 1 ; if ( ( payload ) == null ) return ; if ( ( ( System . currentTimeMillis ( ) ) - ( dragStartTime ) ) < ( dragTime ) ) isValidTarget = false ; if ( ( dragActor ) != null ) dragActor . remove ( ) ; if ( isValidTarget ) { float stageX = ( event . getStageX ( ) ) + ( touchOffsetX ) ; float stageY = ( event . getStageY ( ) ) + ( touchOffsetY ) ; target . actor . stageToLocalCoordinates ( DragAndDrop . tmpVector . set ( stageX , stageY ) ) ; target . drop ( source , payload , DragAndDrop . tmpVector . x , DragAndDrop . tmpVector . y , pointer ) ; } source . dragStop ( event , x , y , pointer , payload , ( isValidTarget ? target : null ) ) ; if ( ( target ) != null ) target . reset ( source , payload ) ; payload = null ; target = null ; isValidTarget = false ; dragActor = null ; } } ;
 source . getActor ( ) . getStage ( ) . cancelTouchFocus ( this , source . getActor ( ) ) ; 
<BUG2FIX>
source . getActor ( ) . getStage ( ) . cancelTouchFocusExcept ( this , source . getActor ( ) ) ;

public class TransportCloseIndexAction extends TransportMasterNodeOperationAction < CloseIndexRequest , CloseIndexResponse > { private final MetaDataStateIndexService stateIndexService ; @ Inject public TransportCloseIndexAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , MetaDataStateIndexService stateIndexService ) { } @ Override protected String executor ( ) { <START_BUG> return Names . CACHED ; <END_BUG> } @ Override protected String transportAction ( ) { } @ Override protected CloseIndexRequest newRequest ( ) { } @ Override protected CloseIndexResponse newResponse ( ) { } @ Override protected ClusterBlockException checkBlock ( CloseIndexRequest request , ClusterState state ) { } @ Override protected CloseIndexResponse masterOperation ( CloseIndexRequest request , ClusterState state ) throws ElasticSearchException { } }
 return Names . CACHED ; 
<BUG2FIX>
return Names . MANAGEMENT ;

public class BulletBuild { public static void main ( String [ ] args ) throws Exception { new NativeCodeGenerator ( ) . generate ( "src" , "bin" , "jni" ) ; String cppFlags = "" ; cppFlags += "<seq2seq4repair_space>-fno-strict-aliasing" ; cppFlags += "<seq2seq4repair_space>-fno-rtti" ; cppFlags += "<seq2seq4repair_space>-DBT_NO_PROFILE" ; String [ ] excludes = new String [ ] { "src/bullet/BulletMultiThreaded/GpuSoftBodySolvers/**" } ; <START_BUG> String [ ] headers = new String [ ] { "src/bullet/" , "src/custom/" , "src/extras/Serialize/" } ; <END_BUG> BuildTarget win32home = BuildTarget . newDefaultTarget ( Windows , false ) ; win32home . compilerPrefix = "" ; win32home . buildFileName = "build-windows32home.xml" ; win32home . excludeFromMasterBuildFile = true ; win32home . cExcludes = win32home . cppExcludes = excludes ; win32home . headerDirs = headers ; win32home . cppFlags += cppFlags ; BuildTarget win32 = BuildTarget . newDefaultTarget ( Windows , false ) ; win32 . cExcludes = win32 . cppExcludes = excludes ; win32 . headerDirs = headers ; win32 . cppFlags += cppFlags ; BuildTarget win64 = BuildTarget . newDefaultTarget ( Windows , true ) ; win64 . cExcludes = win64 . cppExcludes = excludes ; win64 . headerDirs = headers ; win64 . cppFlags += cppFlags ; BuildTarget lin32 = BuildTarget . newDefaultTarget ( Linux , false ) ; lin32 . cExcludes = lin32 . cppExcludes = excludes ; lin32 . headerDirs = headers ; lin32 . cppFlags += cppFlags ; BuildTarget lin64 = BuildTarget . newDefaultTarget ( Linux , true ) ; lin64 . cExcludes = lin64 . cppExcludes = excludes ; lin64 . headerDirs = headers ; lin64 . cppFlags += cppFlags ; BuildTarget mac = BuildTarget . newDefaultTarget ( MacOsX , false ) ; mac . cExcludes = mac . cppExcludes = excludes ; mac . headerDirs = headers ; mac . cppFlags += cppFlags ; BuildTarget android = BuildTarget . newDefaultTarget ( Android , false ) ; android . cExcludes = android . cppExcludes = excludes ; android . headerDirs = headers ; android . cppFlags += cppFlags ; BuildTarget ios = BuildTarget . newDefaultTarget ( IOS , false ) ; ios . cExcludes = ios . cppExcludes = excludes ; ios . headerDirs = headers ; ios . cppFlags += cppFlags ; new AntScriptGenerator ( ) . generate ( new BuildConfig ( "gdx-bullet" ) , win32home , win32 , win64 , lin32 , lin64 , mac , android , ios ) ; } }
 String [ ] headers = new String [ ] { "src/bullet/" , "src/custom/" , "src/extras/Serialize/" } ; 
<BUG2FIX>
String [ ] headers = new String [ ] { "src/bullet/" , "src/custom/" , "src/extras/serialize/" } ;

public class TransportDeleteAction extends TransportShardReplicationOperationAction < DeleteRequest , DeleteRequest , DeleteResponse > { private final AutoCreateIndex autoCreateIndex ; private final TransportCreateIndexAction createIndexAction ; private final TransportIndexDeleteAction indexDeleteAction ; @ Inject public TransportDeleteAction ( Settings settings , TransportService transportService , ClusterService clusterService , IndicesService indicesService , ThreadPool threadPool , ShardStateAction shardStateAction , TransportCreateIndexAction createIndexAction , TransportIndexDeleteAction indexDeleteAction ) { } @ Override protected String executor ( ) { } @ Override protected void doExecute ( final DeleteRequest request , final ActionListener < DeleteResponse > listener ) { } @ Override protected boolean resolveRequest ( final ClusterState state , final DeleteRequest request , final ActionListener < DeleteResponse > listener ) { } private void innerExecute ( final DeleteRequest request , final ActionListener < DeleteResponse > listener ) { } @ Override protected boolean checkWriteConsistency ( ) { } @ Override protected DeleteRequest newRequestInstance ( ) { } @ Override protected DeleteRequest newReplicaRequestInstance ( ) { } @ Override protected DeleteResponse newResponseInstance ( ) { } @ Override protected String transportAction ( ) { } @ Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , DeleteRequest request ) { } @ Override protected ClusterBlockException checkRequestBlock ( ClusterState state , DeleteRequest request ) { } @ Override protected PrimaryResponse < DeleteResponse , DeleteRequest > shardOperationOnPrimary ( ClusterState clusterState , PrimaryOperationRequest shardRequest ) { DeleteRequest request = shardRequest . request ; IndexShard indexShard = indicesService . indexServiceSafe ( shardRequest . request . index ( ) ) . shardSafe ( shardRequest . shardId ) ; Engine . Delete delete = indexShard . prepareDelete ( request . type ( ) , request . id ( ) , request . version ( ) , request . versionType ( ) , PRIMARY ) ; indexShard . delete ( delete ) ; request . versionType ( delete . versionType ( ) . versionTypeForReplicationAndRecovery ( ) ) ; request . version ( delete . version ( ) ) ; <START_BUG> assert request . versionType ( ) . validateVersion ( request . version ( ) ) ; <END_BUG> if ( request . refresh ( ) ) { try { indexShard . refresh ( new Engine . Refresh ( "refresh_flag_delete" ) . force ( false ) ) ; } catch ( Exception e ) { } } DeleteResponse response = new DeleteResponse ( request . index ( ) , request . type ( ) , request . id ( ) , delete . version ( ) , delete . found ( ) ) ; return new PrimaryResponse ( shardRequest . request , response , null ) ; } @ Override protected void shardOperationOnReplica ( ReplicaOperationRequest shardRequest ) { } @ Override protected ShardIterator shards ( ClusterState clusterState , DeleteRequest request ) { } }
 assert request . versionType ( ) . validateVersion ( request . version ( ) ) ; 
<BUG2FIX>
assert request . versionType ( ) . validateVersionForWrites ( request . version ( ) ) ;

public class ShortSoundTest extends GdxTest { @ Override public void create ( ) { <START_BUG> audio . newSound ( files . internal ( "data/tic.ogg" ) ) . play ( ) ; <END_BUG> } }
 audio . newSound ( files . internal ( "data/tic.ogg" ) ) . play ( ) ; 
<BUG2FIX>
audio . newSound ( files . internal ( "data/chirp.ogg" ) ) . play ( ) ;

public class Ray implements Serializable { private static final long serialVersionUID = - 620692054835390878L ; public final Vector3 origin = new Vector3 ( ) ; public final Vector3 direction = new Vector3 ( ) ; public Ray ( Vector3 origin , Vector3 direction ) { } public Ray cpy ( ) { } public Vector3 getEndPoint ( float distance ) { <START_BUG> return new Vector3 ( origin ) . add ( direction . tmp ( ) . scl ( distance ) ) ; <END_BUG> } static Vector3 tmp = new Vector3 ( ) ; public Ray mul ( Matrix4 matrix ) { } public String toString ( ) { } public Ray set ( Vector3 origin , Vector3 direction ) { } public Ray set ( float x , float y , float z , float dx , float dy , float dz ) { } public Ray set ( Ray ray ) { } }
 return new Vector3 ( origin ) . add ( direction . tmp ( ) . scl ( distance ) ) ; 
<BUG2FIX>
return new Vector3 ( origin ) . add ( direction . tmp ( ) . mul ( distance ) ) ;