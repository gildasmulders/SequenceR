###0### lots of Exception > Throwable 
public class RestCreateIndexAction extends BaseRestHandler { @ Inject public RestCreateIndexAction ( Settings settings , Client client , RestController controller ) { } @ SuppressWarnings ( { "unchecked" } ) @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { CreateIndexRequest createIndexRequest = new CreateIndexRequest ( request . param ( "index" ) ) ; createIndexRequest . listenerThreaded ( false ) ; if ( request . hasContent ( ) ) { try { createIndexRequest . source ( request . content ( ) ) ; } catch ( Exception e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . warn ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>response" , e1 ) ; } return ; } } createIndexRequest . timeout ( request . paramAsTime ( "timeout" , timeValueSeconds ( 10 ) ) ) ; client . admin ( ) . indices ( ) . create ( createIndexRequest , new org . elasticsearch . action . ActionListener < CreateIndexResponse > ( ) { @ Override public void onResponse ( CreateIndexResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) . field ( "ok" , true ) . field ( "acknowledged" , response . isAcknowledged ( ) ) . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
 } catch ( Exception e ) { 
<BUG2FIX>
} catch ( Throwable e ) {

###1### should identify assignment structure to make embedding of identifier close to its value -> special tag for assignment
public class MultiValueLongFieldData extends LongFieldData { private static final int VALUE_CACHE_SIZE = 10 ; private ThreadLocal < ThreadLocals . CleanableValue < double [ ] [ ] > > doublesValuesCache = new ThreadLocal < ThreadLocals . CleanableValue < double [ ] [ ] > > ( ) { @ Override protected ThreadLocals . CleanableValue < double [ ] [ ] > initialValue ( ) { } } ; private ThreadLocal < ThreadLocals . CleanableValue < MutableDateTime [ ] [ ] > > dateTimesCache = new ThreadLocal < ThreadLocals . CleanableValue < MutableDateTime [ ] [ ] > > ( ) { @ Override protected ThreadLocals . CleanableValue < MutableDateTime [ ] [ ] > initialValue ( ) { } } ; private ThreadLocal < ThreadLocals . CleanableValue < long [ ] [ ] > > valuesCache = new ThreadLocal < ThreadLocals . CleanableValue < long [ ] [ ] > > ( ) { @ Override protected ThreadLocals . CleanableValue < long [ ] [ ] > initialValue ( ) { } } ; private final int [ ] [ ] ordinals ; public MultiValueLongFieldData ( String fieldName , int [ ] [ ] ordinals , long [ ] values ) { } @ Override protected long computeSizeInBytes ( ) { } @ Override public boolean multiValued ( ) { } @ Override public boolean hasValue ( int docId ) { } @ Override public void forEachValueInDoc ( int docId , StringValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , DoubleValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , LongValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , MissingDoubleValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , MissingLongValueInDocProc proc ) { } @ Override public void forEachOrdinalInDoc ( int docId , OrdinalInDocProc proc ) { boolean found = false ; for ( int [ ] ordinal : ordinals ) { int loc = ordinal [ docId ] ; if ( loc != 0 ) { found = true ; <START_BUG> proc . onOrdinal ( docId , ordinal [ docId ] ) ; <END_BUG> } } if ( ! found ) { proc . onOrdinal ( docId , 0 ) ; } } @ Override public void forEachValueInDoc ( int docId , ValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , DateValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , MutableDateTime dateTime , DateValueInDocProc proc ) { } @ Override public MutableDateTime [ ] dates ( int docId ) { } @ Override public double [ ] doubleValues ( int docId ) { } @ Override public long value ( int docId ) { } @ Override public long [ ] values ( int docId ) { } }
 proc . onOrdinal ( docId , ordinal [ docId ] ) ; 
<BUG2FIX>
proc . onOrdinal ( docId , loc ) ;

###2### failed to use the argument of the method + could distinguish identifiers of variables and identifiers of names of methods and classes
public class WidgetGroup extends Group implements Layout { private boolean needsLayout = true ; private boolean fillParent ; private boolean layoutEnabled = true ; public float getMinWidth ( ) { } public float getMinHeight ( ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public float getMaxWidth ( ) { } public float getMaxHeight ( ) { } public void setLayoutEnabled ( boolean enabled ) { } private void setLayoutEnabled ( Group parent , boolean enabled ) { <START_BUG> SnapshotArray < Actor > children = getChildren ( ) ; <END_BUG> for ( int i = 0 , n = children . size ; i < n ; i ++ ) { Actor actor = children . get ( i ) ; if ( actor instanceof Layout ) ( ( Layout ) ( actor ) ) . setLayoutEnabled ( enabled ) ; else if ( actor instanceof Group ) setLayoutEnabled ( ( ( Group ) ( actor ) ) , enabled ) ; } } public void validate ( ) { } public boolean needsLayout ( ) { } public void invalidate ( ) { } public void invalidateHierarchy ( ) { } protected void childrenChanged ( ) { } protected void sizeChanged ( ) { } public void pack ( ) { } public void setFillParent ( boolean fillParent ) { } public void layout ( ) { } public void draw ( Batch batch , float parentAlpha ) { } }
 SnapshotArray < Actor > children = getChildren ( ) ; 
<BUG2FIX>
SnapshotArray < Actor > children = parent . getChildren ( ) ;

###3### feature to identify that "identifier (" goes with matching parenthese, so it knows all of this works together as an entity
public abstract class GistsFragment extends PagedItemFragment < Gist > { @ Inject protected AvatarLoader avatarHelper ; @ Inject protected GistService service ; @ Inject protected GistStore store ; @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; <START_BUG> setEmptyText ( getString ( no_gists ) ) ; <END_BUG> } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { } @ Override public void onLoadFinished ( Loader < List < Gist > > loader , List < Gist > items ) { } @ Override protected int getLoadingMessage ( ) { } @ Override protected ItemListAdapter < Gist , ? extends ItemView > createAdapter ( List < Gist > items ) { } }
 setEmptyText ( getString ( no_gists ) ) ; 
<BUG2FIX>
setEmptyText ( no_gists ) ;

###4### "actor" not defined yet, could have counter of occurence for variable identifiers + need to understand that the condition works as entity (cf parenthesis feature of #3)
public class ParallelAction extends Action { Array < Action > actions = new Array ( 4 ) ; private boolean complete ; public ParallelAction ( ) { } public ParallelAction ( Action action1 ) { } public ParallelAction ( Action action1 , Action action2 ) { } public ParallelAction ( Action action1 , Action action2 , Action action3 ) { } public ParallelAction ( Action action1 , Action action2 , Action action3 , Action action4 ) { } public ParallelAction ( Action action1 , Action action2 , Action action3 , Action action4 , Action action5 ) { } public boolean act ( float delta ) { if ( complete ) return true ; complete = true ; Array < Action > actions = this . actions ; <START_BUG> for ( int i = 0 , n = actions . size ; ( i < n ) && ( ( actor ) != null ) ; i ++ ) <END_BUG> if ( ! ( actions . get ( i ) . act ( delta ) ) ) complete = false ; return complete ; } public void restart ( ) { } public void reset ( ) { } public void addAction ( Action action ) { } public void setActor ( Actor actor ) { } public Array < Action > getActions ( ) { } public String toString ( ) { } }
 for ( int i = 0 , n = actions . size ; ( i < n ) && ( ( actor ) != null ) ; i ++ ) 
<BUG2FIX>
for ( int i = 0 , n = actions . size ; i < n ; i ++ )

###5### play with parameter order
public class NestedAggregator extends SingleBucketAggregator implements ReaderContextAware { private final String nestedPath ; private final Aggregator parentAggregator ; private Filter parentFilter ; private final Filter childFilter ; private Bits childDocs ; private FixedBitSet parentDocs ; public NestedAggregator ( String name , AggregatorFactories factories , String nestedPath , AggregationContext aggregationContext , Aggregator parentAggregator ) { } @ Override public void setNextReader ( AtomicReaderContext reader ) { } @ Override public void collect ( int parentDoc , long bucketOrd ) throws IOException { if ( ( parentDoc == 0 ) || ( ( parentDocs ) == null ) ) { return ; } int prevParentDoc = parentDocs . prevSetBit ( ( parentDoc - 1 ) ) ; int numChildren = 0 ; for ( int i = parentDoc - 1 ; i > prevParentDoc ; i -- ) { if ( childDocs . get ( i ) ) { ++ numChildren ; collectBucketNoCounts ( i , bucketOrd ) ; } } <START_BUG> incrementBucketDocCount ( numChildren , bucketOrd ) ; <END_BUG> } @ Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) { } @ Override public InternalAggregation buildEmptyAggregation ( ) { } public String getNestedPath ( ) { } static NestedAggregator findClosestNestedAggregator ( Aggregator parent ) { } public static class Factory extends AggregatorFactory { private final String path ; public Factory ( String name , String path ) { } @ Override public Aggregator create ( AggregationContext context , Aggregator parent , long expectedBucketsCount ) { } } }
 incrementBucketDocCount ( numChildren , bucketOrd ) ; 
<BUG2FIX>
incrementBucketDocCount ( bucketOrd , numChildren ) ;

###6### same as #5... need to understand method ( arg1 , arg2 ) structure
public class VertexArray implements VertexData { final VertexAttributes attributes ; final FloatBuffer buffer ; final ByteBuffer byteBuffer ; boolean isBound = false ; public VertexArray ( int numVertices , VertexAttribute ... attributes ) { } public VertexArray ( int numVertices , VertexAttributes attributes ) { } @ Override public void dispose ( ) { } @ Override public FloatBuffer getBuffer ( ) { } @ Override public int getNumVertices ( ) { } public int getNumMaxVertices ( ) { } @ Override public void setVertices ( float [ ] vertices , int offset , int count ) { } @ Override public void updateVertices ( int targetOffset , float [ ] vertices , int sourceOffset , int count ) { final int pos = byteBuffer . position ( ) ; byteBuffer . position ( ( targetOffset * 4 ) ) ; <START_BUG> BufferUtils . copy ( vertices , sourceOffset , byteBuffer , count ) ; <END_BUG> byteBuffer . position ( pos ) ; } @ Override public void bind ( ) { } @ Override public void unbind ( ) { } @ Override public void bind ( final ShaderProgram shader ) { } @ Override public void bind ( final ShaderProgram shader , final int [ ] locations ) { } @ Override public void unbind ( ShaderProgram shader ) { } @ Override public void unbind ( ShaderProgram shader , int [ ] locations ) { } @ Override public VertexAttributes getAttributes ( ) { } }
 BufferUtils . copy ( vertices , sourceOffset , byteBuffer , count ) ; 
<BUG2FIX>
BufferUtils . copy ( vertices , sourceOffset , count , byteBuffer ) ;

###7### basic structure of for loop
public class ObjectSet < T > implements Iterable < T > { private static final int PRIME1 = - 1105259343 ; private static final int PRIME2 = - 1262997959 ; private static final int PRIME3 = - 825114047 ; public int size ; T [ ] keyTable ; int capacity ; int stashSize ; private float loadFactor ; private int hashShift ; private int mask ; private int threshold ; private int stashCapacity ; private int pushIterations ; private ObjectSet . SetIterator iterator1 ; private ObjectSet . SetIterator iterator2 ; public ObjectSet ( ) { } public ObjectSet ( int initialCapacity ) { } public ObjectSet ( int initialCapacity , float loadFactor ) { } public ObjectSet ( ObjectSet set ) { } public boolean add ( T key ) { } public void addAll ( Array < ? extends T > array ) { } public void addAll ( Array < ? extends T > array , int offset , int length ) { } public void addAll ( T ... array ) { } public void addAll ( T [ ] array , int offset , int length ) { } public void addAll ( ObjectSet < T > set ) { } private void addResize ( T key ) { } private void push ( T insertKey , int index1 , T key1 , int index2 , T key2 , int index3 , T key3 ) { } private void addStash ( T key ) { } public boolean remove ( T key ) { } boolean removeStash ( T key ) { } void removeStashIndex ( int index ) { } public void shrink ( int maximumCapacity ) { } public void clear ( int maximumCapacity ) { } public void clear ( ) { } public boolean contains ( T key ) { } private boolean containsKeyStash ( T key ) { } public T first ( ) { T [ ] keyTable = this . keyTable ; <START_BUG> for ( int i = 0 , n = ( capacity ) + ( stashSize ) ; i < n ; ) <END_BUG> if ( ( keyTable [ i ] ) != null ) return keyTable [ i ] ; throw new IllegalStateException ( "IntSet<seq2seq4repair_space>is<seq2seq4repair_space>empty." ) ; } public void ensureCapacity ( int additionalCapacity ) { } private void resize ( int newSize ) { } private int hash2 ( int h ) { } private int hash3 ( int h ) { } public String toString ( ) { } public String toString ( String separator ) { } public ObjectSet . SetIterator < T > iterator ( ) { } public static < T > ObjectSet < T > with ( T ... array ) { } public static class SetIterator < K > implements Iterable < K > , Iterator < K > { public boolean hasNext ; final ObjectSet < K > set ; int nextIndex ; int currentIndex ; boolean valid = true ; public SetIterator ( ObjectSet < K > set ) { } public void reset ( ) { } void findNextIndex ( ) { } public void remove ( ) { } public boolean hasNext ( ) { } public K next ( ) { } public Iterator < K > iterator ( ) { } public Array < K > toArray ( ) { } } }
 for ( int i = 0 , n = ( capacity ) + ( stashSize ) ; i < n ; ) 
<BUG2FIX>
for ( int i = 0 , n = ( capacity ) + ( stashSize ) ; i < n ; i ++ )

###8### cf entity recognition with parentheses 
public final class Intersector { private static final Vector3 v0 = new Vector3 ( ) ; private static final Vector3 v1 = new Vector3 ( ) ; private static final Vector3 v2 = new Vector3 ( ) ; public static boolean isPointInTriangle ( Vector3 point , Vector3 t1 , Vector3 t2 , Vector3 t3 ) { } public static boolean isPointInTriangle ( Vector2 p , Vector2 a , Vector2 b , Vector2 c ) { } public static boolean isPointInTriangle ( float px , float py , float ax , float ay , float bx , float by , float cx , float cy ) { } public static boolean intersectSegmentPlane ( Vector3 start , Vector3 end , Plane plane , Vector3 intersection ) { } public static int pointLineSide ( Vector2 linePoint1 , Vector2 linePoint2 , Vector2 point ) { } public static int pointLineSide ( float linePoint1X , float linePoint1Y , float linePoint2X , float linePoint2Y , float pointX , float pointY ) { } public static boolean isPointInPolygon ( Array < Vector2 > polygon , Vector2 point ) { } public static boolean isPointInPolygon ( float [ ] polygon , int offset , int count , float x , float y ) { } public static float distanceLinePoint ( Vector2 start , Vector2 end , Vector2 point ) { } public static float distanceLinePoint ( float startX , float startY , float endX , float endY , float pointX , float pointY ) { } public static float distanceSegmentPoint ( float startX , float startY , float endX , float endY , float pointX , float pointY ) { } public static float distanceSegmentPoint ( Vector2 start , Vector2 end , Vector2 point ) { } public static Vector2 nearestSegmentPoint ( Vector2 start , Vector2 end , Vector2 point , Vector2 nearest ) { } public static Vector2 nearestSegmentPoint ( float startX , float startY , float endX , float endY , float pointX , float pointY , Vector2 nearest ) { } public static boolean intersectSegmentCircle ( Vector2 start , Vector2 end , Vector2 center , float squareRadius ) { } public static float intersectSegmentCircleDisplace ( Vector2 start , Vector2 end , Vector2 point , float radius , Vector2 displacement ) { } public static boolean intersectRayPlane ( Ray ray , Plane plane , Vector3 intersection ) { } public static float intersectLinePlane ( float x , float y , float z , float x2 , float y2 , float z2 , Plane plane , Vector3 intersection ) { Vector3 direction = Intersector . tmp . set ( x2 , y2 , z2 ) . sub ( x , y , z ) ; Vector3 origin = Intersector . tmp2 . set ( x , y , z ) ; float denom = direction . dot ( plane . getNormal ( ) ) ; if ( denom != 0 ) { float t = ( - ( ( origin . dot ( plane . getNormal ( ) ) ) + ( plane . getD ( ) ) ) ) / denom ; <START_BUG> if ( ( ( t >= 0 ) && ( t <= 1 ) ) && ( intersection != null ) ) <END_BUG> intersection . set ( origin ) . add ( direction . scl ( t ) ) ; return t ; } else if ( ( plane . testPoint ( origin ) ) == ( PlaneSide . OnPlane ) ) { if ( intersection != null ) intersection . set ( origin ) ; return 0 ; } return - 1 ; } private static final Plane p = new Plane ( new Vector3 ( ) , 0 ) ; private static final Vector3 i = new Vector3 ( ) ; public static boolean intersectRayTriangle ( Ray ray , Vector3 t1 , Vector3 t2 , Vector3 t3 , Vector3 intersection ) { } private static final Vector3 dir = new Vector3 ( ) ; private static final Vector3 start = new Vector3 ( ) ; public static boolean intersectRaySphere ( Ray ray , Vector3 center , float radius , Vector3 intersection ) { } public static boolean intersectRayBounds ( Ray ray , BoundingBox box , Vector3 intersection ) { } public static boolean intersectRayBoundsFast ( Ray ray , BoundingBox box ) { } public static boolean intersectRayBoundsFast ( Ray ray , Vector3 center , Vector3 dimensions ) { } static Vector3 best = new Vector3 ( ) ; static Vector3 tmp = new Vector3 ( ) ; static Vector3 tmp1 = new Vector3 ( ) ; static Vector3 tmp2 = new Vector3 ( ) ; static Vector3 tmp3 = new Vector3 ( ) ; static Vector2 v2tmp = new Vector2 ( ) ; public static boolean intersectRayTriangles ( Ray ray , float [ ] triangles , Vector3 intersection ) { } public static boolean intersectRayTriangles ( Ray ray , float [ ] vertices , short [ ] indices , int vertexSize , Vector3 intersection ) { } public static boolean intersectRayTriangles ( Ray ray , List < Vector3 > triangles , Vector3 intersection ) { } public static boolean intersectLines ( Vector2 p1 , Vector2 p2 , Vector2 p3 , Vector2 p4 , Vector2 intersection ) { } public static boolean intersectLines ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 , Vector2 intersection ) { } public static boolean intersectLinePolygon ( Vector2 p1 , Vector2 p2 , Polygon polygon ) { } public static boolean intersectRectangles ( Rectangle rectangle1 , Rectangle rectangle2 , Rectangle intersection ) { } public static boolean intersectSegmentPolygon ( Vector2 p1 , Vector2 p2 , Polygon polygon ) { } public static boolean intersectSegments ( Vector2 p1 , Vector2 p2 , Vector2 p3 , Vector2 p4 , Vector2 intersection ) { }
 if ( ( ( t >= 0 ) && ( t <= 1 ) ) && ( intersection != null ) ) 
<BUG2FIX>
if ( intersection != null )

###9### identify "method ( )" entities
public abstract class GistsFragment extends PagedItemFragment < Gist > { @ Inject protected AvatarLoader avatars ; @ Inject protected GistService service ; @ Inject protected GistStore store ; @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( ( requestCode == ( RequestCodes . GIST_VIEW ) ) || ( requestCode == ( RequestCodes . GIST_CREATE ) ) ) { <START_BUG> getListAdapter ( ) . getWrappedAdapter ( ) . notifyDataSetChanged ( ) ; <END_BUG> forceRefresh ( ) ; return ; } super . onActivityResult ( requestCode , resultCode , data ) ; } @ Override protected int getErrorMessage ( Exception exception ) { } @ Override protected int getLoadingMessage ( ) { } @ Override protected SingleTypeAdapter < Gist > createAdapter ( List < Gist > items ) { } }
 getListAdapter ( ) . getWrappedAdapter ( ) . notifyDataSetChanged ( ) ; 
<BUG2FIX>
notifyDataSetChanged ( ) ;

###10### failed to reuse the parent method name -> typical behavior after "Override"
@ Override public void glPixelStorei ( int pname , int param ) { } @ Override public void glPolygonOffset ( float factor , float units ) { } @ Override public void glReadPixels ( int x , int y , int width , int height , int format , int type , Buffer pixels ) { } @ Override public void glReleaseShaderCompiler ( ) { } @ Override public void glRenderbufferStorage ( int target , int internalformat , int width , int height ) { } @ Override public void glSampleCoverage ( float value , boolean invert ) { } @ Override public void glScissor ( int x , int y , int width , int height ) { } @ Override public void glShaderBinary ( int n , IntBuffer shaders , int binaryformat , Buffer binary , int length ) { } @ Override public void glShaderSource ( int shader , String string ) { } @ Override public void glStencilFunc ( int func , int ref , int mask ) { } @ Override public void glStencilFuncSeparate ( int face , int func , int ref , int mask ) { } @ Override public void glStencilMask ( int mask ) { } @ Override public void glStencilMaskSeparate ( int face , int mask ) { } @ Override public void glStencilOp ( int fail , int zfail , int zpass ) { } @ Override public void glStencilOpSeparate ( int face , int fail , int zfail , int zpass ) { } @ Override public void glTexImage2D ( int target , int level , int internalformat , int width , int height , int border , int format , int type , Buffer pixels ) { } @ Override public void glTexParameterf ( int target , int pname , float param ) { } @ Override public void glTexParameterfv ( int target , int pname , FloatBuffer params ) { } @ Override public void glTexParameteri ( int target , int pname , int param ) { } @ Override public void glTexParameteriv ( int target , int pname , IntBuffer params ) { } @ Override public void glTexSubImage2D ( int target , int level , int xoffset , int yoffset , int width , int height , int format , int type , Buffer pixels ) { } @ Override public void glUniform1f ( int location , float x ) { } @ Override public void glUniform1fv ( int location , int count , FloatBuffer v ) { } @ Override public void glUniform1i ( int location , int x ) { } @ Override public void glUniform1iv ( int location , int count , IntBuffer v ) { } @ Override public void glUniform2f ( int location , float x , float y ) { } @ Override public void glUniform2fv ( int location , int count , FloatBuffer v ) { } @ Override public void glUniform2i ( int location , int x , int y ) { } @ Override public void glUniform2iv ( int location , int count , IntBuffer v ) { } @ Override public void glUniform3f ( int location , float x , float y , float z ) { } @ Override public void glUniform3fv ( int location , int count , FloatBuffer v ) { } @ Override public void glUniform3i ( int location , int x , int y , int z ) { } @ Override public void glUniform3iv ( int location , int count , IntBuffer v ) { } @ Override public void glUniform4f ( int location , float x , float y , float z , float w ) { } @ Override public void glUniform4fv ( int location , int count , FloatBuffer v ) { } @ Override public void glUniform4i ( int location , int x , int y , int z , int w ) { } @ Override public void glUniform4iv ( int location , int count , IntBuffer v ) { } @ Override public void glUniformMatrix2fv ( int location , int count , boolean transpose , FloatBuffer value ) { } @ Override public void glUniformMatrix3fv ( int location , int count , boolean transpose , FloatBuffer value ) { } @ Override public void glUniformMatrix4fv ( int location , int count , boolean transpose , FloatBuffer value ) { <START_BUG> gl . glUniformMatrix2x4fv ( location , count , transpose , value ) ; <END_BUG> } @ Override public void glUseProgram ( int program ) { } @ Override public void glValidateProgram ( int program ) { } @ Override public void glVertexAttrib1f ( int indx , float x ) { } @ Override public void glVertexAttrib1fv ( int indx , FloatBuffer values ) { } @ Override public void glVertexAttrib2f ( int indx , float x , float y ) { } @ Override public void glVertexAttrib2fv ( int indx , FloatBuffer values ) { } @ Override public void glVertexAttrib3f ( int indx , float x , float y , float z ) { } @ Override public void glVertexAttrib3fv ( int indx , FloatBuffer values ) { } @ Override public void glVertexAttrib4f ( int indx , float x , float y , float z , float w ) { } @ Override public void glVertexAttrib4fv ( int indx , FloatBuffer values ) { } @ Override public void glVertexAttribPointer ( int indx , int size , int type , boolean normalized , int stride , Buffer ptr ) { } @ Override public void glViewport ( int x , int y , int width , int height ) { } @ Override public void glDrawElements ( int mode , int count , int type , int indices ) { } @ Override public void glVertexAttribPointer ( int indx , int size , int type , boolean normalized , int stride , int ptr ) { } }
 gl . glUniformMatrix2x4fv ( location , count , transpose , value ) ; 
<BUG2FIX>
gl . glUniformMatrix4fv ( location , count , transpose , value ) ;

###11### justifies the need to identify a list of operators 
public class FloatFieldMapper extends NumberFieldMapper < Float > { public static final String CONTENT_TYPE = "float" ; public static class Defaults extends NumberFieldMapper . Defaults { public static final FieldType FLOAT_FIELD_TYPE = new FieldType ( NumberFieldMapper . Defaults . NUMBER_FIELD_TYPE ) ; public static final Float NULL_VALUE = null ; } public static class Builder extends NumberFieldMapper . Builder < FloatFieldMapper . Builder , FloatFieldMapper > { protected Float nullValue = FloatFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public FloatFieldMapper . Builder nullValue ( float nullValue ) { } @ Override public FloatFieldMapper build ( BuilderContext context ) { <START_BUG> fieldType . setOmitNorms ( ( ( fieldType . omitNorms ( ) ) || ( ( boost ) != 1.0F ) ) ) ; <END_BUG> FloatFieldMapper fieldMapper = new FloatFieldMapper ( buildNames ( context ) , precisionStep , fuzzyFactor , boost , fieldType , nullValue , ignoreMalformed ( context ) ) ; fieldMapper . includeInAll ( includeInAll ) ; return fieldMapper ; } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private Float nullValue ; private String nullValueAsString ; protected FloatFieldMapper ( Names names , int precisionStep , String fuzzyFactor , float boost , FieldType fieldType , Float nullValue , Explicit < Boolean > ignoreMalformed ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Float value ( Field field ) { } @ Override public Float valueFromString ( String value ) { } @ Override public String indexedValue ( String value ) { } @ Override public Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query fuzzyQuery ( String value , double minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query fieldQuery ( String value , @ Nullable QueryParseContext context ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter fieldFilter ( String value , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( FieldDataCache fieldDataCache , String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter nullValueFilter ( ) { } @ Override protected boolean customBoost ( ) { } @ Override protected Field innerParseCreateField ( ParseContext context ) throws IOException { } @ Override public FieldDataType fieldDataType ( ) { } @ Override protected String contentType ( ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override protected void doXContentBody ( XContentBuilder builder ) throws IOException { } public static class CustomFloatNumericField extends CustomNumericField { private final float number ; private final NumberFieldMapper mapper ; public CustomFloatNumericField ( NumberFieldMapper mapper , float number , FieldType fieldType ) { } @ Override public TokenStream tokenStream ( Analyzer analyzer ) throws IOException { } @ Override public String numericAsString ( ) { } } }
 fieldType . setOmitNorms ( ( ( fieldType . omitNorms ( ) ) || ( ( boost ) != 1.0F ) ) ) ; 
<BUG2FIX>
fieldType . setOmitNorms ( ( ( fieldType . omitNorms ( ) ) && ( ( boost ) == 1.0F ) ) ) ;

###12### parentheses mismatch -> count
public class GwtFileHandle extends FileHandle { public final Preloader preloader ; private final String file ; private final FileType type ; protected GwtFileHandle ( Preloader preloader , String fileName , FileType type ) { } public GwtFileHandle ( String path ) { } public String path ( ) { } public String name ( ) { } public String extension ( ) { } public String nameWithoutExtension ( ) { } public String pathWithoutExtension ( ) { } public FileType type ( ) { } public File file ( ) { } public InputStream read ( ) { } public BufferedInputStream read ( int bufferSize ) { } public Reader reader ( ) { } public Reader reader ( String charset ) { } public BufferedReader reader ( int bufferSize ) { } public BufferedReader reader ( int bufferSize , String charset ) { } public String readString ( ) { } public String readString ( String charset ) { } public byte [ ] readBytes ( ) { } public int readBytes ( byte [ ] bytes , int offset , int size ) { } public OutputStream write ( boolean append ) { } public void write ( InputStream input , boolean append ) { } public Writer writer ( boolean append ) { } public Writer writer ( boolean append , String charset ) { } public void writeString ( String string , boolean append ) { } public void writeString ( String string , boolean append , String charset ) { } public void writeBytes ( byte [ ] bytes , boolean append ) { } public void writeBytes ( byte [ ] bytes , int offset , int length , boolean append ) { } public FileHandle [ ] list ( ) { } public FileHandle [ ] list ( String suffix ) { } public boolean isDirectory ( ) { } public FileHandle child ( String name ) { <START_BUG> return new GwtFileHandle ( preloader , ( ( file . isEmpty ( ) ? "" : ( file ) + ( file . endsWith ( "/" ) ? "" : "/" ) ) + name ) , FileType . Internal ) ; <END_BUG> } public FileHandle parent ( ) { } public FileHandle sibling ( String name ) { } public void mkdirs ( ) { } public boolean exists ( ) { } public boolean delete ( ) { } public boolean deleteDirectory ( ) { } public void copyTo ( FileHandle dest ) { } public void moveTo ( FileHandle dest ) { } public long length ( ) { } public long lastModified ( ) { } public String toString ( ) { } }
return new GwtFileHandle ( preloader , ( ( file . isEmpty ( ) ? "" : ( file ) + ( file . endsWith ( "/" ) ? "" : "/" ) ) + name ) , FileType . Internal ) ; 
<BUG2FIX>
return new GwtFileHandle ( preloader , ( file . isEmpty ( ) ? "" : ( ( file ) + ( file . endsWith ( "/" ) ? "" : "/" ) ) + name ) , FileType . Internal ) ;

###13### remove one parameter 
public class ExternalMapper extends AbstractFieldMapper < Object > { @ Override public Object value ( Object value ) { } public static class Names { public static final String FIELD_BIN = "bin" ; public static final String FIELD_BOOL = "bool" ; public static final String FIELD_POINT = "point" ; public static final String FIELD_SHAPE = "shape" ; } public static class Builder extends AbstractFieldMapper . Builder < ExternalMapper . Builder , ExternalMapper > { private BinaryFieldMapper . Builder binBuilder = new BinaryFieldMapper . Builder ( ExternalMapper . Names . FIELD_BIN ) ; private BooleanFieldMapper . Builder boolBuilder = new BooleanFieldMapper . Builder ( ExternalMapper . Names . FIELD_BOOL ) ; private GeoPointFieldMapper . Builder pointBuilder = new GeoPointFieldMapper . Builder ( ExternalMapper . Names . FIELD_POINT ) ; private GeoShapeFieldMapper . Builder shapeBuilder = new GeoShapeFieldMapper . Builder ( ExternalMapper . Names . FIELD_SHAPE ) ; private Mapper . Builder stringBuilder ; private String generatedValue ; private String mapperName ; public Builder ( String name , String generatedValue , String mapperName ) { } public ExternalMapper . Builder string ( Mapper . Builder content ) { } @ Override public ExternalMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { private String generatedValue ; private String mapperName ; TypeParser ( String mapperName , String generatedValue ) { } @ SuppressWarnings ( { "unchecked" } ) @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { ExternalMapper . Builder builder = new ExternalMapper . Builder ( name , generatedValue , mapperName ) ; parseField ( builder , name , node , parserContext ) ; for ( Map . Entry < String , Object > entry : node . entrySet ( ) ) { String propName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object propNode = entry . getValue ( ) ; <START_BUG> parseMultiField ( builder , name , node , parserContext , propName , propNode ) ; <END_BUG> } return builder ; } } private final String generatedValue ; private final String mapperName ; private final BinaryFieldMapper binMapper ; private final BooleanFieldMapper boolMapper ; private final GeoPointFieldMapper pointMapper ; private final GeoShapeFieldMapper shapeMapper ; private final Mapper stringMapper ; public ExternalMapper ( FieldMapper . Names names , String generatedValue , String mapperName , BinaryFieldMapper binMapper , BooleanFieldMapper boolMapper , GeoPointFieldMapper pointMapper , GeoShapeFieldMapper shapeMapper , Mapper stringMapper , MultiFields multiFields , CopyTo copyTo ) { } @ Override public FieldType defaultFieldType ( ) { } @ Override public FieldDataType defaultFieldDataType ( ) { } @ Override public void parse ( ParseContext context ) throws IOException { } @ Override protected void parseCreateField ( ParseContext context , List < Field > fields ) throws IOException { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override public void traverse ( FieldMapperListener fieldMapperListener ) { } @ Override public void traverse ( ObjectMapperListener objectMapperListener ) { } @ Override public void close ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override protected String contentType ( ) { } }
 parseMultiField ( builder , name , node , parserContext , propName , propNode ) ; 
<BUG2FIX>
parseMultiField ( builder , name , parserContext , propName , propNode ) ;

###14### failed to use class attribute MATCH_ALL_QUERY (distbug could help by making class methods and parameters appear at distance 1) 
public class Queries { public static final Query MATCH_ALL_QUERY = new DeletionAwareConstantScoreQuery ( new MatchAllDocsFilter ( ) , true ) ; public static final Filter MATCH_ALL_FILTER = new MatchAllDocsFilter ( ) ; private static final Field disjuncts ; public static List < Query > disMaxClauses ( DisjunctionMaxQuery query ) { } public static Query optimizeQuery ( Query q ) { } public static boolean isNegativeQuery ( Query q ) { } public static Query fixNegativeQueryIfNeeded ( Query q ) { if ( Queries . isNegativeQuery ( q ) ) { BooleanQuery newBq = ( ( BooleanQuery ) ( q . clone ( ) ) ) ; <START_BUG> newBq . add ( new MatchAllDocsQuery ( ) , MUST ) ; <END_BUG> return newBq ; } return q ; } }
 newBq . add ( new MatchAllDocsQuery ( ) , MUST ) ; 
<BUG2FIX>
newBq . add ( Queries . MATCH_ALL_QUERY , MUST ) ;

###15### tag operators
public class Bits { long [ ] bits = new long [ ] { 0 } ; public boolean get ( int index ) { } public void set ( int index ) { } public void flip ( int index ) { } private void checkCapacity ( int len ) { <START_BUG> if ( len > ( bits . length ) ) { <END_BUG> long [ ] newBits = new long [ len + 1 ] ; System . arraycopy ( bits , 0 , newBits , 0 , bits . length ) ; bits = newBits ; } } public void clear ( int index ) { } public void clear ( ) { } public int numBits ( ) { } }
 if ( len > ( bits . length ) ) { 
<BUG2FIX>
if ( len >= ( bits . length ) ) {

###16### set specific tag for assignments to distinguish "x = a * b" from "x = a = b"
public class CircularBuffer { private final short [ ] buffer ; private int writePosition ; private int readPosition ; private int available ; public CircularBuffer ( int size ) { } public void write ( short [ ] data , int offset , int count ) { } public void combine ( short [ ] data , int offset , int count ) { } public int read ( short [ ] data , int offset , int count ) { } public int skip ( int count ) { <START_BUG> int total = count = Math . min ( available , count ) ; <END_BUG> available -= total ; readPosition = ( ( readPosition ) + total ) % ( buffer . length ) ; return total ; } public void clear ( ) { } public void setWritePosition ( int writePosition ) { } public int getWritePosition ( ) { } public void setReadPosition ( int readPosition ) { } public int getReadPosition ( ) { } public int getAvailable ( ) { } private void dump ( ) { } private static void combine ( short [ ] src , int srcPos , short [ ] dest , int destPos , int length ) { } public static void main ( String [ ] args ) throws Exception { } }
 int total = count = Math . min ( available , count ) ; 
<BUG2FIX>
int total = Math . min ( available , count ) ;



###17#### 9 samples in training set using "assert false ;" without it being considered a bug.. -> 78 samples using fail();, but "fail" and assert false ; are never together in the same code. 
public class UpdateSettingsTests extends ElasticsearchIntegrationTest { @ Test public void testOpenCloseUpdateSettings ( ) throws Exception { createIndex ( "test" ) ; try { client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( "test" ) . setSettings ( ImmutableSettings . settingsBuilder ( ) . put ( "index.refresh_interval" , ( - 1 ) ) . put ( "index.cache.filter.type" , "none" ) ) . execute ( ) . actionGet ( ) ; <START_BUG> assert false ; <END_BUG> } catch ( ElasticsearchIllegalArgumentException e ) { } IndexMetaData indexMetaData = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) . metaData ( ) . index ( "test" ) ; assertThat ( indexMetaData . settings ( ) . get ( "index.refresh_interval" ) , nullValue ( ) ) ; assertThat ( indexMetaData . settings ( ) . get ( "index.cache.filter.type" ) , nullValue ( ) ) ; GetSettingsResponse getSettingsResponse = client ( ) . admin ( ) . indices ( ) . prepareGetSettings ( "test" ) . get ( ) ; assertThat ( getSettingsResponse . getSetting ( "test" , "index.refresh_interval" ) , nullValue ( ) ) ; assertThat ( getSettingsResponse . getSetting ( "test" , "index.cache.filter.type" ) , nullValue ( ) ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( "test" ) . setSettings ( ImmutableSettings . settingsBuilder ( ) . put ( "index.refresh_interval" , ( - 1 ) ) ) . execute ( ) . actionGet ( ) ; indexMetaData = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) . metaData ( ) . index ( "test" ) ; assertThat ( indexMetaData . settings ( ) . get ( "index.refresh_interval" ) , equalTo ( "-1" ) ) ; getSettingsResponse = client ( ) . admin ( ) . indices ( ) . prepareGetSettings ( "test" ) . get ( ) ; assertThat ( getSettingsResponse . getSetting ( "test" , "index.refresh_interval" ) , equalTo ( "-1" ) ) ; ClusterHealthResponse health = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setTimeout ( "30s" ) . setWaitForEvents ( LANGUID ) . setWaitForGreenStatus ( ) . execute ( ) . actionGet ( ) ; assertThat ( health . isTimedOut ( ) , equalTo ( false ) ) ; client ( ) . admin ( ) . indices ( ) . prepareClose ( "test" ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( "test" ) . setSettings ( ImmutableSettings . settingsBuilder ( ) . put ( "index.refresh_interval" , "1s" ) . put ( "index.cache.filter.type" , "none" ) ) . execute ( ) . actionGet ( ) ; indexMetaData = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) . metaData ( ) . index ( "test" ) ; assertThat ( indexMetaData . settings ( ) . get ( "index.refresh_interval" ) , equalTo ( "1s" ) ) ; assertThat ( indexMetaData . settings ( ) . get ( "index.cache.filter.type" ) , equalTo ( "none" ) ) ; getSettingsResponse = client ( ) . admin ( ) . indices ( ) . prepareGetSettings ( "test" ) . get ( ) ; assertThat ( getSettingsResponse . getSetting ( "test" , "index.refresh_interval" ) , equalTo ( "1s" ) ) ; assertThat ( getSettingsResponse . getSetting ( "test" , "index.cache.filter.type" ) , equalTo ( "none" ) ) ; } @ Test public void testEngineGCDeletesSetting ( ) throws InterruptedException { } }
 assert false ; 
<BUG2FIX>
fail ( ) ;

###18### basic thing true >< false -> vocab embedding relying on a grammar of java ? 
public class BulletTestCollection extends GdxTest implements InputProcessor , GestureListener { protected final BulletTest [ ] tests = new BulletTest [ ] { new ShootTest ( ) , new BasicShapesTest ( ) , new KinematicTest ( ) , new ConstraintsTest ( ) , new MeshShapeTest ( ) , new ConvexHullTest ( ) , new RayCastTest ( ) , new RayPickRagdollTest ( ) , new InternalTickTest ( ) , new CollisionWorldTest ( ) , new CollisionTest ( ) , new FrustumCullingTest ( ) , new ContactCallbackTest ( ) , new SoftBodyTest ( ) } ; protected int testIndex = 0 ; private Application app = null ; private BitmapFont font ; private Stage hud ; private Label fpsLabel ; private Label titleLabel ; private Label instructLabel ; private int loading = 0 ; @ Override public void render ( ) { } @ Override public void create ( ) { } @ Override public void dispose ( ) { } public void next ( ) { } public void loadnext ( ) { } @ Override public boolean keyDown ( int keycode ) { } @ Override public boolean keyTyped ( char character ) { } @ Override public boolean keyUp ( int keycode ) { } @ Override public boolean touchDown ( int x , int y , int pointer , int button ) { } @ Override public boolean touchDragged ( int x , int y , int pointer ) { } @ Override public boolean touchUp ( int x , int y , int pointer , int button ) { } @ Override public boolean needsGL20 ( ) { <START_BUG> return true ; <END_BUG> } @ Override public boolean mouseMoved ( int x , int y ) { } @ Override public boolean scrolled ( int amount ) { } @ Override public boolean touchDown ( float x , float y , int pointer , int button ) { } @ Override public boolean tap ( float x , float y , int count , int button ) { } @ Override public boolean longPress ( float x , float y ) { } @ Override public boolean fling ( float velocityX , float velocityY , int button ) { } @ Override public boolean pan ( float x , float y , float deltaX , float deltaY ) { } @ Override public boolean zoom ( float originalDistance , float currentDistance ) { } @ Override public boolean pinch ( Vector2 initialFirstPointer , Vector2 initialSecondPointer , Vector2 firstPointer , Vector2 secondPointer ) { } }
 return true ; 
<BUG2FIX>
return false ;

###19### argument swapping does not always work..
public class TransportDeleteMappingAction extends TransportMasterNodeOperationAction < DeleteMappingRequest , DeleteMappingResponse > { private final MetaDataMappingService metaDataMappingService ; private final TransportFlushAction flushAction ; private final TransportDeleteByQueryAction deleteByQueryAction ; private final TransportRefreshAction refreshAction ; private final DestructiveOperations destructiveOperations ; @ Inject public TransportDeleteMappingAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , MetaDataMappingService metaDataMappingService , TransportDeleteByQueryAction deleteByQueryAction , TransportRefreshAction refreshAction , TransportFlushAction flushAction , NodeSettingsService nodeSettingsService ) { } @ Override protected String executor ( ) { } @ Override protected String transportAction ( ) { } @ Override protected DeleteMappingRequest newRequest ( ) { } @ Override protected DeleteMappingResponse newResponse ( ) { } @ Override protected void doExecute ( DeleteMappingRequest request , ActionListener < DeleteMappingResponse > listener ) { } @ Override protected ClusterBlockException checkBlock ( DeleteMappingRequest request , ClusterState state ) { } @ Override protected void masterOperation ( final DeleteMappingRequest request , final ClusterState state , final ActionListener < DeleteMappingResponse > listener ) throws ElasticsearchException { <START_BUG> request . indices ( state . metaData ( ) . concreteIndices ( request . indices ( ) , request . indicesOptions ( ) ) ) ; <END_BUG> flushAction . execute ( Requests . flushRequest ( request . indices ( ) ) , new ActionListener < FlushResponse > ( ) { @ Override public void onResponse ( FlushResponse flushResponse ) { if ( logger . isTraceEnabled ( ) ) { traceLogResponse ( "Flush" , flushResponse ) ; } ImmutableOpenMap < String , ImmutableOpenMap < String , MappingMetaData > > result = clusterService . state ( ) . metaData ( ) . findMappings ( request . indices ( ) , request . types ( ) ) ; BoolFilterBuilder filterBuilder = new BoolFilterBuilder ( ) ; Set < String > types = new HashSet < > ( ) ; for ( ObjectObjectCursor < String , ImmutableOpenMap < String , MappingMetaData > > typesMeta : result ) { for ( ObjectObjectCursor < String , MappingMetaData > type : typesMeta . value ) { filterBuilder . should ( new org . elasticsearch . index . query . TypeFilterBuilder ( type . key ) ) ; types . add ( type . key ) ; } } if ( ( types . size ( ) ) == 0 ) { throw new org . elasticsearch . indices . TypeMissingException ( new Index ( "_all" ) , request . types ( ) , "No<seq2seq4repair_space>index<seq2seq4repair_space>has<seq2seq4repair_space>the<seq2seq4repair_space>type." ) ; } request . types ( types . toArray ( new String [ types . size ( ) ] ) ) ; QuerySourceBuilder querySourceBuilder = new QuerySourceBuilder ( ) . setQuery ( QueryBuilders . filteredQuery ( QueryBuilders . matchAllQuery ( ) , filterBuilder ) ) ; deleteByQueryAction . execute ( Requests . deleteByQueryRequest ( request . indices ( ) ) . source ( querySourceBuilder ) , new ActionListener < DeleteByQueryResponse > ( ) { @ Override public void onResponse ( DeleteByQueryResponse deleteByQueryResponse ) { if ( logger . isTraceEnabled ( ) ) { for ( IndexDeleteByQueryResponse indexResponse : deleteByQueryResponse ) { logger . trace ( "Delete<seq2seq4repair_space>by<seq2seq4repair_space>query[{}]<seq2seq4repair_space>completed<seq2seq4repair_space>with<seq2seq4repair_space>total[{}],<seq2seq4repair_space>successful[{}]<seq2seq4repair_space>and<seq2seq4repair_space>failed[{}]" , indexResponse . getIndex ( ) , indexResponse . getTotalShards ( ) , indexResponse . getSuccessfulShards ( ) , indexResponse . getFailedShards ( ) ) ; if ( ( indexResponse . getFailedShards ( ) ) > 0 ) { for ( ShardOperationFailedException failure : indexResponse . getFailures ( ) ) { logger . trace ( "[{}/{}]<seq2seq4repair_space>Delete<seq2seq4repair_space>by<seq2seq4repair_space>query<seq2seq4repair_space>shard<seq2seq4repair_space>failure<seq2seq4repair_space>reason:<seq2seq4repair_space>{}" , failure . index ( ) , failure . shardId ( ) , failure . reason ( ) ) ; } } } } refreshAction . execute ( Requests . refreshRequest ( request . indices ( ) ) , new ActionListener < RefreshResponse > ( ) { @ Override public void onResponse ( RefreshResponse refreshResponse ) { if ( logger . isTraceEnabled ( ) ) { traceLogResponse ( "Refresh" , refreshResponse ) ; } removeMapping ( ) ; } @ Override public void onFailure ( Throwable e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Refresh<seq2seq4repair_space>failed<seq2seq4repair_space>completely" , e ) ; } removeMapping ( ) ; } protected void removeMapping ( ) { DeleteMappingClusterStateUpdateRequest clusterStateUpdateRequest = new DeleteMappingClusterStateUpdateRequest ( ) . indices ( request . indices ( ) ) . types ( request . types ( ) ) . ackTimeout ( request . timeout ( ) ) . masterNodeTimeout ( request . masterNodeTimeout ( ) ) ; metaDataMappingService . removeMapping ( clusterStateUpdateRequest , new ClusterStateUpdateListener ( ) { @ Override public void onResponse ( ClusterStateUpdateResponse response ) { listener . onResponse ( new DeleteMappingResponse ( response . isAcknowledged ( ) ) ) ; } @ Override public void onFailure ( Throwable t ) { listener . onFailure ( t ) ; } } ) ; } } ) ; } @ Override public void onFailure ( Throwable t ) { listener . onFailure ( t ) ; } } ) ; } @ Override public void onFailure ( Throwable t ) { listener . onFailure ( t ) ; } } ) ; } private void traceLogResponse ( String action , BroadcastOperationResponse response ) { } }
 request . indices ( state . metaData ( ) . concreteIndices ( request . indices ( ) , request . indicesOptions ( ) ) ) ; 
<BUG2FIX>
request . indices ( state . metaData ( ) . concreteIndices ( request . indicesOptions ( ) , request . indices ( ) ) ) ;


###20### technically possible, but really hard to guess without knowledge about the fct's arguments
@ Test public class SimpleJsonIndexQueryParserTests { private final Index index = new Index ( "test" ) ; @ Test public void testQueryStringBuilder ( ) throws Exception { } @ Test public void testQueryString ( ) throws Exception { } @ Test public void testQueryStringFields1Builder ( ) throws Exception { } @ Test public void testQueryStringFields1 ( ) throws Exception { } @ Test public void testQueryStringFields2Builder ( ) throws Exception { } @ Test public void testQueryStringFields2 ( ) throws Exception { } @ Test public void testQueryStringFields3Builder ( ) throws Exception { } @ Test public void testQueryStringFields3 ( ) throws Exception { } @ Test public void testMatchAllBuilder ( ) throws Exception { } @ Test public void testMatchAll ( ) throws Exception { } @ Test public void testDisMaxBuilder ( ) throws Exception { } @ Test public void testDisMax ( ) throws Exception { } @ Test public void testTermQueryBuilder ( ) throws IOException { } @ Test public void testTermQuery ( ) throws IOException { } @ Test public void testFieldQueryBuilder1 ( ) throws IOException { } @ Test public void testFieldQuery1 ( ) throws IOException { } @ Test public void testFieldQuery2 ( ) throws IOException { } @ Test public void testFieldQuery3 ( ) throws IOException { } @ Test public void testTermWithBoostQueryBuilder ( ) throws IOException { } @ Test public void testTermWithBoostQuery ( ) throws IOException { } @ Test public void testPrefixQueryBuilder ( ) throws IOException { } @ Test public void testPrefixQuery ( ) throws IOException { } @ Test public void testPrefixFilteredQueryBuilder ( ) throws IOException { } @ Test public void testPrefixFilteredQuery ( ) throws IOException { } @ Test public void testPrefixQueryBoostQueryBuilder ( ) throws IOException { } @ Test public void testPrefixQueryBoostQuery ( ) throws IOException { } @ Test public void testWildcardQueryBuilder ( ) throws IOException { } @ Test public void testWildcardQuery ( ) throws IOException { } @ Test public void testRangeQueryBuilder ( ) throws IOException { } @ Test public void testRangeQuery ( ) throws IOException { } @ Test public void testRangeFilteredQueryBuilder ( ) throws IOException { } @ Test public void testRangeFilteredQuery ( ) throws IOException { } @ Test public void testBoolFilteredQuery ( ) throws IOException { } @ Test public void testBoolQueryBuilder ( ) throws IOException { } @ Test public void testBoolQuery ( ) throws IOException { } @ Test public void testFilteredQueryBuilder ( ) throws IOException { } @ Test public void testFilteredQuery ( ) throws IOException { } @ Test public void testFilteredQuery2 ( ) throws IOException { } @ Test public void testFilteredQuery3 ( ) throws IOException { } @ Test public void testFilteredQuery4 ( ) throws IOException { } @ Test public void testTermsFilterQueryBuilder ( ) throws Exception { } @ Test public void testTermsFilterQuery ( ) throws Exception { } @ Test public void testConstantScoreQueryBuilder ( ) throws IOException { } @ Test public void testConstantScoreQuery ( ) throws IOException { } @ Test public void testSpanTermQueryBuilder ( ) throws IOException { } @ Test public void testSpanTermQuery ( ) throws IOException { } @ Test public void testSpanNotQueryBuilder ( ) throws IOException { } @ Test public void testSpanNotQuery ( ) throws IOException { } @ Test public void testSpanFirstQueryBuilder ( ) throws IOException { } @ Test public void testSpanFirstQuery ( ) throws IOException { } @ Test public void testSpanNearQueryBuilder ( ) throws IOException { } @ Test public void testSpanNearQuery ( ) throws IOException { } @ Test public void testSpanOrQueryBuilder ( ) throws IOException { } @ Test public void testSpanOrQuery ( ) throws IOException { } @ Test public void testQueryFilterBuilder ( ) throws Exception { } @ Test public void testQueryFilter ( ) throws Exception { } @ Test public void testMoreLikeThisBuilder ( ) throws Exception { } @ Test public void testMoreLikeThis ( ) throws Exception { } @ Test public void testMoreLikeThisFieldBuilder ( ) throws Exception { } @ Test public void testMoreLikeThisField ( ) throws Exception { } private JsonIndexQueryParser newQueryParser ( ) throws IOException { <START_BUG> return new JsonIndexQueryParser ( new Index ( "test" ) , EMPTY_SETTINGS , newMapperService ( ) , new org . elasticsearch . index . cache . filter . none . NoneFilterCache ( index , EMPTY_SETTINGS ) , new org . elasticsearch . index . analysis . AnalysisService ( index ) , null , null , "test" , null ) ; <END_BUG> } private MapperService newMapperService ( ) throws IOException { } }
 return new JsonIndexQueryParser ( new Index ( "test" ) , EMPTY_SETTINGS , newMapperService ( ) , new org . elasticsearch . index . cache . filter . none . NoneFilterCache ( index , EMPTY_SETTINGS ) , new org . elasticsearch . index . analysis . AnalysisService ( index ) , null , null , "test" , null ) ; 
<BUG2FIX>
return new JsonIndexQueryParser ( new Index ( "test" ) , EMPTY_SETTINGS , newMapperService ( ) , new org . elasticsearch . index . cache . filter . none . NoneFilterCache ( index , EMPTY_SETTINGS ) , new org . elasticsearch . index . analysis . AnalysisService ( index ) , null , null , null , "test" , null ) ;


###21### technically possible, but the buggy line is very long -> arguably not very good practice writing such code 
@ AfterClass public void closeNodes ( ) { } protected Client getClient ( ) { } @ Test public void testSimple ( ) throws Exception { } @ Test public void testEmpty ( ) throws Exception { } @ Test public void testWithMultipleCommands ( ) throws Exception { } @ Test public void testSizeAndSort ( ) throws Exception { client . admin ( ) . indices ( ) . prepareDelete ( ) . execute ( ) . actionGet ( ) ; client . admin ( ) . indices ( ) . prepareCreate ( "test" ) . setSettings ( settingsBuilder ( ) . put ( SETTING_NUMBER_OF_SHARDS , 5 ) . put ( SETTING_NUMBER_OF_REPLICAS , 0 ) ) . execute ( ) . actionGet ( ) ; client . admin ( ) . cluster ( ) . prepareHealth ( "test" ) . setWaitForGreenStatus ( ) . execute ( ) . actionGet ( ) ; Map < String , Integer > termsAndDocCount = new HashMap < String , Integer > ( ) ; termsAndDocCount . put ( "prefix_aaad" , 20 ) ; termsAndDocCount . put ( "prefix_abbb" , 18 ) ; termsAndDocCount . put ( "prefix_aaca" , 16 ) ; termsAndDocCount . put ( "prefix_abba" , 14 ) ; termsAndDocCount . put ( "prefix_accc" , 12 ) ; termsAndDocCount . put ( "prefix_addd" , 10 ) ; termsAndDocCount . put ( "prefix_abaa" , 8 ) ; termsAndDocCount . put ( "prefix_dbca" , 6 ) ; termsAndDocCount . put ( "prefix_cbad" , 4 ) ; termsAndDocCount . put ( "prefix_aacd" , 1 ) ; termsAndDocCount . put ( "prefix_abcc" , 1 ) ; termsAndDocCount . put ( "prefix_accd" , 1 ) ; for ( Map . Entry < String , Integer > entry : termsAndDocCount . entrySet ( ) ) { for ( int i = 0 ; i < ( entry . getValue ( ) ) ; i ++ ) { client . prepareIndex ( "test" , "type1" ) . setSource ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( "field1" , entry . getKey ( ) ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; } } client . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; <START_BUG> SearchResponse search = client . prepareSearch ( ) . setSuggestText ( "prefix_abcd" ) . addSuggestion ( fuzzySuggestion ( "size3SortScoreFirst" ) . setSize ( 3 ) . setMinDocFreq ( 0 ) . setField ( "field1" ) . setSuggestMode ( "always" ) ) . addSuggestion ( fuzzySuggestion ( "size10SortScoreFirst" ) . setSize ( 10 ) . setMinDocFreq ( 0 ) . setField ( "field1" ) . setSuggestMode ( "always" ) ) . addSuggestion ( fuzzySuggestion ( "size3SortScoreFirstMaxEdits1" ) . setMaxEdits ( 1 ) . setSize ( 10 ) . setMinDocFreq ( 0 ) . setField ( "field1" ) . setSuggestMode ( "always" ) ) . addSuggestion ( fuzzySuggestion ( "size10SortFrequencyFirst" ) . setSize ( 10 ) . setSort ( "frequency" ) . setShardSize ( 1000 ) . setMinDocFreq ( 0 ) . setField ( "field1" ) . setSuggestMode ( "always" ) ) . execute ( ) . actionGet ( ) ; <END_BUG> assertThat ( Arrays . toString ( search . shardFailures ( ) ) , search . failedShards ( ) , equalTo ( 0 ) ) ; assertThat ( search . suggest ( ) , notNullValue ( ) ) ; assertThat ( search . suggest ( ) . getSuggestions ( ) . size ( ) , equalTo ( 4 ) ) ; assertThat ( search . suggest ( ) . getSuggestions ( ) . get ( 0 ) . getName ( ) , equalTo ( "size3SortScoreFirst" ) ) ; assertThat ( search . suggest ( ) . getSuggestions ( ) . get ( 0 ) . getEntries ( ) . size ( ) , equalTo ( 1 ) ) ; assertThat ( search . suggest ( ) . getSuggestions ( ) . get ( 0 ) . getEntries ( ) . get ( 0 ) . getOptions ( ) . size ( ) , equalTo ( 3 ) ) ; assertThat ( search . suggest ( ) . getSuggestions ( ) . get ( 0 ) . getEntries ( ) . get ( 0 ) . getOptions ( ) . get ( 0 ) . getText ( ) . string ( ) , equalTo ( "prefix_aacd" ) ) ; assertThat ( search . suggest ( ) . getSuggestions ( ) . get ( 0 ) . getEntries ( ) . get ( 0 ) . getOptions ( ) . get ( 1 ) . getText ( ) . string ( ) , equalTo ( "prefix_abcc" ) ) ; assertThat ( search . suggest ( ) . getSuggestions ( ) . get ( 0 ) . getEntries ( ) . get ( 0 ) . getOptions ( ) . get ( 2 ) . getText ( ) . string ( ) , equalTo ( "prefix_accd" ) ) ; assertThat ( search . suggest ( ) . getSuggestions ( ) . get ( 1 ) . getName ( ) , equalTo ( "size10SortScoreFirst" ) ) ; assertThat ( search . suggest ( ) . getSuggestions ( ) . get ( 1 ) . getEntries ( ) . size ( ) , equalTo ( 1 ) ) ; assertThat ( search . suggest ( ) . getSuggestions ( ) . get ( 1 ) . getEntries ( ) . get ( 0 ) . getOptions ( ) . size ( ) , equalTo ( 10 ) ) ; assertThat ( search . suggest ( ) . getSuggestions ( ) . get ( 1 ) . getEntries ( ) . get ( 0 ) . getOptions ( ) . get ( 0 ) . getText ( ) . string ( ) , equalTo ( "prefix_aacd" ) ) ;
 SearchResponse search = client . prepareSearch ( ) . setSuggestText ( "prefix_abcd" ) . addSuggestion ( fuzzySuggestion ( "size3SortScoreFirst" ) . setSize ( 3 ) . setMinDocFreq ( 0 ) . setField ( "field1" ) . setSuggestMode ( "always" ) ) . addSuggestion ( fuzzySuggestion ( "size10SortScoreFirst" ) . setSize ( 10 ) . setMinDocFreq ( 0 ) . setField ( "field1" ) . setSuggestMode ( "always" ) ) . addSuggestion ( fuzzySuggestion ( "size3SortScoreFirstMaxEdits1" ) . setMaxEdits ( 1 ) . setSize ( 10 ) . setMinDocFreq ( 0 ) . setField ( "field1" ) . setSuggestMode ( "always" ) ) . addSuggestion ( fuzzySuggestion ( "size10SortFrequencyFirst" ) . setSize ( 10 ) . setSort ( "frequency" ) . setShardSize ( 1000 ) . setMinDocFreq ( 0 ) . setField ( "field1" ) . setSuggestMode ( "always" ) ) . execute ( ) . actionGet ( ) ; 
<BUG2FIX>
SearchResponse search = client . prepareSearch ( ) . setSuggestText ( "prefix_abcd" ) . addSuggestion ( fuzzySuggestion ( "size3SortScoreFirst" ) . setSize ( 3 ) . setMinDocFreq ( 0 ) . setField ( "field1" ) . setSuggestMode ( "always" ) ) . addSuggestion ( fuzzySuggestion ( "size10SortScoreFirst" ) . setSize ( 10 ) . setMinDocFreq ( 0 ) . setField ( "field1" ) . setSuggestMode ( "always" ) . setShardSize ( 50 ) ) . addSuggestion ( fuzzySuggestion ( "size3SortScoreFirstMaxEdits1" ) . setMaxEdits ( 1 ) . setSize ( 10 ) . setMinDocFreq ( 0 ) . setField ( "field1" ) . setSuggestMode ( "always" ) ) . addSuggestion ( fuzzySuggestion ( "size10SortFrequencyFirst" ) . setSize ( 10 ) . setSort ( "frequency" ) . setShardSize ( 1000 ) . setMinDocFreq ( 0 ) . setField ( "field1" ) . setSuggestMode ( "always" ) ) . execute ( ) . actionGet ( ) ;


###22### rotAngle defined just one line before bug -- as humans, we understand that angle and rotAngle have similar usages -> should include word embedding representative of distance between strings
public class OrthographicCamera extends Camera { public float zoom = 1 ; public OrthographicCamera ( ) { } public OrthographicCamera ( float viewportWidth , float viewportHeight ) { } public OrthographicCamera ( float viewportWidth , float viewportHeight , float diamondAngle ) { } public void findDirectionForIsoView ( float targetAngle , float epsilon , int maxIterations ) { } private float calculateAngle ( float a ) { } private Vector3 calculateDirection ( float angle ) { Matrix4 transform = new Matrix4 ( ) ; Vector3 dir = new Vector3 ( ( - 1 ) , 0 , 1 ) . nor ( ) ; float rotAngle = ( ( float ) ( Math . toDegrees ( Math . asin ( Math . tan ( Math . toRadians ( angle ) ) ) ) ) ) ; <START_BUG> transform . setToRotation ( new Vector3 ( 1 , 0 , 1 ) . nor ( ) , angle ) ; <END_BUG> dir . mul ( transform ) . nor ( ) ; return dir ; } private final Vector3 tmp = new Vector3 ( ) ; @ Override public void update ( ) { } @ Override public void update ( boolean updateFrustum ) { } public void setToOrtho ( boolean yDown ) { } public void setToOrtho ( boolean yDown , float viewportWidth , float viewportHeight ) { } public void rotate ( float angle ) { } public void translate ( float x , float y ) { } public void translate ( Vector2 vec ) { } }
 transform . setToRotation ( new Vector3 ( 1 , 0 , 1 ) . nor ( ) , angle ) ; 
<BUG2FIX>
transform . setToRotation ( new Vector3 ( 1 , 0 , 1 ) . nor ( ) , rotAngle ) ;