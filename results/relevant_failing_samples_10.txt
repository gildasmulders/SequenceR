###0### lots of Exception > Throwable 
public class RestCreateIndexAction extends BaseRestHandler { @ Inject public RestCreateIndexAction ( Settings settings , Client client , RestController controller ) { } @ SuppressWarnings ( { "unchecked" } ) @ Override public void handleRequest ( final RestRequest request , final RestChannel channel ) { CreateIndexRequest createIndexRequest = new CreateIndexRequest ( request . param ( "index" ) ) ; createIndexRequest . listenerThreaded ( false ) ; if ( request . hasContent ( ) ) { try { createIndexRequest . source ( request . content ( ) ) ; } catch ( Exception e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . warn ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>response" , e1 ) ; } return ; } } createIndexRequest . timeout ( request . paramAsTime ( "timeout" , timeValueSeconds ( 10 ) ) ) ; client . admin ( ) . indices ( ) . create ( createIndexRequest , new org . elasticsearch . action . ActionListener < CreateIndexResponse > ( ) { @ Override public void onResponse ( CreateIndexResponse response ) { try { XContentBuilder builder = RestXContentBuilder . restContentBuilder ( request ) ; builder . startObject ( ) . field ( "ok" , true ) . field ( "acknowledged" , response . isAcknowledged ( ) ) . endObject ( ) ; channel . sendResponse ( new XContentRestResponse ( request , RestStatus . OK , builder ) ) ; <START_BUG> } catch ( Exception e ) { <END_BUG> onFailure ( e ) ; } } @ Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( new XContentThrowableRestResponse ( request , e ) ) ; } catch ( IOException e1 ) { logger . error ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>failure<seq2seq4repair_space>response" , e1 ) ; } } } ) ; } }
 } catch ( Exception e ) { 
<BUG2FIX>
} catch ( Throwable e ) {

###1### should identify assignment structure to make embedding of identifier close to its value -> special tag for assignment
public class MultiValueLongFieldData extends LongFieldData { private static final int VALUE_CACHE_SIZE = 10 ; private ThreadLocal < ThreadLocals . CleanableValue < double [ ] [ ] > > doublesValuesCache = new ThreadLocal < ThreadLocals . CleanableValue < double [ ] [ ] > > ( ) { @ Override protected ThreadLocals . CleanableValue < double [ ] [ ] > initialValue ( ) { } } ; private ThreadLocal < ThreadLocals . CleanableValue < MutableDateTime [ ] [ ] > > dateTimesCache = new ThreadLocal < ThreadLocals . CleanableValue < MutableDateTime [ ] [ ] > > ( ) { @ Override protected ThreadLocals . CleanableValue < MutableDateTime [ ] [ ] > initialValue ( ) { } } ; private ThreadLocal < ThreadLocals . CleanableValue < long [ ] [ ] > > valuesCache = new ThreadLocal < ThreadLocals . CleanableValue < long [ ] [ ] > > ( ) { @ Override protected ThreadLocals . CleanableValue < long [ ] [ ] > initialValue ( ) { } } ; private final int [ ] [ ] ordinals ; public MultiValueLongFieldData ( String fieldName , int [ ] [ ] ordinals , long [ ] values ) { } @ Override protected long computeSizeInBytes ( ) { } @ Override public boolean multiValued ( ) { } @ Override public boolean hasValue ( int docId ) { } @ Override public void forEachValueInDoc ( int docId , StringValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , DoubleValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , LongValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , MissingDoubleValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , MissingLongValueInDocProc proc ) { } @ Override public void forEachOrdinalInDoc ( int docId , OrdinalInDocProc proc ) { boolean found = false ; for ( int [ ] ordinal : ordinals ) { int loc = ordinal [ docId ] ; if ( loc != 0 ) { found = true ; <START_BUG> proc . onOrdinal ( docId , ordinal [ docId ] ) ; <END_BUG> } } if ( ! found ) { proc . onOrdinal ( docId , 0 ) ; } } @ Override public void forEachValueInDoc ( int docId , ValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , DateValueInDocProc proc ) { } @ Override public void forEachValueInDoc ( int docId , MutableDateTime dateTime , DateValueInDocProc proc ) { } @ Override public MutableDateTime [ ] dates ( int docId ) { } @ Override public double [ ] doubleValues ( int docId ) { } @ Override public long value ( int docId ) { } @ Override public long [ ] values ( int docId ) { } }
 proc . onOrdinal ( docId , ordinal [ docId ] ) ; 
<BUG2FIX>
proc . onOrdinal ( docId , loc ) ;

###2### failed to use the argument of the method + could distinguish identifiers of variables and identifiers of names of methods and classes
public class WidgetGroup extends Group implements Layout { private boolean needsLayout = true ; private boolean fillParent ; private boolean layoutEnabled = true ; public float getMinWidth ( ) { } public float getMinHeight ( ) { } public float getPrefWidth ( ) { } public float getPrefHeight ( ) { } public float getMaxWidth ( ) { } public float getMaxHeight ( ) { } public void setLayoutEnabled ( boolean enabled ) { } private void setLayoutEnabled ( Group parent , boolean enabled ) { <START_BUG> SnapshotArray < Actor > children = getChildren ( ) ; <END_BUG> for ( int i = 0 , n = children . size ; i < n ; i ++ ) { Actor actor = children . get ( i ) ; if ( actor instanceof Layout ) ( ( Layout ) ( actor ) ) . setLayoutEnabled ( enabled ) ; else if ( actor instanceof Group ) setLayoutEnabled ( ( ( Group ) ( actor ) ) , enabled ) ; } } public void validate ( ) { } public boolean needsLayout ( ) { } public void invalidate ( ) { } public void invalidateHierarchy ( ) { } protected void childrenChanged ( ) { } protected void sizeChanged ( ) { } public void pack ( ) { } public void setFillParent ( boolean fillParent ) { } public void layout ( ) { } public void draw ( Batch batch , float parentAlpha ) { } }
 SnapshotArray < Actor > children = getChildren ( ) ; 
<BUG2FIX>
SnapshotArray < Actor > children = parent . getChildren ( ) ;

###3### feature to identify that "identifier (" goes with matching parenthese, so it knows all of this works together as an entity
public abstract class GistsFragment extends PagedItemFragment < Gist > { @ Inject protected AvatarLoader avatarHelper ; @ Inject protected GistService service ; @ Inject protected GistStore store ; @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; <START_BUG> setEmptyText ( getString ( no_gists ) ) ; <END_BUG> } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { } @ Override public void onLoadFinished ( Loader < List < Gist > > loader , List < Gist > items ) { } @ Override protected int getLoadingMessage ( ) { } @ Override protected ItemListAdapter < Gist , ? extends ItemView > createAdapter ( List < Gist > items ) { } }
 setEmptyText ( getString ( no_gists ) ) ; 
<BUG2FIX>
setEmptyText ( no_gists ) ;

###4### "actor" not defined yet, could have counter of occurence for variable identifiers + need to understand that the condition works as entity (cf parenthesis feature of #3)
public class ParallelAction extends Action { Array < Action > actions = new Array ( 4 ) ; private boolean complete ; public ParallelAction ( ) { } public ParallelAction ( Action action1 ) { } public ParallelAction ( Action action1 , Action action2 ) { } public ParallelAction ( Action action1 , Action action2 , Action action3 ) { } public ParallelAction ( Action action1 , Action action2 , Action action3 , Action action4 ) { } public ParallelAction ( Action action1 , Action action2 , Action action3 , Action action4 , Action action5 ) { } public boolean act ( float delta ) { if ( complete ) return true ; complete = true ; Array < Action > actions = this . actions ; <START_BUG> for ( int i = 0 , n = actions . size ; ( i < n ) && ( ( actor ) != null ) ; i ++ ) <END_BUG> if ( ! ( actions . get ( i ) . act ( delta ) ) ) complete = false ; return complete ; } public void restart ( ) { } public void reset ( ) { } public void addAction ( Action action ) { } public void setActor ( Actor actor ) { } public Array < Action > getActions ( ) { } public String toString ( ) { } }
 for ( int i = 0 , n = actions . size ; ( i < n ) && ( ( actor ) != null ) ; i ++ ) 
<BUG2FIX>
for ( int i = 0 , n = actions . size ; i < n ; i ++ )

###5### play with parameter order
public class NestedAggregator extends SingleBucketAggregator implements ReaderContextAware { private final String nestedPath ; private final Aggregator parentAggregator ; private Filter parentFilter ; private final Filter childFilter ; private Bits childDocs ; private FixedBitSet parentDocs ; public NestedAggregator ( String name , AggregatorFactories factories , String nestedPath , AggregationContext aggregationContext , Aggregator parentAggregator ) { } @ Override public void setNextReader ( AtomicReaderContext reader ) { } @ Override public void collect ( int parentDoc , long bucketOrd ) throws IOException { if ( ( parentDoc == 0 ) || ( ( parentDocs ) == null ) ) { return ; } int prevParentDoc = parentDocs . prevSetBit ( ( parentDoc - 1 ) ) ; int numChildren = 0 ; for ( int i = parentDoc - 1 ; i > prevParentDoc ; i -- ) { if ( childDocs . get ( i ) ) { ++ numChildren ; collectBucketNoCounts ( i , bucketOrd ) ; } } <START_BUG> incrementBucketDocCount ( numChildren , bucketOrd ) ; <END_BUG> } @ Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) { } @ Override public InternalAggregation buildEmptyAggregation ( ) { } public String getNestedPath ( ) { } static NestedAggregator findClosestNestedAggregator ( Aggregator parent ) { } public static class Factory extends AggregatorFactory { private final String path ; public Factory ( String name , String path ) { } @ Override public Aggregator create ( AggregationContext context , Aggregator parent , long expectedBucketsCount ) { } } }
 incrementBucketDocCount ( numChildren , bucketOrd ) ; 
<BUG2FIX>
incrementBucketDocCount ( bucketOrd , numChildren ) ;

###6### same as #5... need to understand method ( arg1 , arg2 ) structure
public class VertexArray implements VertexData { final VertexAttributes attributes ; final FloatBuffer buffer ; final ByteBuffer byteBuffer ; boolean isBound = false ; public VertexArray ( int numVertices , VertexAttribute ... attributes ) { } public VertexArray ( int numVertices , VertexAttributes attributes ) { } @ Override public void dispose ( ) { } @ Override public FloatBuffer getBuffer ( ) { } @ Override public int getNumVertices ( ) { } public int getNumMaxVertices ( ) { } @ Override public void setVertices ( float [ ] vertices , int offset , int count ) { } @ Override public void updateVertices ( int targetOffset , float [ ] vertices , int sourceOffset , int count ) { final int pos = byteBuffer . position ( ) ; byteBuffer . position ( ( targetOffset * 4 ) ) ; <START_BUG> BufferUtils . copy ( vertices , sourceOffset , byteBuffer , count ) ; <END_BUG> byteBuffer . position ( pos ) ; } @ Override public void bind ( ) { } @ Override public void unbind ( ) { } @ Override public void bind ( final ShaderProgram shader ) { } @ Override public void bind ( final ShaderProgram shader , final int [ ] locations ) { } @ Override public void unbind ( ShaderProgram shader ) { } @ Override public void unbind ( ShaderProgram shader , int [ ] locations ) { } @ Override public VertexAttributes getAttributes ( ) { } }
 BufferUtils . copy ( vertices , sourceOffset , byteBuffer , count ) ; 
<BUG2FIX>
BufferUtils . copy ( vertices , sourceOffset , count , byteBuffer ) ;

###7### basic structure of for loop
public class ObjectSet < T > implements Iterable < T > { private static final int PRIME1 = - 1105259343 ; private static final int PRIME2 = - 1262997959 ; private static final int PRIME3 = - 825114047 ; public int size ; T [ ] keyTable ; int capacity ; int stashSize ; private float loadFactor ; private int hashShift ; private int mask ; private int threshold ; private int stashCapacity ; private int pushIterations ; private ObjectSet . SetIterator iterator1 ; private ObjectSet . SetIterator iterator2 ; public ObjectSet ( ) { } public ObjectSet ( int initialCapacity ) { } public ObjectSet ( int initialCapacity , float loadFactor ) { } public ObjectSet ( ObjectSet set ) { } public boolean add ( T key ) { } public void addAll ( Array < ? extends T > array ) { } public void addAll ( Array < ? extends T > array , int offset , int length ) { } public void addAll ( T ... array ) { } public void addAll ( T [ ] array , int offset , int length ) { } public void addAll ( ObjectSet < T > set ) { } private void addResize ( T key ) { } private void push ( T insertKey , int index1 , T key1 , int index2 , T key2 , int index3 , T key3 ) { } private void addStash ( T key ) { } public boolean remove ( T key ) { } boolean removeStash ( T key ) { } void removeStashIndex ( int index ) { } public void shrink ( int maximumCapacity ) { } public void clear ( int maximumCapacity ) { } public void clear ( ) { } public boolean contains ( T key ) { } private boolean containsKeyStash ( T key ) { } public T first ( ) { T [ ] keyTable = this . keyTable ; <START_BUG> for ( int i = 0 , n = ( capacity ) + ( stashSize ) ; i < n ; ) <END_BUG> if ( ( keyTable [ i ] ) != null ) return keyTable [ i ] ; throw new IllegalStateException ( "IntSet<seq2seq4repair_space>is<seq2seq4repair_space>empty." ) ; } public void ensureCapacity ( int additionalCapacity ) { } private void resize ( int newSize ) { } private int hash2 ( int h ) { } private int hash3 ( int h ) { } public String toString ( ) { } public String toString ( String separator ) { } public ObjectSet . SetIterator < T > iterator ( ) { } public static < T > ObjectSet < T > with ( T ... array ) { } public static class SetIterator < K > implements Iterable < K > , Iterator < K > { public boolean hasNext ; final ObjectSet < K > set ; int nextIndex ; int currentIndex ; boolean valid = true ; public SetIterator ( ObjectSet < K > set ) { } public void reset ( ) { } void findNextIndex ( ) { } public void remove ( ) { } public boolean hasNext ( ) { } public K next ( ) { } public Iterator < K > iterator ( ) { } public Array < K > toArray ( ) { } } }
 for ( int i = 0 , n = ( capacity ) + ( stashSize ) ; i < n ; ) 
<BUG2FIX>
for ( int i = 0 , n = ( capacity ) + ( stashSize ) ; i < n ; i ++ )

###8### cf entity recognition with parentheses 
public final class Intersector { private static final Vector3 v0 = new Vector3 ( ) ; private static final Vector3 v1 = new Vector3 ( ) ; private static final Vector3 v2 = new Vector3 ( ) ; public static boolean isPointInTriangle ( Vector3 point , Vector3 t1 , Vector3 t2 , Vector3 t3 ) { } public static boolean isPointInTriangle ( Vector2 p , Vector2 a , Vector2 b , Vector2 c ) { } public static boolean isPointInTriangle ( float px , float py , float ax , float ay , float bx , float by , float cx , float cy ) { } public static boolean intersectSegmentPlane ( Vector3 start , Vector3 end , Plane plane , Vector3 intersection ) { } public static int pointLineSide ( Vector2 linePoint1 , Vector2 linePoint2 , Vector2 point ) { } public static int pointLineSide ( float linePoint1X , float linePoint1Y , float linePoint2X , float linePoint2Y , float pointX , float pointY ) { } public static boolean isPointInPolygon ( Array < Vector2 > polygon , Vector2 point ) { } public static boolean isPointInPolygon ( float [ ] polygon , int offset , int count , float x , float y ) { } public static float distanceLinePoint ( Vector2 start , Vector2 end , Vector2 point ) { } public static float distanceLinePoint ( float startX , float startY , float endX , float endY , float pointX , float pointY ) { } public static float distanceSegmentPoint ( float startX , float startY , float endX , float endY , float pointX , float pointY ) { } public static float distanceSegmentPoint ( Vector2 start , Vector2 end , Vector2 point ) { } public static Vector2 nearestSegmentPoint ( Vector2 start , Vector2 end , Vector2 point , Vector2 nearest ) { } public static Vector2 nearestSegmentPoint ( float startX , float startY , float endX , float endY , float pointX , float pointY , Vector2 nearest ) { } public static boolean intersectSegmentCircle ( Vector2 start , Vector2 end , Vector2 center , float squareRadius ) { } public static float intersectSegmentCircleDisplace ( Vector2 start , Vector2 end , Vector2 point , float radius , Vector2 displacement ) { } public static boolean intersectRayPlane ( Ray ray , Plane plane , Vector3 intersection ) { } public static float intersectLinePlane ( float x , float y , float z , float x2 , float y2 , float z2 , Plane plane , Vector3 intersection ) { Vector3 direction = Intersector . tmp . set ( x2 , y2 , z2 ) . sub ( x , y , z ) ; Vector3 origin = Intersector . tmp2 . set ( x , y , z ) ; float denom = direction . dot ( plane . getNormal ( ) ) ; if ( denom != 0 ) { float t = ( - ( ( origin . dot ( plane . getNormal ( ) ) ) + ( plane . getD ( ) ) ) ) / denom ; <START_BUG> if ( ( ( t >= 0 ) && ( t <= 1 ) ) && ( intersection != null ) ) <END_BUG> intersection . set ( origin ) . add ( direction . scl ( t ) ) ; return t ; } else if ( ( plane . testPoint ( origin ) ) == ( PlaneSide . OnPlane ) ) { if ( intersection != null ) intersection . set ( origin ) ; return 0 ; } return - 1 ; } private static final Plane p = new Plane ( new Vector3 ( ) , 0 ) ; private static final Vector3 i = new Vector3 ( ) ; public static boolean intersectRayTriangle ( Ray ray , Vector3 t1 , Vector3 t2 , Vector3 t3 , Vector3 intersection ) { } private static final Vector3 dir = new Vector3 ( ) ; private static final Vector3 start = new Vector3 ( ) ; public static boolean intersectRaySphere ( Ray ray , Vector3 center , float radius , Vector3 intersection ) { } public static boolean intersectRayBounds ( Ray ray , BoundingBox box , Vector3 intersection ) { } public static boolean intersectRayBoundsFast ( Ray ray , BoundingBox box ) { } public static boolean intersectRayBoundsFast ( Ray ray , Vector3 center , Vector3 dimensions ) { } static Vector3 best = new Vector3 ( ) ; static Vector3 tmp = new Vector3 ( ) ; static Vector3 tmp1 = new Vector3 ( ) ; static Vector3 tmp2 = new Vector3 ( ) ; static Vector3 tmp3 = new Vector3 ( ) ; static Vector2 v2tmp = new Vector2 ( ) ; public static boolean intersectRayTriangles ( Ray ray , float [ ] triangles , Vector3 intersection ) { } public static boolean intersectRayTriangles ( Ray ray , float [ ] vertices , short [ ] indices , int vertexSize , Vector3 intersection ) { } public static boolean intersectRayTriangles ( Ray ray , List < Vector3 > triangles , Vector3 intersection ) { } public static boolean intersectLines ( Vector2 p1 , Vector2 p2 , Vector2 p3 , Vector2 p4 , Vector2 intersection ) { } public static boolean intersectLines ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 , Vector2 intersection ) { } public static boolean intersectLinePolygon ( Vector2 p1 , Vector2 p2 , Polygon polygon ) { } public static boolean intersectRectangles ( Rectangle rectangle1 , Rectangle rectangle2 , Rectangle intersection ) { } public static boolean intersectSegmentPolygon ( Vector2 p1 , Vector2 p2 , Polygon polygon ) { } public static boolean intersectSegments ( Vector2 p1 , Vector2 p2 , Vector2 p3 , Vector2 p4 , Vector2 intersection ) { }
 if ( ( ( t >= 0 ) && ( t <= 1 ) ) && ( intersection != null ) ) 
<BUG2FIX>
if ( intersection != null )

###9### identify "method ( )" entities
public abstract class GistsFragment extends PagedItemFragment < Gist > { @ Inject protected AvatarLoader avatars ; @ Inject protected GistService service ; @ Inject protected GistStore store ; @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { } @ Override public void onActivityCreated ( Bundle savedInstanceState ) { } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent data ) { if ( ( requestCode == ( RequestCodes . GIST_VIEW ) ) || ( requestCode == ( RequestCodes . GIST_CREATE ) ) ) { <START_BUG> getListAdapter ( ) . getWrappedAdapter ( ) . notifyDataSetChanged ( ) ; <END_BUG> forceRefresh ( ) ; return ; } super . onActivityResult ( requestCode , resultCode , data ) ; } @ Override protected int getErrorMessage ( Exception exception ) { } @ Override protected int getLoadingMessage ( ) { } @ Override protected SingleTypeAdapter < Gist > createAdapter ( List < Gist > items ) { } }
 getListAdapter ( ) . getWrappedAdapter ( ) . notifyDataSetChanged ( ) ; 
<BUG2FIX>
notifyDataSetChanged ( ) ;

###10### failed to reuse the parent method name -> typical behavior after "Override"
@ Override public void glPixelStorei ( int pname , int param ) { } @ Override public void glPolygonOffset ( float factor , float units ) { } @ Override public void glReadPixels ( int x , int y , int width , int height , int format , int type , Buffer pixels ) { } @ Override public void glReleaseShaderCompiler ( ) { } @ Override public void glRenderbufferStorage ( int target , int internalformat , int width , int height ) { } @ Override public void glSampleCoverage ( float value , boolean invert ) { } @ Override public void glScissor ( int x , int y , int width , int height ) { } @ Override public void glShaderBinary ( int n , IntBuffer shaders , int binaryformat , Buffer binary , int length ) { } @ Override public void glShaderSource ( int shader , String string ) { } @ Override public void glStencilFunc ( int func , int ref , int mask ) { } @ Override public void glStencilFuncSeparate ( int face , int func , int ref , int mask ) { } @ Override public void glStencilMask ( int mask ) { } @ Override public void glStencilMaskSeparate ( int face , int mask ) { } @ Override public void glStencilOp ( int fail , int zfail , int zpass ) { } @ Override public void glStencilOpSeparate ( int face , int fail , int zfail , int zpass ) { } @ Override public void glTexImage2D ( int target , int level , int internalformat , int width , int height , int border , int format , int type , Buffer pixels ) { } @ Override public void glTexParameterf ( int target , int pname , float param ) { } @ Override public void glTexParameterfv ( int target , int pname , FloatBuffer params ) { } @ Override public void glTexParameteri ( int target , int pname , int param ) { } @ Override public void glTexParameteriv ( int target , int pname , IntBuffer params ) { } @ Override public void glTexSubImage2D ( int target , int level , int xoffset , int yoffset , int width , int height , int format , int type , Buffer pixels ) { } @ Override public void glUniform1f ( int location , float x ) { } @ Override public void glUniform1fv ( int location , int count , FloatBuffer v ) { } @ Override public void glUniform1i ( int location , int x ) { } @ Override public void glUniform1iv ( int location , int count , IntBuffer v ) { } @ Override public void glUniform2f ( int location , float x , float y ) { } @ Override public void glUniform2fv ( int location , int count , FloatBuffer v ) { } @ Override public void glUniform2i ( int location , int x , int y ) { } @ Override public void glUniform2iv ( int location , int count , IntBuffer v ) { } @ Override public void glUniform3f ( int location , float x , float y , float z ) { } @ Override public void glUniform3fv ( int location , int count , FloatBuffer v ) { } @ Override public void glUniform3i ( int location , int x , int y , int z ) { } @ Override public void glUniform3iv ( int location , int count , IntBuffer v ) { } @ Override public void glUniform4f ( int location , float x , float y , float z , float w ) { } @ Override public void glUniform4fv ( int location , int count , FloatBuffer v ) { } @ Override public void glUniform4i ( int location , int x , int y , int z , int w ) { } @ Override public void glUniform4iv ( int location , int count , IntBuffer v ) { } @ Override public void glUniformMatrix2fv ( int location , int count , boolean transpose , FloatBuffer value ) { } @ Override public void glUniformMatrix3fv ( int location , int count , boolean transpose , FloatBuffer value ) { } @ Override public void glUniformMatrix4fv ( int location , int count , boolean transpose , FloatBuffer value ) { <START_BUG> gl . glUniformMatrix2x4fv ( location , count , transpose , value ) ; <END_BUG> } @ Override public void glUseProgram ( int program ) { } @ Override public void glValidateProgram ( int program ) { } @ Override public void glVertexAttrib1f ( int indx , float x ) { } @ Override public void glVertexAttrib1fv ( int indx , FloatBuffer values ) { } @ Override public void glVertexAttrib2f ( int indx , float x , float y ) { } @ Override public void glVertexAttrib2fv ( int indx , FloatBuffer values ) { } @ Override public void glVertexAttrib3f ( int indx , float x , float y , float z ) { } @ Override public void glVertexAttrib3fv ( int indx , FloatBuffer values ) { } @ Override public void glVertexAttrib4f ( int indx , float x , float y , float z , float w ) { } @ Override public void glVertexAttrib4fv ( int indx , FloatBuffer values ) { } @ Override public void glVertexAttribPointer ( int indx , int size , int type , boolean normalized , int stride , Buffer ptr ) { } @ Override public void glViewport ( int x , int y , int width , int height ) { } @ Override public void glDrawElements ( int mode , int count , int type , int indices ) { } @ Override public void glVertexAttribPointer ( int indx , int size , int type , boolean normalized , int stride , int ptr ) { } }
 gl . glUniformMatrix2x4fv ( location , count , transpose , value ) ; 
<BUG2FIX>
gl . glUniformMatrix4fv ( location , count , transpose , value ) ;

###11### justifies the need to identify a list of operators 
public class FloatFieldMapper extends NumberFieldMapper < Float > { public static final String CONTENT_TYPE = "float" ; public static class Defaults extends NumberFieldMapper . Defaults { public static final FieldType FLOAT_FIELD_TYPE = new FieldType ( NumberFieldMapper . Defaults . NUMBER_FIELD_TYPE ) ; public static final Float NULL_VALUE = null ; } public static class Builder extends NumberFieldMapper . Builder < FloatFieldMapper . Builder , FloatFieldMapper > { protected Float nullValue = FloatFieldMapper . Defaults . NULL_VALUE ; public Builder ( String name ) { } public FloatFieldMapper . Builder nullValue ( float nullValue ) { } @ Override public FloatFieldMapper build ( BuilderContext context ) { <START_BUG> fieldType . setOmitNorms ( ( ( fieldType . omitNorms ( ) ) || ( ( boost ) != 1.0F ) ) ) ; <END_BUG> FloatFieldMapper fieldMapper = new FloatFieldMapper ( buildNames ( context ) , precisionStep , fuzzyFactor , boost , fieldType , nullValue , ignoreMalformed ( context ) ) ; fieldMapper . includeInAll ( includeInAll ) ; return fieldMapper ; } } public static class TypeParser implements Mapper . TypeParser { @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { } } private Float nullValue ; private String nullValueAsString ; protected FloatFieldMapper ( Names names , int precisionStep , String fuzzyFactor , float boost , FieldType fieldType , Float nullValue , Explicit < Boolean > ignoreMalformed ) { } @ Override protected int maxPrecisionStep ( ) { } @ Override public Float value ( Field field ) { } @ Override public Float valueFromString ( String value ) { } @ Override public String indexedValue ( String value ) { } @ Override public Query fuzzyQuery ( String value , String minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query fuzzyQuery ( String value , double minSim , int prefixLength , int maxExpansions , boolean transpositions ) { } @ Override public Query fieldQuery ( String value , @ Nullable QueryParseContext context ) { } @ Override public Query rangeQuery ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter fieldFilter ( String value , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter rangeFilter ( FieldDataCache fieldDataCache , String lowerTerm , String upperTerm , boolean includeLower , boolean includeUpper , @ Nullable QueryParseContext context ) { } @ Override public Filter nullValueFilter ( ) { } @ Override protected boolean customBoost ( ) { } @ Override protected Field innerParseCreateField ( ParseContext context ) throws IOException { } @ Override public FieldDataType fieldDataType ( ) { } @ Override protected String contentType ( ) { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override protected void doXContentBody ( XContentBuilder builder ) throws IOException { } public static class CustomFloatNumericField extends CustomNumericField { private final float number ; private final NumberFieldMapper mapper ; public CustomFloatNumericField ( NumberFieldMapper mapper , float number , FieldType fieldType ) { } @ Override public TokenStream tokenStream ( Analyzer analyzer ) throws IOException { } @ Override public String numericAsString ( ) { } } }
 fieldType . setOmitNorms ( ( ( fieldType . omitNorms ( ) ) || ( ( boost ) != 1.0F ) ) ) ; 
<BUG2FIX>
fieldType . setOmitNorms ( ( ( fieldType . omitNorms ( ) ) && ( ( boost ) == 1.0F ) ) ) ;

###12### parentheses mismatch -> count
public class GwtFileHandle extends FileHandle { public final Preloader preloader ; private final String file ; private final FileType type ; protected GwtFileHandle ( Preloader preloader , String fileName , FileType type ) { } public GwtFileHandle ( String path ) { } public String path ( ) { } public String name ( ) { } public String extension ( ) { } public String nameWithoutExtension ( ) { } public String pathWithoutExtension ( ) { } public FileType type ( ) { } public File file ( ) { } public InputStream read ( ) { } public BufferedInputStream read ( int bufferSize ) { } public Reader reader ( ) { } public Reader reader ( String charset ) { } public BufferedReader reader ( int bufferSize ) { } public BufferedReader reader ( int bufferSize , String charset ) { } public String readString ( ) { } public String readString ( String charset ) { } public byte [ ] readBytes ( ) { } public int readBytes ( byte [ ] bytes , int offset , int size ) { } public OutputStream write ( boolean append ) { } public void write ( InputStream input , boolean append ) { } public Writer writer ( boolean append ) { } public Writer writer ( boolean append , String charset ) { } public void writeString ( String string , boolean append ) { } public void writeString ( String string , boolean append , String charset ) { } public void writeBytes ( byte [ ] bytes , boolean append ) { } public void writeBytes ( byte [ ] bytes , int offset , int length , boolean append ) { } public FileHandle [ ] list ( ) { } public FileHandle [ ] list ( String suffix ) { } public boolean isDirectory ( ) { } public FileHandle child ( String name ) { <START_BUG> return new GwtFileHandle ( preloader , ( ( file . isEmpty ( ) ? "" : ( file ) + ( file . endsWith ( "/" ) ? "" : "/" ) ) + name ) , FileType . Internal ) ; <END_BUG> } public FileHandle parent ( ) { } public FileHandle sibling ( String name ) { } public void mkdirs ( ) { } public boolean exists ( ) { } public boolean delete ( ) { } public boolean deleteDirectory ( ) { } public void copyTo ( FileHandle dest ) { } public void moveTo ( FileHandle dest ) { } public long length ( ) { } public long lastModified ( ) { } public String toString ( ) { } }
return new GwtFileHandle ( preloader , ( ( file . isEmpty ( ) ? "" : ( file ) + ( file . endsWith ( "/" ) ? "" : "/" ) ) + name ) , FileType . Internal ) ; 
<BUG2FIX>
return new GwtFileHandle ( preloader , ( file . isEmpty ( ) ? "" : ( ( file ) + ( file . endsWith ( "/" ) ? "" : "/" ) ) + name ) , FileType . Internal ) ;

###13### remove one parameter 
public class ExternalMapper extends AbstractFieldMapper < Object > { @ Override public Object value ( Object value ) { } public static class Names { public static final String FIELD_BIN = "bin" ; public static final String FIELD_BOOL = "bool" ; public static final String FIELD_POINT = "point" ; public static final String FIELD_SHAPE = "shape" ; } public static class Builder extends AbstractFieldMapper . Builder < ExternalMapper . Builder , ExternalMapper > { private BinaryFieldMapper . Builder binBuilder = new BinaryFieldMapper . Builder ( ExternalMapper . Names . FIELD_BIN ) ; private BooleanFieldMapper . Builder boolBuilder = new BooleanFieldMapper . Builder ( ExternalMapper . Names . FIELD_BOOL ) ; private GeoPointFieldMapper . Builder pointBuilder = new GeoPointFieldMapper . Builder ( ExternalMapper . Names . FIELD_POINT ) ; private GeoShapeFieldMapper . Builder shapeBuilder = new GeoShapeFieldMapper . Builder ( ExternalMapper . Names . FIELD_SHAPE ) ; private Mapper . Builder stringBuilder ; private String generatedValue ; private String mapperName ; public Builder ( String name , String generatedValue , String mapperName ) { } public ExternalMapper . Builder string ( Mapper . Builder content ) { } @ Override public ExternalMapper build ( BuilderContext context ) { } } public static class TypeParser implements Mapper . TypeParser { private String generatedValue ; private String mapperName ; TypeParser ( String mapperName , String generatedValue ) { } @ SuppressWarnings ( { "unchecked" } ) @ Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { ExternalMapper . Builder builder = new ExternalMapper . Builder ( name , generatedValue , mapperName ) ; parseField ( builder , name , node , parserContext ) ; for ( Map . Entry < String , Object > entry : node . entrySet ( ) ) { String propName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object propNode = entry . getValue ( ) ; <START_BUG> parseMultiField ( builder , name , node , parserContext , propName , propNode ) ; <END_BUG> } return builder ; } } private final String generatedValue ; private final String mapperName ; private final BinaryFieldMapper binMapper ; private final BooleanFieldMapper boolMapper ; private final GeoPointFieldMapper pointMapper ; private final GeoShapeFieldMapper shapeMapper ; private final Mapper stringMapper ; public ExternalMapper ( FieldMapper . Names names , String generatedValue , String mapperName , BinaryFieldMapper binMapper , BooleanFieldMapper boolMapper , GeoPointFieldMapper pointMapper , GeoShapeFieldMapper shapeMapper , Mapper stringMapper , MultiFields multiFields , CopyTo copyTo ) { } @ Override public FieldType defaultFieldType ( ) { } @ Override public FieldDataType defaultFieldDataType ( ) { } @ Override public void parse ( ParseContext context ) throws IOException { } @ Override protected void parseCreateField ( ParseContext context , List < Field > fields ) throws IOException { } @ Override public void merge ( Mapper mergeWith , MergeContext mergeContext ) throws MergeMappingException { } @ Override public void traverse ( FieldMapperListener fieldMapperListener ) { } @ Override public void traverse ( ObjectMapperListener objectMapperListener ) { } @ Override public void close ( ) { } @ Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { } @ Override protected String contentType ( ) { } }
 parseMultiField ( builder , name , node , parserContext , propName , propNode ) ; 
<BUG2FIX>
parseMultiField ( builder , name , parserContext , propName , propNode ) ;

###14### failed to use class attribute MATCH_ALL_QUERY (distbug could help by making class methods and parameters appear at distance 1) 
public class Queries { public static final Query MATCH_ALL_QUERY = new DeletionAwareConstantScoreQuery ( new MatchAllDocsFilter ( ) , true ) ; public static final Filter MATCH_ALL_FILTER = new MatchAllDocsFilter ( ) ; private static final Field disjuncts ; public static List < Query > disMaxClauses ( DisjunctionMaxQuery query ) { } public static Query optimizeQuery ( Query q ) { } public static boolean isNegativeQuery ( Query q ) { } public static Query fixNegativeQueryIfNeeded ( Query q ) { if ( Queries . isNegativeQuery ( q ) ) { BooleanQuery newBq = ( ( BooleanQuery ) ( q . clone ( ) ) ) ; <START_BUG> newBq . add ( new MatchAllDocsQuery ( ) , MUST ) ; <END_BUG> return newBq ; } return q ; } }
 newBq . add ( new MatchAllDocsQuery ( ) , MUST ) ; 
<BUG2FIX>
newBq . add ( Queries . MATCH_ALL_QUERY , MUST ) ;

###15### tag operators
public class Bits { long [ ] bits = new long [ ] { 0 } ; public boolean get ( int index ) { } public void set ( int index ) { } public void flip ( int index ) { } private void checkCapacity ( int len ) { <START_BUG> if ( len > ( bits . length ) ) { <END_BUG> long [ ] newBits = new long [ len + 1 ] ; System . arraycopy ( bits , 0 , newBits , 0 , bits . length ) ; bits = newBits ; } } public void clear ( int index ) { } public void clear ( ) { } public int numBits ( ) { } }
 if ( len > ( bits . length ) ) { 
<BUG2FIX>
if ( len >= ( bits . length ) ) {

###16### set specific tag for assignments to distinguish "x = a * b" from "x = a = b"
public class CircularBuffer { private final short [ ] buffer ; private int writePosition ; private int readPosition ; private int available ; public CircularBuffer ( int size ) { } public void write ( short [ ] data , int offset , int count ) { } public void combine ( short [ ] data , int offset , int count ) { } public int read ( short [ ] data , int offset , int count ) { } public int skip ( int count ) { <START_BUG> int total = count = Math . min ( available , count ) ; <END_BUG> available -= total ; readPosition = ( ( readPosition ) + total ) % ( buffer . length ) ; return total ; } public void clear ( ) { } public void setWritePosition ( int writePosition ) { } public int getWritePosition ( ) { } public void setReadPosition ( int readPosition ) { } public int getReadPosition ( ) { } public int getAvailable ( ) { } private void dump ( ) { } private static void combine ( short [ ] src , int srcPos , short [ ] dest , int destPos , int length ) { } public static void main ( String [ ] args ) throws Exception { } }
 int total = count = Math . min ( available , count ) ; 
<BUG2FIX>
int total = Math . min ( available , count ) ;