public class OrthographicCamera extends Camera { public float zoom = 1 ; public OrthographicCamera ( float viewportWidth , float viewportHeight ) { } private final Vector3 tmp = new Vector3 ( ) ; @ Override public void update ( ) { <START_BUG> projection . setToOrtho ( ( ( - ( viewportWidth ) ) / 2 ) , ( ( viewportWidth ) / 2 ) , ( ( - ( viewportHeight ) ) / 2 ) , ( ( viewportHeight ) / 2 ) , Math . abs ( near ) , Math . abs ( far ) ) ; <END_BUG> view . setToLookAt ( position , tmp . set ( position ) . add ( direction ) , up ) ; combined . set ( projection ) . mul ( view ) ; invProjectionView . set ( combined ) ; invProjectionView . inv ( ) ; frustum . update ( combined ) ; } }
 projection . setToOrtho ( ( ( - ( viewportWidth ) ) / 2 ) , ( ( viewportWidth ) / 2 ) , ( ( - ( viewportHeight ) ) / 2 ) , ( ( viewportHeight ) / 2 ) , Math . abs ( near ) , Math . abs ( far ) ) ; 
<BUG2FIX>
projection . setToOrtho ( ( ( ( zoom ) * ( - ( viewportWidth ) ) ) / 2 ) , ( ( ( zoom ) * ( viewportWidth ) ) / 2 ) , ( ( ( zoom ) * ( - ( viewportHeight ) ) ) / 2 ) , ( ( ( zoom ) * ( viewportHeight ) ) / 2 ) , Math . abs ( near ) , Math . abs ( far ) ) ;

public class BitmapFontTest extends GdxTest { private SpriteBatch spriteBatch ; private BitmapFont font ; private ShapeRenderer renderer ; @ Override public void create ( ) { } @ Override public void render ( ) { int viewHeight = graphics . getHeight ( ) ; gl . glClearColor ( 1 , 1 , 1 , 1 ) ; gl . glClear ( GL_COLOR_BUFFER_BIT ) ; spriteBatch . begin ( ) ; String text = "Sphinx<seq2seq4repair_space>of<seq2seq4repair_space>black<seq2seq4repair_space>quartz,<seq2seq4repair_space>judge<seq2seq4repair_space>my<seq2seq4repair_space>vow." ; font . setColor ( RED ) ; float x = 100 ; float y = 20 ; float alignmentWidth ; if ( false ) { alignmentWidth = 0 ; font . drawMultiLine ( spriteBatch , text , x , ( viewHeight - y ) , alignmentWidth , RIGHT ) ; } if ( false ) { TextBounds bounds = font . getMultiLineBounds ( text ) ; alignmentWidth = bounds . width ; font . drawMultiLine ( spriteBatch , text , x , ( viewHeight - y ) , alignmentWidth , RIGHT ) ; } if ( true ) { alignmentWidth = 280 ; font . drawWrapped ( spriteBatch , text , x , ( viewHeight - y ) , alignmentWidth , RIGHT ) ; } spriteBatch . end ( ) ; <START_BUG> renderer . begin ( Line ) ; <END_BUG> renderer . rect ( x , ( viewHeight - y ) , ( x + alignmentWidth ) , 300 ) ; renderer . end ( ) ; } public boolean needsGL20 ( ) { } @ Override public void dispose ( ) { } }
 renderer . begin ( Line ) ; 
<BUG2FIX>
renderer . begin ( Rectangle ) ;

public void glBlendFunc ( int sfactor , int dfactor ) { } public void glBlendFuncSeparate ( int srcRGB , int dstRGB , int srcAlpha , int dstAlpha ) { } public void glBufferData ( int target , int size , Buffer data , int usage ) { } public void glBufferSubData ( int target , int offset , int size , Buffer data ) { } public int glCheckFramebufferStatus ( int target ) { } public void glClear ( int mask ) { } public void glClearColor ( float red , float green , float blue , float alpha ) { } public void glClearDepthf ( float depth ) { } public void glClearStencil ( int s ) { } public void glColorMask ( boolean red , boolean green , boolean blue , boolean alpha ) { } public void glCompileShader ( int shader ) { } public void glCompressedTexImage2D ( int target , int level , int internalformat , int width , int height , int border , int imageSize , Buffer data ) { } public void glCompressedTexSubImage2D ( int target , int level , int xoffset , int yoffset , int width , int height , int format , int imageSize , Buffer data ) { } public void glCopyTexImage2D ( int target , int level , int internalformat , int x , int y , int width , int height , int border ) { } public void glCopyTexSubImage2D ( int target , int level , int xoffset , int yoffset , int x , int y , int width , int height ) { } public int glCreateProgram ( ) { } public int glCreateShader ( int type ) { } public void glCullFace ( int mode ) { } public void glDeleteBuffers ( int n , IntBuffer buffers ) { } public void glDeleteFramebuffers ( int n , IntBuffer framebuffers ) { } public void glDeleteProgram ( int program ) { } public void glDeleteRenderbuffers ( int n , IntBuffer renderbuffers ) { } public void glDeleteShader ( int shader ) { } public void glDeleteTextures ( int n , IntBuffer textures ) { } public void glDepthFunc ( int func ) { } public void glDepthMask ( boolean flag ) { } public void glDepthRangef ( float zNear , float zFar ) { } public void glDetachShader ( int program , int shader ) { } public void glDisable ( int cap ) { } public void glDisableVertexAttribArray ( int index ) { } public void glDrawArrays ( int mode , int first , int count ) { } public void glDrawElements ( int mode , int count , int type , Buffer indices ) { } public void glEnable ( int cap ) { } public void glEnableVertexAttribArray ( int index ) { } public void glFinish ( ) { } public void glFlush ( ) { } public void glFramebufferRenderbuffer ( int target , int attachment , int renderbuffertarget , int renderbuffer ) { } public void glFramebufferTexture2D ( int target , int attachment , int textarget , int texture , int level ) { } public void glFrontFace ( int mode ) { } public void glGenBuffers ( int n , IntBuffer buffers ) { } public void glGenFramebuffers ( int n , IntBuffer framebuffers ) { } public void glGenRenderbuffers ( int n , IntBuffer renderbuffers ) { } public void glGenTextures ( int n , IntBuffer textures ) { } public void glGenerateMipmap ( int target ) { } public String glGetActiveAttrib ( int program , int index , IntBuffer size , Buffer type ) { } public String glGetActiveUniform ( int program , int index , IntBuffer size , Buffer type ) { IntBuffer typeTmp = BufferUtils . createIntBuffer ( 2 ) ; String name = org . lwjgl . opengl . GL20 . glGetActiveUniform ( program , index , 256 , typeTmp ) ; size . put ( typeTmp . get ( 0 ) ) ; if ( type instanceof IntBuffer ) <START_BUG> ( ( IntBuffer ) ( type ) ) . put ( typeTmp . get ( 0 ) ) ; <END_BUG> return name ; } public void glGetAttachedShaders ( int program , int maxcount , Buffer count , IntBuffer shaders ) { } public int glGetAttribLocation ( int program , String name ) { } public void glGetBooleanv ( int pname , Buffer params ) { } public void glGetBufferParameteriv ( int target , int pname , IntBuffer params ) { } public int glGetError ( ) { } public void glGetFloatv ( int pname , FloatBuffer params ) { } public void glGetFramebufferAttachmentParameteriv ( int target , int attachment , int pname , IntBuffer params ) { } public void glGetIntegerv ( int pname , IntBuffer params ) { } public String glGetProgramInfoLog ( int program ) { } public void glGetProgramiv ( int program , int pname , IntBuffer params ) { } public void glGetRenderbufferParameteriv ( int target , int pname , IntBuffer params ) { } public String glGetShaderInfoLog ( int shader ) { } public void glGetShaderPrecisionFormat ( int shadertype , int precisiontype , IntBuffer range , IntBuffer precision ) { } public void glGetShaderiv ( int shader , int pname , IntBuffer params ) { } public String glGetString ( int name ) { } public void glGetTexParameterfv ( int target , int pname , FloatBuffer params ) { } public void glGetTexParameteriv ( int target , int pname , IntBuffer params ) { } public int glGetUniformLocation ( int program , String name ) { } public void glGetUniformfv ( int program , int location , FloatBuffer params ) { } public void glGetUniformiv ( int program , int location , IntBuffer params ) { } public void glGetVertexAttribPointerv ( int index , int pname , Buffer pointer ) { } public void glGetVertexAttribfv ( int index , int pname , FloatBuffer params ) { }
 ( ( IntBuffer ) ( type ) ) . put ( typeTmp . get ( 0 ) ) ; 
<BUG2FIX>
( ( IntBuffer ) ( type ) ) . put ( typeTmp . get ( 1 ) ) ;

public class ProjectiveTextureTest extends GdxTest { @ Override public boolean needsGL20 ( ) { } PerspectiveCamera cam ; PerspectiveCamera projector ; Texture texture ; Mesh plane ; Mesh cube ; Matrix4 planeTrans = new Matrix4 ( ) ; Matrix4 cubeTrans = new Matrix4 ( ) ; Matrix4 modelNormal = new Matrix4 ( ) ; ShaderProgram projTexShader ; Stage ui ; InputMultiplexer multiplexer = new InputMultiplexer ( ) ; PerspectiveCamController controller ; ImmediateModeRenderer20 renderer ; float angle = 0 ; @ Override public void create ( ) { } public void setupScene ( ) { } public void setupUI ( ) { ui = new Stage ( 480 , 320 , true ) ; Skin skin = new Skin ( files . internal ( "data/uiskin.json" ) , files . internal ( "data/uiskin.png" ) ) ; Button reload = new Button ( "Reload<seq2seq4repair_space>Shaders" , skin . getStyle ( ButtonStyle . class ) , "reload" ) ; ComboBox camera = new ComboBox ( new String [ ] { "Camera" , "Light" } , ui , skin . getStyle ( ComboBoxStyle . class ) , "camera" ) ; Label fps = new Label ( "fps:<seq2seq4repair_space>" , skin . getStyle ( LabelStyle . class ) , "fps" ) ; <START_BUG> Table table = new Table ( "container" ) ; <END_BUG> table . width = ui . width ( ) ; table . height = ui . height ( ) ; table . top ( ) . padTop ( 15 ) ; table . add ( reload ) . spaceRight ( 5 ) ; table . add ( camera ) . spaceRight ( 5 ) ; table . add ( fps ) ; ui . addActor ( table ) ; reload . setClickListener ( new ClickListener ( ) { @ Override public void click ( Actor button ) { ShaderProgram prog = new ShaderProgram ( files . internal ( "data/shaders/projtex-vert.glsl" ) . readString ( ) , files . internal ( "data/shaders/projtex-frag.glsl" ) . readString ( ) ) ; if ( ( prog . isCompiled ( ) ) == false ) { app . log ( "GLSL<seq2seq4repair_space>ERROR" , ( "Couldn\'t<seq2seq4repair_space>reload<seq2seq4repair_space>shaders:\n" + ( prog . getLog ( ) ) ) ) ; } else { projTexShader . dispose ( ) ; projTexShader = prog ; } } } ) ; } public void setupShaders ( ) { } @ Override public void render ( ) { } Vector3 position = new Vector3 ( ) ; private void renderMesh ( ShaderProgram shader , Matrix4 cam , Matrix4 projector , Matrix4 model , Mesh mesh , Color color ) { } }
 Table table = new Table ( "container" ) ; 
<BUG2FIX>
Table table = new Table ( ) ;


public class CompressedStringTests extends ElasticsearchTestCase { @ Test public void simpleTestsLZF ( ) throws IOException { } public void simpleTests ( String compressor ) throws IOException { } public void testRandom ( ) throws IOException { String compressor = "lzf" ; CompressorFactory . configure ( ImmutableSettings . settingsBuilder ( ) . put ( "compress.default.type" , compressor ) . build ( ) ) ; Random r = getRandom ( ) ; <START_BUG> for ( int i = 0 ; i < 2000 ; i ++ ) { <END_BUG> String string = TestUtil . randomUnicodeString ( r , 10000 ) ; CompressedString compressedString = new CompressedString ( string ) ; assertThat ( compressedString . string ( ) , equalTo ( string ) ) ; } } }
 for ( int i = 0 ; i < 2000 ; i ++ ) { 
<BUG2FIX>
for ( int i = 0 ; i < 1000 ; i ++ ) {

public class TransportSearchScrollScanAction extends AbstractComponent { private final ClusterService clusterService ; private final SearchServiceTransportAction searchService ; private final SearchPhaseController searchPhaseController ; @ Inject public TransportSearchScrollScanAction ( Settings settings , ClusterService clusterService , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } public void execute ( SearchScrollRequest request , ParsedScrollId scrollId , ActionListener < SearchResponse > listener ) { } private class AsyncAction { private final SearchScrollRequest request ; private final ActionListener < SearchResponse > listener ; private final ParsedScrollId scrollId ; private final DiscoveryNodes nodes ; private volatile AtomicArray < ShardSearchFailure > shardFailures ; private final AtomicArray < QueryFetchSearchResult > queryFetchResults ; private final AtomicInteger successfulOps ; private final AtomicInteger counter ; private final long startTime = System . currentTimeMillis ( ) ; private AsyncAction ( SearchScrollRequest request , ParsedScrollId scrollId , ActionListener < SearchResponse > listener ) { } protected final ShardSearchFailure [ ] buildShardFailures ( ) { } protected final void addShardFailure ( final int shardIndex , ShardSearchFailure failure ) { } public void start ( ) { if ( ( scrollId . getContext ( ) . length ) == 0 ) { <START_BUG> final InternalSearchResponse internalResponse = new InternalSearchResponse ( new InternalSearchHits ( InternalSearchHits . EMPTY , Long . parseLong ( this . scrollId . getAttributes ( ) . get ( "total_hits" ) ) , 0.0F ) , null , null , null , false ) ; <END_BUG> listener . onResponse ( new SearchResponse ( internalResponse , request . scrollId ( ) , 0 , 0 , 0L , buildShardFailures ( ) ) ) ; return ; } Tuple < String , Long > [ ] context = scrollId . getContext ( ) ; for ( int i = 0 ; i < ( context . length ) ; i ++ ) { Tuple < String , Long > target = context [ i ] ; DiscoveryNode node = nodes . get ( target . v1 ( ) ) ; if ( node != null ) { executePhase ( i , node , target . v2 ( ) ) ; } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( ( ( ( ( "Node<seq2seq4repair_space>[" + ( target . v1 ( ) ) ) + "]<seq2seq4repair_space>not<seq2seq4repair_space>available<seq2seq4repair_space>for<seq2seq4repair_space>scroll<seq2seq4repair_space>request<seq2seq4repair_space>[" ) + ( scrollId . getSource ( ) ) ) + "]" ) ) ; } successfulOps . decrementAndGet ( ) ; if ( ( counter . decrementAndGet ( ) ) == 0 ) { finishHim ( ) ; } } } for ( Tuple < String , Long > target : scrollId . getContext ( ) ) { DiscoveryNode node = nodes . get ( target . v1 ( ) ) ; if ( node == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( ( ( ( ( "Node<seq2seq4repair_space>[" + ( target . v1 ( ) ) ) + "]<seq2seq4repair_space>not<seq2seq4repair_space>available<seq2seq4repair_space>for<seq2seq4repair_space>scroll<seq2seq4repair_space>request<seq2seq4repair_space>[" ) + ( scrollId . getSource ( ) ) ) + "]" ) ) ; } successfulOps . decrementAndGet ( ) ; if ( ( counter . decrementAndGet ( ) ) == 0 ) { finishHim ( ) ; } } else { } } } void executePhase ( final int shardIndex , DiscoveryNode node , final long searchId ) { } void onPhaseFailure ( Throwable t , long searchId , int shardIndex ) { } private void finishHim ( ) { } private void innerFinishHim ( ) throws IOException { } } }
 final InternalSearchResponse internalResponse = new InternalSearchResponse ( new InternalSearchHits ( InternalSearchHits . EMPTY , Long . parseLong ( this . scrollId . getAttributes ( ) . get ( "total_hits" ) ) , 0.0F ) , null , null , null , false ) ; 
<BUG2FIX>
final InternalSearchResponse internalResponse = new InternalSearchResponse ( new InternalSearchHits ( InternalSearchHits . EMPTY , Long . parseLong ( this . scrollId . getAttributes ( ) . get ( "total_hits" ) ) , 0.0F ) , null , null , null , false , null ) ;

public class TmxMapLoader extends AsynchronousAssetLoader < TiledMap , TmxMapLoader . Parameters > { public static class Parameters extends AssetLoaderParameters < TiledMap > { public boolean yUp = true ; public boolean generateMipMaps = false ; public TextureFilter textureMinFilter = TextureFilter . Nearest ; public TextureFilter textureMagFilter = TextureFilter . Nearest ; } protected static final int FLAG_FLIP_HORIZONTALLY = - 2147483648 ; protected static final int FLAG_FLIP_VERTICALLY = 1073741824 ; protected static final int FLAG_FLIP_DIAGONALLY = 536870912 ; protected static final int MASK_CLEAR = - 536870912 ; protected XmlReader xml = new XmlReader ( ) ; protected Element root ; protected boolean yUp ; protected int mapWidthInPixels ; protected int mapHeightInPixels ; protected TiledMap map ; public TmxMapLoader ( ) { } public TmxMapLoader ( FileHandleResolver resolver ) { } public TiledMap load ( String fileName ) { } public TiledMap load ( String fileName , TmxMapLoader . Parameters parameters ) { try { this . yUp = parameters . yUp ; FileHandle tmxFile = resolve ( fileName ) ; root = xml . parse ( tmxFile ) ; ObjectMap < String , Texture > textures = new ObjectMap < String , Texture > ( ) ; for ( FileHandle textureFile : loadTilesets ( root , tmxFile ) ) { Texture texture = new Texture ( textureFile , parameters . generateMipMaps ) ; texture . setFilter ( parameters . textureMinFilter , parameters . textureMagFilter ) ; <START_BUG> textures . put ( textureFile . path ( ) , texture ) ; <END_BUG> } DirectImageResolver imageResolver = new DirectImageResolver ( textures ) ; TiledMap map = loadTilemap ( root , tmxFile , imageResolver ) ; map . setOwnedTextures ( textures . values ( ) . toArray ( ) ) ; return map ; } catch ( IOException e ) { throw new GdxRuntimeException ( ( ( "Couldn't<seq2seq4repair_space>load<seq2seq4repair_space>tilemap<seq2seq4repair_space>'" + fileName ) + "'" ) , e ) ; } } @ Override public void loadAsync ( AssetManager manager , String fileName , TmxMapLoader . Parameters parameter ) { } @ Override public TiledMap loadSync ( AssetManager manager , String fileName , TmxMapLoader . Parameters parameter ) { } @ Override public Array < AssetDescriptor > getDependencies ( String fileName , TmxMapLoader . Parameters parameter ) { } protected TiledMap loadTilemap ( Element root , FileHandle tmxFile , ImageResolver imageResolver ) { } protected Array < FileHandle > loadTilesets ( Element root , FileHandle tmxFile ) throws IOException { } protected void loadTileSet ( TiledMap map , Element element , FileHandle tmxFile , ImageResolver imageResolver ) { } protected void loadTileLayer ( TiledMap map , Element element ) { } protected void loadObjectGroup ( TiledMap map , Element element ) { } protected void loadObject ( MapLayer layer , Element element ) { } protected void loadProperties ( MapProperties properties , Element element ) { } protected static FileHandle getRelativeFileHandle ( FileHandle file , String path ) { } protected static int unsignedByteToInt ( byte b ) { } }
 textures . put ( textureFile . path ( ) , texture ) ; 
<BUG2FIX>
textures . put ( textureFile . path ( ) , new Texture ( textureFile , parameters . generateMipMaps ) ) ;

public class AndroidApplication extends Activity implements Application { protected AndroidGraphics graphics ; protected AndroidInput input ; protected AndroidAudio audio ; protected AndroidFiles files ; protected ApplicationListener listener ; protected Handler handler ; protected boolean firstResume = true ; protected final List < Runnable > runnables = new ArrayList < Runnable > ( ) ; protected WakeLock wakeLock = null ; public void initialize ( ApplicationListener listener , boolean useGL2IfAvailable ) { } public void initialize ( ApplicationListener listener , AndroidApplicationConfiguration config ) { } protected LayoutParams createLayoutParams ( ) { } protected void createWakeLock ( AndroidApplicationConfiguration config ) { } public View initializeForView ( ApplicationListener listener , boolean useGL2IfAvailable ) { } public View initializeForView ( ApplicationListener listener , AndroidApplicationConfiguration config ) { } @ Override protected void onPause ( ) { } @ Override protected void onResume ( ) { } @ Override protected void onDestroy ( ) { } @ Override public Audio getAudio ( ) { } @ Override public Files getFiles ( ) { } @ Override public Graphics getGraphics ( ) { } @ Override public Input getInput ( ) { } @ Override public void log ( String tag , String message ) { } @ Override public ApplicationType getType ( ) { } @ Override public int getVersion ( ) { <START_BUG> return ( SDK . charAt ( 0 ) ) - '0' ; <END_BUG> } @ Override public long getJavaHeap ( ) { } @ Override public long getNativeHeap ( ) { } @ Override public Preferences getPreferences ( String name ) { } @ Override public void postRunnable ( Runnable runnable ) { } @ Override public void onConfigurationChanged ( Configuration config ) { } @ Override public void log ( String tag , String message , Exception exception ) { } }
 return ( SDK . charAt ( 0 ) ) - '0' ; 
<BUG2FIX>
return Integer . parseInt ( SDK ) ;



### OOV, but sad one, limitation of the token by token approach
public class NodesFaultDetection extends AbstractComponent { public static interface Listener { void onNodeFailure ( DiscoveryNode node , String reason ) { } } private final ThreadPool threadPool ; private final TransportService transportService ; private final boolean connectOnNetworkDisconnect ; private final TimeValue pingInterval ; private final TimeValue pingRetryTimeout ; private final int pingRetryCount ; private final boolean registerConnectionListener ; private final CopyOnWriteArrayList < NodesFaultDetection . Listener > listeners = new CopyOnWriteArrayList < NodesFaultDetection . Listener > ( ) ; private final ConcurrentMap < DiscoveryNode , NodesFaultDetection . NodeFD > nodesFD = newConcurrentMap ( ) ; private final NodesFaultDetection . FDConnectionListener connectionListener ; private volatile DiscoveryNodes latestNodes = EMPTY_NODES ; private volatile boolean running = false ; public NodesFaultDetection ( Settings settings , ThreadPool threadPool , TransportService transportService ) { } public void addListener ( NodesFaultDetection . Listener listener ) { } public void removeListener ( NodesFaultDetection . Listener listener ) { } public void updateNodes ( DiscoveryNodes nodes ) { } public NodesFaultDetection start ( ) { } public NodesFaultDetection stop ( ) { } public void close ( ) { } private void handleTransportDisconnect ( DiscoveryNode node ) { } private void notifyNodeFailure ( final DiscoveryNode node , final String reason ) { } private class SendPingRequest implements Runnable { private final DiscoveryNode node ; private SendPingRequest ( DiscoveryNode node ) { } @ Override public void run ( ) { if ( ! ( running ) ) { return ; } transportService . sendRequest ( node , NodesFaultDetection . PingRequestHandler . ACTION , new NodesFaultDetection . PingRequest ( node . id ( ) ) , options ( ) . withTimeout ( pingRetryTimeout ) , new BaseTransportResponseHandler < NodesFaultDetection . PingResponse > ( ) { @ Override public NodesFaultDetection . PingResponse newInstance ( ) { return new NodesFaultDetection . PingResponse ( ) ; } @ Override public void handleResponse ( NodesFaultDetection . PingResponse response ) { if ( ! ( running ) ) { return ; } NodesFaultDetection . NodeFD nodeFD = nodesFD . get ( node ) ; if ( nodeFD != null ) { nodeFD . retryCount = 0 ; threadPool . schedule ( NodesFaultDetection . SendPingRequest . this , pingInterval ) ; } } @ Override <START_BUG> public void handleException ( RemoteTransportException exp ) { <END_BUG> if ( ! ( running ) ) { return ; } NodesFaultDetection . NodeFD nodeFD = nodesFD . get ( node ) ; if ( nodeFD != null ) { int retryCount = ++ ( nodeFD . retryCount ) ; logger . trace ( "[node<seq2seq4repair_space>]<seq2seq4repair_space>failed<seq2seq4repair_space>to<seq2seq4repair_space>ping<seq2seq4repair_space>[{}],<seq2seq4repair_space>retry<seq2seq4repair_space>[{}]<seq2seq4repair_space>out<seq2seq4repair_space>of<seq2seq4repair_space>[{}]" , exp , node , retryCount , pingRetryCount ) ; if ( retryCount >= ( pingRetryCount ) ) { logger . debug ( "[node<seq2seq4repair_space>]<seq2seq4repair_space>failed<seq2seq4repair_space>to<seq2seq4repair_space>ping<seq2seq4repair_space>[{}],<seq2seq4repair_space>tried<seq2seq4repair_space>[{}]<seq2seq4repair_space>times,<seq2seq4repair_space>each<seq2seq4repair_space>with<seq2seq4repair_space>maximum<seq2seq4repair_space>[{}]<seq2seq4repair_space>timeout" , node , pingRetryCount , pingRetryTimeout ) ; if ( ( nodesFD . remove ( node ) ) != null ) { notifyNodeFailure ( node , ( ( ( ( "failed<seq2seq4repair_space>to<seq2seq4repair_space>ping,<seq2seq4repair_space>tried<seq2seq4repair_space>[" + ( pingRetryCount ) ) + "]<seq2seq4repair_space>times,<seq2seq4repair_space>each<seq2seq4repair_space>with<seq2seq4repair_space>maximum<seq2seq4repair_space>[" ) + ( pingRetryTimeout ) ) + "]<seq2seq4repair_space>timeout" ) ) ; } } else { transportService . sendRequest ( node , NodesFaultDetection . PingRequestHandler . ACTION , new NodesFaultDetection . PingRequest ( node . id ( ) ) , options ( ) . withTimeout ( pingRetryTimeout ) , this ) ; } } } @ Override public boolean spawn ( ) { return false ; } } ) ; } } static class NodeFD { volatile int retryCount ; } private class FDConnectionListener implements TransportConnectionListener { @ Override public void onNodeConnected ( DiscoveryNode node ) { } @ Override public void onNodeDisconnected ( DiscoveryNode node ) { } } class PingRequestHandler extends BaseTransportRequestHandler < NodesFaultDetection . PingRequest > { public static final String ACTION = "discovery/zen/fd/ping" ; @ Override public NodesFaultDetection . PingRequest newInstance ( ) { } @ Override public void messageReceived ( NodesFaultDetection . PingRequest request , TransportChannel channel ) throws Exception { } @ Override public boolean spawn ( ) { } } static class PingRequest implements Streamable { private String nodeId ; PingRequest ( ) { } PingRequest ( String nodeId ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } private static class PingResponse implements Streamable { private PingResponse ( ) { } @ Override public void readFrom ( StreamInput in ) throws IOException { } @ Override public void writeTo ( StreamOutput out ) throws IOException { } } }
 public void handleException ( RemoteTransportException exp ) { 
<BUG2FIX>
public void handleException ( TransportException exp ) {

### same as previous
@ Override public ParentChildAtomicFieldData loadDirect ( AtomicReaderContext context ) throws Exception { AtomicReader reader = context . reader ( ) ; final float acceptableTransientOverheadRatio = fieldDataType . getSettings ( ) . getAsFloat ( "acceptable_transient_overhead_ratio" , DEFAULT_ACCEPTABLE_OVERHEAD_RATIO ) ; synchronized ( lock ) { boolean success = false ; ParentChildAtomicFieldData data = null ; ParentChildFilteredTermsEnum termsEnum = new ParentChildFilteredTermsEnum ( new ParentChildIntersectTermsEnum ( reader , UidFieldMapper . NAME , ParentFieldMapper . NAME ) , parentTypes ) ; ParentChildIndexFieldData . ParentChildEstimator estimator = new ParentChildIndexFieldData . ParentChildEstimator ( breakerService . getBreaker ( ) , termsEnum ) ; TermsEnum estimatedTermsEnum = estimator . beforeLoad ( null ) ; ObjectObjectOpenHashMap < String , ParentChildIndexFieldData . TypeBuilder > typeBuilders = ObjectObjectOpenHashMap . newInstance ( ) ; try { try { DocsEnum docsEnum = null ; for ( BytesRef term = estimatedTermsEnum . next ( ) ; term != null ; term = estimatedTermsEnum . next ( ) ) { String type = termsEnum . type ( ) ; ParentChildIndexFieldData . TypeBuilder typeBuilder = typeBuilders . get ( type ) ; if ( typeBuilder == null ) { typeBuilders . put ( type , ( typeBuilder = new ParentChildIndexFieldData . TypeBuilder ( acceptableTransientOverheadRatio , reader ) ) ) ; } BytesRef id = termsEnum . id ( ) ; final long termOrd = typeBuilder . builder . nextOrdinal ( ) ; assert termOrd == ( typeBuilder . termOrdToBytesOffset . size ( ) ) ; typeBuilder . termOrdToBytesOffset . add ( typeBuilder . bytes . copyUsingLengthPrefix ( id ) ) ; docsEnum = estimatedTermsEnum . docs ( null , docsEnum , FLAG_NONE ) ; for ( int docId = docsEnum . nextDoc ( ) ; docId != ( DocsEnum . NO_MORE_DOCS ) ; docId = docsEnum . nextDoc ( ) ) { typeBuilder . builder . addDoc ( docId ) ; } } ImmutableOpenMap . Builder < String , PagedBytesAtomicFieldData > typeToAtomicFieldData = ImmutableOpenMap . builder ( typeBuilders . size ( ) ) ; for ( ObjectObjectCursor < String , ParentChildIndexFieldData . TypeBuilder > cursor : typeBuilders ) { final long sizePointer = cursor . value . bytes . getPointer ( ) ; PagedBytes . Reader bytesReader = cursor . value . bytes . freeze ( true ) ; final Ordinals ordinals = cursor . value . builder . build ( fieldDataType . getSettings ( ) ) ; typeToAtomicFieldData . put ( cursor . key , new PagedBytesAtomicFieldData ( bytesReader , sizePointer , cursor . value . termOrdToBytesOffset , ordinals ) ) ; } data = new ParentChildAtomicFieldData ( typeToAtomicFieldData . build ( ) ) ; } finally { for ( ObjectObjectCursor < String , ParentChildIndexFieldData . TypeBuilder > cursor : typeBuilders ) { cursor . value . builder . close ( ) ; } } success = true ; return data ; } finally { if ( success ) { estimator . afterLoad ( estimatedTermsEnum , data . getMemorySizeInBytes ( ) ) ; } else { estimator . afterLoad ( estimatedTermsEnum , 0 ) ; } } } } public WithOrdinals getGlobalParentChild ( String type , IndexReader indexReader ) { } @ Override public void beforeCreate ( DocumentMapper mapper ) { } @ Override public void afterRemove ( DocumentMapper mapper ) { } class TypeBuilder { final PagedBytes bytes ; final MonotonicAppendingLongBuffer termOrdToBytesOffset ; final OrdinalsBuilder builder ; TypeBuilder ( float acceptableTransientOverheadRatio , AtomicReader reader ) throws IOException { } } public static class Builder implements IndexFieldData . Builder { @ Override public IndexFieldData < ? > build ( Index index , @ IndexSettings Settings indexSettings , FieldMapper < ? > mapper , IndexFieldDataCache cache , CircuitBreakerService breakerService , MapperService mapperService , GlobalOrdinalsBuilder globalOrdinalBuilder ) { } } public class ParentChildEstimator implements PerValueEstimator { private final MemoryCircuitBreaker breaker ; private final TermsEnum filteredEnum ; public ParentChildEstimator ( MemoryCircuitBreaker breaker , TermsEnum filteredEnum ) { } @ Override public long bytesPerValue ( BytesRef term ) { } @ Override public TermsEnum beforeLoad ( Terms terms ) throws IOException { } @ Override public void afterLoad ( TermsEnum termsEnum , long actualUsed ) { } } private class ParentTypesGlobalOrdinalsLoading implements WithOrdinals { public ParentTypesGlobalOrdinalsLoading ( ) { } @ Override public AtomicFieldData . WithOrdinals load ( AtomicReaderContext context ) { } @ Override public AtomicFieldData . WithOrdinals loadDirect ( AtomicReaderContext context ) { throw new ElasticsearchIllegalStateException ( "Shouldn't<seq2seq4repair_space>be<seq2seq4repair_space>invoked" ) ; } @ Override public WithOrdinals loadGlobal ( IndexReader indexReader ) { } @ Override public WithOrdinals localGlobalDirect ( IndexReader indexReader ) throws Exception { } @ Override public Names getFieldNames ( ) { } @ Override public FieldDataType getFieldDataType ( ) { } @ Override public boolean valuesOrdered ( ) { } @ Override public XFieldComparatorSource comparatorSource ( @ Nullable Object missingValue , MultiValueMode sortMode ) { } @ Override public void clear ( ) { } @ Override public void clear ( IndexReader reader ) { } @ Override public Index index ( ) { } private final class PerType extends ParentChildIndexFieldData . ParentTypesGlobalOrdinalsLoading { private final String type ; public PerType ( String type ) { } @ Override public AtomicFieldData . WithOrdinals load ( AtomicReaderContext context ) { } @ Override public AtomicFieldData . WithOrdinals loadDirect ( AtomicReaderContext context ) { ParentChildAtomicFieldData parentChildAtomicFieldData = ParentChildIndexFieldData . this . load ( context ) ; AtomicFieldData . WithOrdinals typeAfd = parentChildAtomicFieldData . getAtomicFieldData ( type ) ; if ( typeAfd != null ) { return typeAfd ; } else { <START_BUG> return PagedBytesAtomicFieldData . empty ( ) ; <END_BUG> } } @ Override public WithOrdinals loadGlobal ( IndexReader indexReader ) { } @ Override public WithOrdinals localGlobalDirect ( IndexReader indexReader ) throws Exception { } } } private final class ParentChildGlobalOrdinalsIndexFieldData extends GlobalOrdinalsIndexFieldData { private final ImmutableOpenMap < String , WithOrdinals > typeGlobalOrdinals ; private ParentChildGlobalOrdinalsIndexFieldData ( ImmutableOpenMap < String , WithOrdinals > typeGlobalOrdinals , long memorySizeInBytes ) { } @ Override public AtomicFieldData . WithOrdinals load ( AtomicReaderContext context ) { } public WithOrdinals type ( String type ) { } } }
 return PagedBytesAtomicFieldData . empty ( ) ; 
<BUG2FIX>
return AtomicFieldData . WithOrdinals . EMPTY ;

