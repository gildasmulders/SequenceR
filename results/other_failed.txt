public class OrthographicCamera extends Camera { public float zoom = 1 ; public OrthographicCamera ( float viewportWidth , float viewportHeight ) { } private final Vector3 tmp = new Vector3 ( ) ; @ Override public void update ( ) { <START_BUG> projection . setToOrtho ( ( ( - ( viewportWidth ) ) / 2 ) , ( ( viewportWidth ) / 2 ) , ( ( - ( viewportHeight ) ) / 2 ) , ( ( viewportHeight ) / 2 ) , Math . abs ( near ) , Math . abs ( far ) ) ; <END_BUG> view . setToLookAt ( position , tmp . set ( position ) . add ( direction ) , up ) ; combined . set ( projection ) . mul ( view ) ; invProjectionView . set ( combined ) ; invProjectionView . inv ( ) ; frustum . update ( combined ) ; } }
 projection . setToOrtho ( ( ( - ( viewportWidth ) ) / 2 ) , ( ( viewportWidth ) / 2 ) , ( ( - ( viewportHeight ) ) / 2 ) , ( ( viewportHeight ) / 2 ) , Math . abs ( near ) , Math . abs ( far ) ) ; 
<BUG2FIX>
projection . setToOrtho ( ( ( ( zoom ) * ( - ( viewportWidth ) ) ) / 2 ) , ( ( ( zoom ) * ( viewportWidth ) ) / 2 ) , ( ( ( zoom ) * ( - ( viewportHeight ) ) ) / 2 ) , ( ( ( zoom ) * ( viewportHeight ) ) / 2 ) , Math . abs ( near ) , Math . abs ( far ) ) ;

public class BitmapFontTest extends GdxTest { private SpriteBatch spriteBatch ; private BitmapFont font ; private ShapeRenderer renderer ; @ Override public void create ( ) { } @ Override public void render ( ) { int viewHeight = graphics . getHeight ( ) ; gl . glClearColor ( 1 , 1 , 1 , 1 ) ; gl . glClear ( GL_COLOR_BUFFER_BIT ) ; spriteBatch . begin ( ) ; String text = "Sphinx<seq2seq4repair_space>of<seq2seq4repair_space>black<seq2seq4repair_space>quartz,<seq2seq4repair_space>judge<seq2seq4repair_space>my<seq2seq4repair_space>vow." ; font . setColor ( RED ) ; float x = 100 ; float y = 20 ; float alignmentWidth ; if ( false ) { alignmentWidth = 0 ; font . drawMultiLine ( spriteBatch , text , x , ( viewHeight - y ) , alignmentWidth , RIGHT ) ; } if ( false ) { TextBounds bounds = font . getMultiLineBounds ( text ) ; alignmentWidth = bounds . width ; font . drawMultiLine ( spriteBatch , text , x , ( viewHeight - y ) , alignmentWidth , RIGHT ) ; } if ( true ) { alignmentWidth = 280 ; font . drawWrapped ( spriteBatch , text , x , ( viewHeight - y ) , alignmentWidth , RIGHT ) ; } spriteBatch . end ( ) ; <START_BUG> renderer . begin ( Line ) ; <END_BUG> renderer . rect ( x , ( viewHeight - y ) , ( x + alignmentWidth ) , 300 ) ; renderer . end ( ) ; } public boolean needsGL20 ( ) { } @ Override public void dispose ( ) { } }
 renderer . begin ( Line ) ; 
<BUG2FIX>
renderer . begin ( Rectangle ) ;

public void glBlendFunc ( int sfactor , int dfactor ) { } public void glBlendFuncSeparate ( int srcRGB , int dstRGB , int srcAlpha , int dstAlpha ) { } public void glBufferData ( int target , int size , Buffer data , int usage ) { } public void glBufferSubData ( int target , int offset , int size , Buffer data ) { } public int glCheckFramebufferStatus ( int target ) { } public void glClear ( int mask ) { } public void glClearColor ( float red , float green , float blue , float alpha ) { } public void glClearDepthf ( float depth ) { } public void glClearStencil ( int s ) { } public void glColorMask ( boolean red , boolean green , boolean blue , boolean alpha ) { } public void glCompileShader ( int shader ) { } public void glCompressedTexImage2D ( int target , int level , int internalformat , int width , int height , int border , int imageSize , Buffer data ) { } public void glCompressedTexSubImage2D ( int target , int level , int xoffset , int yoffset , int width , int height , int format , int imageSize , Buffer data ) { } public void glCopyTexImage2D ( int target , int level , int internalformat , int x , int y , int width , int height , int border ) { } public void glCopyTexSubImage2D ( int target , int level , int xoffset , int yoffset , int x , int y , int width , int height ) { } public int glCreateProgram ( ) { } public int glCreateShader ( int type ) { } public void glCullFace ( int mode ) { } public void glDeleteBuffers ( int n , IntBuffer buffers ) { } public void glDeleteFramebuffers ( int n , IntBuffer framebuffers ) { } public void glDeleteProgram ( int program ) { } public void glDeleteRenderbuffers ( int n , IntBuffer renderbuffers ) { } public void glDeleteShader ( int shader ) { } public void glDeleteTextures ( int n , IntBuffer textures ) { } public void glDepthFunc ( int func ) { } public void glDepthMask ( boolean flag ) { } public void glDepthRangef ( float zNear , float zFar ) { } public void glDetachShader ( int program , int shader ) { } public void glDisable ( int cap ) { } public void glDisableVertexAttribArray ( int index ) { } public void glDrawArrays ( int mode , int first , int count ) { } public void glDrawElements ( int mode , int count , int type , Buffer indices ) { } public void glEnable ( int cap ) { } public void glEnableVertexAttribArray ( int index ) { } public void glFinish ( ) { } public void glFlush ( ) { } public void glFramebufferRenderbuffer ( int target , int attachment , int renderbuffertarget , int renderbuffer ) { } public void glFramebufferTexture2D ( int target , int attachment , int textarget , int texture , int level ) { } public void glFrontFace ( int mode ) { } public void glGenBuffers ( int n , IntBuffer buffers ) { } public void glGenFramebuffers ( int n , IntBuffer framebuffers ) { } public void glGenRenderbuffers ( int n , IntBuffer renderbuffers ) { } public void glGenTextures ( int n , IntBuffer textures ) { } public void glGenerateMipmap ( int target ) { } public String glGetActiveAttrib ( int program , int index , IntBuffer size , Buffer type ) { } public String glGetActiveUniform ( int program , int index , IntBuffer size , Buffer type ) { IntBuffer typeTmp = BufferUtils . createIntBuffer ( 2 ) ; String name = org . lwjgl . opengl . GL20 . glGetActiveUniform ( program , index , 256 , typeTmp ) ; size . put ( typeTmp . get ( 0 ) ) ; if ( type instanceof IntBuffer ) <START_BUG> ( ( IntBuffer ) ( type ) ) . put ( typeTmp . get ( 0 ) ) ; <END_BUG> return name ; } public void glGetAttachedShaders ( int program , int maxcount , Buffer count , IntBuffer shaders ) { } public int glGetAttribLocation ( int program , String name ) { } public void glGetBooleanv ( int pname , Buffer params ) { } public void glGetBufferParameteriv ( int target , int pname , IntBuffer params ) { } public int glGetError ( ) { } public void glGetFloatv ( int pname , FloatBuffer params ) { } public void glGetFramebufferAttachmentParameteriv ( int target , int attachment , int pname , IntBuffer params ) { } public void glGetIntegerv ( int pname , IntBuffer params ) { } public String glGetProgramInfoLog ( int program ) { } public void glGetProgramiv ( int program , int pname , IntBuffer params ) { } public void glGetRenderbufferParameteriv ( int target , int pname , IntBuffer params ) { } public String glGetShaderInfoLog ( int shader ) { } public void glGetShaderPrecisionFormat ( int shadertype , int precisiontype , IntBuffer range , IntBuffer precision ) { } public void glGetShaderiv ( int shader , int pname , IntBuffer params ) { } public String glGetString ( int name ) { } public void glGetTexParameterfv ( int target , int pname , FloatBuffer params ) { } public void glGetTexParameteriv ( int target , int pname , IntBuffer params ) { } public int glGetUniformLocation ( int program , String name ) { } public void glGetUniformfv ( int program , int location , FloatBuffer params ) { } public void glGetUniformiv ( int program , int location , IntBuffer params ) { } public void glGetVertexAttribPointerv ( int index , int pname , Buffer pointer ) { } public void glGetVertexAttribfv ( int index , int pname , FloatBuffer params ) { }
 ( ( IntBuffer ) ( type ) ) . put ( typeTmp . get ( 0 ) ) ; 
<BUG2FIX>
( ( IntBuffer ) ( type ) ) . put ( typeTmp . get ( 1 ) ) ;

public class ProjectiveTextureTest extends GdxTest { @ Override public boolean needsGL20 ( ) { } PerspectiveCamera cam ; PerspectiveCamera projector ; Texture texture ; Mesh plane ; Mesh cube ; Matrix4 planeTrans = new Matrix4 ( ) ; Matrix4 cubeTrans = new Matrix4 ( ) ; Matrix4 modelNormal = new Matrix4 ( ) ; ShaderProgram projTexShader ; Stage ui ; InputMultiplexer multiplexer = new InputMultiplexer ( ) ; PerspectiveCamController controller ; ImmediateModeRenderer20 renderer ; float angle = 0 ; @ Override public void create ( ) { } public void setupScene ( ) { } public void setupUI ( ) { ui = new Stage ( 480 , 320 , true ) ; Skin skin = new Skin ( files . internal ( "data/uiskin.json" ) , files . internal ( "data/uiskin.png" ) ) ; Button reload = new Button ( "Reload<seq2seq4repair_space>Shaders" , skin . getStyle ( ButtonStyle . class ) , "reload" ) ; ComboBox camera = new ComboBox ( new String [ ] { "Camera" , "Light" } , ui , skin . getStyle ( ComboBoxStyle . class ) , "camera" ) ; Label fps = new Label ( "fps:<seq2seq4repair_space>" , skin . getStyle ( LabelStyle . class ) , "fps" ) ; <START_BUG> Table table = new Table ( "container" ) ; <END_BUG> table . width = ui . width ( ) ; table . height = ui . height ( ) ; table . top ( ) . padTop ( 15 ) ; table . add ( reload ) . spaceRight ( 5 ) ; table . add ( camera ) . spaceRight ( 5 ) ; table . add ( fps ) ; ui . addActor ( table ) ; reload . setClickListener ( new ClickListener ( ) { @ Override public void click ( Actor button ) { ShaderProgram prog = new ShaderProgram ( files . internal ( "data/shaders/projtex-vert.glsl" ) . readString ( ) , files . internal ( "data/shaders/projtex-frag.glsl" ) . readString ( ) ) ; if ( ( prog . isCompiled ( ) ) == false ) { app . log ( "GLSL<seq2seq4repair_space>ERROR" , ( "Couldn\'t<seq2seq4repair_space>reload<seq2seq4repair_space>shaders:\n" + ( prog . getLog ( ) ) ) ) ; } else { projTexShader . dispose ( ) ; projTexShader = prog ; } } } ) ; } public void setupShaders ( ) { } @ Override public void render ( ) { } Vector3 position = new Vector3 ( ) ; private void renderMesh ( ShaderProgram shader , Matrix4 cam , Matrix4 projector , Matrix4 model , Mesh mesh , Color color ) { } }
 Table table = new Table ( "container" ) ; 
<BUG2FIX>
Table table = new Table ( ) ;


public class CompressedStringTests extends ElasticsearchTestCase { @ Test public void simpleTestsLZF ( ) throws IOException { } public void simpleTests ( String compressor ) throws IOException { } public void testRandom ( ) throws IOException { String compressor = "lzf" ; CompressorFactory . configure ( ImmutableSettings . settingsBuilder ( ) . put ( "compress.default.type" , compressor ) . build ( ) ) ; Random r = getRandom ( ) ; <START_BUG> for ( int i = 0 ; i < 2000 ; i ++ ) { <END_BUG> String string = TestUtil . randomUnicodeString ( r , 10000 ) ; CompressedString compressedString = new CompressedString ( string ) ; assertThat ( compressedString . string ( ) , equalTo ( string ) ) ; } } }
 for ( int i = 0 ; i < 2000 ; i ++ ) { 
<BUG2FIX>
for ( int i = 0 ; i < 1000 ; i ++ ) {

public class TransportSearchScrollScanAction extends AbstractComponent { private final ClusterService clusterService ; private final SearchServiceTransportAction searchService ; private final SearchPhaseController searchPhaseController ; @ Inject public TransportSearchScrollScanAction ( Settings settings , ClusterService clusterService , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController ) { } public void execute ( SearchScrollRequest request , ParsedScrollId scrollId , ActionListener < SearchResponse > listener ) { } private class AsyncAction { private final SearchScrollRequest request ; private final ActionListener < SearchResponse > listener ; private final ParsedScrollId scrollId ; private final DiscoveryNodes nodes ; private volatile AtomicArray < ShardSearchFailure > shardFailures ; private final AtomicArray < QueryFetchSearchResult > queryFetchResults ; private final AtomicInteger successfulOps ; private final AtomicInteger counter ; private final long startTime = System . currentTimeMillis ( ) ; private AsyncAction ( SearchScrollRequest request , ParsedScrollId scrollId , ActionListener < SearchResponse > listener ) { } protected final ShardSearchFailure [ ] buildShardFailures ( ) { } protected final void addShardFailure ( final int shardIndex , ShardSearchFailure failure ) { } public void start ( ) { if ( ( scrollId . getContext ( ) . length ) == 0 ) { <START_BUG> final InternalSearchResponse internalResponse = new InternalSearchResponse ( new InternalSearchHits ( InternalSearchHits . EMPTY , Long . parseLong ( this . scrollId . getAttributes ( ) . get ( "total_hits" ) ) , 0.0F ) , null , null , null , false ) ; <END_BUG> listener . onResponse ( new SearchResponse ( internalResponse , request . scrollId ( ) , 0 , 0 , 0L , buildShardFailures ( ) ) ) ; return ; } Tuple < String , Long > [ ] context = scrollId . getContext ( ) ; for ( int i = 0 ; i < ( context . length ) ; i ++ ) { Tuple < String , Long > target = context [ i ] ; DiscoveryNode node = nodes . get ( target . v1 ( ) ) ; if ( node != null ) { executePhase ( i , node , target . v2 ( ) ) ; } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( ( ( ( ( "Node<seq2seq4repair_space>[" + ( target . v1 ( ) ) ) + "]<seq2seq4repair_space>not<seq2seq4repair_space>available<seq2seq4repair_space>for<seq2seq4repair_space>scroll<seq2seq4repair_space>request<seq2seq4repair_space>[" ) + ( scrollId . getSource ( ) ) ) + "]" ) ) ; } successfulOps . decrementAndGet ( ) ; if ( ( counter . decrementAndGet ( ) ) == 0 ) { finishHim ( ) ; } } } for ( Tuple < String , Long > target : scrollId . getContext ( ) ) { DiscoveryNode node = nodes . get ( target . v1 ( ) ) ; if ( node == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( ( ( ( ( "Node<seq2seq4repair_space>[" + ( target . v1 ( ) ) ) + "]<seq2seq4repair_space>not<seq2seq4repair_space>available<seq2seq4repair_space>for<seq2seq4repair_space>scroll<seq2seq4repair_space>request<seq2seq4repair_space>[" ) + ( scrollId . getSource ( ) ) ) + "]" ) ) ; } successfulOps . decrementAndGet ( ) ; if ( ( counter . decrementAndGet ( ) ) == 0 ) { finishHim ( ) ; } } else { } } } void executePhase ( final int shardIndex , DiscoveryNode node , final long searchId ) { } void onPhaseFailure ( Throwable t , long searchId , int shardIndex ) { } private void finishHim ( ) { } private void innerFinishHim ( ) throws IOException { } } }
 final InternalSearchResponse internalResponse = new InternalSearchResponse ( new InternalSearchHits ( InternalSearchHits . EMPTY , Long . parseLong ( this . scrollId . getAttributes ( ) . get ( "total_hits" ) ) , 0.0F ) , null , null , null , false ) ; 
<BUG2FIX>
final InternalSearchResponse internalResponse = new InternalSearchResponse ( new InternalSearchHits ( InternalSearchHits . EMPTY , Long . parseLong ( this . scrollId . getAttributes ( ) . get ( "total_hits" ) ) , 0.0F ) , null , null , null , false , null ) ;

public class TmxMapLoader extends AsynchronousAssetLoader < TiledMap , TmxMapLoader . Parameters > { public static class Parameters extends AssetLoaderParameters < TiledMap > { public boolean yUp = true ; public boolean generateMipMaps = false ; public TextureFilter textureMinFilter = TextureFilter . Nearest ; public TextureFilter textureMagFilter = TextureFilter . Nearest ; } protected static final int FLAG_FLIP_HORIZONTALLY = - 2147483648 ; protected static final int FLAG_FLIP_VERTICALLY = 1073741824 ; protected static final int FLAG_FLIP_DIAGONALLY = 536870912 ; protected static final int MASK_CLEAR = - 536870912 ; protected XmlReader xml = new XmlReader ( ) ; protected Element root ; protected boolean yUp ; protected int mapWidthInPixels ; protected int mapHeightInPixels ; protected TiledMap map ; public TmxMapLoader ( ) { } public TmxMapLoader ( FileHandleResolver resolver ) { } public TiledMap load ( String fileName ) { } public TiledMap load ( String fileName , TmxMapLoader . Parameters parameters ) { try { this . yUp = parameters . yUp ; FileHandle tmxFile = resolve ( fileName ) ; root = xml . parse ( tmxFile ) ; ObjectMap < String , Texture > textures = new ObjectMap < String , Texture > ( ) ; for ( FileHandle textureFile : loadTilesets ( root , tmxFile ) ) { Texture texture = new Texture ( textureFile , parameters . generateMipMaps ) ; texture . setFilter ( parameters . textureMinFilter , parameters . textureMagFilter ) ; <START_BUG> textures . put ( textureFile . path ( ) , texture ) ; <END_BUG> } DirectImageResolver imageResolver = new DirectImageResolver ( textures ) ; TiledMap map = loadTilemap ( root , tmxFile , imageResolver ) ; map . setOwnedTextures ( textures . values ( ) . toArray ( ) ) ; return map ; } catch ( IOException e ) { throw new GdxRuntimeException ( ( ( "Couldn't<seq2seq4repair_space>load<seq2seq4repair_space>tilemap<seq2seq4repair_space>'" + fileName ) + "'" ) , e ) ; } } @ Override public void loadAsync ( AssetManager manager , String fileName , TmxMapLoader . Parameters parameter ) { } @ Override public TiledMap loadSync ( AssetManager manager , String fileName , TmxMapLoader . Parameters parameter ) { } @ Override public Array < AssetDescriptor > getDependencies ( String fileName , TmxMapLoader . Parameters parameter ) { } protected TiledMap loadTilemap ( Element root , FileHandle tmxFile , ImageResolver imageResolver ) { } protected Array < FileHandle > loadTilesets ( Element root , FileHandle tmxFile ) throws IOException { } protected void loadTileSet ( TiledMap map , Element element , FileHandle tmxFile , ImageResolver imageResolver ) { } protected void loadTileLayer ( TiledMap map , Element element ) { } protected void loadObjectGroup ( TiledMap map , Element element ) { } protected void loadObject ( MapLayer layer , Element element ) { } protected void loadProperties ( MapProperties properties , Element element ) { } protected static FileHandle getRelativeFileHandle ( FileHandle file , String path ) { } protected static int unsignedByteToInt ( byte b ) { } }
 textures . put ( textureFile . path ( ) , texture ) ; 
<BUG2FIX>
textures . put ( textureFile . path ( ) , new Texture ( textureFile , parameters . generateMipMaps ) ) ;