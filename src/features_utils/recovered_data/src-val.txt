public class GenericController extends AbstractTestElement implements Serializable , Controller , PerThreadClonable { protected List subControllersAndSamplers = new ArrayList ( ) ; protected int current ; protected Iterator controlIt ; private List configs = new LinkedList ( ) ; private boolean returnedNull = false ; private boolean done = false ; private boolean timeForNext = false ; private List assertions = new LinkedList ( ) ; public GenericController ( ) { } public boolean isNextFirst ( ) { } protected List getConfigElements ( ) { } private void addConfigElement ( TestElement el ) { } public void initialize ( ) { } public void reInitialize ( ) { } protected void removeCurrentController ( ) { } protected void resetCurrent ( ) { } protected void incrementCurrent ( ) { } protected boolean hasNextAtEnd ( ) { } protected void nextAtEnd ( ) { } public boolean hasNext ( ) { } protected void currentHasNextIsFalse ( ) { } protected boolean shortCircuitIsDone ( ) { } protected void setShortCircuit ( boolean done ) { } public boolean isDone ( ) { } protected TestElement getCurrentController ( ) { } protected List getSubControllers ( ) { } public void addTestElement ( TestElement child ) { } private void addController ( TestElement child ) { } public Sampler next ( ) { } public static class Test extends TestCase { public Test ( String name ) { } public void testProcessing ( ) throws Exception { GenericController controller = new GenericController ( ) ; GenericController sub_1 = new GenericController ( ) ; sub_1 . addTestElement ( makeSampler ( "one" ) ) ; sub_1 . addTestElement ( makeSampler ( "two" ) ) ; controller . addTestElement ( sub_1 ) ; controller . addTestElement ( makeSampler ( "three" ) ) ; GenericController sub_2 = new GenericController ( ) ; GenericController sub_3 = new GenericController ( ) ; sub_2 . addTestElement ( makeSampler ( "four" ) ) ; sub_3 . addTestElement ( makeSampler ( "five" ) ) ; sub_3 . addTestElement ( makeSampler ( "six" ) ) ; sub_2 . addTestElement ( sub_3 ) ; sub_2 . addTestElement ( makeSampler ( "seven" ) ) ; controller . addTestElement ( sub_2 ) ; String [ ] order = new String [ ] { "one" , "two" , "three" , "four" , "five" , "six" , "seven" } ; int counter = 7 ; for ( int i = 0 ; i < 2 ; i ++ ) { assertEquals ( 7 , counter ) ; counter = 0 ; while ( controller . hasNext ( ) ) { TestElement sampler = controller . next ( ) ; <START_BUG> assertEquals ( order [ ( counter ++ ) ] , sampler . getProperty ( NAME ) ) ; <END_BUG> } } } private TestElement makeSampler ( String name ) { } class TestSampler extends AbstractSampler implements PerSampleClonable { public void addCustomTestElement ( TestElement t ) { } public SampleResult sample ( Entry e ) { } } } } 
public class RenameFolderAction extends AbstractColumbaAction implements ISelectionListener { public RenameFolderAction ( FrameMediator frameMediator ) { } public void actionPerformed ( ActionEvent evt ) { } public void selectionChanged ( SelectionChangedEvent evt ) { <START_BUG> if ( ( ( ( org . columba . mail . gui . tree . selection . TreeSelectionChangedEvent ) ( evt ) ) . getSelected ( ) . length ) > 0 ) { <END_BUG> AbstractFolder folder = ( ( org . columba . mail . gui . tree . selection . TreeSelectionChangedEvent ) ( evt ) ) . getSelected ( ) [ 0 ] ; if ( ( folder != null ) && ( folder instanceof AbstractMessageFolder ) ) { IFolderItem item = folder . getConfiguration ( ) ; if ( item . getString ( "property" , "accessrights" ) . equals ( "user" ) ) { setEnabled ( true ) ; } else { setEnabled ( false ) ; } } } else { setEnabled ( false ) ; } } } 
public class ResourceUrlEncodingFilter extends OncePerRequestFilter { private static final Log logger = LogFactory . getLog ( ResourceUrlEncodingFilter . class ) ; @ Override protected void doFilterInternal ( HttpServletRequest request , HttpServletResponse response , FilterChain filterChain ) throws IOException , ServletException { } private static class ResourceUrlEncodingResponseWrapper extends HttpServletResponseWrapper { private HttpServletRequest request ; private Integer indexLookupPath ; private ResourceUrlEncodingResponseWrapper ( HttpServletRequest request , HttpServletResponse wrapped ) { } @ Override public String encodeURL ( String url ) { } private ResourceUrlProvider getResourceUrlProvider ( ) { } private void initIndexLookupPath ( ResourceUrlProvider urlProvider ) { if ( ( this . indexLookupPath ) == null ) { String requestUri = urlProvider . getPathHelper ( ) . getRequestUri ( this . request ) ; String lookupPath = urlProvider . getPathHelper ( ) . getLookupPathForRequest ( this . request ) ; <START_BUG> this . indexLookupPath = requestUri . indexOf ( lookupPath ) ; <END_BUG> } } } } 
public class TextFile extends File { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private String encoding = null ; public TextFile ( File filename , String encoding ) { } public TextFile ( File filename ) { } public TextFile ( String filename ) { } public TextFile ( String filename , String encoding ) { } public void setText ( String body ) { } public String getText ( ) { String lineEnd = System . getProperty ( "line.separator" ) ; <START_BUG> StringBuffer sb = new StringBuffer ( ) ; <END_BUG> Reader reader = null ; BufferedReader br = null ; try { if ( ( encoding ) == null ) { reader = new FileReader ( this ) ; } else { reader = new InputStreamReader ( new FileInputStream ( this ) , encoding ) ; } br = new BufferedReader ( reader ) ; String line = "NOTNULL" ; while ( line != null ) { line = br . readLine ( ) ; if ( line != null ) { sb . append ( ( line + lineEnd ) ) ; } } } catch ( IOException ioe ) { TextFile . log . error ( "" , ioe ) ; } finally { JOrphanUtils . closeQuietly ( br ) ; } return sb . toString ( ) ; } public String getEncoding ( ) { } public void setEncoding ( String string ) { } } 
public class DigestAlgorithm implements Algorithm { private static final int BYTE_MASK = 255 ; private static final int BUFFER_SIZE = 8192 ; private String algorithm = "MD5" ; private String provider = null ; private MessageDigest messageDigest = null ; private int readBufferSize = DigestAlgorithm . BUFFER_SIZE ; public void setAlgorithm ( String algorithm ) { } public void setProvider ( String provider ) { } public void initMessageDigest ( ) { } public boolean isValid ( ) { } public String getValue ( File file ) { } public String toString ( ) { <START_BUG> StringBuffer buf = new StringBuffer ( ) ; <END_BUG> buf . append ( "<DigestAlgorithm:" ) ; buf . append ( "algorithm=" ) . append ( algorithm ) ; buf . append ( ";provider=" ) . append ( provider ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } } 
public class ChangePassword extends ScarabTemplateAction { public void doChangepassword ( RunData data , TemplateContext context ) throws Exception { String template = getCurrentTemplate ( data , null ) ; String nextTemplate = getNextTemplate ( data , template ) ; IntakeTool intake = getIntakeTool ( context ) ; if ( intake . isAllValid ( ) ) { Object user = data . getUser ( ) . getTemp ( SESSION_REGISTER ) ; Group register = null ; if ( ( user != null ) && ( user instanceof ScarabUser ) ) { register = intake . get ( "Register" , ( ( ScarabUser ) ( user ) ) . getQueryKey ( ) , false ) ; } else { register = intake . get ( "Register" , DEFAULT_KEY , false ) ; } <START_BUG> String username = register . get ( "Email" ) . toString ( ) ; <END_BUG> String oldPassword = register . get ( "OldPassword" ) . toString ( ) ; String password = register . get ( "Password" ) . toString ( ) ; String passwordConfirm = register . get ( "PasswordConfirm" ) . toString ( ) ; if ( oldPassword . equals ( password ) ) { getScarabRequestTool ( context ) . setInfoMessage ( ( "Your<seq2seq4repair_space>new<seq2seq4repair_space>password<seq2seq4repair_space>was<seq2seq4repair_space>the<seq2seq4repair_space>same<seq2seq4repair_space>as<seq2seq4repair_space>your<seq2seq4repair_space>old<seq2seq4repair_space>one.<seq2seq4repair_space>" + "Your<seq2seq4repair_space>password<seq2seq4repair_space>has<seq2seq4repair_space>not<seq2seq4repair_space>been<seq2seq4repair_space>changed!" ) ) ; setTarget ( data , template ) ; } else if ( password . equals ( passwordConfirm ) ) { try { ScarabUser confirmedUser = ( ( ScarabUser ) ( TurbineSecurity . getUser ( username ) ) ) ; confirmedUser . setPasswordExpire ( ) ; confirmedUser . setHasLoggedIn ( Boolean . FALSE ) ; data . setUser ( confirmedUser ) ; data . save ( ) ; TurbineSecurity . changePassword ( confirmedUser , oldPassword , password ) ; getScarabRequestTool ( context ) . setConfirmMessage ( ( "Your<seq2seq4repair_space>password<seq2seq4repair_space>has<seq2seq4repair_space>been<seq2seq4repair_space>changed." + "<seq2seq4repair_space>Please<seq2seq4repair_space>login<seq2seq4repair_space>with<seq2seq4repair_space>your<seq2seq4repair_space>new<seq2seq4repair_space>password." ) ) ; setTarget ( data , "Login.vm" ) ; } catch ( PasswordMismatchException pme ) { getScarabRequestTool ( context ) . setAlertMessage ( pme . getMessage ( ) ) ; setTarget ( data , template ) ; } } else { getScarabRequestTool ( context ) . setAlertMessage ( "The<seq2seq4repair_space>passwords<seq2seq4repair_space>you<seq2seq4repair_space>entered<seq2seq4repair_space>do<seq2seq4repair_space>not<seq2seq4repair_space>match!" ) ; setTarget ( data , template ) ; } } } } 
void setBackgroundPixel ( int pixel ) { } void setCheckboxImageListColor ( ) { } void setCheckboxImageList ( int width , int height ) { } void setFocusIndex ( int index ) { } public void setFont ( Font font ) { } void setForegroundPixel ( int pixel ) { } public void setHeaderVisible ( boolean show ) { } public void setItemCount ( int count ) { } void setItemHeight ( ) { } public void setLinesVisible ( boolean show ) { } public void setRedraw ( boolean redraw ) { } boolean setScrollWidth ( TableItem item , boolean force ) { } public void setSelection ( int [ ] indices ) { } public void setSelection ( TableItem [ ] items ) { } public void setSelection ( int index ) { } public void setSelection ( int start , int end ) { } void setTableEmpty ( ) { } public void setTopIndex ( int index ) { } public void showColumn ( TableColumn column ) { } void showItem ( int index ) { } public void showItem ( TableItem item ) { } public void showSelection ( ) { } String toolTipText ( NMTTDISPINFO hdr ) { } int widgetStyle ( ) { } TCHAR windowClass ( ) { } int windowProc ( ) { } LRESULT WM_CHAR ( int wParam , int lParam ) { } LRESULT WM_ERASEBKGND ( int wParam , int lParam ) { } LRESULT WM_GETOBJECT ( int wParam , int lParam ) { } LRESULT WM_KEYDOWN ( int wParam , int lParam ) { } LRESULT WM_LBUTTONDBLCLK ( int wParam , int lParam ) { } LRESULT WM_LBUTTONDOWN ( int wParam , int lParam ) { } LRESULT WM_LBUTTONUP ( int wParam , int lParam ) { } LRESULT WM_MOUSEHOVER ( int wParam , int lParam ) { } LRESULT WM_PAINT ( int wParam , int lParam ) { } LRESULT WM_NOTIFY ( int wParam , int lParam ) { NMHDR hdr = new NMHDR ( ) ; OS . MoveMemory ( hdr , lParam , sizeof ) ; int hwndHeader = OS . SendMessage ( handle , LVM_GETHEADER , 0 , 0 ) ; if ( ( hdr . hwndFrom ) == hwndHeader ) { switch ( hdr . code ) { case OS . HDN_BEGINTRACKW : case OS . HDN_BEGINTRACKA : case OS . HDN_DIVIDERDBLCLICKW : case OS . HDN_DIVIDERDBLCLICKA : { NMHEADER phdn = new NMHEADER ( ) ; OS . MoveMemory ( phdn , lParam , NMHEADER . sizeof ) ; TableColumn column = columns [ phdn . iItem ] ; if ( ( column != null ) && ( ! ( column . getResizable ( ) ) ) ) { return LRESULT . ONE ; } break ; } case OS . HDN_ITEMCHANGEDW : case OS . HDN_ITEMCHANGEDA : { int width = OS . SendMessage ( handle , LVM_GETCOLUMNWIDTH , 0 , 0 ) ; if ( ( ( lastWidth ) == 0 ) && ( width > 0 ) ) { int bits = OS . SendMessage ( handle , LVM_GETEXTENDEDLISTVIEWSTYLE , 0 , 0 ) ; if ( ( bits & ( OS . LVS_EX_GRIDLINES ) ) != 0 ) { RECT rect = new RECT ( ) ; OS . GetClientRect ( handle , rect ) ; rect . right = ( rect . left ) + width ; OS . InvalidateRect ( handle , rect , true ) ; } } lastWidth = width ; if ( ! ( ignoreResize ) ) { NMHEADER phdn = new NMHEADER ( ) ; OS . MoveMemory ( phdn , lParam , NMHEADER . sizeof ) ; if ( ( phdn . pitem ) != 0 ) { HDITEM pitem = new HDITEM ( ) ; OS . MoveMemory ( pitem , phdn . pitem , HDITEM . sizeof ) ; if ( ( ( pitem . mask ) & ( OS . HDI_WIDTH ) ) != 0 ) { TableColumn column = columns [ phdn . iItem ] ; if ( column != null ) { column . sendEvent ( Resize ) ; if ( isDisposed ( ) ) return LRESULT . ZERO ; int count = OS . SendMessage ( hwndHeader , HDM_GETITEMCOUNT , 0 , 0 ) ; if ( ( count == 1 ) && ( ( columns [ 0 ] ) == null ) ) count = 0 ; TableColumn [ ] newColumns = new TableColumn [ count ] ; System . arraycopy ( columns , 0 , newColumns , 0 , count ) ; for ( int i = ( phdn . iItem ) + 1 ; i < count ; i ++ ) { <START_BUG> if ( ( ( newColumns [ i ] ) != null ) && ( ! ( newColumns [ i ] . isDisposed ( ) ) ) ) { <END_BUG> newColumns [ i ] . sendEvent ( Move ) ; } } } } } } break ; } case OS . HDN_ITEMDBLCLICKW : case OS . HDN_ITEMDBLCLICKA : { NMHEADER phdn = new NMHEADER ( ) ; OS . MoveMemory ( phdn , lParam , NMHEADER . sizeof ) ; TableColumn column = columns [ phdn . iItem ] ; if ( column != null ) { column . postEvent ( DefaultSelection ) ; } break ; } } } return super . WM_NOTIFY ( wParam , lParam ) ; } LRESULT WM_RBUTTONDBLCLK ( int wParam , int lParam ) { } LRESULT WM_RBUTTONDOWN ( int wParam , int lParam ) { } LRESULT WM_SETFOCUS ( int wParam , int lParam ) { } LRESULT WM_SIZE ( int wParam , int lParam ) { } LRESULT WM_SYSCOLORCHANGE ( int wParam , int lParam ) { } LRESULT WM_VSCROLL ( int wParam , int lParam ) { } LRESULT WM_WINDOWPOSCHANGED ( int wParam , int lParam ) { } LRESULT wmNotifyChild ( int wParam , int lParam ) { } } 
for ( int j = 0 ; j < ( types . length ) ; j ++ ) dTValidators . addElement ( types [ j ] ) ; } else { dTValidators . addElement ( baseValidator ) ; } } } } if ( baseTypeName == null ) { content = DOMUtil . getNextSiblingElement ( content ) ; } else { content = DOMUtil . getFirstChildElement ( content ) ; if ( content != null ) { if ( DOMUtil . getLocalName ( content ) . equals ( ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content , attrValues , false , schemaDoc ) ; content = DOMUtil . getNextSiblingElement ( content ) ; } } } if ( union ) { if ( memberTypes != null ) { if ( content != null ) { if ( DOMUtil . getLocalName ( content ) . equals ( ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content , attrValues , false , schemaDoc ) ; content = DOMUtil . getNextSiblingElement ( content ) ; } } if ( content != null ) { if ( DOMUtil . getLocalName ( content ) . equals ( ELT_ANNOTATION ) ) { Object [ ] args = new Object [ ] { nameProperty } ; reportSchemaError ( "dt-union-memberType" , args ) ; } } } while ( content != null ) { baseValidator = traverseLocal ( content , schemaDoc , grammar ) ; if ( baseValidator != null ) { if ( ( ( fListName . length ( ) ) != 0 ) && ( ( baseValidator . getVariety ( ) ) == ( XSSimpleType . VARIETY_LIST ) ) ) { reportCosListOfAtomic ( qualifiedName ) ; return null ; } if ( ( baseValidator . getVariety ( ) ) == ( XSSimpleType . VARIETY_UNION ) ) { XSSimpleType [ ] types = ( ( org . apache . xerces . impl . dv . XSUnionSimpleType ) ( baseValidator ) ) . getMemberTypes ( ) ; for ( int i = 0 ; i < ( types . length ) ; i ++ ) dTValidators . addElement ( types [ i ] ) ; } else { dTValidators . addElement ( baseValidator ) ; } } if ( baseValidator == null ) { Object [ ] args = new Object [ ] { content . getAttribute ( ATT_BASE ) , nameProperty } ; reportSchemaError ( "dt-unknown-basetype" , args ) ; baseValidator = SchemaGrammar . fAnySimpleType ; } content = DOMUtil . getNextSiblingElement ( content ) ; } } if ( ( fListName . length ( ) ) != 0 ) { if ( fListName . equals ( qualifiedName ) ) { fListName = SchemaSymbols . EMPTY_STRING ; } } XSFacets facetData = null ; short presentFacets = 0 ; short fixedFacets = 0 ; if ( restriction && ( content != null ) ) { FacetInfo fi = traverseFacets ( content , contentAttrs , nameProperty , baseValidator , schemaDoc , grammar ) ; content = fi . nodeAfterFacets ; if ( content != null ) { content = null ; reportSchemaError ( "s4s-elt-must-match" , new Object [ ] { SchemaSymbols . ELT_RESTRICTION , "(annotation?,<seq2seq4repair_space>(simpleType?,<seq2seq4repair_space>(minExclusive<seq2seq4repair_space>|<seq2seq4repair_space>minInclusive<seq2seq4repair_space>|<seq2seq4repair_space>maxExclusive<seq2seq4repair_space>|<seq2seq4repair_space>maxInclusive<seq2seq4repair_space>|<seq2seq4repair_space>totalDigits<seq2seq4repair_space>|<seq2seq4repair_space>fractionDigits<seq2seq4repair_space>|<seq2seq4repair_space>length<seq2seq4repair_space>|<seq2seq4repair_space>minLength<seq2seq4repair_space>|<seq2seq4repair_space>maxLength<seq2seq4repair_space>|<seq2seq4repair_space>enumeration<seq2seq4repair_space>|<seq2seq4repair_space>whiteSpace<seq2seq4repair_space>|<seq2seq4repair_space>pattern)*))" } ) ; } facetData = fi . facetdata ; presentFacets = fi . fPresentFacets ; fixedFacets = fi . fFixedFacets ; } else if ( list && ( content != null ) ) { if ( baseTypeName != null ) { if ( DOMUtil . getLocalName ( content ) . equals ( ELT_ANNOTATION ) ) { traverseAnnotationDecl ( content , attrValues , false , schemaDoc ) ; content = DOMUtil . getNextSiblingElement ( content ) ; } if ( content != null ) { Object [ ] args = new Object [ ] { nameProperty } ; reportSchemaError ( "dt-list-itemType" , args ) ; } } else { reportSchemaError ( "s4s-elt-must-match" , new Object [ ] { SchemaSymbols . ELT_LIST , "(annotation?,<seq2seq4repair_space>(simpleType?))" } ) ; } } else if ( union && ( content != null ) ) { reportSchemaError ( "s4s-elt-must-match" , new Object [ ] { SchemaSymbols . ELT_UNION , "(annotation?,<seq2seq4repair_space>(simpleType?))" } ) ; } XSSimpleType newDecl = null ; if ( list ) { newDecl = schemaFactory . createTypeList ( nameProperty , schemaDoc . fTargetNamespace , ( ( short ) ( finalProperty ) ) , baseValidator ) ; } else if ( restriction ) { newDecl = schemaFactory . createTypeRestriction ( nameProperty , schemaDoc . fTargetNamespace , ( ( short ) ( finalProperty ) ) , baseValidator ) ; try { fValidationState . setNamespaceSupport ( schemaDoc . fNamespaceSupport ) ; newDecl . applyFacets ( facetData , presentFacets , fixedFacets , fValidationState ) ; } catch ( InvalidDatatypeFacetException ex ) { <START_BUG> reportGenericSchemaError ( ( ( ( "facet<seq2seq4repair_space>error<seq2seq4repair_space>when<seq2seq4repair_space>creating<seq2seq4repair_space>type<seq2seq4repair_space>'" + qualifiedName ) + "':<seq2seq4repair_space>" ) + ( ex . getLocalizedMessage ( ) ) ) ) ; <END_BUG> } } else { XSSimpleType [ ] memberDecls = new XSSimpleType [ dTValidators . size ( ) ] ; for ( int i = 0 ; i < ( dTValidators . size ( ) ) ; i ++ ) memberDecls [ i ] = ( ( XSSimpleType ) ( dTValidators . elementAt ( i ) ) ) ; newDecl = schemaFactory . createTypeUnion ( nameProperty , schemaDoc . fTargetNamespace , ( ( short ) ( finalProperty ) ) , memberDecls ) ; } if ( ( nameProperty == null ) && isGlobal ) { return null ; } if ( ( newDecl != null ) && isGlobal ) { grammar . addGlobalTypeDecl ( newDecl ) ; } return newDecl ; } private void reportCosListOfAtomic ( String qualifiedName ) { } private XSSimpleType findDTValidator ( Element elm , QName baseTypeStr , short baseRefContext , XSDocumentInfo schemaDoc ) { } private boolean isListDatatype ( XSSimpleType validator ) { } } 
public class WarWebXmlInterceptor extends BaseInterceptor implements ContextInterceptor { private static StringManager sm = StringManager . getManager ( "org.apache.tomcat.core" ) ; public WarWebXmlInterceptor ( ) { } public void contextInit ( Context ctx ) { if ( ! ( ctx . getDocumentBase ( ) . getProtocol ( ) . equalsIgnoreCase ( "war" ) ) ) { return ; } WebApplicationReader webXmlReader = new WebApplicationReader ( ) ; try { webXmlReader . processDefaultWebApp ( ctx ) ; String s = ctx . getDocumentBase ( ) . toString ( ) ; if ( s . endsWith ( "/" ) ) s = s . substring ( 0 , ( ( s . length ( ) ) - 1 ) ) ; URL webURL = null ; <START_BUG> webURL = new URL ( ( ( s + "!/" ) + ( Constants . Context . ConfigFile ) ) ) ; <END_BUG> InputStream is = webURL . openConnection ( ) . getInputStream ( ) ; System . out . println ( ( ( ( "Context(" + ( ctx . getPath ( ) ) ) + "):<seq2seq4repair_space>" ) + ( webURL . getFile ( ) ) ) ) ; webXmlReader . processWebApp ( ctx , is ) ; } catch ( Exception e ) { String msg = WarWebXmlInterceptor . sm . getString ( "context.getConfig.e" , ( ( ( ctx . getPath ( ) ) + "<seq2seq4repair_space>" ) + ( ctx . getDocBase ( ) ) ) ) ; } } } 
public class Choices < T > extends AbstractOptions < T > { private static final long serialVersionUID = 1L ; public Choices ( String id , Palette < T > palette ) { } @ Override protected void onComponentTag ( ComponentTag tag ) { super . onComponentTag ( tag ) ; IValueMap attrs = tag . getAttributes ( ) ; String onFocus = Choices . getPalette ( ) . getChoicesOnFocusJS ( ) ; if ( onFocus != null ) { <START_BUG> attrs . put ( "onFocus" , onFocus ) ; <END_BUG> } tag . getAttributes ( ) . put ( "ondblclick" , Choices . getPalette ( ) . getAddOnClickJS ( ) ) ; } @ Override protected Iterator < T > getOptionsIterator ( ) { } } 
public class CodeFlow implements Opcodes { private final Stack < ArrayList < String > > compilationScopes ; public CodeFlow ( ) { } public void loadTarget ( MethodVisitor mv ) { } public void pushDescriptor ( String descriptor ) { <START_BUG> Assert . notNull ( descriptor ) ; <END_BUG> this . compilationScopes . peek ( ) . add ( descriptor ) ; } public void enterCompilationScope ( ) { } public void exitCompilationScope ( ) { } public String lastDescriptor ( ) { } public void unboxBooleanIfNecessary ( MethodVisitor mv ) { } public static void insertUnboxInsns ( MethodVisitor mv , char ch , boolean isObject ) { } public static String createSignatureDescriptor ( Method method ) { } public static String createSignatureDescriptor ( Constructor < ? > ctor ) { } public static String toJVMDescriptor ( Class < ? > clazz ) { } public static String toDescriptorFromObject ( Object value ) { } public static boolean isBooleanCompatible ( String descriptor ) { } public static boolean isPrimitive ( String descriptor ) { } public static boolean isPrimitiveArray ( String descriptor ) { } public static boolean areBoxingCompatible ( String desc1 , String desc2 ) { } public static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean ( String descriptor ) { } public static boolean isPrimitiveOrUnboxableSupportedNumber ( String descriptor ) { } public static char toPrimitiveTargetDesc ( String descriptor ) { } public static void insertCheckCast ( MethodVisitor mv , String descriptor ) { } public static void insertBoxIfNecessary ( MethodVisitor mv , String descriptor ) { } public static void insertBoxIfNecessary ( MethodVisitor mv , char ch ) { } public static String toDescriptor ( Class < ? > type ) { } public static String [ ] toParamDescriptors ( Method method ) { } public static String [ ] toParamDescriptors ( Constructor < ? > ctor ) { } private static String [ ] toDescriptors ( Class < ? > [ ] types ) { } } 
public class Form extends WebMarkupContainer implements IFormSubmitListener { public abstract static class ValidationVisitor implements FormComponent . IVisitor { public Object formComponent ( IFormVisitorParticipant component ) { } public abstract void validate ( FormComponent formComponent ) { } } class FormDispatchRequest extends Request { private final ValueMap params = new ValueMap ( ) ; private final Request realRequest ; private final String url ; public FormDispatchRequest ( final Request realRequest , final String url ) { } public Locale getLocale ( ) { } public String getParameter ( String key ) { } public Map getParameterMap ( ) { } public String [ ] getParameters ( String key ) { } public String getPath ( ) { } public String getRelativePathPrefixToContextRoot ( ) { } public String getRelativePathPrefixToWicketHandler ( ) { } public String getURL ( ) { } } public static final String METHOD_GET = "get" ; public static final String METHOD_POST = "post" ; private static final short FLAG_SUBMITTED = FLAG_RESERVED1 ; private static final Logger log = LoggerFactory . getLogger ( Form . class ) ; private static final long serialVersionUID = 1L ; private static final String UPLOAD_FAILED_RESOURCE_KEY = "uploadFailed" ; private static final String UPLOAD_TOO_LARGE_RESOURCE_KEY = "uploadTooLarge" ; private IFormSubmittingComponent defaultSubmittingComponent ; private Object formValidators = null ; private String javascriptId ; private Bytes maxSize = null ; private boolean multiPart = false ; public Form ( final String id ) { } public Form ( final String id , IModel model ) { } public void add ( IFormValidator validator ) { } public void remove ( IFormValidator validator ) { } private final int formValidators_indexOf ( IFormValidator validator ) { } private final IFormValidator formValidators_remove ( IFormValidator validator ) { } private final IFormValidator formValidators_remove ( int index ) { } public final void clearInput ( ) { } public final void error ( String error , Map args ) { } public final IFormSubmittingComponent findSubmittingButton ( ) { } public final IFormSubmittingComponent getDefaultButton ( ) { } public final CharSequence getJsForInterfaceUrl ( CharSequence url ) { } public Bytes getMaxSize ( ) { } public Form getRootForm ( ) { } public String getValidatorKeyPrefix ( ) { } public final boolean hasError ( ) { } public boolean isRootForm ( ) { } public final boolean isSubmitted ( ) { } public boolean isVersioned ( ) { } public final void loadPersistentFormComponentValues ( ) { } public final void onFormSubmitted ( ) { } public boolean process ( ) { } private void callOnError ( ) { } private void markFormsSubmitted ( ) { } public void removePersistentFormComponentValues ( final boolean disablePersistence ) { } public final void setDefaultButton ( IFormSubmittingComponent submittingComponent ) { } public void setMaxSize ( final Bytes maxSize ) { } public void setMultiPart ( boolean multiPart ) { } public final Component setVersioned ( final boolean isVersioned ) { } public final void visitFormComponents ( final FormComponent . IVisitor visitor ) { } public final void visitFormComponentsPostOrder ( final FormComponent . IVisitor visitor ) { } private void visitChildrenInContainingBorder ( final FormComponent . IVisitor visitor ) { } private boolean anyFormComponentError ( ) { } private void dispatchEvent ( final Page page , final String url ) { } private void formValidators_add ( final IFormValidator validator ) { } private IFormValidator formValidators_get ( int index ) { } private int formValidators_size ( ) { } private void inputChanged ( ) { } private void persistFormComponentData ( ) { } protected void appendDefaultButtonField ( final MarkupStream markupStream , final ComponentTag openTag ) { } protected void beforeUpdateFormComponentModels ( ) { } protected void delegateSubmit ( IFormSubmittingComponent submittingComponent ) { } protected final String getHiddenFieldId ( ) { } protected final String getJavascriptId ( ) { } protected String getMethod ( ) { } protected boolean getStatelessHint ( ) { } protected IValuePersister getValuePersister ( ) { } protected boolean handleMultiPart ( ) { } protected void internalOnModelChanged ( ) { } protected final void markFormComponentsInvalid ( ) { } protected final void markFormComponentsValid ( ) { } private void markNestedFormComponentsValid ( ) { } private void internalMarkFormComponentsValid ( ) { } protected void onComponentTag ( final ComponentTag tag ) { } protected void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } protected void onDetach ( ) { } protected void onError ( ) { } protected void onRender ( final MarkupStream markupStream ) { } protected void onSubmit ( ) { } protected final void updateFormComponentModels ( ) { } private final void updateNestedFormComponentModels ( ) { } private void internalUpdateFormComponentModels ( ) { } protected void validate ( ) { } protected final void validateComponents ( ) { <START_BUG> visitFormComponents ( new Form . ValidationVisitor ( ) { <END_BUG> public void validate ( final FormComponent formComponent ) { final Form form = formComponent . getForm ( ) ; if ( ( ( ( form == ( Form . this ) ) && ( form . isEnabled ( ) ) ) && ( form . isEnableAllowed ( ) ) ) && ( form . isVisibleInHierarchy ( ) ) ) { formComponent . validate ( ) ; } } } ) ; } private boolean isFormComponentVisibleInPage ( FormComponent fc ) { } protected final void validateFormValidator ( final IFormValidator validator ) { } protected final void validateFormValidators ( ) { } private void validateNestedForms ( ) { } private class FormValidatorRemovedChange extends Change { private static final long serialVersionUID = 1L ; private final IFormValidator removed ; public FormValidatorRemovedChange ( final IFormValidator removed ) { } public void undo ( ) { } } } 
public final class LegacyActionPersistence extends RegistryPersistence { private static final int INDEX_ACTION_SETS = 0 ; private static final int INDEX_EDITOR_CONTRIBUTIONS = 1 ; private static final int INDEX_OBJECT_CONTRIBUTIONS = 2 ; private static final int INDEX_VIEW_CONTRIBUTIONS = 3 ; private static final int INDEX_VIEWER_CONTRIBUTIONS = 4 ; private static final SLocation createLocation ( final String barType , final String path , final LegacyLocationInfo locationInfo , final char mnemonic , final String imageStyle ) { final LeafLocationElement leafElement = new SBar ( barType , path ) ; final LocationElement locationElement ; if ( locationInfo == null ) { locationElement = leafElement ; } else { locationElement = locationInfo . append ( leafElement ) ; } <START_BUG> return new SLocation ( mnemonic , imageStyle , null , locationElement ) ; <END_BUG> } private static final Expression readVisibility ( final IConfigurationElement parentElement , final String parentId , final List warningsToLog ) { } private final BindingManager bindingManager ; private final CommandImageManager commandImageManager ; private final CommandManager commandManager ; private final Collection menuContributions = new ArrayList ( ) ; private final IMenuService menuService ; public LegacyActionPersistence ( final CommandManager commandManager , final BindingManager bindingManager , final CommandImageManager commandImageManager , final IMenuService menuService ) { } private final void clearBindings ( ) { } private final void clearImages ( ) { } private final void clearMenus ( ) { } private final void convertActionToBinding ( final IConfigurationElement element , final ParameterizedCommand command ) { } private final ParameterizedCommand convertActionToCommand ( final IConfigurationElement element , final String primaryId , final String secondaryId , final List warningsToLog ) { } private final String convertActionToImages ( final IConfigurationElement element , final ParameterizedCommand command ) { } private final void convertActionToItem ( final IConfigurationElement element , final List warningsToLog , final ParameterizedCommand command , final String imageStyle , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression ) { } protected final boolean isChangeImportant ( final IRegistryChangeEvent event ) { } public final void dispose ( ) { } public final void read ( ) { } private final SReference [ ] readActions ( final String primaryId , final IConfigurationElement [ ] elements , final List warningsToLog , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression ) { } private final SReference [ ] readActionsAndMenus ( final IConfigurationElement element , final String id , final List warningsToLog , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression ) { } private final void readActionSets ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } private final void readEditorContributions ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } private final SReference [ ] readGroups ( final IConfigurationElement [ ] elements , final List warningsToLog , final String path , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression , final boolean separatorsVisible ) { } private final SReference [ ] readMenusAndGroups ( final IConfigurationElement [ ] menuElements , final String contributionId , final List warningsToLog , final LegacyLocationInfo locationInfo , final Expression visibleWhenExpression ) { } private final void readObjectContributions ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } private final void readViewContributions ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } private final void readViewerContributions ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount ) { } } 
public class HelloHostApplication implements IDistributionConstants , IApplication { private static final String DEFAULT_CONTAINER_TYPE = "ecf.r_osgi.peer" ; public static final String DEFAULT_CONTAINER_ID = null ; private BundleContext bundleContext ; private ServiceTracker containerManagerServiceTracker ; private String containerType = HelloHostApplication . DEFAULT_CONTAINER_TYPE ; private String containerId = HelloHostApplication . DEFAULT_CONTAINER_ID ; private final Object appLock = new Object ( ) ; private boolean done = false ; private ServiceRegistration helloRegistration ; public Object start ( IApplicationContext appContext ) throws Exception { bundleContext = Activator . getContext ( ) ; processArgs ( appContext ) ; IContainerManager containerManager = getContainerManagerService ( ) ; if ( ( ( containerId ) == null ) || ( "" . equals ( containerId ) ) ) containerManager . getContainerFactory ( ) . createContainer ( containerType ) ; else containerManager . getContainerFactory ( ) . createContainer ( containerType , new Object [ ] { containerId } ) ; Properties props = new Properties ( ) ; <START_BUG> props . put ( REMOTE_INTERFACES , REMOTE_INTERFACES_WILDCARD ) ; <END_BUG> helloRegistration = bundleContext . registerService ( IHello . class . getName ( ) , new Hello ( ) , props ) ; System . out . println ( "Host:<seq2seq4repair_space>Hello<seq2seq4repair_space>Service<seq2seq4repair_space>Registered" ) ; waitForDone ( ) ; return IApplication . EXIT_OK ; } public void stop ( ) { } private IContainerManager getContainerManagerService ( ) { } private void processArgs ( IApplicationContext appContext ) { } private void waitForDone ( ) { } } 
public class ImageTransfer extends ByteArrayTransfer { private static ImageTransfer _instance = new ImageTransfer ( ) ; private static final String CF_DIB = "CF_DIB" ; private static final int CF_DIBID = COM . CF_DIB ; private ImageTransfer ( ) { } public static ImageTransfer getInstance ( ) { } public void javaToNative ( Object object , TransferData transferData ) { } public Object nativeToJava ( TransferData transferData ) { if ( ( ! ( isSupportedType ( transferData ) ) ) || ( ( transferData . pIDataObject ) == 0 ) ) return null ; IDataObject dataObject = new IDataObject ( transferData . pIDataObject ) ; dataObject . AddRef ( ) ; FORMATETC formatetc = new FORMATETC ( ) ; formatetc . cfFormat = COM . CF_DIB ; formatetc . ptd = 0 ; formatetc . dwAspect = COM . DVASPECT_CONTENT ; formatetc . lindex = - 1 ; formatetc . tymed = COM . TYMED_HGLOBAL ; STGMEDIUM stgmedium = new STGMEDIUM ( ) ; stgmedium . tymed = COM . TYMED_HGLOBAL ; transferData . result = getData ( dataObject , formatetc , stgmedium ) ; if ( ( transferData . result ) != ( COM . S_OK ) ) return null ; int hMem = stgmedium . unionField ; dataObject . Release ( ) ; try { int ptr = OS . GlobalLock ( hMem ) ; if ( ptr == 0 ) return null ; try { BITMAPINFOHEADER bmiHeader = new BITMAPINFOHEADER ( ) ; OS . MoveMemory ( bmiHeader , ptr , sizeof ) ; int [ ] pBits = new int [ 1 ] ; int memDib = OS . CreateDIBSection ( 0 , ptr , DIB_RGB_COLORS , pBits , 0 , 0 ) ; if ( memDib == 0 ) SWT . error ( ERROR_NO_HANDLES ) ; int bits = ptr + ( bmiHeader . biSize ) ; if ( ( bmiHeader . biBitCount ) <= 8 ) { <START_BUG> bits += ( 1 << ( bmiHeader . biBitCount ) ) * 4 ; <END_BUG> } else if ( ( bmiHeader . biCompression ) == ( OS . BI_BITFIELDS ) ) { bits += 12 ; } if ( ( bmiHeader . biHeight ) < 0 ) { OS . MoveMemory ( pBits [ 0 ] , bits , bmiHeader . biSizeImage ) ; } else { DIBSECTION dib = new DIBSECTION ( ) ; OS . GetObject ( memDib , DIBSECTION . sizeof , dib ) ; int biHeight = dib . biHeight ; int scanline = ( dib . biSizeImage ) / biHeight ; int pDestBits = pBits [ 0 ] ; int pSourceBits = bits + ( scanline * ( biHeight - 1 ) ) ; for ( int i = 0 ; i < biHeight ; i ++ ) { OS . MoveMemory ( pDestBits , pSourceBits , scanline ) ; pDestBits += scanline ; pSourceBits -= scanline ; } } Image image = Image . win32_new ( null , BITMAP , memDib ) ; ImageData data = image . getImageData ( ) ; OS . DeleteObject ( memDib ) ; image . dispose ( ) ; return data ; } finally { OS . GlobalUnlock ( hMem ) ; } } finally { OS . GlobalFree ( hMem ) ; } } protected int [ ] getTypeIds ( ) { } protected String [ ] getTypeNames ( ) { } boolean checkImage ( Object object ) { } protected boolean validate ( Object object ) { } } 
public class FunctionReference extends SpelNodeImpl { private final String name ; public FunctionReference ( String functionName , int pos , SpelNodeImpl ... arguments ) { } @ Override public TypedValue getValueInternal ( ExpressionState state ) throws EvaluationException { } private TypedValue executeFunctionJLRMethod ( ExpressionState state , Method method ) throws EvaluationException { Object [ ] functionArgs = getArguments ( state ) ; if ( ( ! ( method . isVarArgs ( ) ) ) && ( ( method . getParameterTypes ( ) . length ) != ( functionArgs . length ) ) ) { throw new org . springframework . expression . spel . SpelEvaluationException ( SpelMessage . INCORRECT_NUMBER_OF_ARGUMENTS_TO_FUNCTION , functionArgs . length , method . getParameterTypes ( ) . length ) ; } if ( ! ( Modifier . isStatic ( method . getModifiers ( ) ) ) ) { throw new org . springframework . expression . spel . SpelEvaluationException ( getStartPosition ( ) , SpelMessage . FUNCTION_MUST_BE_STATIC , ( ( ( method . getDeclaringClass ( ) . getName ( ) ) + "." ) + ( method . getName ( ) ) ) , name ) ; } if ( functionArgs != null ) { TypeConverter converter = state . getEvaluationContext ( ) . getTypeConverter ( ) ; ReflectionHelper . convertAllArguments ( converter , functionArgs , method ) ; } if ( method . isVarArgs ( ) ) { functionArgs = ReflectionHelper . setupArgumentsForVarargsInvocation ( method . getParameterTypes ( ) , functionArgs ) ; } try { ReflectionUtils . makeAccessible ( method ) ; Object result = method . invoke ( method . getClass ( ) , functionArgs ) ; <START_BUG> return new TypedValue ( result , new org . springframework . core . convert . TypeDescriptor ( new MethodParameter ( method , ( - 1 ) ) ) ) ; <END_BUG> } catch ( Exception ex ) { throw new org . springframework . expression . spel . SpelEvaluationException ( getStartPosition ( ) , ex , SpelMessage . EXCEPTION_DURING_FUNCTION_CALL , this . name , ex . getMessage ( ) ) ; } } @ Override public String toStringAST ( ) { } private Object [ ] getArguments ( ExpressionState state ) throws EvaluationException { } } 
public class ReturnStatement extends Statement { public Expression expression ; public TypeBinding expressionType ; public boolean isSynchronized ; public AstNode [ ] subroutines ; public LocalVariableBinding saveValueVariable ; public ReturnStatement ( Expression expr , int s , int e ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void generateReturnBytecode ( BlockScope currentScope , CodeStream codeStream ) { } public void generateStoreSaveValueIfNecessary ( BlockScope currentScope , CodeStream codeStream ) { } public boolean needValue ( ) { } public void prepareSaveValueLocation ( TryStatement targetTryStatement ) { } public void resolve ( BlockScope scope ) { MethodScope methodScope = scope . methodScope ( ) ; MethodBinding methodBinding ; TypeBinding methodType = ( ( methodScope . referenceContext ) instanceof AbstractMethodDeclaration ) ? ( methodBinding = ( ( AbstractMethodDeclaration ) ( methodScope . referenceContext ) ) . binding ) == null ? null : methodBinding . returnType : VoidBinding ; if ( methodType == ( VoidBinding ) ) { if ( ( expression ) == null ) return ; if ( ( expressionType = expression . resolveType ( scope ) ) != null ) scope . problemReporter ( ) . attemptToReturnNonVoidExpression ( this , expressionType ) ; return ; } if ( ( expression ) == null ) { if ( methodType != null ) scope . problemReporter ( ) . shouldReturn ( methodType , this ) ; return ; } if ( ( expressionType = expression . resolveType ( scope ) ) == null ) return ; if ( ( methodType != null ) && ( expression . isConstantValueOfTypeAssignableToType ( expressionType , methodType ) ) ) { expression . implicitWidening ( methodType , expressionType ) ; return ; } if ( ( expressionType ) == ( VoidBinding ) ) { scope . problemReporter ( ) . attemptToReturnVoidValue ( this ) ; return ; } <START_BUG> if ( ( methodType != null ) && ( org . eclipse . jdt . internal . compiler . lookup . Scope . areTypesCompatible ( expressionType , methodType ) ) ) { <END_BUG> expression . implicitWidening ( methodType , expressionType ) ; return ; } if ( methodType != null ) { scope . problemReporter ( ) . typeMismatchErrorActualTypeExpectedType ( expression , expressionType , methodType ) ; } } public String toString ( int tab ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } } 
public class WeldEjbServices implements EjbServices { private final ServiceRegistry serviceRegistry ; private volatile Map < String , InterceptorBindings > bindings = Collections . emptyMap ( ) ; public WeldEjbServices ( ServiceRegistry serviceRegistry ) { } @ Override public synchronized void registerInterceptors ( EjbDescriptor < ? > ejbDescriptor , InterceptorBindings interceptorBindings ) { } @ Override public SessionObjectReference resolveEjb ( EjbDescriptor < ? > ejbDescriptor ) { if ( ejbDescriptor . isStateful ( ) ) { return new StatefulSessionObjectReferenceImpl ( ( ( EjbDescriptorImpl < ? > ) ( ejbDescriptor ) ) ) ; } else { <START_BUG> return new org . jboss . as . weld . ejb . SessionObjectReferenceImpl ( ( ( EjbDescriptorImpl < ? > ) ( ejbDescriptor ) ) , serviceRegistry ) ; <END_BUG> } } @ Override public void cleanup ( ) { } public InterceptorBindings getBindings ( String ejbName ) { } } 
public class JMXSubsystemTestCase extends AbstractSubsystemTest { private static final String LAUNCH_TYPE = "launch-type" ; private static final String TYPE_STANDALONE = "STANDALONE" ; public JMXSubsystemTestCase ( ) { } @ Test public void testParseEmptySubsystem ( ) throws Exception { } @ Test public void testParseSubsystemWithBadChild ( ) throws Exception { } @ Test public void testParseSubsystemWithBadAttribute ( ) throws Exception { } @ Test public void testParseSubsystemWithConnector ( ) throws Exception { } @ Test public void testParseSubsystemWithTwoConnectors ( ) throws Exception { } @ Test public void testParseSubsystemWithBadConnectorAttribute ( ) throws Exception { } @ Test public void testInstallIntoController ( ) throws Exception { } @ Test public void testParseAndMarshalModel1_0 ( ) throws Exception { } @ Test public void testParseAndMarshalModel1_1WithShowModel ( ) throws Exception { } @ Test public void testParseAndMarshalModelWithRemoteConnectorRef1_1 ( ) throws Exception { } @ Test public void testParseAndMarshalModel1_1 ( ) throws Exception { } @ Test public void testParseAndMarshalModel1_2WithShowModels ( ) throws Exception { } @ Test public void testParseAndMarshalModel1_2WithShowModelsAndOldPropertyFormat ( ) throws Exception { } @ Test public void testDescribeHandler ( ) throws Exception { } @ Test public void testShowModelAlias ( ) throws Exception { } @ Test public void testTransformationAS712 ( ) throws Exception { } @ Test public void testTransformationAS713 ( ) throws Exception { } private void testTransformation_1_0_0 ( ModelTestControllerVersion controllerVersion ) throws Exception { } @ Test public void testRejectExpressionsAS712 ( ) throws Exception { } @ Test public void testRejectExpressionsAS713 ( ) throws Exception { } private void testRejectExpressions_1_0_0 ( ModelTestControllerVersion controllerVersion ) throws Exception { } private List < FailedOperationTransformationConfig . AttributesPathAddressConfig < ? > > createChainedConfigList ( FailedOperationTransformationConfig < ? > ... cfgs ) { } private void check_1_0_0_Model ( ModelNode legacySubsystem , boolean remotingConnector , boolean showModel ) { } private void assertJmxConnectorAddress ( ModelNode address ) { } private void assertJmxSubsystemAddress ( ModelNode address ) { } private static ModelNode createOperation ( String name , String ... addressElements ) { } private static class BaseAdditionalInitalization extends AdditionalInitialization { @ Override protected void initializeExtraSubystemsAndModel ( ExtensionRegistry extensionRegistry , Resource rootResource , ManagementResourceRegistration rootRegistration ) { } @ Override protected void setupController ( ControllerInitializer controllerInitializer ) { } @ Override protected void addExtraServices ( final ServiceTarget target ) { <START_BUG> ManagementRemotingServices . installRemotingEndpoint ( target , MANAGEMENT_ENDPOINT , "loaclhost" , MANAGEMENT , null , null ) ; <END_BUG> ServiceName tmpDirPath = JBOSS . append ( "server" , "path" , "jboss.controller.temp.dir" ) ; RemotingServices . installSecurityServices ( target , "remote" , null , null , tmpDirPath , null , null ) ; RemotingServices . installConnectorServicesForSocketBinding ( target , MANAGEMENT_ENDPOINT , "remote" , JBOSS_BINDING_NAME . append ( "remote" ) , EMPTY , null , null ) ; } } private static class CorrectDomainNameConfig extends FailedOperationTransformationConfig . AttributesPathAddressConfig < JMXSubsystemTestCase . CorrectDomainNameConfig > { public CorrectDomainNameConfig ( AttributeDefinition ... attributes ) { } @ Override protected boolean isAttributeWritable ( String attributeName ) { } @ Override protected boolean checkValue ( String attrName , ModelNode attribute , boolean isWriteAttribute ) { } @ Override protected ModelNode correctValue ( ModelNode toResolve , boolean isWriteAttribute ) { } } private static class CorrectPropertyFormatConfig extends FailedOperationTransformationConfig . AttributesPathAddressConfig < JMXSubsystemTestCase . CorrectDomainNameConfig > { public CorrectPropertyFormatConfig ( AttributeDefinition ... attributes ) { } @ Override protected boolean isAttributeWritable ( String attributeName ) { } @ Override protected boolean checkValue ( String attrName , ModelNode attribute , boolean isWriteAttribute ) { } @ Override protected ModelNode correctValue ( ModelNode toResolve , boolean isWriteAttribute ) { } } } 
public class BootStrapperTest { @ Test public void testGuessToken ( ) throws IOException { StorageService ss = StorageService . instance ( ) ; generateFakeEndpoints ( 3 ) ; InetAddress one = InetAddress . getByName ( "127.0.0.2" ) ; InetAddress two = InetAddress . getByName ( "127.0.0.3" ) ; InetAddress three = InetAddress . getByName ( "127.0.0.4" ) ; Map < InetAddress , Double > load = new HashMap < InetAddress , Double > ( ) ; load . put ( one , 1.0 ) ; load . put ( two , 2.0 ) ; load . put ( three , 3.0 ) ; TokenMetadata tmd = ss . getTokenMetadata ( ) ; InetAddress source = BootStrapper . getBootstrapSource ( tmd , load ) ; assert three . equals ( source ) ; InetAddress myEndpoint = InetAddress . getByName ( "127.0.0.1" ) ; Range range3 = ss . getPrimaryRangeForEndPoint ( three ) ; <START_BUG> Token fakeToken = ( ( IPartitioner ) ( StorageService . getPartitioner ( ) ) ) . midpoint ( range3 . left ( ) , range3 . right ( ) ) ; <END_BUG> assert range3 . contains ( fakeToken ) ; ss . onChange ( myEndpoint , MOVE_STATE , new org . apache . cassandra . gms . ApplicationState ( ( ( ( StorageService . STATE_BOOTSTRAPPING ) + ( StorageService . Delimiter ) ) + ( ss . getPartitioner ( ) . getTokenFactory ( ) . toString ( fakeToken ) ) ) ) ) ; tmd = ss . getTokenMetadata ( ) ; InetAddress source2 = BootStrapper . getBootstrapSource ( tmd , load ) ; assert two . equals ( source2 ) : source2 ; } @ Test public void testSourceTargetComputation ( ) throws UnknownHostException { } private void testSourceTargetComputation ( int numOldNodes ) throws UnknownHostException { } private void generateFakeEndpoints ( int numOldNodes ) throws UnknownHostException { } } 
public class FieldReference extends Reference implements InvocationSite { public Expression receiver ; public char [ ] token ; public FieldBinding binding ; public FieldBinding codegenBinding ; public long nameSourcePosition ; MethodBinding syntheticReadAccessor ; MethodBinding syntheticWriteAccessor ; public TypeBinding receiverType ; public FieldReference ( char [ ] source , long pos ) { } public FlowInfo analyseAssignment ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , Assignment assignment , boolean isCompound ) { if ( isCompound ) { if ( ( ( ( binding . isBlankFinal ( ) ) && ( receiver . isThis ( ) ) ) && ( currentScope . allowBlankFinalFieldAssignment ( binding ) ) ) && ( ! ( flowInfo . isDefinitelyAssigned ( binding ) ) ) ) { currentScope . problemReporter ( ) . uninitializedBlankFinalField ( binding , this ) ; } manageSyntheticReadAccessIfNecessary ( currentScope , flowInfo ) ; } flowInfo = receiver . analyseCode ( currentScope , flowContext , flowInfo , ( ! ( binding . isStatic ( ) ) ) ) . unconditionalInits ( ) ; if ( ( assignment . expression ) != null ) { flowInfo = assignment . expression . analyseCode ( currentScope , flowContext , flowInfo ) . unconditionalInits ( ) ; } manageSyntheticWriteAccessIfNecessary ( currentScope , flowInfo ) ; if ( binding . isFinal ( ) ) { if ( ( ( ( ( ( binding . isBlankFinal ( ) ) && ( ! isCompound ) ) && ( receiver . isThis ( ) ) ) && ( ! ( ( receiver ) instanceof QualifiedThisReference ) ) ) && ( ( ( receiver . bits ) & ( ASTNode . ParenthesizedMASK ) ) == 0 ) ) && ( currentScope . allowBlankFinalFieldAssignment ( binding ) ) ) { if ( flowInfo . isPotentiallyAssigned ( binding ) ) { currentScope . problemReporter ( ) . duplicateInitializationOfBlankFinalField ( binding , this ) ; } else { <START_BUG> flowContext . recordSettingFinal ( binding , this ) ; <END_BUG> } flowInfo . markAsDefinitelyAssigned ( binding ) ; } else { currentScope . problemReporter ( ) . cannotAssignToFinalField ( binding , this ) ; } } return flowInfo ; } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , boolean valueRequired ) { } public FieldBinding fieldBinding ( ) { } public void generateAssignment ( BlockScope currentScope , CodeStream codeStream , Assignment assignment , boolean valueRequired ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateCompoundAssignment ( BlockScope currentScope , CodeStream codeStream , Expression expression , int operator , int assignmentImplicitConversion , boolean valueRequired ) { } public void generatePostIncrement ( BlockScope currentScope , CodeStream codeStream , CompoundAssignment postIncrement , boolean valueRequired ) { } public static final Constant getConstantFor ( FieldBinding binding , Reference reference , boolean isImplicit , Scope referenceScope ) { } public boolean isSuperAccess ( ) { } public boolean isTypeAccess ( ) { } public void manageSyntheticReadAccessIfNecessary ( BlockScope currentScope , FlowInfo flowInfo ) { } public void manageSyntheticWriteAccessIfNecessary ( BlockScope currentScope , FlowInfo flowInfo ) { } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope ) { } public void setActualReceiverType ( ReferenceBinding receiverType ) { } public void setDepth ( int depth ) { } public void setFieldIndex ( int index ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } } 
public class PossibleMatch implements ICompilationUnit { public static final String NO_SOURCE_FILE_NAME = "NO<seq2seq4repair_space>SOURCE<seq2seq4repair_space>FILE<seq2seq4repair_space>NAME" ; public IResource resource ; public Openable openable ; public MatchingNodeSet nodeSet ; public char [ ] [ ] compoundName ; CompilationUnitDeclaration parsedUnit ; public SearchDocument document ; private String sourceFileName ; private char [ ] source ; public PossibleMatch ( MatchLocator locator , IResource resource , Openable openable , SearchDocument document , boolean mustResolve ) { } public void cleanUp ( ) { } public boolean equals ( Object obj ) { } public char [ ] getContents ( ) { } public char [ ] getFileName ( ) { } public char [ ] getMainTypeName ( ) { } public char [ ] [ ] getPackageName ( ) { } private char [ ] getQualifiedName ( ) { if ( ( this . openable ) instanceof CompilationUnit ) { <START_BUG> String fileName = this . resource . getFullPath ( ) . lastSegment ( ) ; <END_BUG> char [ ] mainTypeName = Util . getNameWithoutJavaLikeExtension ( fileName ) . toCharArray ( ) ; CompilationUnit cu = ( ( CompilationUnit ) ( this . openable ) ) ; return cu . getType ( new String ( mainTypeName ) ) . getFullyQualifiedName ( ) . toCharArray ( ) ; } else if ( ( this . openable ) instanceof ClassFile ) { String fileName = getSourceFileName ( ) ; if ( fileName == ( PossibleMatch . NO_SOURCE_FILE_NAME ) ) return ( ( ClassFile ) ( this . openable ) ) . getType ( ) . getFullyQualifiedName ( '.' ) . toCharArray ( ) ; int index = Util . indexOfJavaLikeExtension ( fileName ) ; String simpleName = ( index == ( - 1 ) ) ? fileName : fileName . substring ( 0 , index ) ; PackageFragment pkg = ( ( PackageFragment ) ( this . openable . getParent ( ) ) ) ; return Util . concatWith ( pkg . names , simpleName , '.' ) . toCharArray ( ) ; } return null ; } private String getSourceFileName ( ) { } public int hashCode ( ) { } public String toString ( ) { } } 
public class WebRequestCycle extends RequestCycle { private static final Log log = LogFactory . getLog ( WebRequestCycle . class ) ; public WebRequestCycle ( final WebSession session , final WebRequest request , final Response response ) { } public WebRequest getWebRequest ( ) { } public WebResponse getWebResponse ( ) { } public WebSession getWebSession ( ) { } public final void redirectTo ( final Page page ) { String redirectUrl = null ; ApplicationSettings settings = application . getSettings ( ) ; if ( ( ( settings . getRenderStrategy ( ) ) == ( ApplicationSettings . REDIRECT_TO_BUFFER ) ) && ( ( application ) instanceof WebApplication ) ) { final Response currentResponse = getResponse ( ) ; try { final BufferedResponse redirectResponse = new BufferedResponse ( ) { public String encodeURL ( String url ) { return currentResponse . encodeURL ( url ) ; } } ; redirectResponse . setCharacterEncoding ( currentResponse . getCharacterEncoding ( ) ) ; setResponse ( redirectResponse ) ; page . doRender ( ) ; setResponse ( currentResponse ) ; final String responseRedirect = redirectResponse . getRedirectUrl ( ) ; if ( responseRedirect != null ) { redirectUrl = responseRedirect ; } else if ( ( redirectResponse . getContentLength ( ) ) > 0 ) { redirectResponse . setCharacterEncoding ( currentResponse . getCharacterEncoding ( ) ) ; redirectResponse . filter ( ) ; redirectResponse . close ( ) ; redirectUrl = page . urlFor ( page , IRedirectListener . class ) ; <START_BUG> ( ( WebApplication ) ( application ) ) . addRedirect ( getWebRequest ( ) . getHttpServletRequest ( ) , redirectUrl , redirectResponse ) ; <END_BUG> } } catch ( RuntimeException ex ) { setResponse ( currentResponse ) ; WebRequestCycle . log . error ( ex . getMessage ( ) , ex ) ; IRequestCycleProcessor processor = getRequestCycleProcessor ( ) ; processor . respond ( ex , this ) ; return ; } } else { session . touch ( page ) ; page . internalEndRequest ( ) ; } if ( redirectUrl == null ) { redirectUrl = page . urlFor ( page , IRedirectListener . class ) ; } response . redirect ( redirectUrl ) ; } protected ClientInfo newClientInfo ( ) { } public IRequestCycleProcessor getRequestCycleProcessor ( ) { } } 
public class DomainClientImpl implements DomainClient { private volatile DomainDeploymentManager deploymentManager ; private final ModelControllerClient delegate ; public DomainClientImpl ( InetAddress address , int port ) { } @ Override public OperationResult execute ( ModelNode operation , ResultHandler handler ) { } @ Override public ModelNode execute ( ModelNode operation ) throws IOException , CancellationException { } @ Override public OperationResult execute ( Operation operation , ResultHandler handler ) { } @ Override public ModelNode execute ( Operation operation ) throws IOException , CancellationException { } @ Override public byte [ ] addDeploymentContent ( InputStream stream ) { } @ Override public DomainDeploymentManager getDeploymentManager ( ) { } @ Override public List < String > getHostControllerNames ( ) { } @ Override public Map < ServerIdentity , ServerStatus > getServerStatuses ( ) { } private Set < String > getServerNames ( String host ) { ModelNode op = new ModelNode ( ) ; op . get ( "operation" ) . set ( "read-children-names" ) ; op . get ( "child-type" ) . set ( "server-config" ) ; <START_BUG> op . get ( "address" ) . set ( "host" , host ) ; <END_BUG> ModelNode result = executeForResult ( Factory . create ( op ) . build ( ) ) ; Set < String > servers = new HashSet < String > ( ) ; for ( ModelNode server : result . asList ( ) ) { servers . add ( server . asString ( ) ) ; } return servers ; } private ModelNode readAttribute ( String name , ModelNode address ) { } @ Override public ServerStatus startServer ( String hostControllerName , String serverName ) { } @ Override public ServerStatus stopServer ( String hostControllerName , String serverName , long gracefulShutdownTimeout , TimeUnit timeUnit ) { } @ Override public ServerStatus restartServer ( String hostControllerName , String serverName , long gracefulShutdownTimeout , TimeUnit timeUnit ) { } boolean isDeploymentNameUnique ( final String deploymentName ) { } @ Override public void close ( ) throws IOException { } ModelNode executeForResult ( Operation op ) { } } 
public class RarConfigProcessor implements DeploymentUnitProcessor { private static ModuleIdentifier JAVAX_ID = ModuleIdentifier . create ( "javax.resource.api" ) ; private static ModuleIdentifier LOGGING_ID = ModuleIdentifier . create ( "org.jboss.logging" ) ; private static ModuleIdentifier IRON_JACAMAR_ID = ModuleIdentifier . create ( "org.jboss.ironjacamar.api" ) ; private static ModuleIdentifier IRON_JACAMAR_IMPL_ID = ModuleIdentifier . create ( "org.jboss.ironjacamar.impl" ) ; private static ModuleIdentifier NAMING_ID = ModuleIdentifier . create ( "org.jboss.as.naming" ) ; private static ModuleIdentifier VALIDATION_ID = ModuleIdentifier . create ( "javax.validation.api" ) ; private static ModuleIdentifier HIBERNATE_VALIDATOR_ID = ModuleIdentifier . create ( "org.hibernate.validator" ) ; private static ModuleIdentifier COMMON_CORE_ID = ModuleIdentifier . create ( "org.jboss.common-core" ) ; private static ModuleIdentifier SYSTEM_ID = ModuleIdentifier . create ( "javax.api" ) ; public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { if ( ( phaseContext . getDeploymentUnit ( ) . getAttachment ( ATTACHMENT_KEY ) ) == null ) { return ; } final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; <START_BUG> final ModuleLoader moduleLoader = Module . getSystemModuleLoader ( ) ; <END_BUG> final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( MODULE_SPECIFICATION ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . JAVAX_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . LOGGING_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . IRON_JACAMAR_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . IRON_JACAMAR_IMPL_ID , false , true , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . SYSTEM_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . NAMING_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . VALIDATION_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . HIBERNATE_VALIDATOR_ID , false , false , false ) ) ; moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , RarConfigProcessor . COMMON_CORE_ID , false , false , false ) ) ; } public void undeploy ( final DeploymentUnit context ) { } } 
public class ReturnStatement extends Statement { public Expression expression ; public boolean isSynchronized ; public SubRoutineStatement [ ] subroutines ; public boolean isAnySubRoutineEscaping = false ; public LocalVariableBinding saveValueVariable ; public ReturnStatement ( Expression expr , int s , int e ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void generateReturnBytecode ( CodeStream codeStream ) { } public void generateStoreSaveValueIfNecessary ( CodeStream codeStream ) { } public boolean needValue ( ) { } public void prepareSaveValueLocation ( TryStatement targetTryStatement ) { } public StringBuffer printStatement ( int tab , StringBuffer output ) { } public void resolve ( BlockScope scope ) { MethodScope methodScope = scope . methodScope ( ) ; MethodBinding methodBinding ; TypeBinding methodType = ( ( methodScope . referenceContext ) instanceof AbstractMethodDeclaration ) ? ( methodBinding = ( ( AbstractMethodDeclaration ) ( methodScope . referenceContext ) ) . binding ) == null ? null : methodBinding . returnType : VoidBinding ; TypeBinding expressionType ; if ( methodType == ( VoidBinding ) ) { if ( ( expression ) == null ) return ; if ( ( expressionType = expression . resolveType ( scope ) ) != null ) scope . problemReporter ( ) . attemptToReturnNonVoidExpression ( this , expressionType ) ; return ; } if ( ( expression ) == null ) { if ( methodType != null ) scope . problemReporter ( ) . shouldReturn ( methodType , this ) ; return ; } expression . setExpectedType ( methodType ) ; if ( ( expressionType = expression . resolveType ( scope ) ) == null ) return ; if ( expressionType == ( VoidBinding ) ) { scope . problemReporter ( ) . attemptToReturnVoidValue ( this ) ; return ; } if ( methodType == null ) return ; <START_BUG> if ( ( expressionType . isRawType ( ) ) && ( ( methodType . isBoundParameterizedType ( ) ) || ( methodType . isGenericType ( ) ) ) ) { <END_BUG> scope . problemReporter ( ) . unsafeRawConversion ( this . expression , expressionType , methodType ) ; } if ( expression . isConstantValueOfTypeAssignableToType ( expressionType , methodType ) ) { expression . computeConversion ( scope , methodType , expressionType ) ; return ; } if ( expressionType . isCompatibleWith ( methodType ) ) { expression . computeConversion ( scope , methodType , expressionType ) ; return ; } scope . problemReporter ( ) . typeMismatchError ( expressionType , methodType , expression ) ; } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } } 
public class PanelTest extends WicketTestCase { public PanelTest ( String name ) { } public void testRenderHomePage_1 ( ) throws Exception { boolean hit = false ; try { executeTest ( PanelPage_1 . class , "Dummy.html" ) ; } catch ( MarkupException mex ) { hit = true ; assertNotNull ( mex . getMarkupStream ( ) ) ; <START_BUG> assertTrue ( mex . getMessage ( ) . contains ( "does<seq2seq4repair_space>not<seq2seq4repair_space>have<seq2seq4repair_space>a<seq2seq4repair_space>close<seq2seq4repair_space>tag" ) ) ; <END_BUG> assertTrue ( mex . getMessage ( ) . contains ( "SimplePanel_1.html" ) ) ; } assertTrue ( "Did<seq2seq4repair_space>expect<seq2seq4repair_space>a<seq2seq4repair_space>MarkupException" , hit ) ; } public void testRenderHomePage_2 ( ) throws Exception { } public void testPanel3 ( ) throws Exception { } public void testPanel4 ( ) throws Exception { } public void testInlinePanel ( ) throws Exception { } public void testInlinePanel_2 ( ) throws Exception { } public void testInlinePanel_3 ( ) throws Exception { } public void testInlinePanel_4 ( ) throws Exception { } public void testInlinePanel_5 ( ) throws Exception { } public void testInlinePanel_6 ( ) throws Exception { } public void testPanelWithAttributeModifier ( ) throws Exception { } public void testInlinePanel_7 ( ) throws Exception { } public void testInlinePanel_8 ( ) throws Exception { } public void testStartPanel ( ) { } } 
public class SegmentTest { @ Test public void testDistance ( ) { Vector2D start = new Vector2D ( 2 , 2 ) ; Vector2D end = new Vector2D ( ( - 2 ) , ( - 2 ) ) ; <START_BUG> Segment segment = new Segment ( start , end , new Line ( start , end ) ) ; <END_BUG> Assert . assertEquals ( FastMath . sqrt ( 2 ) , segment . distance ( new Vector2D ( 1 , ( - 1 ) ) ) , 1.0E-10 ) ; Assert . assertEquals ( FastMath . sin ( ( ( Math . PI ) / 4.0 ) ) , segment . distance ( new Vector2D ( 0 , ( - 1 ) ) ) , 1.0E-10 ) ; Assert . assertEquals ( FastMath . sqrt ( 8 ) , segment . distance ( new Vector2D ( 0 , 4 ) ) , 1.0E-10 ) ; Assert . assertEquals ( FastMath . sqrt ( 8 ) , segment . distance ( new Vector2D ( 0 , ( - 4 ) ) ) , 1.0E-10 ) ; } } 
public class Wizard extends Panel implements IWizard , IWizardModelListener { public static final String BUTTONS_ID = "buttons" ; public static final String FEEDBACK_ID = "feedback" ; public static final String HEADER_ID = "header" ; public static final String OVERVIEW_ID = "overview" ; public static final String FORM_ID = "form" ; public static final String VIEW_ID = "view" ; private static final long serialVersionUID = 1L ; private IWizardStep activeStep ; private Form form ; private IWizardModel wizardModel ; public Wizard ( String id ) { } public Wizard ( String id , boolean addDefaultCssStyle ) { } public Wizard ( String id , IWizardModel wizardModel ) { } public Wizard ( String id , IWizardModel wizardModel , boolean addDefaultCssStyle ) { } public final void addDefaultCssStyle ( ) { } public final IWizardStep getActiveStep ( ) { } public Form getForm ( ) { } public final IWizardModel getWizardModel ( ) { } public boolean isVersioned ( ) { } public void onActiveStepChanged ( IWizardStep newStep ) { } public void onCancel ( ) { } public void onFinish ( ) { } protected void init ( IWizardModel wizardModel ) { } protected Component newButtonBar ( String id ) { } protected FeedbackPanel newFeedbackPanel ( String id ) { } protected Form newForm ( String id ) { } protected void onBeforeRender ( ) { super . onBeforeRender ( ) ; <START_BUG> Component buttonBar = get ( Wizard . BUTTONS_ID ) ; <END_BUG> if ( buttonBar instanceof IDefaultButtonProvider ) { IFormSubmittingComponent defaultButton = ( ( IDefaultButtonProvider ) ( buttonBar ) ) . getDefaultButton ( wizardModel ) ; form . setDefaultButton ( defaultButton ) ; } } protected Component newOverviewBar ( String id ) { } } 
public class WorkingSetManager implements IWorkingSetManager { private static final String WORKING_SET_STATE_FILENAME = "workingsets.xml" ; private static final int MRU_SIZE = 5 ; private SortedSet workingSets = new TreeSet ( new WorkingSetComparator ( ) ) ; private List recentWorkingSets = new ArrayList ( ) ; private ListenerList propertyChangeListeners = new ListenerList ( ) ; public void addRecentWorkingSet ( IWorkingSet workingSet ) { } public void addWorkingSet ( IWorkingSet workingSet ) { } public void addPropertyChangeListener ( IPropertyChangeListener listener ) { } public IWorkingSet createWorkingSet ( String name , IAdaptable [ ] elements ) { } public IWorkingSetEditWizard createWorkingSetEditWizard ( IWorkingSet workingSet ) { } public IWorkingSetSelectionDialog createWorkingSetSelectionDialog ( Shell parent ) { } public IWorkingSetSelectionDialog createWorkingSetSelectionDialog ( Shell parent , boolean multi ) { } public boolean equals ( Object object ) { } private void firePropertyChange ( String changeId , Object oldValue , Object newValue ) { } public IWorkingSet [ ] getRecentWorkingSets ( ) { } public IWorkingSet getWorkingSet ( String name ) { } public int hashCode ( ) { } public IWorkingSet [ ] getWorkingSets ( ) { } private File getWorkingSetStateFile ( ) { } public void removePropertyChangeListener ( IPropertyChangeListener listener ) { } public void removeWorkingSet ( IWorkingSet workingSet ) { } private void restoreMruList ( IMemento memento ) { } public void restoreState ( ) { File stateFile = getWorkingSetStateFile ( ) ; if ( stateFile . exists ( ) ) { try { FileInputStream input = new FileInputStream ( stateFile ) ; <START_BUG> InputStreamReader reader = new InputStreamReader ( input , "utf-8" ) ; <END_BUG> IMemento memento = XMLMemento . createReadRoot ( reader ) ; restoreWorkingSetState ( memento ) ; restoreMruList ( memento ) ; reader . close ( ) ; } catch ( IOException e ) { MessageDialog . openError ( ( ( Shell ) ( null ) ) , WorkbenchMessages . getString ( "ProblemRestoringWorkingSetState.title" ) , WorkbenchMessages . getString ( "ProblemRestoringWorkingSetState.message" ) ) ; } catch ( WorkbenchException e ) { ErrorDialog . openError ( ( ( Shell ) ( null ) ) , WorkbenchMessages . getString ( "ProblemRestoringWorkingSetState.title" ) , WorkbenchMessages . getString ( "ProblemRestoringWorkingSetState.message" ) , e . getStatus ( ) ) ; } } } private IWorkingSet restoreWorkingSet ( IMemento memento ) { } private void restoreWorkingSetState ( IMemento memento ) { } private void saveState ( ) { } private void saveMruList ( IMemento memento ) { } private void saveWorkingSetState ( IMemento memento ) { } public void workingSetChanged ( IWorkingSet changedWorkingSet , String propertyChangeId ) { } } 
public class Text extends Scrollable { int txnObject ; int txnFrameID ; int textLimit = Text . LIMIT ; int tabs = 8 ; char echoCharacter ; boolean doubleClick ; String hiddenText ; ControlEditTextSelectionRec selection ; public static final int LIMIT ; public static final String DELIMITER ; static final char PASSWORD = '' ; public Text ( Composite parent , int style ) { } public void addModifyListener ( ModifyListener listener ) { } public void addSelectionListener ( SelectionListener listener ) { } public void addVerifyListener ( VerifyListener listener ) { } public void append ( String string ) { } static int checkStyle ( int style ) { } int callFocusEventHandler ( int nextHandler , int theEvent ) { } public void clearSelection ( ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } public Rectangle computeTrim ( int x , int y , int width , int height ) { } public void copy ( ) { } void copy ( char [ ] buffer ) { } void createHandle ( ) { } ScrollBar createScrollBar ( int style ) { } void createWidget ( ) { } public void cut ( ) { } Color defaultBackground ( ) { } Color defaultForeground ( ) { } void drawBackground ( int control , int context ) { if ( ! ( OS . HIVIEW ) ) { <START_BUG> drawFocus ( control , context , ( ( hasFocus ( ) ) && ( drawFocusRing ( ) ) ) , hasBorder ( ) , getParentBackground ( ) , inset ( ) ) ; <END_BUG> } } void drawWidget ( int control , int context , int damageRgn , int visibleRgn , int theEvent ) { } public int getCaretLineNumber ( ) { } public Point getCaretLocation ( ) { } public int getCaretPosition ( ) { } public int getCharCount ( ) { } String getClipboardText ( ) { } public boolean getDoubleClickEnabled ( ) { } public char getEchoChar ( ) { } public boolean getEditable ( ) { } Rect getInset ( ) { } public int getLineCount ( ) { } public String getLineDelimiter ( ) { } public int getLineHeight ( ) { } public int getOrientation ( ) { } public Point getSelection ( ) { } public int getSelectionCount ( ) { } public String getSelectionText ( ) { } public int getTabs ( ) { } public String getText ( ) { } public String getText ( int start , int end ) { } char [ ] getEditText ( int start , int end , boolean hidden ) { } public int getTextLimit ( ) { } public int getTopIndex ( ) { } public int getTopPixel ( ) { } String getTXNText ( int iStartOffset , int iEndOffset ) { } Rect inset ( ) { } public void insert ( String string ) { } void insertEditText ( String string ) { } int kEventControlActivate ( int nextHandler , int theEvent , int userData ) { } int kEventControlBoundsChanged ( int nextHandler , int theEvent , int userData ) { } int kEventControlClick ( int nextHandler , int theEvent , int userData ) { } int kEventControlDeactivate ( int nextHandler , int theEvent , int userData ) { } int kEventControlGetFocusPart ( int nextHandler , int theEvent , int userData ) { } int kEventMouseDown ( int nextHandler , int theEvent , int userData ) { } int kEventControlSetCursor ( int nextHandler , int theEvent , int userData ) { } int kEventControlSetFocusPart ( int nextHandler , int theEvent , int userData ) { } int kEventUnicodeKeyPressed ( int nextHandler , int theEvent , int userData ) { } org . eclipse . swt . internal . carbon . Point measureSpace ( ) { } public void paste ( ) { } void releaseWidget ( ) { } public void removeModifyListener ( ModifyListener listener ) { } public void removeSelectionListener ( SelectionListener listener ) { } public void removeVerifyListener ( VerifyListener listener ) { } void resetVisibleRegion ( int control ) { } public void selectAll ( ) { } boolean sendKeyEvent ( int type , Event event ) { } void setBackground ( float [ ] color ) { } int setBounds ( int x , int y , int width , int height , boolean move , boolean resize , boolean events ) { } public void setDoubleClickEnabled ( boolean doubleClick ) { } public void setEchoChar ( char echo ) { } public void setEditable ( boolean editable ) { } void setForeground ( float [ ] color ) { } void setFontStyle ( Font font ) { } public void setOrientation ( int orientation ) { } public void setSelection ( int start ) { } public void setSelection ( int start , int end ) { } public void setSelection ( Point selection ) { } public void setTabs ( int tabs ) { } public void setText ( String string ) { } void setEditText ( String string ) { } void setTXNBounds ( ) { } void setTXNText ( int iStartOffset , int iEndOffset , String string ) { } public void setTextLimit ( int limit ) { } public void setTopIndex ( int index ) { } public void showSelection ( ) { } int traversalCode ( int key , int theEvent ) { } String verifyText ( String string , int start , int end , Event keyEvent ) { } } 
public final class Program { String name ; String command ; String iconName ; Program ( ) { } public static Program findProgram ( String extension ) { } public static String [ ] getExtensions ( ) { } static String getKeyValue ( String string , boolean expand ) { } static Program getProgram ( String key ) { String name = Program . getKeyValue ( key , false ) ; if ( ( name == null ) || ( ( name . length ( ) ) == 0 ) ) { name = key ; } String DEFAULT_COMMAND = "\\shell" ; String defaultCommand = Program . getKeyValue ( ( key + DEFAULT_COMMAND ) , true ) ; <START_BUG> if ( defaultCommand == null ) <END_BUG> defaultCommand = "open" ; String COMMAND = ( "\\shell\\" + defaultCommand ) + "\\command" ; String command = Program . getKeyValue ( ( key + COMMAND ) , true ) ; if ( ( command == null ) || ( ( command . length ( ) ) == 0 ) ) return null ; String DEFAULT_ICON = "\\DefaultIcon" ; String iconName = Program . getKeyValue ( ( key + DEFAULT_ICON ) , true ) ; if ( ( iconName == null ) || ( ( iconName . length ( ) ) == 0 ) ) return null ; Program program = new Program ( ) ; program . name = name ; program . command = command ; program . iconName = iconName ; return program ; } public static Program [ ] getPrograms ( ) { } public static boolean launch ( String fileName ) { } public boolean execute ( String fileName ) { } public ImageData getImageData ( ) { } public String getName ( ) { } public boolean equals ( Object other ) { } public int hashCode ( ) { } public String toString ( ) { } } 
public class ShowViewDialog extends Dialog implements IDoubleClickListener , ISelectionChangedListener { private static final String DIALOG_SETTING_SECTION_NAME = "ShowViewDialog" ; private static final int LIST_HEIGHT = 300 ; private static final int LIST_WIDTH = 250 ; private static final String STORE_EXPANDED_CATEGORIES_ID = ( ShowViewDialog . DIALOG_SETTING_SECTION_NAME ) + ".STORE_EXPANDED_CATEGORIES_ID" ; private static final String STORE_SELECTED_VIEW_ID = ( ShowViewDialog . DIALOG_SETTING_SECTION_NAME ) + ".STORE_SELECTED_VIEW_ID" ; private FilteredTree filteredTree ; private Button okButton ; private IViewDescriptor [ ] viewDescs = new IViewDescriptor [ 0 ] ; private IViewRegistry viewReg ; private IWorkbenchWindow window ; private Color dimmedForeground ; public ShowViewDialog ( IWorkbenchWindow window , IViewRegistry viewReg ) { } protected void buttonPressed ( int buttonId ) { } protected void cancelPressed ( ) { } protected void configureShell ( Shell shell ) { } protected void createButtonsForButtonBar ( Composite parent ) { } protected Control createDialogArea ( Composite parent ) { } private static RGB blend ( RGB c1 , RGB c2 , int ratio ) { } private static int blend ( int v1 , int v2 , int ratio ) { } private void createFilteredTreeViewer ( Composite parent ) { PatternFilter filter = new ViewPatternFilter ( ) ; int styleBits = ( ( ( SWT . MULTI ) | ( SWT . H_SCROLL ) ) | ( SWT . V_SCROLL ) ) | ( SWT . BORDER ) ; filteredTree = new FilteredTree ( parent , styleBits , filter ) ; filteredTree . setBackground ( parent . getDisplay ( ) . getSystemColor ( COLOR_WIDGET_BACKGROUND ) ) ; TreeViewer treeViewer = filteredTree . getViewer ( ) ; Control treeControl = treeViewer . getControl ( ) ; RGB dimmedRGB = ShowViewDialog . blend ( treeControl . getForeground ( ) . getRGB ( ) , treeControl . getBackground ( ) . getRGB ( ) , 60 ) ; dimmedForeground = new Color ( treeControl . getDisplay ( ) , dimmedRGB ) ; treeControl . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent e ) { dimmedForeground . dispose ( ) ; } } ) ; treeViewer . setLabelProvider ( new ViewLabelProvider ( window , dimmedForeground ) ) ; treeViewer . setContentProvider ( new ViewContentProvider ( ) ) ; <START_BUG> treeViewer . setSorter ( new ViewSorter ( ( ( ViewRegistry ) ( viewReg ) ) ) ) ; <END_BUG> treeViewer . setInput ( viewReg ) ; treeViewer . addSelectionChangedListener ( this ) ; treeViewer . addDoubleClickListener ( this ) ; treeViewer . addFilter ( new CapabilityFilter ( ) ) ; if ( hasAtMostOneView ( filteredTree . getViewer ( ) ) ) { Text filterText = filteredTree . getFilterControl ( ) ; if ( filterText != null ) { filterText . setEnabled ( false ) ; } } applyDialogFont ( filteredTree ) ; } private boolean hasAtMostOneView ( TreeViewer tree ) { } public void doubleClick ( DoubleClickEvent event ) { } protected IDialogSettings getDialogSettings ( ) { } public IViewDescriptor [ ] getSelection ( ) { } private void layoutTopControl ( Control control ) { } protected void restoreWidgetValues ( ) { } protected void saveWidgetValues ( ) { } public void selectionChanged ( SelectionChangedEvent event ) { } protected void updateButtons ( ) { } protected void updateSelection ( SelectionChangedEvent event ) { } } 
public class FieldReference extends Reference implements InvocationSite { public Expression receiver ; public char [ ] token ; public FieldBinding binding ; public FieldBinding codegenBinding ; public long nameSourcePosition ; MethodBinding syntheticReadAccessor ; MethodBinding syntheticWriteAccessor ; public TypeBinding receiverType ; public FieldReference ( char [ ] source , long pos ) { } public FlowInfo analyseAssignment ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , Assignment assignment , boolean isCompound ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , boolean valueRequired ) { } public FieldBinding fieldBinding ( ) { } public void generateAssignment ( BlockScope currentScope , CodeStream codeStream , Assignment assignment , boolean valueRequired ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateCompoundAssignment ( BlockScope currentScope , CodeStream codeStream , Expression expression , int operator , int assignmentImplicitConversion , boolean valueRequired ) { } public void generatePostIncrement ( BlockScope currentScope , CodeStream codeStream , CompoundAssignment postIncrement , boolean valueRequired ) { } public static final Constant getConstantFor ( FieldBinding binding , Reference reference , boolean isImplicit , Scope referenceScope ) { } public boolean isSuperAccess ( ) { } public boolean isTypeAccess ( ) { } public void manageSyntheticReadAccessIfNecessary ( BlockScope currentScope , FlowInfo flowInfo ) { } public void manageSyntheticWriteAccessIfNecessary ( BlockScope currentScope , FlowInfo flowInfo ) { } public TypeBinding resolveType ( BlockScope scope ) { this . receiverType = receiver . resolveType ( scope ) ; if ( ( this . receiverType ) == null ) { constant = NotAConstant ; return null ; } this . codegenBinding = this . binding = scope . getField ( this . receiverType , token , this ) ; if ( ! ( binding . isValidBinding ( ) ) ) { constant = NotAConstant ; scope . problemReporter ( ) . invalidField ( this , this . receiverType ) ; return null ; } <START_BUG> if ( isFieldUseDeprecated ( binding , scope ) ) <END_BUG> scope . problemReporter ( ) . deprecatedField ( binding , this ) ; boolean isImplicitThisRcv = receiver . isImplicitThis ( ) ; constant = FieldReference . getConstantFor ( binding , this , isImplicitThisRcv , scope ) ; if ( ! isImplicitThisRcv ) { constant = NotAConstant ; } if ( binding . isStatic ( ) ) { if ( ! ( ( isImplicitThisRcv || ( receiver . isSuper ( ) ) ) || ( ( ( receiver ) instanceof NameReference ) && ( ( ( ( ( NameReference ) ( receiver ) ) . bits ) & ( BindingIds . TYPE ) ) != 0 ) ) ) ) { scope . problemReporter ( ) . unnecessaryReceiverForStaticField ( this , binding ) ; } } return this . resolvedType = binding . type ; } public void setActualReceiverType ( ReferenceBinding receiverType ) { } public void setDepth ( int depth ) { } public void setFieldIndex ( int index ) { } public String toStringExpression ( ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } } 
public class OSGiSubsystemSupport { private static final Logger log = Logger . getLogger ( OSGiSubsystemSupport . class ) ; public static final byte [ ] BLANK_SHA1 = new byte [ 20 ] ; private static final AtomicInteger archiveCount = new AtomicInteger ( ) ; private final ServiceContainer serviceContainer ; private OSGiSubsystemState subsystemState ; private DeploymentChain deploymentChain ; private Selector selector ; public OSGiSubsystemSupport ( ) throws Exception { } public OSGiSubsystemSupport ( final OSGiSubsystemState subsystemState ) throws Exception { } public ServiceContainer getServiceContainer ( ) { } public ModuleLoader getClassifyingModuleLoader ( ) { } public OSGiSubsystemSupport . TestModuleLoader getTestModuleLoader ( ) { } public DeploymentChain getDeploymentChain ( ) { } public String getUniqueName ( String prefix ) { } public void assertServiceUp ( ServiceName serviceName ) { } public void assertServiceDown ( ServiceName serviceName ) { } public void shutdown ( ) { } public void removeDeploymentChain ( ) { } public void setupServices ( final BatchBuilder batchBuilder ) throws Exception { } public void setupEnvironmentServices ( final BatchBuilder batchBuilder ) { } public void setupModuleLoaderServices ( final BatchBuilder batchBuilder ) { } public void setupDeploymentServices ( final BatchBuilder batchBuilder ) { } public void setupFrameworkServices ( final BatchBuilder batchBuilder ) { batchBuilder . addService ( SERVICE_NAME , new MBeanServerService ( ) ) ; OSGiSubsystemSupport . TestBundleManagerService . addService ( batchBuilder ) ; <START_BUG> FrameworkService . addService ( batchBuilder , IMMEDIATE ) ; <END_BUG> PackageAdminService . addService ( batchBuilder ) ; } private Selector getDeploymentChainSelector ( ) { } public BundleManager getBundleManager ( ) { } public BundleContext getSystemContext ( ) { } public Configuration getSubsystemConfig ( ) { } public void assertLoadClass ( ModuleIdentifier identifier , String className ) throws Exception { } public void assertLoadClass ( ModuleIdentifier identifier , String className , ModuleIdentifier exporterId ) throws Exception { } public void assertLoadClassFails ( ModuleIdentifier identifier , String className ) throws Exception { } public Class < ? > loadClass ( ModuleIdentifier identifier , String className ) throws Exception { } public Module loadModule ( ModuleIdentifier identifier ) throws ModuleLoadException { } public Bundle executeDeploy ( final JavaArchive archive ) throws Exception { } public void executeUndeploy ( final JavaArchive archive ) throws Exception { } List < ServiceName > runWithLatchedBatch ( final OSGiSubsystemSupport . BatchedWork work ) throws Exception { } public interface BatchedWork { void execute ( final BatchBuilder batchBuilder ) throws Exception { } } private static class TestServiceListener extends AbstractServiceListener < Object > { final List < ServiceName > registeredServices = new ArrayList < ServiceName > ( ) ; final List < ServiceName > startedServices = new ArrayList < ServiceName > ( ) ; final List < ServiceName > failedServices = new ArrayList < ServiceName > ( ) ; final Map < Mode , List < ServiceName > > initialModes ; private final AtomicInteger count = new AtomicInteger ( 1 ) ; private final Runnable finishTask ; public TestServiceListener ( Runnable finishTask , Map < Mode , List < ServiceName > > initialModes ) { } public void listenerAdded ( final ServiceController < ? extends Object > controller ) { } public void serviceStarted ( final ServiceController < ? extends Object > controller ) { } public void serviceFailed ( ServiceController < ? extends Object > controller , StartException reason ) { } @ Override public void serviceRemoved ( ServiceController < ? extends Object > controller ) { } public void finishBatch ( ) { } private void batchComplete ( ) { } } public static class TestModuleLoader extends ModuleLoader implements Service < OSGiSubsystemSupport . TestModuleLoader > { public static final ServiceName SERVICE_NAME = JBOSS . append ( "module" , "loader" , "support" ) ; private String prefix ; private Map < ModuleIdentifier , ModuleSpec > modules = new HashMap < ModuleIdentifier , ModuleSpec > ( ) ; private Injector < ClassifyingModuleLoaderService > injector ; TestModuleLoader ( String prefix ) { } public void addModuleSpec ( ModuleSpec moduleSpec ) { } @ Override protected ModuleSpec findModule ( ModuleIdentifier identifier ) throws ModuleLoadException { } public static OSGiSubsystemSupport . TestModuleLoader getServiceValue ( ServiceContainer container ) { } public synchronized void start ( StartContext context ) throws StartException { } public synchronized void stop ( StopContext context ) { } public synchronized OSGiSubsystemSupport . TestModuleLoader getValue ( ) throws IllegalStateException { } @ Override public String toString ( ) { } } static class TestBundleManagerService implements Service < BundleManager > { public static final ServiceName SERVICE_NAME = BundleManagerService . SERVICE_NAME ; private static final Logger log = Logger . getLogger ( "org.jboss.as.osgi" ) ; private InjectedValue < Configuration > injectedConfig = new InjectedValue < Configuration > ( ) ; private InjectedValue < ClassifyingModuleLoaderService > injectedModuleLoader = new InjectedValue < ClassifyingModuleLoaderService > ( ) ; private Injector < ClassifyingModuleLoaderService > moduleLoaderInjector ; private BundleManager bundleManager ; public static void addService ( final BatchBuilder batchBuilder ) { } public static BundleManager getServiceValue ( ServiceContainer container ) { } public synchronized void start ( StartContext context ) throws StartException { } public synchronized void stop ( StopContext context ) { } @ Override public BundleManager getValue ( ) throws IllegalStateException { } } static class TestServerDeploymentRepository implements ServerDeploymentRepository , Service < ServerDeploymentRepository > { private Map < String , JavaArchive > repository = new HashMap < String , JavaArchive > ( ) ; public static OSGiSubsystemSupport . TestServerDeploymentRepository getServiceValue ( ServiceContainer container ) { } public void registerDeploymentArchive ( String name , JavaArchive archive ) { } @ Override public void start ( StartContext context ) throws StartException { } @ Override public void stop ( StopContext context ) { } @ Override public ServerDeploymentRepository getValue ( ) throws IllegalStateException { } @ Override public byte [ ] addDeploymentContent ( String name , String runtimeName , InputStream stream ) throws IOException { } @ Override public Closeable mountDeploymentContent ( String name , String runtimeName , byte [ ] deploymentHash , VirtualFile mountPoint ) throws IOException { } } } 
public class JavadocAllocationExpression extends AllocationExpression { public int tagSourceStart ; public int tagSourceEnd ; public int tagValue ; public boolean superAccess = false ; public JavadocAllocationExpression ( long pos ) { } private TypeBinding internalResolveType ( Scope scope ) { this . constant = NotAConstant ; if ( ( this . type ) == null ) { this . resolvedType = scope . enclosingSourceType ( ) ; } else if ( ( scope . kind ) == ( Scope . CLASS_SCOPE ) ) { this . resolvedType = this . type . resolveType ( ( ( ClassScope ) ( scope ) ) ) ; } else { <START_BUG> this . resolvedType = this . type . resolveType ( ( ( BlockScope ) ( scope ) ) ) ; <END_BUG> } TypeBinding [ ] argumentTypes = NoParameters ; if ( ( this . arguments ) != null ) { boolean argHasError = false ; int length = this . arguments . length ; argumentTypes = new TypeBinding [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { Expression argument = this . arguments [ i ] ; if ( ( scope . kind ) == ( Scope . CLASS_SCOPE ) ) { argumentTypes [ i ] = argument . resolveType ( ( ( ClassScope ) ( scope ) ) ) ; } else { argumentTypes [ i ] = argument . resolveType ( ( ( BlockScope ) ( scope ) ) ) ; } if ( ( argumentTypes [ i ] ) == null ) { argHasError = true ; } } if ( argHasError ) { return null ; } } if ( ( this . resolvedType ) == null ) { return null ; } this . superAccess = scope . enclosingSourceType ( ) . isCompatibleWith ( this . resolvedType ) ; ReferenceBinding allocationType = ( ( ReferenceBinding ) ( this . resolvedType ) ) ; this . binding = scope . getConstructor ( allocationType , argumentTypes , this ) ; if ( ! ( this . binding . isValidBinding ( ) ) ) { MethodBinding methodBinding = scope . getMethod ( this . resolvedType , this . resolvedType . sourceName ( ) , argumentTypes , this ) ; if ( methodBinding . isValidBinding ( ) ) { this . binding = methodBinding ; } else { if ( ( this . binding . declaringClass ) == null ) { this . binding . declaringClass = allocationType ; } scope . problemReporter ( ) . javadocInvalidConstructor ( this , this . binding , scope . getDeclarationModifiers ( ) ) ; } return this . resolvedType ; } if ( isMethodUseDeprecated ( this . binding , scope ) ) { scope . problemReporter ( ) . javadocDeprecatedMethod ( this . binding , this , scope . getDeclarationModifiers ( ) ) ; } return allocationType ; } public boolean isSuperAccess ( ) { } public TypeBinding resolveType ( BlockScope scope ) { } public TypeBinding resolveType ( ClassScope scope ) { } } 
public class OracleDictionary extends DBDictionary { public static final String SELECT_HINT = "openjpa.hint.OracleSelectHint" ; public static final String VENDOR_ORACLE = "oracle" ; private static final int BEHAVE_OTHER = 0 ; private static final int BEHAVE_ORACLE = 1 ; private static final int BEHAVE_DATADIRECT31 = 2 ; private static Blob EMPTY_BLOB = null ; private static Clob EMPTY_CLOB = null ; private static final Localizer _loc = Localizer . forPackage ( OracleDictionary . class ) ; public boolean useTriggersForAutoAssign = false ; public String autoAssignSequenceName = null ; public boolean openjpa3GeneratedKeyNames = false ; public boolean useSetFormOfUseForUnicode = true ; private boolean _checkedUpdateBug = false ; private boolean _warnedCharColumn = false ; private boolean _warnedNcharColumn = false ; private int _driverBehavior = - 1 ; private Method _putBytes = null ; private Method _putString = null ; private Method _putChars = null ; private int defaultBatchLimit = 100 ; public OracleDictionary ( ) { } public void endConfiguration ( ) { } public void connectedConfiguration ( Connection conn ) throws SQLException { } private void cacheDriverBehavior ( String driverVendor ) { } public void ensureDriverVendor ( ) { } public boolean supportsLocking ( Select sel ) { } protected SQLBuffer getSelects ( Select sel , boolean distinctIdentifiers , boolean forUpdate ) { } public boolean canOuterJoin ( int syntax , ForeignKey fk ) { } public SQLBuffer toNativeJoin ( Join join ) { } protected SQLBuffer toSelect ( SQLBuffer select , JDBCFetchConfiguration fetch , SQLBuffer tables , SQLBuffer where , SQLBuffer group , SQLBuffer having , SQLBuffer order , boolean distinct , boolean forUpdate , long start , long end , boolean subselect , Select sel ) { } protected SQLBuffer toSelect ( SQLBuffer select , JDBCFetchConfiguration fetch , SQLBuffer tables , SQLBuffer where , SQLBuffer group , SQLBuffer having , SQLBuffer order , boolean distinct , boolean forUpdate , long start , long end , Select sel ) { } private boolean requiresSubselectForRange ( long start , long end , boolean distinct , SQLBuffer order ) { } public String getSelectOperation ( JDBCFetchConfiguration fetch ) { } public void setString ( PreparedStatement stmnt , int idx , String val , Column col ) throws SQLException { } public void setNull ( PreparedStatement stmnt , int idx , int colType , Column col ) throws SQLException { } public String getClobString ( ResultSet rs , int column ) throws SQLException { } public Timestamp getTimestamp ( ResultSet rs , int column , Calendar cal ) throws SQLException { } public Object getObject ( ResultSet rs , int column , Map map ) throws SQLException { } private static Object convertFromOracleType ( Object obj , String convertMethod ) throws SQLException { } public Column [ ] getColumns ( DatabaseMetaData meta , String catalog , String schemaName , String tableName , String columnName , Connection conn ) throws SQLException { } public PrimaryKey [ ] getPrimaryKeys ( DatabaseMetaData meta , String catalog , String schemaName , String tableName , Connection conn ) throws SQLException { } public Index [ ] getIndexInfo ( DatabaseMetaData meta , String catalog , String schemaName , String tableName , boolean unique , boolean approx , Connection conn ) throws SQLException { } public ForeignKey [ ] getImportedKeys ( DatabaseMetaData meta , String catalog , String schemaName , String tableName , Connection conn , boolean partialKeys ) throws SQLException { } public String [ ] getCreateTableSQL ( Table table ) { } public String [ ] getCreateSequenceSQL ( Sequence seq ) { } @ Override public int getJDBCType ( int metaTypeCode , boolean lob , int precis , int scale , boolean xml ) { <START_BUG> return getJDBCType ( metaTypeCode , ( lob && ( ! xml ) ) , precis , scale ) ; <END_BUG> } protected String getSequencesSQL ( String schemaName , String sequenceName ) { } public boolean isSystemSequence ( String name , String schema , boolean targetSchema ) { } public Object getGeneratedKey ( Column col , Connection conn ) throws SQLException { } protected String getGeneratedKeyTriggerName ( Column col ) { } protected String getOpenJPA3GeneratedKeySequenceName ( Column col ) { } protected String getOpenJPA3GeneratedKeyTriggerName ( Column col ) { } public void putBytes ( Blob blob , byte [ ] data ) throws SQLException { } public void putString ( Clob clob , String data ) throws SQLException { } public void putChars ( Clob clob , char [ ] data ) throws SQLException { } private static void invokePutLobMethod ( Method method , Object target , Object data ) throws SQLException { } private Clob getEmptyClob ( ) throws SQLException { } private Blob getEmptyBlob ( ) throws SQLException { } private static boolean isOraclePreparedStatement ( Statement stmnt ) { } public void appendXmlComparison ( SQLBuffer buf , String op , FilterValue lhs , FilterValue rhs , boolean lhsxml , boolean rhsxml ) { } private void appendXmlComparison1 ( SQLBuffer buf , String op , FilterValue lhs , FilterValue rhs ) { } private void appendXmlComparison2 ( SQLBuffer buf , String op , FilterValue lhs , FilterValue rhs ) { } private void appendXmlExtractValue ( SQLBuffer buf , FilterValue val ) { } public void insertClobForStreamingLoad ( Row row , Column col , Object ob ) throws SQLException { } public int getBatchUpdateCount ( PreparedStatement ps ) throws SQLException { } @ Override protected Boolean matchErrorState ( int subtype , Set < String > errorStates , SQLException ex ) { } @ Override public void insertBlobForStreamingLoad ( Row row , Column col , JDBCStore store , Object ob , Select sel ) throws SQLException { } } 
public class ModClusterEnableContext implements OperationStepHandler , DescriptionProvider { static final ModClusterEnableContext INSTANCE = new ModClusterEnableContext ( ) ; @ Override public ModelNode getModelDescription ( Locale locale ) { } @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { <START_BUG> if ( context . getProcessType ( ) . isServer ( ) ) { <END_BUG> context . addStep ( new OperationStepHandler ( ) { @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { ServiceController < ? > controller = context . getServiceRegistry ( false ) . getService ( NAME ) ; ModCluster modcluster = ( ( ModCluster ) ( controller . getValue ( ) ) ) ; ModClusterLogger . ROOT_LOGGER . debugf ( "enable-context:<seq2seq4repair_space>%s" , operation ) ; ContextHost contexthost = new ContextHost ( operation ) ; modcluster . enableContext ( contexthost . webhost , contexthost . webcontext ) ; context . completeStep ( ) ; } } , RUNTIME ) ; } context . completeStep ( ) ; } } 
class ASTSyntaxErrorPropagator extends ASTVisitor { private IProblem [ ] problems ; ASTSyntaxErrorPropagator ( IProblem [ ] problems ) { } private boolean checkAndTagAsMalformed ( ASTNode node ) { boolean tagWithErrors = false ; search : for ( int i = 0 , max = this . problems . length ; i < max ; i ++ ) { IProblem problem = this . problems [ i ] ; switch ( problem . getID ( ) ) { case IProblem . ParsingErrorOnKeywordNoSuggestion : case IProblem . ParsingErrorOnKeyword : case IProblem . ParsingError : case IProblem . ParsingErrorNoSuggestion : break ; case IProblem . ParsingErrorInsertTokenBefore : case IProblem . ParsingErrorInsertTokenAfter : case IProblem . ParsingErrorDeleteToken : case IProblem . ParsingErrorDeleteTokens : case IProblem . ParsingErrorMergeTokens : case IProblem . ParsingErrorInvalidToken : case IProblem . ParsingErrorMisplacedConstruct : case IProblem . ParsingErrorReplaceTokens : case IProblem . ParsingErrorNoSuggestionForTokens : case IProblem . ParsingErrorUnexpectedEOF : case IProblem . ParsingErrorInsertToComplete : case IProblem . ParsingErrorInsertToCompleteScope : case IProblem . ParsingErrorInsertToCompletePhrase : break ; default : continue search ; } int position = problem . getSourceStart ( ) ; int start = node . getStartPosition ( ) ; int end = start + ( node . getLength ( ) ) ; if ( ( start <= position ) && ( position <= end ) ) { <START_BUG> node . setFlags ( ASTNode . MALFORMED ) ; <END_BUG> ASTNode currentNode = node . getParent ( ) ; while ( currentNode != null ) { currentNode . setFlags ( ( ( currentNode . getFlags ( ) ) & ( ~ ( ASTNode . MALFORMED ) ) ) ) ; currentNode = currentNode . getParent ( ) ; } tagWithErrors = true ; } } return tagWithErrors ; } public boolean visit ( FieldDeclaration node ) { } public boolean visit ( MethodDeclaration node ) { } public boolean visit ( PackageDeclaration node ) { } public boolean visit ( ImportDeclaration node ) { } public boolean visit ( CompilationUnit node ) { } public boolean visit ( Initializer node ) { } } 
public class TestBufferedIndexInput extends LuceneTestCase { private static void writeBytes ( File aFile , long size ) throws IOException { } private static final long TEST_FILE_LENGTH = 1024 * 1024 ; public void testReadByte ( ) throws Exception { } public void testReadBytes ( ) throws Exception { } private void runReadBytesAndClose ( IndexInput input , int bufferSize , Random r ) throws IOException { } private void runReadBytes ( IndexInput input , int bufferSize , Random r ) throws IOException { } private byte [ ] buffer = new byte [ 10 ] ; private void checkReadBytes ( IndexInput input , int size , int pos ) throws IOException { } public void testEOF ( ) throws Exception { } private static byte byten ( long n ) { } private static class MyBufferedIndexInput extends BufferedIndexInput { private long pos ; private long len ; public MyBufferedIndexInput ( long len ) { } public MyBufferedIndexInput ( ) { } protected void readInternal ( byte [ ] b , int offset , int length ) throws IOException { } protected void seekInternal ( long pos ) throws IOException { } public void close ( ) throws IOException { } public long length ( ) { } } public void testSetBufferSize ( ) throws IOException { File indexDir = new File ( System . getProperty ( "tempDir" ) , "testSetBufferSize" ) ; TestBufferedIndexInput . MockFSDirectory dir = new TestBufferedIndexInput . MockFSDirectory ( indexDir , newRandom ( ) ) ; try { IndexWriter writer = new IndexWriter ( dir , new WhitespaceAnalyzer ( ) , true , MaxFieldLength . LIMITED ) ; writer . setUseCompoundFile ( false ) ; for ( int i = 0 ; i < 37 ; i ++ ) { Document doc = new Document ( ) ; doc . add ( new org . apache . lucene . document . Field ( "content" , ( "aaa<seq2seq4repair_space>bbb<seq2seq4repair_space>ccc<seq2seq4repair_space>ddd" + i ) , Store . YES , Index . ANALYZED ) ) ; doc . add ( new org . apache . lucene . document . Field ( "id" , ( "" + i ) , Store . YES , Index . ANALYZED ) ) ; writer . addDocument ( doc ) ; } writer . close ( ) ; dir . allIndexInputs . clear ( ) ; <START_BUG> IndexReader reader = IndexReader . open ( dir ) ; <END_BUG> Term aaa = new Term ( "content" , "aaa" ) ; Term bbb = new Term ( "content" , "bbb" ) ; Term ccc = new Term ( "content" , "ccc" ) ; assertEquals ( 37 , reader . docFreq ( ccc ) ) ; reader . deleteDocument ( 0 ) ; assertEquals ( 37 , reader . docFreq ( aaa ) ) ; dir . tweakBufferSizes ( ) ; reader . deleteDocument ( 4 ) ; assertEquals ( reader . docFreq ( bbb ) , 37 ) ; dir . tweakBufferSizes ( ) ; IndexSearcher searcher = new IndexSearcher ( reader ) ; ScoreDoc [ ] hits = searcher . search ( new org . apache . lucene . search . TermQuery ( bbb ) , null , 1000 ) . scoreDocs ; dir . tweakBufferSizes ( ) ; assertEquals ( 35 , hits . length ) ; dir . tweakBufferSizes ( ) ; hits = searcher . search ( new org . apache . lucene . search . TermQuery ( new Term ( "id" , "33" ) ) , null , 1000 ) . scoreDocs ; dir . tweakBufferSizes ( ) ; assertEquals ( 1 , hits . length ) ; hits = searcher . search ( new org . apache . lucene . search . TermQuery ( aaa ) , null , 1000 ) . scoreDocs ; dir . tweakBufferSizes ( ) ; assertEquals ( 35 , hits . length ) ; searcher . close ( ) ; reader . close ( ) ; } finally { _TestUtil . rmDir ( indexDir ) ; } } private static class MockFSDirectory extends Directory { List allIndexInputs = new ArrayList ( ) ; Random rand ; private Directory dir ; public MockFSDirectory ( File path , Random rand ) throws IOException { } public IndexInput openInput ( String name ) throws IOException { } public void tweakBufferSizes ( ) { } public IndexInput openInput ( String name , int bufferSize ) throws IOException { } public IndexOutput createOutput ( String name ) throws IOException { } public void close ( ) throws IOException { } public void deleteFile ( String name ) throws IOException { } public void touchFile ( String name ) throws IOException { } public long fileModified ( String name ) throws IOException { } public boolean fileExists ( String name ) throws IOException { } public String [ ] list ( ) throws IOException { } public String [ ] listAll ( ) throws IOException { } public long fileLength ( String name ) throws IOException { } public void renameFile ( String from , String to ) throws IOException { } } } 
public class TestCustomSearcherSort extends LuceneTestCase implements Serializable { private Directory index = null ; private Query query = null ; private static final int INDEX_SIZE = 2000 ; public TestCustomSearcherSort ( String name ) { } public static void main ( String [ ] argv ) { } public static Test suite ( ) { } private Directory getIndex ( ) throws IOException { RAMDirectory indexStore = new RAMDirectory ( ) ; <START_BUG> IndexWriter writer = new IndexWriter ( indexStore , new org . apache . lucene . analysis . standard . StandardAnalyzer ( Version . LUCENE_CURRENT ) , true , MaxFieldLength . LIMITED ) ; <END_BUG> TestCustomSearcherSort . RandomGen random = new TestCustomSearcherSort . RandomGen ( newRandom ( ) ) ; for ( int i = 0 ; i < ( TestCustomSearcherSort . INDEX_SIZE ) ; ++ i ) { Document doc = new Document ( ) ; if ( ( i % 5 ) != 0 ) { doc . add ( new org . apache . lucene . document . Field ( "publicationDate_" , random . getLuceneDate ( ) , Store . YES , Index . NOT_ANALYZED ) ) ; } if ( ( i % 7 ) == 0 ) { doc . add ( new org . apache . lucene . document . Field ( "content" , "test" , Store . YES , Index . ANALYZED ) ) ; } doc . add ( new org . apache . lucene . document . Field ( "mandant" , Integer . toString ( ( i % 3 ) ) , Store . YES , Index . NOT_ANALYZED ) ) ; writer . addDocument ( doc ) ; } writer . optimize ( ) ; writer . close ( ) ; return indexStore ; } @ Override public void setUp ( ) throws Exception { } public void testFieldSortCustomSearcher ( ) throws Exception { } public void testFieldSortSingleSearcher ( ) throws Exception { } public void testFieldSortMultiCustomSearcher ( ) throws Exception { } private void matchHits ( Searcher searcher , Sort sort ) throws IOException { } private void checkHits ( ScoreDoc [ ] hits , String prefix ) { } private void log ( String message ) { } public class CustomSearcher extends IndexSearcher { private int switcher ; public CustomSearcher ( Directory directory , int switcher ) throws IOException { } public CustomSearcher ( IndexReader r , int switcher ) { } @ Override public TopFieldDocs search ( Query query , Filter filter , int nDocs , Sort sort ) throws IOException { } @ Override public TopDocs search ( Query query , Filter filter , int nDocs ) throws IOException { } } private class RandomGen { RandomGen ( Random random ) { } private Random random ; private Calendar base = new GregorianCalendar ( 1980 , 1 , 1 ) ; private String getLuceneDate ( ) { } } } 
public class BasicSearchEngine { private Parser parser ; private CompilerOptions compilerOptions ; private ICompilationUnit [ ] workingCopies ; private WorkingCopyOwner workingCopyOwner ; public static boolean VERBOSE = false ; public BasicSearchEngine ( ) { } public BasicSearchEngine ( ICompilationUnit [ ] workingCopies ) { } char convertTypeKind ( int typeDeclarationKind ) { } public BasicSearchEngine ( WorkingCopyOwner workingCopyOwner ) { } public static IJavaSearchScope createHierarchyScope ( IType type ) throws JavaModelException { } public static IJavaSearchScope createHierarchyScope ( IType type , WorkingCopyOwner owner ) throws JavaModelException { } public static IJavaSearchScope createJavaSearchScope ( IJavaElement [ ] elements ) { } public static IJavaSearchScope createJavaSearchScope ( IJavaElement [ ] elements , boolean includeReferencedProjects ) { } public static IJavaSearchScope createJavaSearchScope ( IJavaElement [ ] elements , int includeMask ) { } public static IJavaSearchScope createWorkspaceScope ( ) { <START_BUG> return JavaWorkspaceScope . createScope ( ) ; <END_BUG> } public void findMatches ( SearchPattern pattern , SearchParticipant [ ] participants , IJavaSearchScope scope , SearchRequestor requestor , IProgressMonitor monitor ) throws CoreException { } public static SearchParticipant getDefaultSearchParticipant ( ) { } private Parser getParser ( ) { } private IResource getResource ( IJavaElement element ) { } private ICompilationUnit [ ] getWorkingCopies ( ) { } private ICompilationUnit [ ] getWorkingCopies ( IJavaElement element ) { } boolean match ( char patternTypeSuffix , int modifiers ) { } boolean match ( char patternTypeSuffix , char [ ] patternPkg , char [ ] patternTypeName , int matchRule , int typeKind , char [ ] pkg , char [ ] typeName ) { } public void search ( SearchPattern pattern , SearchParticipant [ ] participants , IJavaSearchScope scope , SearchRequestor requestor , IProgressMonitor monitor ) throws CoreException { } public void searchAllTypeNames ( final char [ ] packageName , final char [ ] typeName , final int matchRule , int searchFor , IJavaSearchScope scope , final IRestrictedAccessTypeRequestor nameRequestor , int waitingPolicy , IProgressMonitor progressMonitor ) throws JavaModelException { } public void searchAllTypeNames ( final char [ ] [ ] qualifications , final char [ ] [ ] typeNames , final int matchRule , int searchFor , IJavaSearchScope scope , final IRestrictedAccessTypeRequestor nameRequestor , int waitingPolicy , IProgressMonitor progressMonitor ) throws JavaModelException { } public void searchDeclarations ( IJavaElement enclosingElement , SearchRequestor requestor , SearchPattern pattern , IProgressMonitor monitor ) throws JavaModelException { } public void searchDeclarationsOfAccessedFields ( IJavaElement enclosingElement , SearchRequestor requestor , IProgressMonitor monitor ) throws JavaModelException { } public void searchDeclarationsOfReferencedTypes ( IJavaElement enclosingElement , SearchRequestor requestor , IProgressMonitor monitor ) throws JavaModelException { } public void searchDeclarationsOfSentMessages ( IJavaElement enclosingElement , SearchRequestor requestor , IProgressMonitor monitor ) throws JavaModelException { } } 
class TypeBinding implements ITypeBinding { private static final IMethodBinding [ ] NO_METHOD_BINDINGS = new IMethodBinding [ 0 ] ; private static final String NO_NAME = "" ; private static final ITypeBinding [ ] NO_TYPE_BINDINGS = new ITypeBinding [ 0 ] ; private static final IVariableBinding [ ] NO_VARIABLE_BINDINGS = new IVariableBinding [ 0 ] ; private static final int VALID_MODIFIERS = ( ( ( ( ( ( Modifier . PUBLIC ) | ( Modifier . PROTECTED ) ) | ( Modifier . PRIVATE ) ) | ( Modifier . ABSTRACT ) ) | ( Modifier . STATIC ) ) | ( Modifier . FINAL ) ) | ( Modifier . STRICTFP ) ; private org . eclipse . jdt . internal . compiler . lookup . TypeBinding binding ; private String key ; private BindingResolver resolver ; public TypeBinding ( BindingResolver resolver , org . eclipse . jdt . internal . compiler . lookup . TypeBinding binding ) { } public String getBinaryName ( ) { } public ITypeBinding getBound ( ) { } private IClassFile getClassFile ( char [ ] fileName ) { } private ICompilationUnit getCompilationUnit ( char [ ] fileName ) { } public IVariableBinding [ ] getDeclaredFields ( ) { } public IMethodBinding [ ] getDeclaredMethods ( ) { } public int getDeclaredModifiers ( ) { } public ITypeBinding [ ] getDeclaredTypes ( ) { } public IMethodBinding getDeclaringMethod ( ) { } public ITypeBinding getDeclaringClass ( ) { } public int getDimensions ( ) { } public ITypeBinding getElementType ( ) { } public ITypeBinding getTypeDeclaration ( ) { } public ITypeBinding getErasure ( ) { } public ITypeBinding [ ] getInterfaces ( ) { } public IJavaElement getJavaElement ( ) { } private JavaElement getUnresolvedJavaElement ( ) { } public String getKey ( ) { } public int getKind ( ) { } public int getModifiers ( ) { } public String getName ( ) { } public IPackageBinding getPackage ( ) { } private IPackageFragment getPackageFragment ( char [ ] fileName , int lastSlash ) { } public String getQualifiedName ( ) { } public ITypeBinding getSuperclass ( ) { } public ITypeBinding [ ] getTypeArguments ( ) { } public ITypeBinding [ ] getTypeBounds ( ) { } public ITypeBinding [ ] getTypeParameters ( ) { } public ITypeBinding getWildcard ( ) { } public boolean isGenericType ( ) { } public boolean isAnnotation ( ) { } public boolean isAnonymous ( ) { } public boolean isArray ( ) { } public boolean isAssignmentCompatible ( ITypeBinding type ) { } public boolean isCapture ( ) { } public boolean isCastCompatible ( ITypeBinding type ) { } public boolean isClass ( ) { } public boolean isDeprecated ( ) { } public boolean isEnum ( ) { } public boolean isEqualTo ( IBinding other ) { } public boolean isFromSource ( ) { } public boolean isInterface ( ) { <START_BUG> return this . binding . isInterface ( ) ; <END_BUG> } public boolean isLocal ( ) { } public boolean isMember ( ) { } public boolean isNested ( ) { } public boolean isNullType ( ) { } public boolean isParameterizedType ( ) { } public boolean isPrimitive ( ) { } public boolean isRawType ( ) { } public boolean isSubTypeCompatible ( ITypeBinding type ) { } public boolean isSynthetic ( ) { } public boolean isTopLevel ( ) { } public boolean isTypeVariable ( ) { } public boolean isUpperbound ( ) { } public boolean isWildcardType ( ) { } private boolean shouldBeRemoved ( MethodBinding methodBinding ) { } public String toString ( ) { } } 
public class TestPlan extends AbstractTestElement implements Serializable , TestListener { private static final long serialVersionUID = 233L ; private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final String FUNCTIONAL_MODE = "TestPlan.functional_mode" ; private static final String USER_DEFINED_VARIABLES = "TestPlan.user_defined_variables" ; private static final String SERIALIZE_THREADGROUPS = "TestPlan.serialize_threadgroups" ; private static final String CLASSPATHS = "TestPlan.user_define_classpath" ; private static final String CLASSPATH_SEPARATOR = "," ; private static final String BASEDIR = "basedir" ; private transient List < ThreadGroup > threadGroups = new LinkedList < ThreadGroup > ( ) ; private static volatile boolean functionalMode = false ; public TestPlan ( ) { } public TestPlan ( String name ) { } private Object readResolve ( ) { } public void prepareForPreCompile ( ) { } public boolean isFunctionalMode ( ) { } public void setUserDefinedVariables ( Arguments vars ) { } public JMeterProperty getUserDefinedVariablesAsProperty ( ) { } public String getBasedir ( ) { } public void setBasedir ( String b ) { } public Arguments getArguments ( ) { } public Map < String , String > getUserDefinedVariables ( ) { } private Arguments getVariables ( ) { } public void setFunctionalMode ( boolean funcMode ) { } public static boolean getFunctionalMode ( ) { } public void setSerialized ( boolean serializeTGs ) { } public void setTestPlanClasspath ( String text ) { } public void setTestPlanClasspathArray ( String [ ] text ) { <START_BUG> StringBuffer cat = new StringBuffer ( ) ; <END_BUG> for ( int idx = 0 ; idx < ( text . length ) ; idx ++ ) { if ( idx > 0 ) { cat . append ( TestPlan . CLASSPATH_SEPARATOR ) ; } cat . append ( text [ idx ] ) ; } this . setTestPlanClasspath ( cat . toString ( ) ) ; } public String [ ] getTestPlanClasspathArray ( ) { } public String getTestPlanClasspath ( ) { } public boolean isSerialized ( ) { } public void addParameter ( String name , String value ) { } @ Override public void addTestElement ( TestElement tg ) { } public void addThreadGroup ( ThreadGroup group ) { } public void testEnded ( ) { } public void testEnded ( String host ) { } public void testIterationStart ( LoopIterationEvent event ) { } public void testStarted ( ) { } public void testStarted ( String host ) { } } 
public class AboutFeaturesDialog extends ProductInfoDialog { private static final int TABLE_HEIGHT = 150 ; private static final int INFO_HEIGHT = 100 ; private static final int MORE_ID = ( IDialogConstants . CLIENT_ID ) + 1 ; private static final int PLUGINS_ID = ( IDialogConstants . CLIENT_ID ) + 2 ; private static final int COLUMNS_ID = ( IDialogConstants . CLIENT_ID ) + 3 ; private Table table ; private Label imageLabel ; private StyledText text ; private Composite infoArea ; private Map cachedImages = new HashMap ( ) ; private String [ ] columnTitles = new String [ ] { WorkbenchMessages . AboutFeaturesDialog_provider , WorkbenchMessages . AboutFeaturesDialog_featureName , WorkbenchMessages . AboutFeaturesDialog_version , WorkbenchMessages . AboutFeaturesDialog_featureId } ; private String productName ; private AboutBundleGroupData [ ] bundleGroupInfos ; private int lastColumnChosen = 0 ; private boolean reverseSort = false ; private AboutBundleGroupData lastSelection = null ; private Button moreButton ; private Button pluginsButton ; private static Map featuresMap ; public AboutFeaturesDialog ( Shell parentShell , String productName , AboutBundleGroupData [ ] bundleGroupInfos ) { } private void handleMoreInfoPressed ( ) { } private void handlePluginInfoPressed ( ) { } protected void buttonPressed ( int buttonId ) { } private void handleColumnsPressed ( ) { } protected void configureShell ( Shell newShell ) { } protected void createButtonsForButtonBar ( Composite parent ) { } protected Control createDialogArea ( Composite parent ) { } protected void createInfoArea ( Composite parent ) { Font font = parent . getFont ( ) ; infoArea = new Composite ( parent , SWT . NULL ) ; GridData data = new GridData ( GridData . FILL , GridData . FILL , true , true ) ; data . heightHint = convertVerticalDLUsToPixels ( AboutFeaturesDialog . INFO_HEIGHT ) ; infoArea . setLayoutData ( data ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; infoArea . setLayout ( layout ) ; imageLabel = new Label ( infoArea , SWT . NONE ) ; data = new GridData ( GridData . FILL , GridData . BEGINNING , false , false ) ; data . widthHint = 32 ; data . heightHint = 32 ; imageLabel . setLayoutData ( data ) ; imageLabel . setFont ( font ) ; <START_BUG> text = new StyledText ( infoArea , ( ( SWT . MULTI ) | ( SWT . READ_ONLY ) ) ) ; <END_BUG> text . setCaret ( null ) ; text . setFont ( parent . getFont ( ) ) ; data = new GridData ( GridData . FILL , GridData . FILL , true , true ) ; text . setLayoutData ( data ) ; text . setFont ( font ) ; text . setCursor ( null ) ; text . setBackground ( infoArea . getBackground ( ) ) ; addListeners ( text ) ; TableItem [ ] items = table . getSelection ( ) ; if ( ( items . length ) > 0 ) { updateInfoArea ( ( ( AboutBundleGroupData ) ( items [ 0 ] . getData ( ) ) ) ) ; } } protected void createTable ( Composite parent ) { } public boolean close ( ) { } private void updateButtons ( AboutBundleGroupData info ) { } private void updateInfoArea ( AboutBundleGroupData info ) { } public void setInitialSelection ( AboutBundleGroupData info ) { } private void sort ( int column ) { } private void refreshTable ( ) { } private static String [ ] createRow ( AboutBundleGroupData info ) { } } 
public abstract class UploadForm extends Form { Bytes maxSize = Bytes . MAX ; public UploadForm ( String id ) { } public UploadForm ( final String id , IFeedback validationFeedback ) { } public UploadForm ( final String id , IModel model , IFeedback feedback ) { } public void process ( ) { final HttpServletRequest request = ( ( wicket . protocol . http . WebRequest ) ( getRequest ( ) ) ) . getHttpServletRequest ( ) ; try { final MultipartWebRequest multipartWebRequest = new MultipartWebRequest ( this , request ) ; getRequestCycle ( ) . setRequest ( multipartWebRequest ) ; <START_BUG> super . onFormSubmitted ( ) ; <END_BUG> } catch ( FileUploadException e ) { final HashMap model = new HashMap ( ) ; model . put ( "exception" , e ) ; model . put ( "maxSize" , maxSize ) ; if ( e instanceof SizeLimitExceededException ) { final String defaultValue = "Upload<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>less<seq2seq4repair_space>than<seq2seq4repair_space>" + ( maxSize ) ; error ( getString ( ( ( getId ( ) ) + ".uploadTooLarge" ) , Model . valueOf ( model ) , defaultValue ) ) ; } else { final String defaultValue = "Upload<seq2seq4repair_space>failed:<seq2seq4repair_space>" + ( e . getLocalizedMessage ( ) ) ; error ( getString ( ( ( getId ( ) ) + ".uploadFailed" ) , Model . valueOf ( model ) , defaultValue ) ) ; } } } public void setMaxSize ( final Bytes maxSize ) { } protected final void onComponentTag ( final ComponentTag tag ) { } protected abstract void onSubmit ( ) { } } 
public class FloatDatatypeValidator extends AbstractNumericValidator { public FloatDatatypeValidator ( ) throws InvalidDatatypeFacetException { } public FloatDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { } public int compare ( String value1 , String value2 ) { } protected void assignAdditionalFacets ( String key , Hashtable facets ) throws InvalidDatatypeFacetException { } protected int compareValues ( Object value1 , Object value2 ) { } protected void setMaxInclusive ( String value ) { } protected void setMinInclusive ( String value ) { } protected void setMaxExclusive ( String value ) { } protected void setMinExclusive ( String value ) { } protected void setEnumeration ( Vector enumeration ) throws InvalidDatatypeValueException { } protected String getMaxInclusive ( boolean isBase ) { } protected String getMinInclusive ( boolean isBase ) { } protected String getMaxExclusive ( boolean isBase ) { } protected String getMinExclusive ( boolean isBase ) { } protected void checkContent ( String content , Object state , Vector enumeration , boolean asBase ) throws InvalidDatatypeValueException { <START_BUG> if ( ( this . fBaseValidator ) != null ) { <END_BUG> ( ( FloatDatatypeValidator ) ( fBaseValidator ) ) . checkContent ( content , state , enumeration , true ) ; } if ( ( ( fFacetsDefined ) & ( DatatypeValidator . FACET_PATTERN ) ) != 0 ) { if ( ( ( fRegex ) == null ) || ( ( fRegex . matches ( content ) ) == false ) ) throw new InvalidDatatypeValueException ( ( ( ( "Value'" + content ) + "does<seq2seq4repair_space>not<seq2seq4repair_space>match<seq2seq4repair_space>regular<seq2seq4repair_space>expression<seq2seq4repair_space>facet" ) + ( fPattern ) ) ) ; } if ( asBase ) return ; Float f = null ; try { f = FloatDatatypeValidator . fValueOf ( content ) ; } catch ( NumberFormatException nfe ) { String msg = getErrorString ( DatatypeMessageProvider . fgMessageKeys [ DatatypeMessageProvider . NOT_FLOAT ] , new Object [ ] { content } ) ; throw new InvalidDatatypeValueException ( msg ) ; } if ( enumeration != null ) { int size = enumeration . size ( ) ; Float [ ] enumFloats = new Float [ size ] ; int i = 0 ; try { for ( ; i < size ; i ++ ) enumFloats [ i ] = FloatDatatypeValidator . fValueOf ( ( ( String ) ( enumeration . elementAt ( i ) ) ) ) ; } catch ( NumberFormatException nfe ) { String msg = getErrorString ( DatatypeMessageProvider . fgMessageKeys [ DatatypeMessageProvider . INVALID_ENUM_VALUE ] , new Object [ ] { enumeration . elementAt ( i ) } ) ; throw new InvalidDatatypeValueException ( msg ) ; } enumCheck ( f . floatValue ( ) , enumFloats ) ; } boundsCheck ( f ) ; if ( ( ( ( fFacetsDefined ) & ( DatatypeValidator . FACET_ENUMERATION ) ) != 0 ) && ( ( fEnumeration ) != null ) ) { enumCheck ( f . floatValue ( ) , ( ( Float [ ] ) ( fEnumeration ) ) ) ; } } protected int getInvalidFacetMsg ( ) { } private void enumCheck ( float v , Float [ ] enumFloats ) throws InvalidDatatypeValueException { } private static Float fValueOf ( String s ) throws NumberFormatException { } private int compareFloats ( float f1 , float f2 ) { } } 
public class Echo extends Task { protected String message = "" ; protected File file = null ; protected boolean append = false ; protected int logLevel = Project . MSG_WARN ; public void setAppend ( boolean append ) { } public void setFile ( File file ) { } public void setLevel ( Echo . EchoLevel echoLevel ) { } public void setMessage ( String msg ) { } public void addText ( String msg ) throws TaskException { <START_BUG> message += project . replaceProperties ( msg ) ; <END_BUG> } public void execute ( ) throws TaskException { } public static class EchoLevel extends EnumeratedAttribute { public String [ ] getValues ( ) { } } } 
public class SSTableExport { private static int INPUT_FILE_BUFFER_SIZE = ( 8 * 1024 ) * 1024 ; private static final String KEY_OPTION = "k" ; private static final String EXCLUDEKEY_OPTION = "x" ; private static final String ENUMERATEKEYS_OPTION = "e" ; private static Options options ; private static CommandLine cmd ; private static String quote ( String val ) { } private static String asKey ( String val ) { } @ Deprecated private static String asStr ( byte [ ] val ) { } private static String serializeColumns ( Collection < IColumn > cols , AbstractType comp ) { } private static String serializeRow ( SSTableIdentityIterator row ) throws IOException { } public static void enumeratekeys ( String ssTableFile , PrintStream outs ) throws IOException { IPartitioner partitioner = StorageService . getPartitioner ( ) ; BufferedRandomAccessFile input = new BufferedRandomAccessFile ( SSTable . indexFilename ( ssTableFile ) , "r" ) ; while ( ! ( input . isEOF ( ) ) ) { <START_BUG> DecoratedKey decoratedKey = partitioner . convertFromDiskFormat ( input . readUTF ( ) ) ; <END_BUG> long dataPosition = input . readLong ( ) ; outs . println ( SSTableExport . asStr ( decoratedKey . key ) ) ; } outs . flush ( ) ; } public static void enumeratekeys ( String ssTableFile , String outFile ) throws IOException { } public static void export ( String ssTableFile , PrintStream outs , String [ ] keys , String [ ] excludes ) throws IOException { } public static void export ( String ssTableFile , String outFile , String [ ] keys , String [ ] excludes ) throws IOException { } static void export ( SSTableReader reader , PrintStream outs , String [ ] excludes ) throws IOException { } public static void export ( String ssTableFile , PrintStream outs , String [ ] excludes ) throws IOException { } public static void export ( String ssTableFile , String outFile , String [ ] excludes ) throws IOException { } public static void export ( String ssTableFile , String [ ] excludes ) throws IOException { } public static void main ( String [ ] args ) throws IOException { } } 
public class DomainUtil { public static void writeResponse ( final HttpServerExchange exchange , final int status , ModelNode response , OperationParameter operationParameter ) { } private static int getResponseLength ( final ModelNode modelNode , final OperationParameter operationParameter ) throws IOException { } public static void writeCacheHeaders ( final HttpServerExchange exchange , final int status , final OperationParameter operationParameter ) { } public static String constructUrl ( final HttpServerExchange exchange , final String path ) { final HeaderMap headers = exchange . getRequestHeaders ( ) ; String host = headers . getFirst ( HOST ) ; <START_BUG> String protocol = ( ( exchange . getConnection ( ) . getSslSession ( ) ) != null ) ? "https" : "http" ; <END_BUG> return ( ( protocol + "://" ) + host ) + path ; } } 
final class ComponentEventSender implements IEventSource { private final Component source ; private final IEventDispatcher dispatcher ; public ComponentEventSender ( Component source , IEventDispatcher dispatcher ) { } public < T > void send ( IEventSink sink , Broadcast type , T payload ) { } private void breadth ( final ComponentEvent < ? > event ) { IEventSink sink = event . getSink ( ) ; boolean targetsApplication = sink instanceof Application ; boolean targetsSession = targetsApplication || ( sink instanceof Session ) ; boolean targetsCycle = targetsSession || ( sink instanceof RequestCycle ) ; boolean targetsComponent = sink instanceof Component ; if ( ( ! targetsComponent ) && ( ! targetsCycle ) ) { dispatcher . dispatchEvent ( sink , event ) ; return ; } if ( targetsApplication ) { dispatcher . dispatchEvent ( source . getApplication ( ) , event ) ; } if ( event . isStop ( ) ) { return ; } if ( targetsSession ) { dispatcher . dispatchEvent ( source . getSession ( ) , event ) ; } if ( event . isStop ( ) ) { return ; } if ( targetsCycle ) { dispatcher . dispatchEvent ( source . getRequestCycle ( ) , event ) ; } if ( event . isStop ( ) ) { return ; } <START_BUG> Component cursor = ( targetsCycle ) ? cursor = source . getPage ( ) : ( ( Component ) ( sink ) ) ; <END_BUG> dispatcher . dispatchEvent ( cursor , event ) ; if ( event . isStop ( ) ) { return ; } event . resetShallow ( ) ; if ( cursor instanceof MarkupContainer ) { ( ( MarkupContainer ) ( cursor ) ) . visitChildren ( new ComponentEventSender . ComponentEventVisitor ( event , dispatcher ) ) ; } } private void depth ( final ComponentEvent < ? > event ) { } private void bubble ( ComponentEvent < ? > event ) { } private static class ComponentEventVisitor implements IVisitor < Component , Void > { private final ComponentEvent < ? > e ; private final IEventDispatcher dispatcher ; private ComponentEventVisitor ( ComponentEvent < ? > event , IEventDispatcher dispatcher ) { } public void component ( Component object , IVisit < Void > visit ) { } } } 
public class ModelBean implements Serializable { private String property1 ; private String property2 ; private String property3 ; private String property4 ; private String property5 ; private String property6 ; public ModelBean ( String s ) { } public String getProperty1 ( ) { } public void setProperty1 ( String property1 ) { } public String getProperty2 ( ) { } public void setProperty2 ( String property2 ) { } public String getProperty3 ( ) { } public void setProperty3 ( String property3 ) { } public String getProperty4 ( ) { } public void setProperty4 ( String property4 ) { } public String getProperty5 ( ) { } public void setProperty5 ( String property5 ) { } public String getProperty6 ( ) { } public void setProperty6 ( String property6 ) { } @ Override public String toString ( ) { <START_BUG> return getProperty1 ( ) ; <END_BUG> } } 
public class Version { private Version ( ) { } public static String id ( ) { <START_BUG> return "4.5-SNAPSHOT-20080602-1631" ; <END_BUG> } public static void main ( String [ ] args ) { } } 
class MethodVerifier15 extends MethodVerifier { MethodVerifier15 ( LookupEnvironment environment ) { } boolean areMethodsEqual ( MethodBinding one , MethodBinding substituteTwo ) { } boolean areParametersEqual ( MethodBinding one , MethodBinding two ) { } boolean areReturnTypesEqual ( MethodBinding one , MethodBinding substituteTwo ) { } boolean areTypesEqual ( TypeBinding one , TypeBinding two ) { } boolean canSkipInheritedMethods ( ) { } boolean canSkipInheritedMethods ( MethodBinding one , MethodBinding two ) { } void checkConcreteInheritedMethod ( MethodBinding concreteMethod , MethodBinding [ ] abstractMethods ) { } void checkForBridgeMethod ( MethodBinding currentMethod , MethodBinding inheritedMethod , MethodBinding [ ] otherInheritedMethods ) { } void checkForInheritedNameClash ( MethodBinding inheritedMethod , MethodBinding otherInheritedMethod ) { } void checkForNameClash ( MethodBinding currentMethod , MethodBinding inheritedMethod ) { } void checkInheritedMethods ( MethodBinding [ ] methods , int length ) { } void checkTypeVariableMethods ( ) { } MethodBinding computeSubstituteMethod ( MethodBinding inheritedMethod , MethodBinding currentMethod ) { } boolean detectInheritedMethodClash ( MethodBinding inherited , MethodBinding otherInherited ) { } boolean detectNameClash ( MethodBinding current , MethodBinding inherited ) { } public boolean doesMethodOverride ( MethodBinding one , MethodBinding two ) { } boolean doParametersClash ( MethodBinding one , MethodBinding substituteTwo ) { } public boolean doReturnTypesCollide ( MethodBinding method , MethodBinding inheritedMethod ) { } boolean doTypeVariablesClash ( MethodBinding one , MethodBinding substituteTwo ) { <START_BUG> return ( ( one . typeVariables . length ) > 0 ) && ( ! ( one . areTypeVariableErasuresEqual ( substituteTwo . original ( ) ) ) ) ; <END_BUG> } boolean isInterfaceMethodImplemented ( MethodBinding inheritedMethod , MethodBinding existingMethod , ReferenceBinding superType ) { } boolean mustImplementAbstractMethod ( ReferenceBinding declaringClass ) { } void verify ( SourceTypeBinding someType ) { } } 
public abstract class JavaElement extends PlatformObject implements IJavaElement { public static final char JEM_JAVAPROJECT = '=' ; public static final char JEM_PACKAGEFRAGMENTROOT = Path . SEPARATOR ; public static final char JEM_PACKAGEFRAGMENT = '<' ; public static final char JEM_FIELD = '^' ; public static final char JEM_METHOD = '~' ; public static final char JEM_INITIALIZER = '|' ; public static final char JEM_COMPILATIONUNIT = '{' ; public static final char JEM_CLASSFILE = '(' ; public static final char JEM_TYPE = '[' ; public static final char JEM_PACKAGEDECLARATION = '%' ; public static final char JEM_IMPORTDECLARATION = '#' ; protected int fOccurrenceCount = 1 ; protected int fLEType = 0 ; protected IJavaElement fParent ; protected String fName ; protected static JavaModelManager fgJavaModelManager = JavaModelManager . getJavaModelManager ( ) ; protected static final Object NO_INFO = new Object ( ) ; protected JavaElement ( int type , IJavaElement parent , String name ) throws IllegalArgumentException { } public void close ( ) throws JavaModelException { Object info = JavaElement . fgJavaModelManager . peekAtInfo ( this ) ; if ( info != null ) { if ( ( JavaModelManager . VERBOSE ) && ( ( this ) instanceof JavaModel ) ) { System . out . println ( "CLOSING<seq2seq4repair_space>Java<seq2seq4repair_space>Model" ) ; JavaModelManager . VERBOSE = false ; } if ( ( this ) instanceof IParent ) { IJavaElement [ ] children = ( ( JavaElementInfo ) ( info ) ) . getChildren ( ) ; for ( int i = 0 , size = children . length ; i < size ; ++ i ) { JavaElement child = ( ( JavaElement ) ( children [ i ] ) ) ; child . close ( ) ; } } closing ( info ) ; JavaElement . fgJavaModelManager . removeInfo ( this ) ; if ( JavaModelManager . VERBOSE ) { <START_BUG> System . out . println ( ( ( "-><seq2seq4repair_space>Package<seq2seq4repair_space>cache<seq2seq4repair_space>filling<seq2seq4repair_space>rate<seq2seq4repair_space>=<seq2seq4repair_space>" + ( JavaElement . fgJavaModelManager . cache . pkgFillingRate ( ) ) ) + "%" ) ) ; <END_BUG> System . out . println ( ( ( "-><seq2seq4repair_space>Openable<seq2seq4repair_space>cache<seq2seq4repair_space>filling<seq2seq4repair_space>rate<seq2seq4repair_space>=<seq2seq4repair_space>" + ( JavaElement . fgJavaModelManager . cache . openableFillingRate ( ) ) ) + "%" ) ) ; } } } protected void closing ( Object info ) throws JavaModelException { } public boolean equals ( Object o ) { } protected boolean equalsDOMNode ( IDOMNode node ) throws JavaModelException { } public boolean exists ( ) { } public IDOMNode findNode ( IDOMCompilationUnit dom ) { } protected IDOMNode followPath ( ArrayList path , int position , IDOMNode node ) { } public IJavaElement getAncestor ( int ancestorType ) { } public IJavaElement [ ] getChildren ( ) throws JavaModelException { } public ArrayList getChildrenOfType ( int type ) throws JavaModelException { } public IClassFile getClassFile ( ) { } public ICompilationUnit getCompilationUnit ( ) { } public JavaElementInfo getElementInfo ( ) throws JavaModelException { } public String getElementName ( ) { } public int getElementType ( ) { } public String getHandleIdentifier ( ) { } public String getHandleMemento ( ) { } protected abstract char getHandleMementoDelimiter ( ) { } public IJavaModel getJavaModel ( ) { } public JavaModelManager getJavaModelManager ( ) { } public IJavaProject getJavaProject ( ) { } protected int getOccurrenceCount ( ) { } public IOpenable getOpenable ( ) { } public IOpenable getOpenableParent ( ) { } public IJavaElement getParent ( ) { } public Object getRawInfo ( ) throws JavaModelException { } protected IJavaElement getSourceElementAt ( int position ) throws JavaModelException { } public SourceMapper getSourceMapper ( ) { } public abstract IResource getUnderlyingResource ( ) throws JavaModelException { } public IWorkspace getWorkspace ( ) { } public int hashCode ( ) { } protected boolean isAncestorOf ( IJavaElement e ) { } public boolean isReadOnly ( ) { } public boolean isStructureKnown ( ) throws JavaModelException { } protected JavaModelException newNotPresentException ( ) { } public void offsetSourceEndAndChildren ( int amount , IJavaElement child ) { } public void offsetSourceRange ( int amount ) { } protected void openHierarchy ( ) throws JavaModelException { } protected void opening ( Object info ) { } public String readableName ( ) { } protected void removeInfo ( ) { } public abstract IJavaElement rootedAt ( IJavaProject project ) { } protected void runOperation ( JavaModelOperation operation , IProgressMonitor monitor ) throws JavaModelException { } protected void setOccurrenceCount ( int count ) { } protected String tabString ( int tab ) { } public String toDebugString ( ) { } public String toString ( ) { } protected void toString ( int tab , StringBuffer buffer ) { } public String toStringWithAncestors ( ) { } protected void toStringAncestors ( StringBuffer buffer ) { } protected void toStringChildren ( int tab , StringBuffer buffer , Object info ) { } public Object toStringInfo ( int tab , StringBuffer buffer ) { } protected void toStringInfo ( int tab , StringBuffer buffer , Object info ) { } public void triggerSourceEndOffset ( int amount , int nameStart , int nameEnd ) { } public void triggerSourceRangeOffset ( int amount , int nameStart , int nameEnd ) { } } 
public class CastExpression extends Expression { public Expression expression ; public Expression type ; public TypeBinding expectedType ; public CastExpression ( Expression expression , Expression type ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public static void checkNeedForAssignedCast ( BlockScope scope , TypeBinding expectedType , CastExpression rhs ) { } public static void checkNeedForEnclosingInstanceCast ( BlockScope scope , Expression enclosingInstance , TypeBinding enclosingInstanceType , TypeBinding memberType ) { } public static void checkNeedForArgumentCast ( BlockScope scope , int operator , int operatorSignature , Expression expression , int expressionTypeId ) { } public static void checkNeedForArgumentCasts ( BlockScope scope , Expression receiver , TypeBinding receiverType , MethodBinding binding , Expression [ ] arguments , TypeBinding [ ] argumentTypes , final InvocationSite invocationSite ) { } public static void checkNeedForArgumentCasts ( BlockScope scope , int operator , int operatorSignature , Expression left , int leftTypeId , boolean leftIsCast , Expression right , int rightTypeId , boolean rightIsCast ) { } private static void checkAlternateBinding ( BlockScope scope , Expression receiver , TypeBinding receiverType , MethodBinding binding , Expression [ ] arguments , TypeBinding [ ] originalArgumentTypes , TypeBinding [ ] alternateArgumentTypes , final InvocationSite invocationSite ) { } public boolean checkUnsafeCast ( Scope scope , TypeBinding castType , TypeBinding expressionType , TypeBinding match , boolean isNarrowing ) { if ( match == castType ) { if ( ( ! isNarrowing ) && ( match == ( this . resolvedType . leafComponentType ( ) ) ) ) { tagAsUnnecessaryCast ( scope , castType ) ; } return true ; } if ( match != null ) { if ( isNarrowing ? checkProvablyDistinctTypes ( scope , match , expressionType , 0 ) : checkProvablyDistinctTypes ( scope , castType , match , 0 ) ) { return false ; } } switch ( castType . kind ( ) ) { case Binding . PARAMETERIZED_TYPE : if ( castType . isBoundParameterizedType ( ) ) { if ( match == null ) { this . bits |= ASTNode . UnsafeCast ; return true ; } switch ( match . kind ( ) ) { case Binding . PARAMETERIZED_TYPE : if ( isNarrowing ) { if ( ( expressionType . isRawType ( ) ) || ( ! ( expressionType . isEquivalentTo ( match ) ) ) ) { this . bits |= ASTNode . UnsafeCast ; return true ; } TypeBinding genericCastType = castType . erasure ( ) ; <START_BUG> TypeBinding genericMatch = genericCastType . findSuperTypeWithSameErasure ( expressionType ) ; <END_BUG> if ( genericMatch == match ) { this . bits |= ASTNode . UnsafeCast ; } return true ; } else { if ( ! ( match . isEquivalentTo ( castType ) ) ) { this . bits |= ASTNode . UnsafeCast ; return true ; } } break ; case Binding . RAW_TYPE : this . bits |= ASTNode . UnsafeCast ; return true ; default : if ( isNarrowing ) { this . bits |= ASTNode . UnsafeCast ; return true ; } break ; } } break ; case Binding . ARRAY_TYPE : TypeBinding leafType = castType . leafComponentType ( ) ; if ( isNarrowing && ( ( leafType . isBoundParameterizedType ( ) ) || ( leafType . isTypeVariable ( ) ) ) ) { this . bits |= ASTNode . UnsafeCast ; return true ; } break ; case Binding . TYPE_PARAMETER : this . bits |= ASTNode . UnsafeCast ; return true ; } if ( ( ! isNarrowing ) && ( match == ( this . resolvedType . leafComponentType ( ) ) ) ) { tagAsUnnecessaryCast ( scope , castType ) ; } return true ; } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public Expression innermostCastedExpression ( ) { } public LocalVariableBinding localVariableBinding ( ) { } public int nullStatus ( FlowInfo flowInfo ) { } public Constant optimizedBooleanConstant ( ) { } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope ) { } public void setExpectedType ( TypeBinding expectedType ) { } private boolean isIndirectlyUsed ( ) { } public void tagAsNeedCheckCast ( ) { } public void tagAsUnnecessaryCast ( Scope scope , TypeBinding castType ) { } public void traverse ( ASTVisitor visitor , BlockScope blockScope ) { } } 
public class PanelTest extends WicketTestCase { public PanelTest ( String name ) { } public void testRenderHomePage_1 ( ) throws Exception { boolean hit = false ; try { executeTest ( PanelPage_1 . class , "Dummy.html" ) ; } catch ( MarkupException mex ) { hit = true ; assertNotNull ( mex . getMarkupStream ( ) ) ; <START_BUG> assertTrue ( mex . getMessage ( ) . contains ( "Expected<seq2seq4repair_space>close<seq2seq4repair_space>tag<seq2seq4repair_space>for<seq2seq4repair_space>" ) ) ; <END_BUG> assertTrue ( mex . getMessage ( ) . contains ( "SimplePanel_1.html" ) ) ; } assertTrue ( "Did<seq2seq4repair_space>expect<seq2seq4repair_space>a<seq2seq4repair_space>MarkupException" , hit ) ; } public void testRenderHomePage_2 ( ) throws Exception { } public void testPanel3 ( ) throws Exception { } public void testPanel4 ( ) throws Exception { } public void testInlinePanel ( ) throws Exception { } public void testInlinePanel_2 ( ) throws Exception { } public void testInlinePanel_3 ( ) throws Exception { } public void testInlinePanel_4 ( ) throws Exception { } public void testInlinePanel_5 ( ) throws Exception { } public void testInlinePanel_6 ( ) throws Exception { } public void testPanelWithAttributeModifier ( ) throws Exception { } public void testInlinePanel_7 ( ) throws Exception { } public void testInlinePanel_8 ( ) throws Exception { } public void testStartPanel ( ) { } } 
public class DomainServerCommunicationServices implements Serializable , ServiceActivator { private static final OptionMap DEFAULTS = OptionMap . create ( RECEIVE_WINDOW_SIZE , WINDOW_SIZE ) ; private static final long serialVersionUID = 1593964083902839384L ; private static volatile int initialOperationID ; private final ModelNode endpointConfig ; private final InetSocketAddress managementSocket ; private final String serverName ; private final String serverProcessName ; private final byte [ ] authKey ; private final boolean managementSubsystemEndpoint ; DomainServerCommunicationServices ( ModelNode endpointConfig , InetSocketAddress managementSocket , String serverName , String serverProcessName , byte [ ] authKey , boolean managementSubsystemEndpoint ) { } static void updateOperationID ( final int operationID ) { } @ Override public void activate ( final ServiceActivatorContext serviceActivatorContext ) throws ServiceRegistryException { final ServiceTarget serviceTarget = serviceActivatorContext . getServiceTarget ( ) ; final ServiceName endpointName = ( managementSubsystemEndpoint ) ? RemotingServices . SUBSYSTEM_ENDPOINT : ManagementRemotingServices . MANAGEMENT_ENDPOINT ; final EndpointService . EndpointType endpointType = ( managementSubsystemEndpoint ) ? EndpointType . SUBSYSTEM : EndpointType . MANAGEMENT ; try { @ SuppressWarnings ( "deprecation" ) final OptionMap options = EndpointConfigFactory . create ( DEFAULT , endpointConfig , DomainServerCommunicationServices . DEFAULTS ) ; <START_BUG> ManagementRemotingServices . installRemotingManagementEndpoint ( serviceTarget , endpointName , WildFlySecurityManager . getPropertyPrivileged ( NODE_NAME , null ) , endpointType , options , null , null ) ; <END_BUG> final int port = managementSocket . getPort ( ) ; final String host = managementSocket . getAddress ( ) . getHostAddress ( ) ; HostControllerConnectionService service = new HostControllerConnectionService ( host , port , serverName , serverProcessName , authKey , DomainServerCommunicationServices . initialOperationID , managementSubsystemEndpoint ) ; serviceTarget . addService ( SERVICE_NAME , service ) . addDependency ( endpointName , Endpoint . class , service . getEndpointInjector ( ) ) . addDependency ( ControlledProcessStateService . SERVICE_NAME , ControlledProcessStateService . class , service . getProcessStateServiceInjectedValue ( ) ) . setInitialMode ( ACTIVE ) . install ( ) ; } catch ( OperationFailedException e ) { throw new ServiceRegistryException ( e ) ; } } public static ServiceActivator create ( final ModelNode endpointConfig , final InetSocketAddress managementSocket , final String serverName , final String serverProcessName , final byte [ ] authKey , final boolean managementSubsystemEndpoint ) { } public interface OperationIDUpdater { void updateOperationID ( int operationID ) { } } } 
public class Base64 { private static final char [ ] intToBase64 = new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' , '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '/' } ; private static final byte [ ] base64ToInt = new byte [ ] { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 62 , - 1 , - 1 , - 1 , 63 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 } ; public static String byteArrayToBase64 ( byte [ ] a , int offset , int len ) { int aLen = len ; int numFullGroups = aLen / 3 ; int numBytesInPartialGroup = aLen - ( 3 * numFullGroups ) ; int resultLen = 4 * ( ( aLen + 2 ) / 3 ) ; <START_BUG> StringBuffer result = new StringBuffer ( resultLen ) ; <END_BUG> char [ ] intToAlpha = Base64 . intToBase64 ; int inCursor = offset ; for ( int i = 0 ; i < numFullGroups ; i ++ ) { int byte0 = ( a [ ( inCursor ++ ) ] ) & 255 ; int byte1 = ( a [ ( inCursor ++ ) ] ) & 255 ; int byte2 = ( a [ ( inCursor ++ ) ] ) & 255 ; result . append ( intToAlpha [ ( byte0 > > 2 ) ] ) ; result . append ( intToAlpha [ ( ( ( byte0 << 4 ) & 63 ) | ( byte1 > > 4 ) ) ] ) ; result . append ( intToAlpha [ ( ( ( byte1 << 2 ) & 63 ) | ( byte2 > > 6 ) ) ] ) ; result . append ( intToAlpha [ ( byte2 & 63 ) ] ) ; } if ( numBytesInPartialGroup != 0 ) { int byte0 = ( a [ ( inCursor ++ ) ] ) & 255 ; result . append ( intToAlpha [ ( byte0 > > 2 ) ] ) ; if ( numBytesInPartialGroup == 1 ) { result . append ( intToAlpha [ ( ( byte0 << 4 ) & 63 ) ] ) ; result . append ( "==" ) ; } else { int byte1 = ( a [ ( inCursor ++ ) ] ) & 255 ; result . append ( intToAlpha [ ( ( ( byte0 << 4 ) & 63 ) | ( byte1 > > 4 ) ) ] ) ; result . append ( intToAlpha [ ( ( byte1 << 2 ) & 63 ) ] ) ; result . append ( '=' ) ; } } return result . toString ( ) ; } public static byte [ ] base64ToByteArray ( String s ) { } private static int base64toInt ( char c , byte [ ] alphaToInt ) { } } 
public abstract class AbstractCollectionTest < E > extends AbstractObjectTest { private Collection < E > collection ; private Collection < E > confirmed ; public AbstractCollectionTest ( String testName ) { } public boolean areEqualElementsDistinguishable ( ) { } public boolean isAddSupported ( ) { } public boolean isRemoveSupported ( ) { } public boolean isNullSupported ( ) { } public boolean isFailFastSupported ( ) { } @ Override public boolean isEqualsCheckable ( ) { } public void verify ( ) { } public void resetEmpty ( ) { } public void resetFull ( ) { } public abstract Collection < E > makeConfirmedCollection ( ) { } public abstract Collection < E > makeConfirmedFullCollection ( ) { } @ Override public abstract Collection < E > makeObject ( ) { } public Collection < E > makeFullCollection ( ) { } public Map . Entry < E , E > cloneMapEntry ( Map . Entry < E , E > entry ) { } @ SuppressWarnings ( "unchecked" ) public E [ ] getFullElements ( ) { } public E [ ] getOtherElements ( ) { } @ SuppressWarnings ( "unchecked" ) public E [ ] getFullNonNullElements ( ) { } @ SuppressWarnings ( "unchecked" ) public E [ ] getOtherNonNullElements ( ) { } public Object [ ] getFullNonNullStringElements ( ) { } public Object [ ] getOtherNonNullStringElements ( ) { } public void testCollectionAdd ( ) { } public void testCollectionAddAll ( ) { } public void testUnsupportedAdd ( ) { } public void testCollectionClear ( ) { } public void testCollectionContains ( ) { } public void testCollectionContainsAll ( ) { } public void testCollectionIsEmpty ( ) { } public void testCollectionIterator ( ) { } @ SuppressWarnings ( "unchecked" ) public void testCollectionIteratorRemove ( ) { } public void testCollectionRemove ( ) { } public void testCollectionRemoveAll ( ) { } public void testCollectionRetainAll ( ) { } public void testCollectionSize ( ) { } public void testCollectionToArray ( ) { } public void testCollectionToArray2 ( ) { } public void testCollectionToString ( ) { } public void testUnsupportedRemove ( ) { if ( isRemoveSupported ( ) ) return ; resetEmpty ( ) ; try { getCollection ( ) . clear ( ) ; AbstractCollectionTest . fail ( "clear<seq2seq4repair_space>should<seq2seq4repair_space>raise<seq2seq4repair_space>UnsupportedOperationException" ) ; } catch ( UnsupportedOperationException e ) { } verify ( ) ; try { getCollection ( ) . remove ( null ) ; AbstractCollectionTest . fail ( "remove<seq2seq4repair_space>should<seq2seq4repair_space>raise<seq2seq4repair_space>UnsupportedOperationException" ) ; } catch ( UnsupportedOperationException e ) { } verify ( ) ; try { getCollection ( ) . removeAll ( null ) ; AbstractCollectionTest . fail ( "removeAll<seq2seq4repair_space>should<seq2seq4repair_space>raise<seq2seq4repair_space>UnsupportedOperationException" ) ; } catch ( UnsupportedOperationException e ) { } verify ( ) ; try { getCollection ( ) . retainAll ( null ) ; <START_BUG> AbstractCollectionTest . fail ( "removeAll<seq2seq4repair_space>should<seq2seq4repair_space>raise<seq2seq4repair_space>UnsupportedOperationException" ) ; <END_BUG> } catch ( UnsupportedOperationException e ) { } verify ( ) ; resetFull ( ) ; try { Iterator < E > iterator = getCollection ( ) . iterator ( ) ; iterator . next ( ) ; iterator . remove ( ) ; AbstractCollectionTest . fail ( "iterator.remove<seq2seq4repair_space>should<seq2seq4repair_space>raise<seq2seq4repair_space>UnsupportedOperationException" ) ; } catch ( UnsupportedOperationException e ) { } verify ( ) ; } public void testCollectionIteratorFailFast ( ) { } @ Override public void testSerializeDeserializeThenCompare ( ) throws Exception { } public Collection < E > getCollection ( ) { } public void setCollection ( Collection < E > collection ) { } public Collection < E > getConfirmed ( ) { } public void setConfirmed ( Collection < E > confirmed ) { } protected static void assertNotCollectionContains ( Collection < ? > coll , Object element ) { } protected static void assertNotCollectionContainsAll ( Collection < ? > coll , Collection < ? > sub ) { } protected static void assertNotRemoveFromCollection ( Collection < ? > coll , Object element ) { } protected static void assertNotRemoveAllFromCollection ( Collection < ? > coll , Collection < ? > sub ) { } } 
public class NativeRemotingManagementAddHandler extends AbstractAddStepHandler implements DescriptionProvider { public static final NativeRemotingManagementAddHandler INSTANCE = new NativeRemotingManagementAddHandler ( ) ; public static final String OPERATION_NAME = ModelDescriptionConstants . ADD ; protected void populateModel ( ModelNode operation , ModelNode model ) { } protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model , ServiceVerificationHandler verificationHandler , List < ServiceController < ? > > newControllers ) { } public ModelNode getModelDescription ( Locale locale ) { <START_BUG> return ManagementDescription . getAddNativeManagementDescription ( locale ) ; <END_BUG> } } 
i ++ ) { int index = classpathContains ( newResolvedPath , oldResolvedPath [ i ] ) ; if ( index == ( - 1 ) ) { if ( ( oldResolvedPath [ i ] . getEntryKind ( ) ) == ( IClasspathEntry . CPE_PROJECT ) ) { needToUpdateDependents = true ; this . needCycleCheck = true ; continue ; } IPackageFragmentRoot [ ] pkgFragmentRoots = null ; if ( removedRoots != null ) { IPackageFragmentRoot removedRoot = ( ( IPackageFragmentRoot ) ( removedRoots . get ( oldResolvedPath [ i ] . getPath ( ) ) ) ) ; if ( removedRoot != null ) { pkgFragmentRoots = new IPackageFragmentRoot [ ] { removedRoot } ; } } if ( pkgFragmentRoots == null ) { pkgFragmentRoots = project . computePackageFragmentRoots ( oldResolvedPath [ i ] ) ; } addClasspathDeltas ( pkgFragmentRoots , IJavaElementDelta . F_REMOVED_FROM_CLASSPATH , delta ) ; int changeKind = oldResolvedPath [ i ] . getEntryKind ( ) ; needToUpdateDependents |= ( changeKind == ( IClasspathEntry . CPE_SOURCE ) ) || ( oldResolvedPath [ i ] . isExported ( ) ) ; if ( ( indexManager != null ) && ( changeKind == ( IClasspathEntry . CPE_SOURCE ) ) ) { final IPath path = oldResolvedPath [ i ] . getPath ( ) ; postAction ( new JavaModelOperation . IPostAction ( ) { public String getID ( ) { return path . toString ( ) ; } public void run ( ) throws JavaModelException { indexManager . removeSourceFolderFromIndex ( project , path ) ; } } , JavaModelOperation . REMOVEALL_APPEND ) ; } hasDelta = true ; } else { if ( ( oldResolvedPath [ i ] . getEntryKind ( ) ) == ( IClasspathEntry . CPE_PROJECT ) ) { this . needCycleCheck |= ( oldResolvedPath [ i ] . isExported ( ) ) != ( newResolvedPath [ index ] . isExported ( ) ) ; continue ; } needToUpdateDependents |= ( oldResolvedPath [ i ] . isExported ( ) ) != ( newResolvedPath [ index ] . isExported ( ) ) ; if ( oldResolvedPathLongest && ( index != i ) ) { addClasspathDeltas ( project . computePackageFragmentRoots ( oldResolvedPath [ i ] ) , IJavaElementDelta . F_CLASSPATH_REORDER , delta ) ; int changeKind = oldResolvedPath [ i ] . getEntryKind ( ) ; needToUpdateDependents |= changeKind == ( IClasspathEntry . CPE_SOURCE ) ; hasDelta = true ; } int sourceAttachmentFlags = this . getSourceAttachmentDeltaFlag ( oldResolvedPath [ i ] . getSourceAttachmentPath ( ) , newResolvedPath [ index ] . getSourceAttachmentPath ( ) ) ; int sourceAttachmentRootFlags = this . getSourceAttachmentDeltaFlag ( oldResolvedPath [ i ] . getSourceAttachmentRootPath ( ) , newResolvedPath [ index ] . getSourceAttachmentRootPath ( ) ) ; int flags = sourceAttachmentFlags | sourceAttachmentRootFlags ; if ( flags != 0 ) { addClasspathDeltas ( project . computePackageFragmentRoots ( oldResolvedPath [ i ] ) , flags , delta ) ; hasDelta = true ; } } } for ( int i = 0 ; i < ( newResolvedPath . length ) ; i ++ ) { int index = classpathContains ( oldResolvedPath , newResolvedPath [ i ] ) ; if ( index == ( - 1 ) ) { if ( ( newResolvedPath [ i ] . getEntryKind ( ) ) == ( IClasspathEntry . CPE_PROJECT ) ) { needToUpdateDependents = true ; this . needCycleCheck = true ; continue ; } addClasspathDeltas ( project . computePackageFragmentRoots ( newResolvedPath [ i ] ) , IJavaElementDelta . F_ADDED_TO_CLASSPATH , delta ) ; int changeKind = newResolvedPath [ i ] . getEntryKind ( ) ; if ( indexManager != null ) { switch ( changeKind ) { case IClasspathEntry . CPE_LIBRARY : boolean pathHasChanged = true ; final IPath newPath = newResolvedPath [ i ] . getPath ( ) ; for ( int j = 0 ; j < ( oldResolvedPath . length ) ; j ++ ) { IClasspathEntry oldEntry = oldResolvedPath [ j ] ; if ( oldEntry . getPath ( ) . equals ( newPath ) ) { pathHasChanged = false ; break ; } } if ( pathHasChanged ) { postAction ( new JavaModelOperation . IPostAction ( ) { public String getID ( ) { return newPath . toString ( ) ; } public void run ( ) throws JavaModelException { indexManager . indexLibrary ( newPath , project . getProject ( ) ) ; } } , JavaModelOperation . REMOVEALL_APPEND ) ; } break ; case IClasspathEntry . CPE_SOURCE : IClasspathEntry entry = newResolvedPath [ i ] ; final IPath path = entry . getPath ( ) ; <START_BUG> final char [ ] [ ] exclusionPatterns = ( ( ClasspathEntry ) ( entry ) ) . fulExclusionPatternChars ( ) ; <END_BUG> postAction ( new JavaModelOperation . IPostAction ( ) { public String getID ( ) { return path . toString ( ) ; } public void run ( ) throws JavaModelException { indexManager . indexSourceFolder ( project , path , exclusionPatterns ) ; } } , JavaModelOperation . APPEND ) ; break ; } } needToUpdateDependents |= ( changeKind == ( IClasspathEntry . CPE_SOURCE ) ) || ( newResolvedPath [ i ] . isExported ( ) ) ; hasDelta = true ; } } if ( hasDelta ) { this . addDelta ( delta ) ; } if ( needToUpdateDependents ) { updateAffectedProjects ( project . getProject ( ) . getFullPath ( ) ) ; } } protected JavaProject getProject ( ) { } private int getSourceAttachmentDeltaFlag ( IPath oldPath , IPath newPath ) { } public boolean isReadOnly ( ) { } protected void saveClasspathIfNecessary ( ) throws JavaModelException { } public String toString ( ) { } private void updateClasspath ( ) throws JavaModelException { } protected void updateAffectedProjects ( IPath prerequisiteProjectPath ) { } protected void updateCycleMarkersIfNecessary ( IClasspathEntry [ ] newResolvedPath ) { } protected void updateOutputLocation ( ) throws JavaModelException { } protected void updateProjectReferencesIfNecessary ( ) throws JavaModelException { } public IJavaModelStatus verify ( ) { } } 
public class BundleContextService implements Service < BundleContext > { public static final ServiceName SERVICE_NAME = JBOSS . append ( "osgi" , "context" ) ; private static final Logger log = Logger . getLogger ( "org.jboss.as.osgi" ) ; private final InjectedValue < BundleManager > injectedBundleManager = new InjectedValue < BundleManager > ( ) ; private final InjectedValue < Framework > injectedFramework = new InjectedValue < Framework > ( ) ; private BundleContext sysContext ; public static void addService ( final ServiceTarget target , Activation policy ) { } public static BundleContext getServiceValue ( ServiceContainer container ) { } public synchronized void start ( final StartContext context ) throws StartException { sysContext = injectedFramework . getValue ( ) . getBundleContext ( ) ; BundleListener bundleListener = new BundleListener ( ) { @ Override public void bundleChanged ( BundleEvent event ) { if ( ( event . getType ( ) ) == ( BundleEvent . INSTALLED ) ) { AbstractUserBundle userBundle ; try { userBundle = AbstractUserBundle . assertBundleState ( event . getBundle ( ) ) ; } catch ( RuntimeException ex ) { return ; } Deployment dep = userBundle . getDeployment ( ) ; String contextName = DeploymentHolderService . getContextName ( dep ) ; ServiceContainer container = context . getController ( ) . getServiceContainer ( ) ; ServiceName osgiDeploymentService = OSGiDeploymentService . getServiceName ( contextName ) ; <START_BUG> ServiceName deploymentService = JBOSS_DEPLOYMENT . append ( contextName ) ; <END_BUG> if ( ( ( container . getService ( deploymentService ) ) != null ) && ( ( container . getService ( osgiDeploymentService ) ) == null ) ) { ServiceName serviceName = ModuleRegistrationService . getServiceName ( contextName ) ; try { BundleContextService . log . tracef ( "Register<seq2seq4repair_space>service:<seq2seq4repair_space>%s" , serviceName ) ; BatchBuilder batchBuilder = container . batchBuilder ( ) ; ModuleRegistrationService . addService ( batchBuilder , dep , contextName ) ; batchBuilder . install ( ) ; } catch ( ServiceRegistryException ex ) { throw new IllegalStateException ( ( "Cannot<seq2seq4repair_space>register<seq2seq4repair_space>service:<seq2seq4repair_space>" + serviceName ) , ex ) ; } } } } } ; sysContext . addBundleListener ( bundleListener ) ; } public synchronized void stop ( StopContext context ) { } @ Override public BundleContext getValue ( ) throws IllegalStateException { } } 
public class StreamThread extends Thread { InputStream is ; String type ; StringBuffer buf ; public StreamThread ( InputStream is , String type ) { } public void run ( ) { try { InputStreamReader isr = new InputStreamReader ( is ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { <START_BUG> log . debug ( ( ( ( type ) + ">" ) + line ) ) ; <END_BUG> buf . append ( ( line + "\n" ) ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } public String getBuffer ( ) { } } 
public abstract class AbstractPathService implements Service < String > { private static final ServiceName SERVICE_NAME_BASE = JBOSS . append ( "server" , "path" ) ; public static ServiceName pathNameOf ( String pathName ) { } private String path ; @ Override public void start ( StartContext context ) throws StartException { <START_BUG> this . path = resolvePath ( ) ; <END_BUG> } @ Override public void stop ( StopContext context ) { } @ Override public String getValue ( ) throws IllegalStateException { } protected abstract String resolvePath ( ) { } } 
public class Path extends Resource { public int handle ; PointF currentPoint = new PointF ( ) ; PointF startPoint = new PointF ( ) ; public Path ( Device device ) { } public void addArc ( float x , float y , float width , float height , float startAngle , float arcAngle ) { if ( isDisposed ( ) ) SWT . error ( ERROR_GRAPHIC_DISPOSED ) ; if ( width < 0 ) { x = x + width ; width = - width ; } if ( height < 0 ) { y = y + height ; height = - height ; } if ( ( ( width == 0 ) || ( height == 0 ) ) || ( arcAngle == 0 ) ) return ; if ( width == height ) { Gdip . GraphicsPath_AddArc ( handle , x , y , width , height , ( - startAngle ) , ( - arcAngle ) ) ; } else { int path = Gdip . GraphicsPath_new ( FillModeAlternate ) ; if ( path == 0 ) SWT . error ( ERROR_NO_HANDLES ) ; int matrix = Gdip . Matrix_new ( width , 0 , 0 , height , x , y ) ; if ( matrix == 0 ) SWT . error ( ERROR_NO_HANDLES ) ; Gdip . GraphicsPath_AddArc ( path , 0 , 0 , 1 , 1 , ( - startAngle ) , ( - arcAngle ) ) ; Gdip . GraphicsPath_Transform ( path , matrix ) ; <START_BUG> Gdip . GraphicsPath_AddPath ( handle , path , false ) ; <END_BUG> Gdip . Matrix_delete ( matrix ) ; Gdip . GraphicsPath_delete ( path ) ; } Gdip . GraphicsPath_GetLastPoint ( handle , currentPoint ) ; } public void addPath ( Path path ) { } public void addRectangle ( float x , float y , float width , float height ) { } public void addString ( String string , float x , float y , Font font ) { } public void close ( ) { } public boolean contains ( float x , float y , GC gc , boolean outline ) { } public void cubicTo ( float cx1 , float cy1 , float cx2 , float cy2 , float x , float y ) { } public void dispose ( ) { } public void getBounds ( float [ ] bounds ) { } public void getCurrentPoint ( float [ ] point ) { } public PathData getPathData ( ) { } public void lineTo ( float x , float y ) { } public boolean isDisposed ( ) { } public void moveTo ( float x , float y ) { } public void quadTo ( float cx , float cy , float x , float y ) { } public String toString ( ) { } } 
public class CodeSnippetClassFile extends ClassFile { public CodeSnippetClassFile ( SourceTypeBinding aType , ClassFile enclosingClassFile , boolean creatingProblemType ) { } public static void createProblemType ( TypeDeclaration typeDeclaration , CompilationResult unitResult ) { SourceTypeBinding typeBinding = typeDeclaration . binding ; ClassFile classFile = new CodeSnippetClassFile ( typeBinding , null , true ) ; if ( typeBinding . isMemberType ( ) ) classFile . recordEnclosingTypeAttributes ( typeBinding ) ; FieldBinding [ ] fields = typeBinding . fields ; if ( ( fields != null ) && ( fields != ( NoFields ) ) ) { for ( int i = 0 , max = fields . length ; i < max ; i ++ ) { <START_BUG> if ( ( fields [ i ] . constant ) == null ) { <END_BUG> org . eclipse . jdt . internal . compiler . ast . FieldReference . getConstantFor ( fields [ i ] , null , false , null ) ; } } classFile . addFieldInfos ( ) ; } else { classFile . contents [ ( ( classFile . contentsOffset ) ++ ) ] = 0 ; classFile . contents [ ( ( classFile . contentsOffset ) ++ ) ] = 0 ; } classFile . setForMethodInfos ( ) ; MethodBinding [ ] methods = typeBinding . methods ; AbstractMethodDeclaration [ ] methodDeclarations = typeDeclaration . methods ; int maxMethodDecl = ( methodDeclarations == null ) ? 0 : methodDeclarations . length ; int problemsLength ; IProblem [ ] problems = unitResult . getErrors ( ) ; if ( problems == null ) { problems = new IProblem [ 0 ] ; } IProblem [ ] problemsCopy = new IProblem [ problemsLength = problems . length ] ; System . arraycopy ( problems , 0 , problemsCopy , 0 , problemsLength ) ; if ( methods != null ) { if ( typeBinding . isInterface ( ) ) { classFile . addProblemClinit ( problemsCopy ) ; for ( int i = 0 , max = methods . length ; i < max ; i ++ ) { MethodBinding methodBinding ; if ( ( methodBinding = methods [ i ] ) != null ) { for ( int j = 0 ; j < maxMethodDecl ; j ++ ) { if ( ( ( methodDeclarations [ j ] ) != null ) && ( ( methodDeclarations [ j ] . binding ) == ( methods [ i ] ) ) ) { if ( ! ( methodBinding . isConstructor ( ) ) ) { classFile . addAbstractMethod ( methodDeclarations [ j ] , methodBinding ) ; } break ; } } } } } else { for ( int i = 0 , max = methods . length ; i < max ; i ++ ) { MethodBinding methodBinding ; if ( ( methodBinding = methods [ i ] ) != null ) { for ( int j = 0 ; j < maxMethodDecl ; j ++ ) { if ( ( ( methodDeclarations [ j ] ) != null ) && ( ( methodDeclarations [ j ] . binding ) == ( methods [ i ] ) ) ) { AbstractMethodDeclaration methodDecl ; if ( ( methodDecl = methodDeclarations [ j ] ) . isConstructor ( ) ) { classFile . addProblemConstructor ( methodDecl , methodBinding , problemsCopy ) ; } else { classFile . addProblemMethod ( methodDecl , methodBinding , problemsCopy ) ; } break ; } } } } } classFile . addDefaultAbstractMethods ( ) ; } if ( ( typeDeclaration . memberTypes ) != null ) { for ( int i = 0 , max = typeDeclaration . memberTypes . length ; i < max ; i ++ ) { TypeDeclaration memberType = typeDeclaration . memberTypes [ i ] ; if ( ( memberType . binding ) != null ) { classFile . recordNestedMemberAttribute ( memberType . binding ) ; ClassFile . createProblemType ( memberType , unitResult ) ; } } } classFile . addAttributes ( ) ; unitResult . record ( typeBinding . constantPoolName ( ) , classFile ) ; } } 
public class CommandProvider extends QuickAccessProvider { private Map idToElement ; private IEvaluationContext contextSnapshot ; private HandlerService realHandlerService ; public CommandProvider ( ) { } public String getId ( ) { } public QuickAccessElement getElementForId ( String id ) { } public QuickAccessElement [ ] getElements ( ) { } public ImageDescriptor getImageDescriptor ( ) { } public String getName ( ) { } private void saveApplicationContext ( ) { realHandlerService = ( ( HandlerService ) ( PlatformUI . getWorkbench ( ) . getService ( IHandlerService . class ) ) ) ; <START_BUG> contextSnapshot = realHandlerService . getContextSnapshot ( ) ; <END_BUG> } HandlerService getRealHandlerService ( ) { } IEvaluationContext getContextSnapshot ( ) { } } 
public final class SelectionEngine extends Engine implements ISearchRequestor { public static boolean DEBUG = false ; public static boolean PERF = false ; SelectionParser parser ; ISelectionRequestor requestor ; boolean acceptedAnswer ; private int actualSelectionStart ; private int actualSelectionEnd ; private char [ ] selectedIdentifier ; private char [ ] [ ] [ ] acceptedClasses ; private int [ ] acceptedClassesModifiers ; private char [ ] [ ] [ ] acceptedInterfaces ; private int [ ] acceptedInterfacesModifiers ; private char [ ] [ ] [ ] acceptedEnums ; private int [ ] acceptedEnumsModifiers ; private char [ ] [ ] [ ] acceptedAnnotations ; private int [ ] acceptedAnnotationsModifiers ; int acceptedClassesCount ; int acceptedInterfacesCount ; int acceptedEnumsCount ; int acceptedAnnotationsCount ; boolean noProposal = true ; CategorizedProblem problem = null ; public SelectionEngine ( SearchableEnvironment nameEnvironment , ISelectionRequestor requestor , Map settings ) { } public void acceptType ( char [ ] packageName , char [ ] simpleTypeName , char [ ] [ ] enclosingTypeNames , int modifiers , AccessRestriction accessRestriction ) { } public void acceptPackage ( char [ ] packageName ) { } private void acceptQualifiedTypes ( ) { } private boolean checkSelection ( char [ ] source , int selectionStart , int selectionEnd ) { } private boolean checkTypeArgument ( Scanner scanner ) throws InvalidInputException { } public AssistParser getParser ( ) { } private boolean isLocal ( ReferenceBinding binding ) { } public void select ( ICompilationUnit sourceUnit , int selectionSourceStart , int selectionSourceEnd ) { } private void selectMemberTypeFromImport ( CompilationUnitDeclaration parsedUnit , char [ ] lastToken , ReferenceBinding ref , boolean staticOnly ) { } private void selectStaticFieldFromStaticImport ( CompilationUnitDeclaration parsedUnit , char [ ] lastToken , ReferenceBinding ref ) { } private void selectStaticMethodFromStaticImport ( CompilationUnitDeclaration parsedUnit , char [ ] lastToken , ReferenceBinding ref ) { } private void selectFrom ( Binding binding , CompilationUnitDeclaration parsedUnit , boolean isDeclaration ) { } private void selectLocalDeclaration ( ASTNode node ) { } public void selectType ( ISourceType sourceType , char [ ] typeName , SourceTypeElementInfo [ ] topLevelTypes , boolean searchInEnvironment ) { } private boolean selectDeclaration ( CompilationUnitDeclaration compilationUnit ) { char [ ] assistIdentifier = this . getParser ( ) . assistIdentifier ( ) ; if ( assistIdentifier == null ) return false ; ImportReference currentPackage = compilationUnit . currentPackage ; <START_BUG> char [ ] packageName = ( currentPackage == null ) ? new char [ 0 ] : CharOperation . concatWith ( currentPackage . tokens , '.' ) ; <END_BUG> TypeDeclaration [ ] types = compilationUnit . types ; for ( int i = 0 , length = ( types == null ) ? 0 : types . length ; i < length ; i ++ ) { if ( selectDeclaration ( types [ i ] , assistIdentifier , packageName ) ) return true ; } return false ; } private boolean selectDeclaration ( TypeDeclaration typeDeclaration , char [ ] assistIdentifier , char [ ] packageName ) { } } 
public final class AllTests { private static transient Logger log = LoggingManager . getLoggerForClass ( ) ; private AllTests ( ) { } private static void logprop ( String prop , boolean show ) { } private static void logprop ( String prop ) { } public static void main ( String [ ] args ) { if ( ( args . length ) < 1 ) { System . out . println ( ( "You<seq2seq4repair_space>must<seq2seq4repair_space>specify<seq2seq4repair_space>a<seq2seq4repair_space>comma-delimited<seq2seq4repair_space>list<seq2seq4repair_space>of<seq2seq4repair_space>paths<seq2seq4repair_space>to<seq2seq4repair_space>search<seq2seq4repair_space>" + "for<seq2seq4repair_space>unit<seq2seq4repair_space>tests" ) ) ; System . exit ( 0 ) ; } AllTests . initializeLogging ( args ) ; AllTests . initializeManager ( args ) ; AllTests . logprop ( "java.version" , true ) ; AllTests . logprop ( "java.vendor" ) ; AllTests . logprop ( "java.home" , true ) ; AllTests . logprop ( "user.home" ) ; <START_BUG> AllTests . logprop ( "user.dir" ) ; <END_BUG> AllTests . logprop ( "os.name" ) ; AllTests . logprop ( "os.version" ) ; AllTests . logprop ( "os.arch" ) ; AllTests . logprop ( "java.class.version" ) ; String cp = System . getProperty ( "java.class.path" ) ; String [ ] cpe = JOrphanUtils . split ( cp , File . pathSeparator ) ; StringBuffer sb = new StringBuffer ( 3000 ) ; sb . append ( "java.class.path=" ) ; for ( int i = 0 ; i < ( cpe . length ) ; i ++ ) { sb . append ( "\n" ) ; sb . append ( cpe [ i ] ) ; if ( new File ( cpe [ i ] ) . exists ( ) ) { sb . append ( "<seq2seq4repair_space>-<seq2seq4repair_space>OK" ) ; } else { sb . append ( "<seq2seq4repair_space>-<seq2seq4repair_space>??" ) ; } } AllTests . log . info ( sb . toString ( ) ) ; System . out . println ( "+++++++++++" ) ; AllTests . logprop ( "java.awt.headless" , true ) ; AllTests . logprop ( "java.awt.graphicsenv" , true ) ; System . out . println ( "------------" ) ; System . out . println ( "Creating<seq2seq4repair_space>test<seq2seq4repair_space>suite" ) ; TestSuite suite = AllTests . suite ( args [ 0 ] ) ; System . out . println ( "Starting<seq2seq4repair_space>test<seq2seq4repair_space>run" ) ; TestRunner . run ( suite ) ; System . out . println ( "+++++++++++" ) ; System . out . println ( "------------" ) ; System . exit ( 0 ) ; } protected static void initializeLogging ( String [ ] args ) { } protected static void initializeManager ( String [ ] args ) { } public static TestSuite suite ( ) { } private static TestSuite suite ( String searchPaths ) { } } 
public class AttachmentController implements KeyListener { AttachmentView view ; ComposerController controller ; AttachmentActionListener actionListener ; AttachmentMenu menu ; private JFileChooser fileChooser ; public AttachmentController ( ComposerController controller ) { } public ActionListener getActionListener ( ) { } public void installListener ( ) { } public void updateComponents ( boolean b ) { } public void add ( MimePart part ) { } public void removeSelected ( ) { } public void addFileAttachment ( ) { int returnValue ; File [ ] files ; <START_BUG> fileChooser . setDialogTitle ( MailResourceLoader . getString ( "menu" , "mainframe" , "composer_attach_file" ) ) ; <END_BUG> fileChooser . setFileSelectionMode ( JFileChooser . FILES_ONLY ) ; fileChooser . setMultiSelectionEnabled ( true ) ; returnValue = fileChooser . showOpenDialog ( view ) ; if ( returnValue == ( JFileChooser . APPROVE_OPTION ) ) { files = fileChooser . getSelectedFiles ( ) ; for ( int i = 0 ; i < ( files . length ) ; i ++ ) { File file = files [ i ] ; FileNameMap fileNameMap = URLConnection . getFileNameMap ( ) ; String mimetype = fileNameMap . getContentTypeFor ( file . getName ( ) ) ; if ( mimetype == null ) mimetype = "application/octet-stream" ; MimeHeader header = new MimeHeader ( mimetype . substring ( 0 , mimetype . indexOf ( '/' ) ) , mimetype . substring ( ( ( mimetype . indexOf ( '/' ) ) + 1 ) ) ) ; ComposerAttachment mimePart = new ComposerAttachment ( header , file ) ; view . add ( mimePart ) ; } } } public void keyPressed ( KeyEvent k ) { } public void keyReleased ( KeyEvent k ) { } public void keyTyped ( KeyEvent k ) { } class PopupListener extends MouseAdapter { public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } private void maybeShowPopup ( MouseEvent e ) { } } } 
public final class LocalizedResource implements PrivilegedAction { private static final boolean SUPPORTS_BIG_DECIMAL_CALLS ; private ResourceBundle res ; private Locale locale ; private String encode ; private static final String MESSAGE_FILE = "org.apache.derby.loc.toolsmessages" ; private static final String ENV_CODESET = "derby.ui.codeset" ; private static final String ENV_LOCALE = "derby.ui.locale" ; private String messageFileName ; private String resourceKey ; private LocalizedOutput out ; private LocalizedInput in ; private boolean enableLocalized ; private boolean unicodeEscape ; private static LocalizedResource local ; private int dateSize ; private int timeSize ; private int timestampSize ; private DateFormat formatDate ; private DateFormat formatTime ; private DateFormat formatTimestamp ; private NumberFormat formatNumber ; private DecimalFormat formatDecimal ; public LocalizedResource ( ) { } public LocalizedResource ( String encStr , String locStr , String msgF ) { } public static LocalizedResource getInstance ( ) { } public void init ( ) { } public void init ( String encStr , String locStr , String msgF ) { } private void setResource ( ) { if ( ( res ) != null ) { return ; } if ( ( ( locale ) == null ) || ( locale . toString ( ) . equals ( "none" ) ) ) { <START_BUG> res = ResourceBundle . getBundle ( LocalizedResource . MESSAGE_FILE ) ; <END_BUG> } else try { res = ResourceBundle . getBundle ( messageFileName , locale ) ; } catch ( MissingResourceException e ) { res = ResourceBundle . getBundle ( messageFileName , Locale . ENGLISH ) ; } } private void initMaxSizes2 ( ) { } public LocalizedInput getNewInput ( InputStream i ) { } public LocalizedInput getNewEncodedInput ( InputStream i , String encoding ) { } public LocalizedOutput getNewOutput ( OutputStream o ) { } public LocalizedOutput getNewEncodedOutput ( OutputStream o , String encoding ) throws UnsupportedEncodingException { } public String getTextMessage ( String key ) { } public String getTextMessage ( String key , Object o ) { } public String getTextMessage ( String key , Object o1 , Object o2 ) { } public String getTextMessage ( String key , Object o1 , Object o2 , Object o3 ) { } public String getTextMessage ( String key , Object o1 , Object o2 , Object o3 , Object o4 ) { } private Locale getNewLocale ( String locStr ) { } public String getTextMessage ( String key , Object [ ] objectArr ) { } public String getLocalizedString ( ResultSet rs , ResultSetMetaData rsm , int columnNumber ) throws SQLException { } public String getDateAsString ( Date d ) { } public String getTimeAsString ( Date t ) { } public String getNumberAsString ( int o ) { } public String getNumberAsString ( long o ) { } public String getNumberAsString ( Object o ) { } public String getNumberAsString ( double o ) { } public String getTimestampAsString ( Timestamp t ) { } public int getColumnDisplaySize ( ResultSetMetaData rsm , int columnNumber ) throws SQLException { } public String getStringFromDate ( String dateStr ) throws ParseException { } public String getStringFromTime ( String timeStr ) throws ParseException { } public String getStringFromValue ( String val ) throws ParseException { } public String getStringFromTimestamp ( String timestampStr ) throws ParseException { } public Locale getLocale ( ) { } private final synchronized String getEnvProperty ( String key ) { } public final Object run ( ) { } public static boolean enableLocalization ( boolean mode ) { } public boolean isLocalized ( ) { } public static String getMessage ( String key ) { } public static String getMessage ( String key , Object o1 ) { } public static String getMessage ( String key , Object o1 , Object o2 ) { } public static String getMessage ( String key , Object o1 , Object o2 , Object o3 ) { } public static String getMessage ( String key , Object o1 , Object o2 , Object o3 , Object o4 ) { } public static LocalizedOutput OutputWriter ( ) { } public static LocalizedInput InputReader ( ) { } public static String getNumber ( long o ) { } public static String getNumber ( int o ) { } public static void setUnicodeEscape ( boolean u ) { } public static boolean getUnicodeEscape ( ) { } public String toString ( ) { } } 
public abstract class Page extends MarkupContainer implements IRedirectListener { protected static final boolean ACCESS_ALLOWED = true ; protected static final boolean ACCESS_DENIED = false ; private static final Log log = LogFactory . getLog ( Page . class ) ; private int autoIndex ; private transient int changeCount ; private IFeedback feedback ; private FeedbackMessages feedbackMessages ; private int id = - 1 ; private transient Set renderedComponents ; private transient Session session = null ; private boolean trackChanges = false ; private IPageVersionManager versionManager ; protected Page ( ) { } protected Page ( final IModel model ) { } public int getAutoIndex ( ) { } public final int getCurrentVersionNumber ( ) { } public FeedbackMessages getFeedbackMessages ( ) { } public final int getId ( ) { } public final String getName ( ) { } public final Session getSession ( ) { } public Page getVersion ( final int versionNumber ) { } public PageState newPageState ( ) { } public final void onRedirect ( ) { <START_BUG> getRequestCycle ( ) . setPage ( this ) ; <END_BUG> } public final void removePersistedFormData ( final Class formClass , final boolean disablePersistence ) { } public void setFeedback ( final IFeedback feedback ) { } public String toString ( ) { } protected boolean checkAccess ( ) { } protected void configureResponse ( ) { } protected IModel initModel ( ) { } protected void internalOnModelChanged ( ) { } protected IPageVersionManager newVersionManager ( ) { } protected void onEndRequest ( ) { } protected final void onRender ( ) { } final void componentAdded ( final Component component ) { } final void componentModelChangeImpending ( final Component component ) { } final void componentRemoved ( final Component component ) { } final void componentRendered ( final Component component ) { } final void internalOnBeginRender ( ) { } final void internalOnEndRender ( ) { } final void internalOnEndRequest ( ) { } final void resetMarkupStreams ( ) { } final void setId ( final int id ) { } private final void checkRendering ( ) { } private void init ( ) { } private final void onChanged ( ) { } } 
public class TestUmlNamespace extends GenericObjectTestFixture { public TestUmlNamespace ( String arg0 ) { } public void testNamespace ( ) { <START_BUG> Object o = getFactory ( ) . create ( NAMESPACE ) ; <END_BUG> assertNotNull ( "Didn't<seq2seq4repair_space>create<seq2seq4repair_space>object" , o ) ; assertTrue ( "Should<seq2seq4repair_space>be<seq2seq4repair_space>a<seq2seq4repair_space>base" , ModelFacade . isABase ( o ) ) ; assertTrue ( "Should<seq2seq4repair_space>be<seq2seq4repair_space>a<seq2seq4repair_space>namespace" , ModelFacade . isANamespace ( o ) ) ; runTruthTests ( o ) ; } protected void initializeTruth ( ) { } } 
final class TermScorer extends Scorer { private Weight weight ; private DocsEnum docsEnum ; private byte [ ] norms ; private float weightValue ; private int doc = - 1 ; private int freq ; private int pointer ; private int pointerMax ; private static final int SCORE_CACHE_SIZE = 32 ; private float [ ] scoreCache = new float [ TermScorer . SCORE_CACHE_SIZE ] ; private int [ ] docs ; private int [ ] freqs ; private final BulkReadResult bulkResult ; TermScorer ( Weight weight , DocsEnum td , Similarity similarity , byte [ ] norms ) { } @ Override public void score ( Collector c ) throws IOException { } private final void refillBuffer ( ) throws IOException { } @ Override protected boolean score ( Collector c , int end , int firstDocID ) throws IOException { } @ Override public int docID ( ) { } @ Override public int nextDoc ( ) throws IOException { } @ Override public float score ( ) { } @ Override public int advance ( int target ) throws IOException { for ( ( pointer ) ++ ; ( pointer ) < ( pointerMax ) ; ( pointer ) ++ ) { if ( ( docs [ pointer ] ) >= target ) { freq = freqs [ pointer ] ; return doc = docs [ pointer ] ; } } int newDoc = docsEnum . advance ( target ) ; <START_BUG> if ( newDoc != ( DocsEnum . NO_MORE_DOCS ) ) { <END_BUG> doc = newDoc ; freq = docsEnum . freq ( ) ; } else { doc = NO_MORE_DOCS ; } return doc ; } @ Override public String toString ( ) { } } 
public final class LocalShowHistoryHandler implements OperationStepHandler { public static final OperationStepHandler INSTANCE = new LocalShowHistoryHandler ( ) ; @ Override public void execute ( final OperationContext context , final ModelNode operation ) throws OperationFailedException { context . acquireControllerLock ( ) ; final InstallationManager installationManager = ( ( InstallationManager ) ( context . getServiceRegistry ( false ) . getRequiredService ( NAME ) . getValue ( ) ) ) ; try { final PatchableTarget . TargetInfo info = installationManager . getIdentity ( ) . loadTargetInfo ( ) ; final InstalledImage installedImage = info . getDirectoryStructure ( ) . getInstalledImage ( ) ; final ModelNode result = new ModelNode ( ) ; result . setEmptyList ( ) ; final String releaseID = info . getCumulativePatchID ( ) ; if ( ! ( Constants . BASE . equals ( releaseID ) ) ) { fillHistory ( result , CUMULATIVE , releaseID , installedImage . getPatchHistoryDir ( releaseID ) ) ; } final List < String > oneOffPatchIDs = info . getPatchIDs ( ) ; for ( String oneOffPatchID : oneOffPatchIDs ) { File historyDir = installedImage . getPatchHistoryDir ( oneOffPatchID ) ; fillHistory ( result , ONE_OFF , oneOffPatchID , historyDir ) ; } context . getResult ( ) . set ( result ) ; context . stepCompleted ( ) ; } catch ( Throwable t ) { <START_BUG> t . printStackTrace ( ) ; <END_BUG> throw MESSAGES . failedToShowHistory ( t ) ; } } private void fillHistory ( ModelNode result , PatchType type , String oneOffPatchID , File historyDir ) throws Exception { } } 
public class TreeItem extends Item { Tree parent ; TreeItem parentItem ; TreeItem [ ] items ; int itemCount ; String [ ] strings ; Image [ ] images ; boolean checked ; boolean grayed ; boolean cached ; Color foreground ; Color background ; Color [ ] cellForeground ; Color [ ] cellBackground ; Font font ; Font [ ] cellFont ; int width = - 1 ; SWTTreeItem handle ; static final int IMAGETEXT_MARGIN = 2 ; public TreeItem ( Tree parent , int style ) { } public TreeItem ( Tree parent , int style , int index ) { } public TreeItem ( TreeItem parentItem , int style ) { } public TreeItem ( TreeItem parentItem , int style , int index ) { } TreeItem ( Tree parent , TreeItem parentItem , int style , int index , boolean create ) { } static TreeItem checkNull ( TreeItem item ) { } static Tree checkNull ( Tree parent ) { } static int checkIndex ( int index ) { } int calculateWidth ( int index , GC gc ) { } protected void checkSubclass ( ) { } void clear ( ) { } public void clear ( int index , boolean all ) { } public void clearAll ( boolean all ) { } void clearSelection ( ) { } NSObject createString ( int index ) { } void deregister ( ) { } void destroyWidget ( ) { } public Color getBackground ( ) { } public Color getBackground ( int index ) { } public Rectangle getBounds ( ) { } public Rectangle getBounds ( int index ) { } public boolean getChecked ( ) { } public boolean getExpanded ( ) { } public Font getFont ( ) { } public Font getFont ( int index ) { } public Color getForeground ( ) { } public Color getForeground ( int index ) { } public boolean getGrayed ( ) { } public Image getImage ( ) { } public Image getImage ( int index ) { } public Rectangle getImageBounds ( int index ) { } public TreeItem getItem ( int index ) { } public int getItemCount ( ) { } public TreeItem [ ] getItems ( ) { } String getNameText ( ) { } public Tree getParent ( ) { } public TreeItem getParentItem ( ) { } public String getText ( ) { } public String getText ( int index ) { } public Rectangle getTextBounds ( int index ) { } public int indexOf ( TreeItem item ) { } void redraw ( int columnIndex ) { <START_BUG> if ( ( parent . ignoreRedraw ) || ( ( parent . drawCount ) != 0 ) ) <END_BUG> return ; NSOutlineView outlineView = ( ( NSOutlineView ) ( parent . view ) ) ; NSRect rect ; if ( ( ( ( columnIndex == ( - 1 ) ) || ( parent . hooks ( MeasureItem ) ) ) || ( parent . hooks ( EraseItem ) ) ) || ( parent . hooks ( PaintItem ) ) ) { rect = outlineView . rectOfRow ( outlineView . rowForItem ( handle ) ) ; } else { int index ; if ( ( parent . columnCount ) == 0 ) { index = ( ( ( parent . style ) & ( SWT . CHECK ) ) != 0 ) ? 1 : 0 ; } else { TreeColumn column = parent . getColumn ( columnIndex ) ; index = ( ( int ) ( outlineView . columnWithIdentifier ( column . nsColumn ) ) ) ; } rect = outlineView . frameOfCellAtColumn ( index , outlineView . rowForItem ( handle ) ) ; } outlineView . setNeedsDisplayInRect ( rect ) ; } void register ( ) { } void release ( boolean destroy ) { } void releaseChildren ( boolean destroy ) { } void releaseHandle ( ) { } void releaseWidget ( ) { } public void removeAll ( ) { } public void setBackground ( Color color ) { } public void setBackground ( int index , Color color ) { } public void setChecked ( boolean checked ) { } public void setExpanded ( boolean expanded ) { } public void setFont ( Font font ) { } public void setFont ( int index , Font font ) { } public void setForeground ( Color color ) { } public void setForeground ( int index , Color color ) { } public void setGrayed ( boolean grayed ) { } public void setImage ( Image [ ] images ) { } public void setImage ( int index , Image image ) { } public void setImage ( Image image ) { } public void setItemCount ( int count ) { } public void setText ( String [ ] strings ) { } public void setText ( int index , String string ) { } public void setText ( String string ) { } } 
public final class RawMarkup extends MarkupElement { private final CharSequence string ; public RawMarkup ( final CharSequence string ) { } @ Override public boolean equals ( final Object o ) { <START_BUG> if ( o instanceof String ) { <END_BUG> return string . equals ( o ) ; } if ( o instanceof RawMarkup ) { return string . equals ( ( ( RawMarkup ) ( o ) ) . string ) ; } return false ; } @ Override public boolean equalTo ( final MarkupElement element ) { } @ Override public int hashCode ( ) { } @ Override public CharSequence toCharSequence ( ) { } @ Override public String toString ( ) { } @ Override public String toUserDebugString ( ) { } } 
public class PersistenceContextInjectionSource extends InjectionSource { private final PersistenceContextType type ; private final PersistenceContextInjectionSource . PersistenceContextJndiInjectable injectable ; private final ServiceName puServiceName ; public PersistenceContextInjectionSource ( final PersistenceContextType type , final SynchronizationType synchronizationType , final Map properties , final ServiceName puServiceName , final ServiceRegistry serviceRegistry , final String scopedPuName , final String injectionTypeName , final PersistenceUnitMetadata pu , final JPADeploymentSettings jpaDeploymentSettings ) { } public void getResourceValue ( final ResolutionContext resolutionContext , final ServiceBuilder < ? > serviceBuilder , final DeploymentPhaseContext phaseContext , final Injector < ManagedReferenceFactory > injector ) throws DeploymentUnitProcessingException { } public boolean equals ( Object other ) { } public int hashCode ( ) { } private static final class PersistenceContextJndiInjectable implements ManagedReferenceFactory { private final ServiceName puServiceName ; private final ServiceRegistry serviceRegistry ; private final PersistenceContextType type ; private final SynchronizationType synchronizationType ; private final Map properties ; private final String unitName ; private final String injectionTypeName ; private final PersistenceUnitMetadata pu ; private final JPADeploymentSettings jpaDeploymentSettings ; private static final String ENTITY_MANAGER_CLASS = "javax.persistence.EntityManager" ; public PersistenceContextJndiInjectable ( final ServiceName puServiceName , final ServiceRegistry serviceRegistry , final PersistenceContextType type , SynchronizationType synchronizationType , final Map properties , final String unitName , final String injectionTypeName , final PersistenceUnitMetadata pu , final JPADeploymentSettings jpaDeploymentSettings ) { } @ Override public ManagedReference getReference ( ) { PersistenceUnitServiceImpl service = ( ( PersistenceUnitServiceImpl ) ( serviceRegistry . getRequiredService ( puServiceName ) . getValue ( ) ) ) ; EntityManagerFactory emf = service . getEntityManagerFactory ( ) ; EntityManager entityManager ; boolean standardEntityManager = PersistenceContextInjectionSource . PersistenceContextJndiInjectable . ENTITY_MANAGER_CLASS . equals ( injectionTypeName ) ; if ( type . equals ( TRANSACTION ) ) { entityManager = new org . jboss . as . jpa . container . TransactionScopedEntityManager ( unitName , properties , emf , synchronizationType ) ; if ( JPA_LOGGER . isDebugEnabled ( ) ) JPA_LOGGER . debugf ( "created<seq2seq4repair_space>new<seq2seq4repair_space>TransactionScopedEntityManager<seq2seq4repair_space>for<seq2seq4repair_space>unit<seq2seq4repair_space>name=%s" , unitName ) ; } else { boolean useDeepInheritance = ! ( SHALLOW . equals ( JPAService . getDefaultExtendedPersistenceInheritance ( ) ) ) ; if ( ( jpaDeploymentSettings ) != null ) { useDeepInheritance = DEEP . equals ( jpaDeploymentSettings . getExtendedPersistenceInheritanceType ( ) ) ; } boolean createdNewExtendedPersistence = false ; ExtendedEntityManager entityManager1 ; if ( useDeepInheritance ) { entityManager1 = INSTANCE . findExtendedPersistenceContext ( unitName ) ; } else { entityManager1 = ExtendedPersistenceShallowInheritance . INSTANCE . findExtendedPersistenceContext ( unitName ) ; } if ( entityManager1 == null ) { <START_BUG> entityManager1 = new ExtendedEntityManager ( unitName , emf . createEntityManager ( properties ) , synchronizationType ) ; <END_BUG> createdNewExtendedPersistence = true ; if ( JPA_LOGGER . isDebugEnabled ( ) ) JPA_LOGGER . debugf ( "created<seq2seq4repair_space>new<seq2seq4repair_space>ExtendedEntityManager<seq2seq4repair_space>for<seq2seq4repair_space>unit<seq2seq4repair_space>name=%s,<seq2seq4repair_space>useDeepInheritance<seq2seq4repair_space>=<seq2seq4repair_space>%b" , unitName , useDeepInheritance ) ; } else { entityManager1 . increaseReferenceCount ( ) ; if ( JPA_LOGGER . isDebugEnabled ( ) ) JPA_LOGGER . debugf ( ( "inherited<seq2seq4repair_space>existing<seq2seq4repair_space>ExtendedEntityManager<seq2seq4repair_space>from<seq2seq4repair_space>SFSB<seq2seq4repair_space>invocation<seq2seq4repair_space>stack,<seq2seq4repair_space>unit<seq2seq4repair_space>name=%s,<seq2seq4repair_space>" + "%d<seq2seq4repair_space>beans<seq2seq4repair_space>sharing<seq2seq4repair_space>ExtendedEntityManager,<seq2seq4repair_space>useDeepInheritance<seq2seq4repair_space>=<seq2seq4repair_space>%b" ) , unitName , entityManager1 . getReferenceCount ( ) , useDeepInheritance ) ; } entityManager = entityManager1 ; CreatedEntityManagers . registerPersistenceContext ( entityManager1 ) ; if ( createdNewExtendedPersistence ) { if ( useDeepInheritance ) { INSTANCE . registerExtendedPersistenceContext ( unitName , entityManager1 ) ; } else { ExtendedPersistenceShallowInheritance . INSTANCE . registerExtendedPersistenceContext ( unitName , entityManager1 ) ; } } } if ( ! standardEntityManager ) { Class extensionClass ; try { extensionClass = pu . getClassLoader ( ) . loadClass ( injectionTypeName ) ; } catch ( ClassNotFoundException e ) { throw MESSAGES . cannotLoadFromJpa ( e , injectionTypeName ) ; } Object targetValueToInject = entityManager . unwrap ( extensionClass ) ; Class [ ] targetInterfaces = targetValueToInject . getClass ( ) . getInterfaces ( ) ; Class [ ] proxyInterfaces = new Class [ ( targetInterfaces . length ) + 1 ] ; boolean alreadyHasInterfaceClass = false ; for ( int interfaceIndex = 0 ; interfaceIndex < ( targetInterfaces . length ) ; interfaceIndex ++ ) { Class interfaceClass = targetInterfaces [ interfaceIndex ] ; if ( interfaceClass . equals ( extensionClass ) ) { proxyInterfaces = targetInterfaces ; alreadyHasInterfaceClass = true ; break ; } proxyInterfaces [ ( 1 + interfaceIndex ) ] = interfaceClass ; } if ( ! alreadyHasInterfaceClass ) { proxyInterfaces [ 0 ] = extensionClass ; } EntityManagerUnwrappedTargetInvocationHandler entityManagerUnwrappedTargetInvocationHandler = new EntityManagerUnwrappedTargetInvocationHandler ( entityManager , extensionClass ) ; Object proxyForUnwrappedObject = Proxy . newProxyInstance ( extensionClass . getClassLoader ( ) , proxyInterfaces , entityManagerUnwrappedTargetInvocationHandler ) ; if ( JPA_LOGGER . isDebugEnabled ( ) ) JPA_LOGGER . debugf ( "injecting<seq2seq4repair_space>entity<seq2seq4repair_space>manager<seq2seq4repair_space>into<seq2seq4repair_space>a<seq2seq4repair_space>'%s'<seq2seq4repair_space>(unit<seq2seq4repair_space>name=%s)" , extensionClass . getName ( ) , unitName ) ; return new ValueManagedReference ( new org . jboss . msc . value . ImmediateValue < Object > ( proxyForUnwrappedObject ) ) ; } return new ValueManagedReference ( new org . jboss . msc . value . ImmediateValue < Object > ( entityManager ) ) ; } } } 
public class TestPlanGui extends AbstractJMeterGuiComponent { private JCheckBox functionalMode ; private JCheckBox serializedMode ; private ArgumentsPanel argsPanel ; public TestPlanGui ( ) { } public JPopupMenu createPopupMenu ( ) { } public TestElement createTestElement ( ) { } public void modifyTestElement ( TestElement plan ) { } public String getStaticLabel ( ) { <START_BUG> return JMeterUtils . getResString ( "Test<seq2seq4repair_space>Plan" ) ; <END_BUG> } public Collection getMenuCategories ( ) { } public void configure ( TestElement el ) { } private JPanel createVariablePanel ( ) { } private void init ( ) { } } 
public class PackageMapper extends AbstractBookmarkableMapper { private final String mountPath ; private final PackageName packageName ; private final IPageParametersEncoder pageParametersEncoder ; public PackageMapper ( final String mountPath , final PackageName packageName ) { } public PackageMapper ( final String mountPath , final PackageName packageName , final IPageParametersEncoder pageParametersEncoder ) { } @ Override protected Url buildUrl ( UrlInfo info ) { Class < ? extends IRequestablePage > pageClass = info . getPageClass ( ) ; <START_BUG> if ( pageClass . getName ( ) . startsWith ( packageName . getName ( ) ) ) { <END_BUG> Url url = new Url ( ) ; url . getSegments ( ) . add ( mountPath ) ; url . getSegments ( ) . add ( pageClass . getSimpleName ( ) ) ; encodePageComponentInfo ( url , info . getPageComponentInfo ( ) ) ; return encodePageParameters ( url , info . getPageParameters ( ) , pageParametersEncoder ) ; } return null ; } @ Override protected UrlInfo parseRequest ( Request request ) { } @ Override protected boolean pageMustHaveBeenCreatedBookmarkable ( ) { } @ Override public int getCompatibilityScore ( Request request ) { } } 
@ RunWith ( Arquillian . class ) public class ResourceRefTestCase { private static final Logger log = Logger . getLogger ( ResourceRefTestCase . class ) ; @ Deployment public static Archive < ? > deployment ( ) { } @ Test public void testCorrectBinding ( ) throws NamingException { } @ Test public void testInjection ( ) throws NamingException { } @ Test public void testResourceRefEntriesWithoutResType ( ) throws Exception { } @ Test public void testResourceEnvRefWithoutInjectionTarget ( ) throws Exception { } @ Test public void test2 ( ) throws Exception { ResUrlChecker bean = ( ( ResUrlChecker ) ( new InitialContext ( ) . lookup ( "java:app/resource-ref-test/ResUrlCheckerBean" ) ) ) ; <START_BUG> URL expected = new URL ( "http://localhost/url2" ) ; <END_BUG> URL actual = bean . getURL2 ( ) ; Assert . assertEquals ( expected , actual ) ; } } 
public class Gcj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { } protected Commandline setupGCJCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = new Path ( project ) ; if ( ( bootclasspath ) != null ) { classpath . append ( bootclasspath ) ; } <START_BUG> addExtdirsToClasspath ( classpath ) ; <END_BUG> if ( ( ( bootclasspath ) == null ) || ( ( bootclasspath . size ( ) ) == 0 ) ) { includeJavaRuntime = true ; } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; cmd . setExecutable ( "gcj" ) ; if ( ( destDir ) != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; if ( destDir . mkdirs ( ) ) { throw new BuildException ( "Can't<seq2seq4repair_space>make<seq2seq4repair_space>output<seq2seq4repair_space>directories.<seq2seq4repair_space>Maybe<seq2seq4repair_space>permission<seq2seq4repair_space>is<seq2seq4repair_space>wrong.<seq2seq4repair_space>" ) ; } } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( ( encoding ) != null ) { cmd . createArgument ( ) . setValue ( ( "--encoding=" + ( encoding ) ) ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g1" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } cmd . createArgument ( ) . setValue ( "-C" ) ; addCurrentCompilerArgs ( cmd ) ; return cmd ; } } 
public class PerformanceTest { private final int max = 10 ; private static final File BIG_FILE = new File ( System . getProperty ( "java.io.tmpdir" ) , "worldcitiespop.txt" ) ; @ BeforeClass public static void setUpClass ( ) throws FileNotFoundException , IOException { } private BufferedReader getBufferedReader ( ) throws IOException { } private long parse ( final Reader in , boolean traverseColumns ) throws IOException { <START_BUG> final CSVFormat format = CSVFormat . defaults ( ) . withIgnoreSurroundingSpaces ( false ) . build ( ) ; <END_BUG> long recordCount = 0 ; for ( final CSVRecord record : format . parse ( in ) ) { recordCount ++ ; if ( traverseColumns ) { for ( String value : record ) { } } } return recordCount ; } private void println ( final String s ) { } private long readAll ( final BufferedReader in ) throws IOException { } public long testParseBigFile ( boolean traverseColumns ) throws Exception { } @ Test public void testParseBigFileRepeat ( ) throws Exception { } @ Test public void testReadBigFile ( ) throws Exception { } } 
public class EqualExpression extends BinaryExpression { public EqualExpression ( Expression left , Expression right , int operator ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public final boolean areTypesCastCompatible ( BlockScope scope , TypeBinding castType , TypeBinding expressionType ) { } public final void computeConstant ( TypeBinding leftType , TypeBinding rightType ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateOptimizedBoolean ( BlockScope currentScope , CodeStream codeStream , Label trueLabel , Label falseLabel , boolean valueRequired ) { } public void generateOptimizedBooleanEqual ( BlockScope currentScope , CodeStream codeStream , Label trueLabel , Label falseLabel , boolean valueRequired ) { } public void generateOptimizedNonBooleanEqual ( BlockScope currentScope , CodeStream codeStream , Label trueLabel , Label falseLabel , boolean valueRequired ) { } public boolean isCompactableOperation ( ) { } public TypeBinding resolveType ( BlockScope scope ) { boolean argsContainCast = false ; if ( ( left ) instanceof CastExpression ) { left . bits |= IgnoreNeedForCastCheckMASK ; argsContainCast = true ; } TypeBinding leftType = left . resolveType ( scope ) ; if ( ( right ) instanceof CastExpression ) { right . bits |= IgnoreNeedForCastCheckMASK ; argsContainCast = true ; } TypeBinding rightType = right . resolveType ( scope ) ; if ( ( leftType == null ) || ( rightType == null ) ) { constant = NotAConstant ; return null ; } if ( ( leftType . isBaseType ( ) ) && ( rightType . isBaseType ( ) ) ) { <START_BUG> int operatorSignature = ResolveTypeTables [ OperatorIds . EQUAL_EQUAL ] [ ( ( ( leftType . id ) << 4 ) + ( rightType . id ) ) ] ; <END_BUG> left . implicitConversion = operatorSignature > > > 12 ; right . implicitConversion = ( operatorSignature > > > 4 ) & 255 ; bits |= operatorSignature & 15 ; if ( ( operatorSignature & 15 ) == ( TypeIds . T_undefined ) ) { constant = Constant . NotAConstant ; scope . problemReporter ( ) . invalidOperator ( this , leftType , rightType ) ; return null ; } if ( argsContainCast ) { CastExpression . checkNeedForArgumentCasts ( scope , OperatorIds . EQUAL_EQUAL , operatorSignature , left , leftType . id , right , rightType . id ) ; } computeConstant ( leftType , rightType ) ; return this . resolvedType = BooleanBinding ; } if ( ( areTypesCastCompatible ( scope , rightType , leftType ) ) || ( areTypesCastCompatible ( scope , leftType , rightType ) ) ) { if ( ( ( rightType . id ) == ( T_String ) ) && ( ( leftType . id ) == ( T_String ) ) ) { computeConstant ( leftType , rightType ) ; } else { constant = NotAConstant ; } if ( ( rightType . id ) == ( T_String ) ) { right . implicitConversion = TypeIds . String2String ; } if ( ( leftType . id ) == ( T_String ) ) { left . implicitConversion = TypeIds . String2String ; } boolean unnecessaryLeftCast = ( ( left . bits ) & ( UnnecessaryCastMask ) ) != 0 ; boolean unnecessaryRightCast = ( ( right . bits ) & ( UnnecessaryCastMask ) ) != 0 ; if ( unnecessaryLeftCast || unnecessaryRightCast ) { TypeBinding alternateLeftType = ( unnecessaryLeftCast ) ? ( ( CastExpression ) ( left ) ) . expression . resolvedType : leftType ; TypeBinding alternateRightType = ( unnecessaryRightCast ) ? ( ( CastExpression ) ( right ) ) . expression . resolvedType : rightType ; if ( ( areTypesCastCompatible ( scope , alternateLeftType , alternateRightType ) ) || ( areTypesCastCompatible ( scope , alternateRightType , alternateLeftType ) ) ) { if ( unnecessaryLeftCast ) scope . problemReporter ( ) . unnecessaryCast ( ( ( CastExpression ) ( left ) ) ) ; if ( unnecessaryRightCast ) scope . problemReporter ( ) . unnecessaryCast ( ( ( CastExpression ) ( right ) ) ) ; } } return this . resolvedType = BooleanBinding ; } constant = NotAConstant ; scope . problemReporter ( ) . notCompatibleTypesError ( this , leftType , rightType ) ; return null ; } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } } 
class DefaultFailureDetailView implements FailureDetailView { JTextArea fTextArea ; public Component getComponent ( ) { } public void showFailure ( TestFailure failure ) { <START_BUG> fTextArea . setText ( BaseTestRunner . getFilteredTrace ( failure . thrownException ( ) ) ) ; <END_BUG> fTextArea . select ( 0 , 0 ) ; } public void clear ( ) { } } 
public class DatabaseTimerPersistence implements TimerPersistence , Service < DatabaseTimerPersistence > { private final InjectedValue < ManagedReferenceFactory > dataSourceInjectedValue = new InjectedValue < ManagedReferenceFactory > ( ) ; private final InjectedValue < ModuleLoader > moduleLoader = new InjectedValue < ModuleLoader > ( ) ; private final String name ; private final String database ; private final String partition ; private volatile ManagedReference managedReference ; private volatile DataSource dataSource ; private volatile Properties sql ; private MarshallerFactory factory ; private MarshallingConfiguration configuration ; private static final String CREATE_TABLE = "create-table" ; private static final String CREATE_TIMER = "create-timer" ; private static final String UPDATE_TIMER = "update-timer" ; private static final String LOAD_ALL_TIMERS = "load-all-timers" ; private static final String LOAD_TIMER = "load-timer" ; private static final String DELETE_TIMER = "delete-timer" ; public DatabaseTimerPersistence ( final String name , final String database , String partition ) { } @ Override public void start ( final StartContext context ) throws StartException { } @ Override public void stop ( final StopContext context ) { } void runCreateTable ( ) { } private String sql ( final String key ) { } @ Override public void addTimer ( final TimerImpl timerEntity ) { } @ Override public void persistTimer ( final TimerImpl timerEntity ) { } @ Override public void timerUndeployed ( final String timedObjectId ) { } @ Override public List < TimerImpl > loadActiveTimers ( final String timedObjectId , final TimerServiceImpl timerService ) { } @ Override public DatabaseTimerPersistence getValue ( ) throws IllegalArgumentException , IllegalStateException { } private TimerImpl timerFromResult ( final ResultSet resultSet , final TimerServiceImpl timerService ) throws SQLException { boolean calendarTimer = resultSet . getBoolean ( 24 ) ; TimerImpl . Builder builder = null ; if ( calendarTimer ) { CalendarTimer . Builder cb = CalendarTimer . builder ( ) ; builder = cb ; cb . setScheduleExprSecond ( resultSet . getString ( 10 ) ) ; cb . setScheduleExprMinute ( resultSet . getString ( 11 ) ) ; cb . setScheduleExprHour ( resultSet . getString ( 12 ) ) ; cb . setScheduleExprDayOfWeek ( resultSet . getString ( 13 ) ) ; cb . setScheduleExprDayOfMonth ( resultSet . getString ( 14 ) ) ; cb . setScheduleExprMonth ( resultSet . getString ( 15 ) ) ; cb . setScheduleExprYear ( resultSet . getString ( 16 ) ) ; cb . setScheduleExprStartDate ( resultSet . getTimestamp ( 17 ) ) ; cb . setScheduleExprEndDate ( resultSet . getTimestamp ( 18 ) ) ; cb . setScheduleExprTimezone ( resultSet . getString ( 19 ) ) ; cb . setAutoTimer ( resultSet . getBoolean ( 20 ) ) ; final String clazz = resultSet . getString ( 21 ) ; final String methodName = resultSet . getString ( 22 ) ; if ( methodName != null ) { final String paramString = resultSet . getString ( 23 ) ; final String [ ] params = ( ( paramString == null ) || ( paramString . isEmpty ( ) ) ) ? new String [ 0 ] : paramString . split ( ";" ) ; <START_BUG> final Method timeoutMethod = CalendarTimer . getTimeoutMethod ( new TimeoutMethod ( clazz , methodName , params ) , timerService . getTimedObjectInvoker ( ) . getValue ( ) . getClassLoader ( ) ) ; <END_BUG> if ( timeoutMethod == null ) { ROOT_LOGGER . timerReinstatementFailed ( resultSet . getString ( 2 ) , resultSet . getString ( 1 ) , new NoSuchMethodException ( ) ) ; } cb . setTimeoutMethod ( timeoutMethod ) ; } } else { builder = TimerImpl . builder ( ) ; } builder . setId ( resultSet . getString ( 1 ) ) ; builder . setTimedObjectId ( resultSet . getString ( 2 ) ) ; builder . setInitialDate ( resultSet . getTimestamp ( 3 ) ) ; builder . setRepeatInterval ( resultSet . getLong ( 4 ) ) ; builder . setNextDate ( resultSet . getTimestamp ( 5 ) ) ; builder . setPreviousRun ( resultSet . getTimestamp ( 6 ) ) ; builder . setPrimaryKey ( deSerialize ( resultSet . getString ( 7 ) ) ) ; builder . setInfo ( ( ( Serializable ) ( deSerialize ( resultSet . getString ( 8 ) ) ) ) ) ; builder . setTimerState ( TimerState . valueOf ( resultSet . getString ( 9 ) ) ) ; builder . setPersistent ( true ) ; return builder . build ( timerService ) ; } private void statementParameters ( final TimerImpl timerEntity , final PreparedStatement statement ) throws SQLException { } private String serialize ( final Serializable serializable ) { } public Object deSerialize ( final String data ) throws SQLException { } private Timestamp timestamp ( final Date date ) { } public InjectedValue < ManagedReferenceFactory > getDataSourceInjectedValue ( ) { } public InjectedValue < ModuleLoader > getModuleLoader ( ) { } private static void safeClose ( final Closeable resource ) { } private static void safeClose ( final Statement resource ) { } private static void safeClose ( final Connection resource ) { } private static void safeClose ( final ResultSet resource ) { } } 
public class JaxrsSpringProcessor implements DeploymentUnitProcessor { private static final String VERSION_KEY = "resteasy.version" ; private static final String SPRING_INT_JAR_BASE = "resteasy-spring" ; private static final String JAR_LOCATION = "resteasy-spring-jar" ; private static final ModuleIdentifier MODULE = ModuleIdentifier . create ( "org.jboss.resteasy.resteasy-spring" ) ; public static final String SPRING_LISTENER = "org.jboss.resteasy.plugins.spring.SpringContextLoaderListener" ; public static final String SPRING_SERVLET = "org.springframework.web.servlet.DispatcherServlet" ; @ Deprecated public static final String DISABLE_PROPERTY = "org.jboss.as.jaxrs.disableSpringIntegration" ; public static final String ENABLE_PROPERTY = "org.jboss.as.jaxrs.enableSpringIntegration" ; public static final String SERVICE_NAME = "resteasy-spring-integration-resource-root" ; private final ServiceTarget serviceTarget ; private VirtualFile resourceRoot ; public JaxrsSpringProcessor ( ServiceTarget serviceTarget ) { } protected synchronized VirtualFile getResteasySpringVirtualFile ( ) throws DeploymentUnitProcessingException { try { Module module = Module . getBootModuleLoader ( ) . loadModule ( JaxrsSpringProcessor . MODULE ) ; URL fileUrl = module . getClassLoader ( ) . getResource ( JaxrsSpringProcessor . JAR_LOCATION ) ; if ( fileUrl == null ) { throw JAXRS_LOGGER . noSpringIntegrationJar ( ) ; } <START_BUG> File dir = new File ( fileUrl . getFile ( ) ) ; <END_BUG> File file = null ; for ( String jar : dir . list ( ) ) { if ( jar . endsWith ( ".jar" ) ) { file = new File ( dir , jar ) ; break ; } } if ( file == null ) { throw JAXRS_LOGGER . noSpringIntegrationJar ( ) ; } VirtualFile vf = VFS . getChild ( file . toURI ( ) ) ; final Closeable mountHandle = VFS . mountZip ( file , vf , TempFileProviderService . provider ( ) ) ; Service < Closeable > mountHandleService = new Service < Closeable > ( ) { public void start ( StartContext startContext ) throws StartException { } public void stop ( StopContext stopContext ) { VFSUtils . safeClose ( mountHandle ) ; } public Closeable getValue ( ) throws IllegalArgumentException , IllegalStateException { return mountHandle ; } } ; ServiceBuilder < Closeable > builder = serviceTarget . addService ( JBOSS . append ( JaxrsSpringProcessor . SERVICE_NAME ) , mountHandleService ) ; builder . setInitialMode ( ACTIVE ) . install ( ) ; resourceRoot = vf ; return resourceRoot ; } catch ( Exception e ) { throw new DeploymentUnitProcessingException ( e ) ; } } public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { } public void undeploy ( DeploymentUnit context ) { } } 
public abstract class FormComponent < T > extends WebMarkupContainer < T > implements IFormProcessingListener { private static final long serialVersionUID = 1L ; private static final String [ ] EMPTY_STRING_ARRAY = new String [ ] { "" } ; public static final String VALUE_SEPARATOR = ";" ; public static interface IVisitor { public Object formComponent ( IFormProcessingListener formComponent ) { } } public abstract static class AbstractVisitor implements FormComponent . IVisitor { public Object formComponent ( IFormProcessingListener component ) { } protected abstract void onFormComponent ( FormComponent formComponent ) { } } private final class RequiredStateChange extends Change { private static final long serialVersionUID = 1L ; private final boolean required = isRequired ( ) ; @ Override public void undo ( ) { } } private Class type ; protected static final short FLAG_CONVERT_EMPTY_INPUT_STRING_TO_NULL = FLAG_RESERVED1 ; private static final short FLAG_PERSISTENT = FLAG_RESERVED2 ; private static final short FLAG_REQUIRED = FLAG_RESERVED3 ; private static final String NO_RAW_INPUT = "[-NO-RAW-INPUT-]" ; private String rawInput = FormComponent . NO_RAW_INPUT ; private Object validators = null ; private IModel labelModel = null ; private transient T convertedInput ; public FormComponent ( MarkupContainer parent , final String id ) { } public FormComponent ( MarkupContainer parent , final String id , IModel < T > model ) { } public final FormComponent add ( final IValidator validator ) { } public Form getForm ( ) { } @ SuppressWarnings ( "unchecked" ) public FormComponent setLabel ( final IModel labelModel ) { } public IModel getLabel ( ) { } public final String getInput ( ) { } public String [ ] getInputAsArray ( ) { } public String getInputName ( ) { String id = FormComponent . getId ( ) ; final PrependingStringBuffer inputName = new PrependingStringBuffer ( id . length ( ) ) ; Component c = this ; while ( true ) { inputName . prepend ( id ) ; c = c . getParent ( ) ; <START_BUG> if ( ( ( c == null ) || ( c instanceof Form ) ) || ( c instanceof Page ) ) { <END_BUG> break ; } inputName . prepend ( PATH_SEPARATOR ) ; id = c . getId ( ) ; } return inputName . toString ( ) ; } public final List < IValidator > getValidators ( ) { } public final String getValue ( ) { } public final String getRawInput ( ) { } public final boolean hasRawInput ( ) { } public final void invalid ( ) { } public boolean isMultiPart ( ) { } public final boolean isPersistent ( ) { } public final boolean isValid ( ) { } public final boolean isValidated ( ) { } public boolean isInputNullable ( ) { } public void setModelValue ( final String value ) { } public void setModelValue ( final String [ ] value ) { } public final FormComponent setPersistent ( final boolean persistent ) { } public void updateModel ( ) { } public final void valid ( ) { } public final void clearInput ( ) { } public final boolean checkRequired ( ) { } protected final void validateRequired ( ) { } @ SuppressWarnings ( "unchecked" ) protected final void convert ( ) { } @ SuppressWarnings ( "unchecked" ) protected T convertValue ( String [ ] value ) throws ConversionException { } public final void validate ( ) { } @ SuppressWarnings ( "unchecked" ) protected final void validateValidators ( ) { } protected String getModelValue ( ) { } protected final int inputAsInt ( ) { } protected final int inputAsInt ( final int defaultValue ) { } protected final int [ ] inputAsIntArray ( ) { } @ Override protected void onComponentTag ( final ComponentTag tag ) { } protected void onInvalid ( ) { } @ Override protected void internalOnModelChanged ( ) { } protected void onValid ( ) { } protected boolean supportsPersistence ( ) { } private void validators_add ( final IValidator validator ) { } private IValidator validators_get ( int index ) { } private int validators_size ( ) { } public final void inputChanged ( ) { } public final FormComponent setRequired ( final boolean required ) { } public boolean isRequired ( ) { } public final T getConvertedInput ( ) { } @ Override protected void onDetach ( ) { } public final Class getType ( ) { } public final FormComponent setType ( Class type ) { } public String getValidatorKeyPrefix ( ) { } public void error ( IValidationError error ) { } public final void processInput ( ) { } private class ValidatableAdapter implements IValidatable < T > { public void error ( IValidationError error ) { } public T getValue ( ) { } } private class MessageSource implements IMessageSource { public String getMessage ( String key ) { } private Map < String , Object > addDefaultVars ( Map < String , Object > params ) { } private Object getLabel ( ) { } public String substitute ( String string , Map < String , Object > vars ) throws IllegalStateException { } } public boolean processChildren ( ) { } } 
class AddCompilationUnitToIndex extends IndexRequest { IFile resource ; IndexManager manager ; IPath indexedContainer ; char [ ] contents ; public AddCompilationUnitToIndex ( IFile resource , IndexManager manager , IPath indexedContainer ) { } public boolean belongsTo ( String jobFamily ) { } public boolean execute ( IProgressMonitor progressMonitor ) { if ( ( progressMonitor != null ) && ( progressMonitor . isCanceled ( ) ) ) return IJob . COMPLETE ; try { <START_BUG> IIndex index = manager . getIndex ( this . indexedContainer ) ; <END_BUG> if ( index == null ) return IJob . COMPLETE ; ReadWriteMonitor monitor = manager . getMonitorFor ( index ) ; if ( monitor == null ) return IJob . COMPLETE ; try { monitor . enterWrite ( ) ; char [ ] contents = this . getContents ( ) ; if ( contents == null ) return IJob . FAILED ; index . add ( new IFileDocument ( resource , contents ) , new SourceIndexer ( ) ) ; } finally { monitor . exitWrite ( ) ; } } catch ( IOException e ) { if ( JobManager . VERBOSE ) { JobManager . verbose ( ( ( "-><seq2seq4repair_space>failed<seq2seq4repair_space>to<seq2seq4repair_space>index<seq2seq4repair_space>" + ( this . resource ) ) + "<seq2seq4repair_space>because<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>following<seq2seq4repair_space>exception:" ) ) ; e . printStackTrace ( ) ; } return IJob . FAILED ; } return IJob . COMPLETE ; } private char [ ] getContents ( ) { } public void initializeContents ( ) { } public String toString ( ) { } } 
public class CreateVFolderOnMessageCommand extends FolderCommand { private static final Logger LOG = Logger . getLogger ( "org.columba.mail.folder.command" ) ; public static final String VFOLDER_ON_SUBJECT = "Subject" ; public static final String VFOLDER_ON_FROM = "From" ; public static final String VFOLDER_ON_TO = "To" ; private String vfolderType ; private MessageFolder parentFolder = null ; private VirtualFolder vfolder = null ; public CreateVFolderOnMessageCommand ( FrameMediator frameController , DefaultCommandReference [ ] references , String vfolderType ) { } public void updateGUI ( ) throws Exception { treeModel . nodeStructureChanged ( parentFolder ) ; if ( ( vfolder ) != null ) { <START_BUG> new org . columba . mail . gui . config . filter . ConfigFrame ( getFrameMediator ( ) . getView ( ) . getFrame ( ) , vfolder ) ; <END_BUG> } } public void execute ( WorkerStatusController worker ) throws Exception { } public VirtualFolder createVirtualFolder ( String folderName , String headerField , String pattern , MessageFolder parent ) { } } 
public final class StatisticalSummaryValuesTest extends TestCase { public StatisticalSummaryValuesTest ( String name ) { } public void setUp ( ) { } public static Test suite ( ) { } public void testSerialization ( ) { } public void testEqualsAndHashCode ( ) { StatisticalSummaryValues u = new StatisticalSummaryValues ( 1 , 2 , 3 , 4 , 5 , 6 ) ; StatisticalSummaryValues t = null ; assertTrue ( "reflexive" , u . equals ( u ) ) ; assertFalse ( "non-null<seq2seq4repair_space>compared<seq2seq4repair_space>to<seq2seq4repair_space>null" , u . equals ( t ) ) ; <START_BUG> assertFalse ( "wrong<seq2seq4repair_space>type" , u . equals ( Double . valueOf ( 0 ) ) ) ; <END_BUG> t = new StatisticalSummaryValues ( 1 , 2 , 3 , 4 , 5 , 6 ) ; assertTrue ( "instances<seq2seq4repair_space>with<seq2seq4repair_space>same<seq2seq4repair_space>data<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>equal" , t . equals ( u ) ) ; assertEquals ( "hash<seq2seq4repair_space>code" , u . hashCode ( ) , t . hashCode ( ) ) ; u = new StatisticalSummaryValues ( Double . NaN , 2 , 3 , 4 , 5 , 6 ) ; t = new StatisticalSummaryValues ( 1 , Double . NaN , 3 , 4 , 5 , 6 ) ; assertFalse ( "instances<seq2seq4repair_space>based<seq2seq4repair_space>on<seq2seq4repair_space>different<seq2seq4repair_space>data<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>different" , ( ( u . equals ( t ) ) || ( t . equals ( u ) ) ) ) ; } private void verifyEquality ( StatisticalSummaryValues s , StatisticalSummaryValues u ) { } } 
public class Composite extends Scrollable { Layout layout ; Control [ ] tabList ; int layoutCount ; int backgroundMode ; boolean keyInputHappened ; Composite ( ) { } public Composite ( Composite parent , int style ) { } Control [ ] _getChildren ( ) { } Control [ ] _getTabList ( ) { } boolean acceptsFirstResponder ( int id , int sel ) { } int accessibilityAttributeNames ( int id , int sel ) { } boolean accessibilityIsIgnored ( int id , int sel ) { } public void changed ( Control [ ] changed ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } protected void checkSubclass ( ) { } Control [ ] computeTabList ( ) { } void setBounds ( int x , int y , int width , int height , boolean move , boolean resize ) { } void createHandle ( ) { state |= CANVAS ; boolean scrolled = ( ( style ) & ( ( SWT . V_SCROLL ) | ( SWT . H_SCROLL ) ) ) != 0 ; if ( ! scrolled ) state |= THEME_BACKGROUND ; NSRect rect = new NSRect ( ) ; if ( scrolled || ( hasBorder ( ) ) ) { NSScrollView scrollWidget = ( ( NSScrollView ) ( new SWTScrollView ( ) . alloc ( ) ) ) ; scrollWidget . initWithFrame ( rect ) ; scrollWidget . setDrawsBackground ( false ) ; if ( ( ( style ) & ( SWT . H_SCROLL ) ) != 0 ) scrollWidget . setHasHorizontalScroller ( true ) ; if ( ( ( style ) & ( SWT . V_SCROLL ) ) != 0 ) scrollWidget . setHasVerticalScroller ( true ) ; scrollWidget . setBorderType ( ( hasBorder ( ) ? OS . NSBezelBorder : OS . NSNoBorder ) ) ; scrollView = scrollWidget ; } <START_BUG> NSView widget = ( ( NSView ) ( new SWTView ( ) . alloc ( ) ) ) ; <END_BUG> widget . initWithFrame ( rect ) ; view = widget ; } void doCommandBySelector ( int id , int sel , int selector ) { } void drawWidget ( int id , NSGraphicsContext context , NSRect rect , boolean sendPaint ) { } void flagsChanged ( int id , int sel , int theEvent ) { } Composite findDeferredControl ( ) { } Menu [ ] findMenus ( Control control ) { } void fixChildren ( Shell newShell , Shell oldShell , Decorations newDecorations , Decorations oldDecorations , Menu [ ] menus ) { } void fixTabList ( Control control ) { } public int getBackgroundMode ( ) { } public Control [ ] getChildren ( ) { } int getChildrenCount ( ) { } public Layout getLayout ( ) { } public boolean getLayoutDeferred ( ) { } public Control [ ] getTabList ( ) { } boolean hooksKeys ( ) { } boolean insertText ( int id , int sel , int string ) { } public boolean isLayoutDeferred ( ) { } boolean isOpaque ( int id , int sel ) { } boolean isTabGroup ( ) { } void keyDown ( int id , int sel , int theEvent ) { } public void layout ( ) { } public void layout ( boolean changed ) { } public void layout ( boolean changed , boolean all ) { } public void layout ( Control [ ] changed ) { } void markLayout ( boolean changed , boolean all ) { } Point minimumSize ( int wHint , int Hint , boolean changed ) { } void pageDown ( int id , int sel , int sender ) { } void pageUp ( int id , int sel , int sender ) { } void reflectScrolledClipView ( int id , int sel , int aClipView ) { } void releaseChildren ( boolean destroy ) { } void releaseWidget ( ) { } void removeControl ( Control control ) { } void resized ( ) { } void scrollWheel ( int id , int sel , int theEvent ) { } public void setBackgroundMode ( int mode ) { } public boolean setFocus ( ) { } public void setLayout ( Layout layout ) { } public void setLayoutDeferred ( boolean defer ) { } boolean setMarkedText_selectedRange ( int id , int sel , int string , int range ) { } boolean setScrollBarVisible ( ScrollBar bar , boolean visible ) { } boolean setTabGroupFocus ( ) { } public void setTabList ( Control [ ] tabList ) { } int traversalCode ( int key , NSEvent theEvent ) { } void updateBackgroundMode ( ) { } void updateLayout ( boolean all ) { } } 
@ RunWith ( Arquillian . class ) public class JMSMessageDrivenBeanTestCase { @ Deployment public static Archive < ? > deployment ( ) { } @ Test public void testSendMessage ( ) throws JMSException , NamingException { final InitialContext ctx = new InitialContext ( ) ; final QueueConnectionFactory factory = ( ( QueueConnectionFactory ) ( ctx . lookup ( "java:/JmsXA" ) ) ) ; final QueueConnection connection = factory . createQueueConnection ( ) ; connection . start ( ) ; try { final QueueSession session = connection . createQueueSession ( false , AUTO_ACKNOWLEDGE ) ; final Queue replyDestination = session . createTemporaryQueue ( ) ; final QueueReceiver receiver = session . createReceiver ( replyDestination ) ; final Message message = session . createTextMessage ( "Test" ) ; message . setJMSReplyTo ( replyDestination ) ; <START_BUG> final Destination destination = ( ( Destination ) ( ctx . lookup ( "java:jboss/jms/queue/test" ) ) ) ; <END_BUG> final MessageProducer producer = session . createProducer ( destination ) ; producer . send ( message ) ; producer . close ( ) ; final Message reply = receiver . receive ( 1000 ) ; assertNotNull ( reply ) ; final String result = ( ( javax . jms . TextMessage ) ( reply ) ) . getText ( ) ; assertEquals ( "replying<seq2seq4repair_space>Test" , result ) ; } finally { } } } 
public class LuceneSegmentInputSplitTest extends AbstractLuceneStorageTest { private Configuration configuration ; @ Before public void before ( ) throws IOException { <START_BUG> configuration = new Configuration ( ) ; <END_BUG> } @ After public void after ( ) throws IOException { } @ Test public void testGetSegment ( ) throws Exception { } @ Test ( expected = IllegalArgumentException . class ) public void testGetSegmentNonExistingSegment ( ) throws Exception { } private void assertSegmentContainsOneDoc ( String segmentName ) throws IOException { } } 
public class DeleteResourceElementsOperation extends MultiOperation { protected DeleteResourceElementsOperation ( IJavaElement [ ] elementsToProcess , boolean force ) { } private void deletePackageFragment ( IPackageFragment frag ) throws JavaModelException { IResource res = frag . getResource ( ) ; if ( ( res != null ) && ( ( res . getType ( ) ) == ( IResource . FOLDER ) ) ) { IJavaElement [ ] childrenOfInterest = frag . getChildren ( ) ; if ( ( childrenOfInterest . length ) > 0 ) { IResource [ ] resources = new IResource [ childrenOfInterest . length ] ; for ( int i = 0 ; i < ( childrenOfInterest . length ) ; i ++ ) { resources [ i ] = childrenOfInterest [ i ] . getCorrespondingResource ( ) ; } deleteResources ( resources , fForce ) ; } Object [ ] nonJavaResources = frag . getNonJavaResources ( ) ; int actualResourceCount = 0 ; for ( int i = 0 , max = nonJavaResources . length ; i < max ; i ++ ) { if ( ( nonJavaResources [ i ] ) instanceof IResource ) actualResourceCount ++ ; } IResource [ ] actualNonJavaResources = new IResource [ actualResourceCount ] ; for ( int i = 0 , max = nonJavaResources . length , index = 0 ; i < max ; i ++ ) { if ( ( nonJavaResources [ i ] ) instanceof IResource ) actualNonJavaResources [ ( index ++ ) ] = ( ( IResource ) ( nonJavaResources [ i ] ) ) ; } deleteResources ( actualNonJavaResources , fForce ) ; IResource [ ] remainingFiles ; try { remainingFiles = ( ( IFolder ) ( res ) ) . members ( ) ; } catch ( CoreException ce ) { throw new JavaModelException ( ce ) ; } boolean isEmpty = true ; for ( int i = 0 , length = remainingFiles . length ; i < length ; i ++ ) { IResource file = remainingFiles [ i ] ; if ( file instanceof IFile ) { this . deleteResource ( file , ( ( IResource . FORCE ) | ( IResource . KEEP_HISTORY ) ) ) ; } else { isEmpty = false ; } } <START_BUG> if ( isEmpty ) { <END_BUG> IResource fragResource = frag . getResource ( ) ; if ( fragResource != null ) { deleteEmptyPackageFragment ( frag , false , fragResource . getParent ( ) ) ; } } } } protected String getMainTaskName ( ) { } protected void processElement ( IJavaElement element ) throws JavaModelException { } protected void verify ( IJavaElement element ) throws JavaModelException { } } 
public class OperationCoordinatorStepHandler { private final LocalHostControllerInfo localHostControllerInfo ; private final Map < String , ProxyController > hostProxies ; private final Map < String , ProxyController > serverProxies ; private final OperationSlaveStepHandler localSlaveHandler ; private volatile ExecutorService executorService ; OperationCoordinatorStepHandler ( final LocalHostControllerInfo localHostControllerInfo , final Map < String , ProxyController > hostProxies , final Map < String , ProxyController > serverProxies , final OperationSlaveStepHandler localSlaveHandler ) { } void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { } public void setExecutorService ( ExecutorService executorService ) { } private ExecutorService getExecutorService ( ) { } private void routetoMasterDomainController ( OperationContext context , ModelNode operation ) { <START_BUG> context . getFailureDescription ( ) . set ( String . format ( ( "Operation<seq2seq4repair_space>%s<seq2seq4repair_space>for<seq2seq4repair_space>address<seq2seq4repair_space>%s<seq2seq4repair_space>can<seq2seq4repair_space>only<seq2seq4repair_space>handled<seq2seq4repair_space>by<seq2seq4repair_space>the<seq2seq4repair_space>" + "master<seq2seq4repair_space>Domain<seq2seq4repair_space>Controller;<seq2seq4repair_space>this<seq2seq4repair_space>host<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>the<seq2seq4repair_space>master<seq2seq4repair_space>Domain<seq2seq4repair_space>Controller" ) , operation . get ( OP ) . asString ( ) , PathAddress . pathAddress ( operation . get ( OP_ADDR ) ) ) ) ; <END_BUG> context . completeStep ( ) ; } private void executeDirect ( OperationContext context , ModelNode operation ) throws OperationFailedException { } private void executeTwoPhaseOperation ( OperationContext context , ModelNode operation , OperationRouting routing ) throws OperationFailedException { } private void storeDeploymentContent ( ModelNode opNode , OperationContext context ) throws OperationFailedException { } private boolean hasStorableContent ( ModelNode operation ) { } private static final List < String > CONTENT_ADDITION_PARAMETERS = Arrays . asList ( INPUT_STREAM_INDEX , BYTES , URL ) ; private static boolean hasValidContentAdditionParameterDefined ( ModelNode item ) { } } 
class Substring extends AbstractVal implements Val { private final Val _val1 ; private final Val _val2 ; private Joins _joins = null ; private ClassMetaData _meta = null ; public Substring ( Val val1 , Val val2 ) { } public ClassMetaData getMetaData ( ) { } public void setMetaData ( ClassMetaData meta ) { } public boolean isVariable ( ) { } public Class getType ( ) { } public void setImplicitType ( Class type ) { } public void initialize ( Select sel , JDBCStore store , boolean nullTest ) { } public Joins getJoins ( ) { } public Object toDataStoreValue ( Object val , JDBCStore store ) { } public void select ( Select sel , JDBCStore store , Object [ ] params , boolean pks , JDBCFetchConfiguration fetch ) { } public void selectColumns ( Select sel , JDBCStore store , Object [ ] params , boolean pks , JDBCFetchConfiguration fetch ) { } public void groupBy ( Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { <START_BUG> sel . groupBy ( newSQLBuffer ( sel , store , params , fetch ) , false ) ; <END_BUG> } public void orderBy ( Select sel , JDBCStore store , Object [ ] params , boolean asc , JDBCFetchConfiguration fetch ) { } private SQLBuffer newSQLBuffer ( Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { } public Object load ( Result res , JDBCStore store , JDBCFetchConfiguration fetch ) throws SQLException { } public boolean hasVariable ( Variable var ) { } public void calculateValue ( Select sel , JDBCStore store , Object [ ] params , Val other , JDBCFetchConfiguration fetch ) { } public void clearParameters ( ) { } public int length ( ) { } public void appendTo ( SQLBuffer sql , int index , Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { } } 
public class LoggerLevelChange extends AbstractModelUpdateHandler { static final String OPERATION_NAME = "change-log-level" ; static final LoggerLevelChange INSTANCE = new LoggerLevelChange ( ) ; @ Override protected void updateModel ( final ModelNode operation , final ModelNode model ) throws OperationFailedException { } @ Override protected void performRuntime ( final OperationContext context , final ModelNode operation , final ModelNode model , final ServiceVerificationHandler verificationHandler , final List < ServiceController < ? > > newControllers ) throws OperationFailedException { final PathAddress address = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) ; final String name = address . getLastElement ( ) . getValue ( ) ; final ModelNode level = CommonAttributes . LEVEL . validateResolvedOperation ( model ) ; <START_BUG> final ServiceRegistry serviceRegistry = context . getServiceRegistry ( false ) ; <END_BUG> final ServiceController < Logger > controller = ( ( ServiceController < Logger > ) ( serviceRegistry . getService ( LogServices . loggerName ( name ) ) ) ) ; if ( ( controller != null ) && ( level . isDefined ( ) ) ) { controller . getValue ( ) . setLevel ( Level . parse ( level . asString ( ) ) ) ; } } } 
public abstract class AbstractMessageChannel implements BeanNameAware , MessageChannel { protected Log logger = LogFactory . getLog ( getClass ( ) ) ; private String beanName ; private final ChannelInterceptorChain interceptorChain = new ChannelInterceptorChain ( ) ; public AbstractMessageChannel ( ) { } @ Override public void setBeanName ( String name ) { } public String getBeanName ( ) { } public void setInterceptors ( List < ChannelInterceptor > interceptors ) { } public void addInterceptor ( ChannelInterceptor interceptor ) { } public List < ChannelInterceptor > getInterceptors ( ) { } protected ChannelInterceptorChain getInterceptorChain ( ) { } @ Override public final boolean send ( Message < ? > message ) { } @ Override public final boolean send ( Message < ? > message , long timeout ) { Assert . notNull ( message , "Message<seq2seq4repair_space>must<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>null" ) ; if ( logger . isTraceEnabled ( ) ) { <START_BUG> logger . trace ( ( ( ( "[" + ( this . beanName ) ) + "]<seq2seq4repair_space>sending<seq2seq4repair_space>message<seq2seq4repair_space>" ) + message ) ) ; <END_BUG> } message = this . interceptorChain . preSend ( message , this ) ; if ( message == null ) { return false ; } try { boolean sent = sendInternal ( message , timeout ) ; this . interceptorChain . postSend ( message , this , sent ) ; return sent ; } catch ( Exception e ) { if ( e instanceof MessagingException ) { throw ( ( MessagingException ) ( e ) ) ; } throw new org . springframework . messaging . MessageDeliveryException ( message , ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>send<seq2seq4repair_space>message<seq2seq4repair_space>to<seq2seq4repair_space>channel<seq2seq4repair_space>'" + ( this . getBeanName ( ) ) ) + "'" ) , e ) ; } } protected abstract boolean sendInternal ( Message < ? > message , long timeout ) { } @ Override public String toString ( ) { } } 
public class PlatformLoggingMXBeanGetLoggerLevelHandler implements OperationStepHandler , DescriptionProvider { public static final PlatformLoggingMXBeanGetLoggerLevelHandler INSTANCE = new PlatformLoggingMXBeanGetLoggerLevelHandler ( ) ; private static final String [ ] SIGNATURE = new String [ ] { String . class . getName ( ) } ; private final ParametersValidator parametersValidator = new ParametersValidator ( ) ; private PlatformLoggingMXBeanGetLoggerLevelHandler ( ) { } @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { parametersValidator . validate ( operation ) ; final String loggerName = operation . require ( LOGGER_NAME ) . asString ( ) ; try { Object level = ManagementFactory . getPlatformMBeanServer ( ) . invoke ( PLATFORM_LOGGING_OBJECT_NAME , "getLoggerLevel" , new String [ ] { loggerName } , PlatformLoggingMXBeanGetLoggerLevelHandler . SIGNATURE ) ; final ModelNode result = context . getResult ( ) ; if ( level != null ) { result . set ( level . toString ( ) ) ; } } catch ( JMRuntimeException e ) { throw e ; } catch ( JMException e ) { throw new RuntimeException ( e ) ; } <START_BUG> context . completeStep ( ) ; <END_BUG> } @ Override public ModelNode getModelDescription ( Locale locale ) { } } 
@ ServerSetup ( NonExistingProfileTestCase . NonExistingProfileTestCaseSetup . class ) @ RunWith ( Arquillian . class ) public class NonExistingProfileTestCase extends AbstractLoggingTest { private static Logger log = Logger . getLogger ( NonExistingProfileTestCase . class ) ; @ ArquillianResource ( LoggingServlet . class ) URL url ; private static final String LOG_FILE_NAME = "non-existing-profile-test.log" ; private static File loggingTestLog ; static class NonExistingProfileTestCaseSetup extends AbstractMgmtServerSetupTask { @ Override protected void doSetup ( ManagementClient managementClient ) throws Exception { } @ Override public void tearDown ( ManagementClient managementClient , String containerId ) throws Exception { } } @ Deployment public static WebArchive createDeployment ( ) { } @ AfterClass @ RunAsClient public static void cleanCustomFile ( ) { } @ Test @ RunAsClient public void warningMessageTest ( ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( NonExistingProfileTestCase . loggingTestLog ) , StandardCharsets . UTF_8 ) ) ; String line ; boolean warningFound = false ; while ( ( line = br . readLine ( ) ) != null ) { <START_BUG> if ( line . contains ( "JBAS011509" ) ) { <END_BUG> warningFound = true ; break ; } } br . close ( ) ; Assert . assertTrue ( warningFound ) ; } @ Test @ RunAsClient public void defaultLoggingTest ( ) throws IOException { } } 
public class ForStatement extends Statement { private ASTNode . NodeList initializers = new ASTNode . NodeList ( true , Expression . class ) ; private Expression optionalConditionExpression = null ; private ASTNode . NodeList updaters = new ASTNode . NodeList ( true , Expression . class ) ; private Statement body = null ; ForStatement ( AST ast ) { } public int getNodeType ( ) { } ASTNode clone ( AST target ) { ForStatement result = new ForStatement ( target ) ; result . setSourceRange ( this . getStartPosition ( ) , this . getLength ( ) ) ; <START_BUG> result . setLeadingComment ( getLeadingComment ( ) ) ; <END_BUG> result . initializers ( ) . addAll ( ASTNode . copySubtrees ( target , initializers ( ) ) ) ; result . setExpression ( ( ( Expression ) ( ASTNode . copySubtree ( target , getExpression ( ) ) ) ) ) ; result . updaters ( ) . addAll ( ASTNode . copySubtrees ( target , updaters ( ) ) ) ; result . setBody ( ( ( Statement ) ( ASTNode . copySubtree ( target , getBody ( ) ) ) ) ) ; return result ; } public boolean subtreeMatch ( ASTMatcher matcher , Object other ) { } void accept0 ( ASTVisitor visitor ) { } public List initializers ( ) { } public Expression getExpression ( ) { } public void setExpression ( Expression expression ) { } public List updaters ( ) { } public Statement getBody ( ) { } public void setBody ( Statement statement ) { } int memSize ( ) { } int treeSize ( ) { } } 
public class BeanShell { public static void evalSelection ( View view , JEditTextArea textArea ) { } public static void showEvaluateDialog ( View view ) { } public static void showEvaluateLinesDialog ( View view ) { } public static void runScript ( View view , String path , Reader in , boolean ownNamespace ) { } public static void _runScript ( View view , String path , Reader in , boolean ownNamespace ) throws Exception { } public static Object eval ( View view , NameSpace namespace , String command ) { } public static Object _eval ( View view , NameSpace namespace , String command ) throws Exception { } public static BshMethod cacheBlock ( String id , String code , boolean namespace ) throws Exception { String name = "__internal_" + id ; if ( namespace ) { <START_BUG> BeanShell . _eval ( null , BeanShell . global , ( ( ( name + "(ns)<seq2seq4repair_space>{\this.callstack.set(0,ns);\n" ) + code ) + "\n}" ) ) ; <END_BUG> return BeanShell . global . getMethod ( name , new Class [ ] { NameSpace . class } ) ; } else { BeanShell . _eval ( null , BeanShell . global , ( ( ( name + "()<seq2seq4repair_space>{\n" ) + code ) + "\n}" ) ) ; return BeanShell . global . getMethod ( name , new Class [ 0 ] ) ; } } public static Object runCachedBlock ( BshMethod method , View view , NameSpace namespace ) throws Exception { } public static boolean isScriptRunning ( ) { } public static NameSpace getNameSpace ( ) { } public static void runScript ( View view , String path , boolean ownNamespace , boolean rethrowBshErrors ) { } public static void runScript ( View view , String path , Reader in , boolean ownNamespace , boolean rethrowBshErrors ) { } public static Object eval ( View view , String command , boolean rethrowBshErrors ) { } public static Object eval ( View view , NameSpace namespace , String command , boolean rethrowBshErrors ) { } static void init ( ) { } private static final Object [ ] NO_ARGS = new Object [ 0 ] ; private static Interpreter interpForMethods ; private static NameSpace global ; private static boolean running ; private static void unwrapException ( Exception e ) throws Exception { } private static void handleException ( View view , String path , Throwable t ) { } private static Interpreter createInterpreter ( NameSpace nameSpace ) { } } 
public class PackageTest extends JMeterTestCase { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; public PackageTest ( String arg0 ) { } private static CSVRead setCSVReadParams ( String p1 , String p2 ) throws Exception { } private static StringFromFile SFFParams ( String p1 , String p2 , String p3 , String p4 ) throws Exception { } private static SplitFunction SplitParams ( String p1 , String p2 , String p3 ) throws Exception { } private static BeanShell BSHFParams ( String p1 , String p2 , String p3 ) throws Exception { } private static Collection MakeParams ( String p1 , String p2 , String p3 ) { } public static Test suite ( ) throws Exception { } private JMeterContext jmctx = null ; private JMeterVariables vars = null ; public void setUp ( ) { } public void BSH1 ( ) throws Exception { } public void splitTest1 ( ) throws Exception { } public void SFFTest1 ( ) throws Exception { } public void SFFTest2 ( ) throws Exception { } public void SFFTest3 ( ) throws Exception { } public void SFFTest4 ( ) throws Exception { } public void SFFTest5 ( ) throws Exception { } private static CSVRead cr1 ; private static CSVRead cr2 ; private static CSVRead cr3 ; private static CSVRead cr4 ; private static CSVRead cr5 ; private static CSVRead cr6 ; private static class Baton { void pass ( ) { } void done ( ) { } } private static final PackageTest . Baton baton = new PackageTest . Baton ( ) ; public void CSVThread1 ( ) throws Exception { } public void CSVThread2 ( ) throws Exception { } public void CSVRun ( ) throws Exception { } public void CSVParams ( ) throws Exception { } public void CSVSetup ( ) throws Exception { } public void CSValias ( ) throws Exception { } public void CSVNoFile ( ) throws Exception { } public void CSVBlankLine ( ) throws Exception { } public void XPathtestNull ( ) throws Exception { } public void XPathtestrowNum ( ) throws Exception { } public void XPathtestColumns ( ) throws Exception { } public void XPathtestDefault ( ) throws Exception { XPathFileContainer f = new XPathFileContainer ( "../build.xml" , "/project/@default" ) ; assertNotNull ( f ) ; assertTrue ( "Not<seq2seq4repair_space>empty" , ( ( f . size ( ) ) > 0 ) ) ; <START_BUG> assertEquals ( "all" , f . getXPathString ( 0 ) ) ; <END_BUG> } public void XPathEmpty ( ) throws Exception { } public void XPathNoFile ( ) throws Exception { } public void XPathFile1 ( ) throws Exception { } public void XPathFile2 ( ) throws Exception { } private static XPath sxp1 ; private static XPath sxp2 ; public void XPathSetup1 ( ) throws Exception { } public void XPathSetup2 ( ) throws Exception { } public void XPathThread1 ( ) throws Exception { } public void XPathThread2 ( ) throws Exception { } private XPath setupXPath ( String file , String expr ) throws Exception { } public void randomTest1 ( ) throws Exception { } public void variableTest1 ( ) throws Exception { } public void evalTest1 ( ) throws Exception { } public void evalTest2 ( ) throws Exception { } public void sumTest ( ) throws Exception { } private void checkSum ( AbstractFunction func , String value , String [ ] addends ) throws Exception { } private void checkSumNoVar ( AbstractFunction func , String value , String [ ] addends ) throws Exception { } } 
public class AnnotProxyFieldValueFactory implements IFieldValueFactory { private final ISpringContextLocator contextLocator ; private final ConcurrentHashMap < SpringBeanLocator , Object > cache = Generics . newConcurrentHashMap ( ) ; private final ConcurrentHashMap < Class < ? > , String > beanNameCache = Generics . newConcurrentHashMap ( ) ; private final boolean wrapInProxies ; public AnnotProxyFieldValueFactory ( ISpringContextLocator contextLocator ) { } public AnnotProxyFieldValueFactory ( ISpringContextLocator contextLocator , boolean wrapInProxies ) { } public Object getFieldValue ( Field field , Object fieldOwner ) { <START_BUG> if ( field . isAnnotationPresent ( SpringBean . class ) ) { <END_BUG> SpringBeanLocator locator = new SpringBeanLocator ( getBeanName ( field ) , field . getType ( ) , contextLocator ) ; Object cachedValue = cache . get ( locator ) ; if ( cachedValue != null ) { return cachedValue ; } final Object target ; if ( wrapInProxies ) { target = LazyInitProxyFactory . createProxy ( field . getType ( ) , locator ) ; } else { target = locator . locateProxyTarget ( ) ; } if ( locator . isSingletonBean ( ) ) { cache . put ( locator , target ) ; } return target ; } return null ; } private String getBeanName ( final Field field ) { } private final String getBeanNameOfClass ( ApplicationContext ctx , Class < ? > clazz ) { } public boolean supportsField ( Field field ) { } } 
class PrefixMapper { private static int debug = 1 ; SimpleHashtable vhostMaps = new SimpleHashtable ( ) ; SimpleHashtable vhostMapsWC = new SimpleHashtable ( ) ; SimpleHashtable prefixMappedServlets ; SimpleHashtable exactMappedServlets ; SimpleHashtable mapCache ; boolean mapCacheEnabled = false ; boolean ignoreCase = false ; public PrefixMapper ( ) { } public void setMapCache ( boolean v ) { } public void setIgnoreCase ( boolean b ) { } public void removeAllMappings ( String host , Context ctx ) { PrefixMapper vmap = this ; if ( host != null ) { host = host . toLowerCase ( ) ; if ( host . startsWith ( "*" ) ) vmap = ( ( PrefixMapper ) ( vhostMapsWC . get ( host . substring ( 1 ) ) ) ) ; else vmap = ( ( PrefixMapper ) ( vhostMaps . get ( host ) ) ) ; } Enumeration en = vmap . prefixMappedServlets . keys ( ) ; while ( en . hasMoreElements ( ) ) { String s = ( ( String ) ( en . nextElement ( ) ) ) ; Container ct = ( ( Container ) ( vmap . prefixMappedServlets . get ( s ) ) ) ; <START_BUG> if ( ( ct . getContext ( ) ) == ctx ) { <END_BUG> if ( ( PrefixMapper . debug ) > 0 ) ctx . log ( ( "Remove<seq2seq4repair_space>mapping<seq2seq4repair_space>" + s ) ) ; vmap . prefixMappedServlets . remove ( s ) ; } } en = vmap . exactMappedServlets . keys ( ) ; while ( en . hasMoreElements ( ) ) { String s = ( ( String ) ( en . nextElement ( ) ) ) ; Container ct = ( ( Container ) ( vmap . exactMappedServlets . get ( s ) ) ) ; if ( ( ct . getContext ( ) ) == ctx ) { if ( ( PrefixMapper . debug ) > 0 ) ctx . log ( ( "Remove<seq2seq4repair_space>mapping<seq2seq4repair_space>" + s ) ) ; vmap . exactMappedServlets . remove ( s ) ; } } mapCache = new SimpleHashtable ( ) ; } void addMapping ( String path , Object target ) { } void addExactMapping ( String path , Object target ) { } public void addMapping ( String host , String path , Object target ) { } public void addMappings ( Enumeration hostAliases , String path , Object target ) { } public void addExactMapping ( String host , String path , Object target ) { } public void addExactMappings ( Enumeration hostAliases , String path , Object target ) { } public Object getLongestPrefixMatch ( MessageBytes hostMB , MessageBytes pathMB ) { } } 
class MethodVerifier15 extends MethodVerifier { MethodVerifier15 ( LookupEnvironment environment ) { } boolean areTypesEqual ( TypeBinding one , TypeBinding two ) { } void checkAgainstInheritedMethods ( MethodBinding currentMethod , MethodBinding [ ] methods , int length ) { } boolean doesMethodOverride ( MethodBinding method , MethodBinding inheritedMethod ) { } boolean hasBoundedParameters ( ParameterizedTypeBinding parameterizedType ) { } boolean isReturnTypeSubstituable ( MethodBinding one , MethodBinding two ) { } boolean isTypeSubstituable ( TypeBinding one , TypeBinding two ) { if ( one == two ) return true ; if ( ( one . isArrayType ( ) ) || ( two . isArrayType ( ) ) ) { if ( ( one . isArrayType ( ) ) != ( two . isArrayType ( ) ) ) return false ; ArrayBinding arrayOne = ( ( ArrayBinding ) ( one ) ) ; ArrayBinding arrayTwo = ( ( ArrayBinding ) ( two ) ) ; if ( ( arrayOne . dimensions ) != ( arrayTwo . dimensions ) ) return false ; one = arrayOne . leafComponentType ; two = arrayTwo . leafComponentType ; } if ( ( one . isBaseType ( ) ) || ( two . isBaseType ( ) ) ) return false ; ReferenceBinding subType = ( ( ReferenceBinding ) ( one ) ) ; ReferenceBinding superType = ( ( ReferenceBinding ) ( two ) ) ; if ( CharOperation . equals ( subType . compoundName , superType . compoundName ) ) return true ; superType = BinaryTypeBinding . resolveType ( superType , this . environment , true ) ; subType = BinaryTypeBinding . resolveType ( subType , this . environment , true ) ; if ( superType . isInterface ( ) ) return subType . implementsInterface ( superType , true ) ; <START_BUG> return ( subType . isClass ( ) ) && ( isSameClassOrSubclassOf ( subType , superType ) ) ; <END_BUG> } } 
public class TCPSyslogServer extends TCPNetSyslogServer { private static final Logger LOGGER = Logger . getLogger ( TCPSyslogServer . class ) ; @ SuppressWarnings ( "unchecked" ) public TCPSyslogServer ( ) { } @ SuppressWarnings ( "unchecked" ) @ Override public void run ( ) { try { TCPSyslogServer . LOGGER . debug ( "Creating<seq2seq4repair_space>Syslog<seq2seq4repair_space>server<seq2seq4repair_space>socket" ) ; this . serverSocket = createServerSocket ( ) ; } catch ( IOException e ) { TCPSyslogServer . LOGGER . error ( "ServerSocket<seq2seq4repair_space>creation<seq2seq4repair_space>failed." , e ) ; throw new SyslogRuntimeException ( e ) ; } while ( ! ( this . shutdown ) ) { try { final Socket socket = this . serverSocket . accept ( ) ; if ( TCPSyslogServer . LOGGER . isDebugEnabled ( ) ) { TCPSyslogServer . LOGGER . debug ( ( "Handling<seq2seq4repair_space>Syslog<seq2seq4repair_space>client<seq2seq4repair_space>" + ( socket . getInetAddress ( ) ) ) ) ; } new Thread ( new TCPSyslogSocketHandler ( this . sockets , this , socket ) ) . start ( ) ; } catch ( IOException e ) { <START_BUG> TCPSyslogServer . LOGGER . error ( "IOException<seq2seq4repair_space>occurred." , e ) ; <END_BUG> } } } } 
public class WeblogicDeploymentTool extends GenericDeploymentTool { public static final String PUBLICID_EJB11 = "-//Sun<seq2seq4repair_space>Microsystems,<seq2seq4repair_space>Inc.//DTD<seq2seq4repair_space>Enterprise<seq2seq4repair_space>JavaBeans<seq2seq4repair_space>1.1//EN" ; public static final String PUBLICID_EJB20 = "-//Sun<seq2seq4repair_space>Microsystems,<seq2seq4repair_space>Inc.//DTD<seq2seq4repair_space>Enterprise<seq2seq4repair_space>JavaBeans<seq2seq4repair_space>2.0//EN" ; public static final String PUBLICID_WEBLOGIC_EJB510 = "-//BEA<seq2seq4repair_space>Systems,<seq2seq4repair_space>Inc.//DTD<seq2seq4repair_space>WebLogic<seq2seq4repair_space>5.1.0<seq2seq4repair_space>EJB//EN" ; public static final String PUBLICID_WEBLOGIC_EJB600 = "-//BEA<seq2seq4repair_space>Systems,<seq2seq4repair_space>Inc.//DTD<seq2seq4repair_space>WebLogic<seq2seq4repair_space>6.0.0<seq2seq4repair_space>EJB//EN" ; public static final String PUBLICID_WEBLOGIC_EJB700 = "-//BEA<seq2seq4repair_space>Systems,<seq2seq4repair_space>Inc.//DTD<seq2seq4repair_space>WebLogic<seq2seq4repair_space>7.0.0<seq2seq4repair_space>EJB//EN" ; protected static final String DEFAULT_WL51_EJB11_DTD_LOCATION = "/weblogic/ejb/deployment/xml/ejb-jar.dtd" ; protected static final String DEFAULT_WL60_EJB11_DTD_LOCATION = "/weblogic/ejb20/dd/xml/ejb11-jar.dtd" ; protected static final String DEFAULT_WL60_EJB20_DTD_LOCATION = "/weblogic/ejb20/dd/xml/ejb20-jar.dtd" ; protected static final String DEFAULT_WL51_DTD_LOCATION = "/weblogic/ejb/deployment/xml/weblogic-ejb-jar.dtd" ; protected static final String DEFAULT_WL60_51_DTD_LOCATION = "/weblogic/ejb20/dd/xml/weblogic510-ejb-jar.dtd" ; protected static final String DEFAULT_WL60_DTD_LOCATION = "/weblogic/ejb20/dd/xml/weblogic600-ejb-jar.dtd" ; protected static final String DEFAULT_WL70_DTD_LOCATION = "/weblogic/ejb20/dd/xml/weblogic700-ejb-jar.dtd" ; protected static final String DEFAULT_COMPILER = "default" ; protected static final String WL_DD = "weblogic-ejb-jar.xml" ; protected static final String WL_CMP_DD = "weblogic-cmp-rdbms-jar.xml" ; protected static final String COMPILER_EJB11 = "weblogic.ejbc" ; protected static final String COMPILER_EJB20 = "weblogic.ejbc20" ; private String jarSuffix = ".jar" ; private String weblogicDTD ; private String ejb11DTD ; private boolean keepgenerated = false ; private String ejbcClass = null ; private String additionalArgs = "" ; private String additionalJvmArgs = "" ; private boolean keepGeneric = false ; private String compiler = null ; private boolean alwaysRebuild = true ; private boolean noEJBC = false ; private boolean newCMP = false ; private Path wlClasspath = null ; private Vector sysprops = new Vector ( ) ; private Integer jvmDebugLevel = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private File outputDir ; public void addSysproperty ( Environment . Variable sysp ) { } public Path createWLClasspath ( ) { } public void setOutputDir ( File outputDir ) { } public void setWLClasspath ( Path wlClasspath ) { } public void setCompiler ( String compiler ) { } public void setRebuild ( boolean rebuild ) { } public void setJvmDebugLevel ( Integer jvmDebugLevel ) { } public Integer getJvmDebugLevel ( ) { } public void setSuffix ( String inString ) { } public void setKeepgeneric ( boolean inValue ) { } public void setKeepgenerated ( String inValue ) { } public void setArgs ( String args ) { } public void setJvmargs ( String args ) { } public void setEjbcClass ( String ejbcClass ) { } public String getEjbcClass ( ) { } public void setWeblogicdtd ( String inString ) { } public void setWLdtd ( String inString ) { } public void setEJBdtd ( String inString ) { } public void setOldCMP ( boolean oldCMP ) { } public void setNewCMP ( boolean newCMP ) { } public void setNoEJBC ( boolean noEJBC ) { } protected void registerKnownDTDs ( DescriptorHandler handler ) { } protected DescriptorHandler getWeblogicDescriptorHandler ( final File srcDir ) { } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { } File getVendorOutputJarFile ( String baseName ) { } private void buildWeblogicJar ( File sourceJar , File destJar , String publicId ) { } protected void writeJar ( String baseName , File jarFile , Hashtable files , String publicId ) throws BuildException { } public void validateConfigured ( ) throws BuildException { } protected boolean isRebuildRequired ( File genericJarFile , File weblogicJarFile ) { } protected ClassLoader getClassLoaderFromJar ( File classjar ) throws IOException { Path lookupPath = new Path ( getTask ( ) . getProject ( ) ) ; lookupPath . setLocation ( classjar ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath != null ) { lookupPath . append ( classpath ) ; } <START_BUG> return new org . apache . tools . ant . AntClassLoader ( getTask ( ) . getProject ( ) , lookupPath ) ; <END_BUG> } } 
public class MenuSeparatorContribution extends CommonMenuAddition { public MenuSeparatorContribution ( IConfigurationElement element ) { } public boolean isVisible ( ) { String val = element . getAttribute ( ATT_VISIBLE ) ; <START_BUG> return Boolean . parseBoolean ( val ) ; <END_BUG> } public void fill ( Menu parent , int index ) { } public void fill ( ToolBar parent , int index ) { } public String toString ( ) { } } 
public class Copy extends Task { protected File file = null ; protected File destFile = null ; protected File destDir = null ; protected Vector filesets = new Vector ( ) ; protected boolean filtering = false ; protected boolean forceOverwrite = false ; protected boolean flatten = false ; protected int verbosity = Project . MSG_VERBOSE ; protected boolean includeEmpty = true ; protected Hashtable fileCopyMap = new Hashtable ( ) ; protected Hashtable dirCopyMap = new Hashtable ( ) ; public void setFile ( File file ) { } public void setTofile ( File destFile ) { } public void setTodir ( File destDir ) { } public void setFiltering ( boolean filtering ) { } public void setOverwrite ( boolean overwrite ) { } public void setFlatten ( boolean flatten ) { } public void setVerbose ( boolean verbose ) { } public void setIncludeEmptyDirs ( boolean includeEmpty ) { } public void addFileset ( FileSet set ) { } public void execute ( ) throws BuildException { } protected void validateAttributes ( ) throws BuildException { } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { String [ ] toCopy = null ; if ( forceOverwrite ) { toCopy = names ; } else { <START_BUG> SourceFileScanner ds = new SourceFileScanner ( ) ; <END_BUG> toCopy = ds . restrict ( names , fromDir , toDir , mapper ) ; } for ( int i = 0 ; i < ( toCopy . length ) ; i ++ ) { File src = new File ( fromDir , toCopy [ i ] ) ; File dest = new File ( toDir , mapper . mapFileName ( toCopy [ i ] ) [ 0 ] ) ; map . put ( src . getAbsolutePath ( ) , dest . getAbsolutePath ( ) ) ; } } protected void doFileOperations ( ) { } } 
public class SearchGroupsRequestFactory implements ShardRequestFactory { public ShardRequest [ ] constructRequest ( ResponseBuilder rb ) { ShardRequest sreq = new ShardRequest ( ) ; GroupingSpecification groupingSpecification = rb . getGroupingSpec ( ) ; if ( ( groupingSpecification . getFields ( ) . length ) == 0 ) { return new ShardRequest [ 0 ] ; } sreq . purpose = ShardRequest . PURPOSE_GET_TOP_GROUPS ; sreq . params = new org . apache . solr . common . params . ModifiableSolrParams ( rb . req . getParams ( ) ) ; sreq . params . remove ( SHARDS ) ; if ( ( rb . shards_start ) > ( - 1 ) ) { sreq . params . set ( START , rb . shards_start ) ; } else { sreq . params . set ( START , "0" ) ; } if ( ( rb . shards_rows ) > ( - 1 ) ) { sreq . params . set ( ROWS , rb . shards_rows ) ; } else { sreq . params . set ( ROWS , ( ( rb . getSortSpec ( ) . getOffset ( ) ) + ( rb . getSortSpec ( ) . getCount ( ) ) ) ) ; } <START_BUG> sreq . params . set ( "group.distibuted.first" , "true" ) ; <END_BUG> if ( ( ( ( rb . getFieldFlags ( ) ) & ( SolrIndexSearcher . GET_SCORES ) ) != 0 ) || ( rb . getSortSpec ( ) . includesScore ( ) ) ) { sreq . params . set ( FL , ( ( rb . req . getSchema ( ) . getUniqueKeyField ( ) . getName ( ) ) + ",score" ) ) ; } else { sreq . params . set ( FL , rb . req . getSchema ( ) . getUniqueKeyField ( ) . getName ( ) ) ; } return new ShardRequest [ ] { sreq } ; } } 
public final class UnmodifiableBoundedCollection < E > extends AbstractCollectionDecorator < E > implements BoundedCollection < E > { private static final long serialVersionUID = - 7112672385450340330L ; public static < E > BoundedCollection < E > unmodifiableBoundedCollection ( final BoundedCollection < E > coll ) { } @ SuppressWarnings ( "unchecked" ) public static < E > BoundedCollection < E > unmodifiableBoundedCollection ( Collection < ? extends E > coll ) { if ( coll == null ) { throw new IllegalArgumentException ( "The<seq2seq4repair_space>collection<seq2seq4repair_space>must<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>null" ) ; } for ( int i = 0 ; i < 1000 ; i ++ ) { if ( coll instanceof BoundedCollection ) { break ; } if ( coll instanceof AbstractCollectionDecorator ) { coll = ( ( AbstractCollectionDecorator < E > ) ( coll ) ) . collection ; } else if ( coll instanceof SynchronizedCollection ) { <START_BUG> coll = ( ( SynchronizedCollection < E > ) ( coll ) ) . collection ; <END_BUG> } } if ( ( coll instanceof BoundedCollection ) == false ) { throw new IllegalArgumentException ( "The<seq2seq4repair_space>collection<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>a<seq2seq4repair_space>bounded<seq2seq4repair_space>collection" ) ; } return new UnmodifiableBoundedCollection < E > ( ( ( BoundedCollection < E > ) ( coll ) ) ) ; } private UnmodifiableBoundedCollection ( final BoundedCollection < E > coll ) { } @ Override public Iterator < E > iterator ( ) { } @ Override public boolean add ( final E object ) { } @ Override public boolean addAll ( final Collection < ? extends E > coll ) { } @ Override public void clear ( ) { } @ Override public boolean remove ( final Object object ) { } @ Override public boolean removeAll ( final Collection < ? > coll ) { } @ Override public boolean retainAll ( final Collection < ? > coll ) { } public boolean isFull ( ) { } public int maxSize ( ) { } @ Override protected BoundedCollection < E > decorated ( ) { } } 
public class ColumnIndexer { public static void serialize ( ColumnFamily columnFamily , DataOutput dos ) { } private static BloomFilter createColumnBloomFilter ( Collection < IColumn > columns ) { int columnCount = 0 ; for ( IColumn column : columns ) { columnCount += column . getObjectCount ( ) ; } <START_BUG> BloomFilter bf = new BloomFilter ( columnCount , 4 ) ; <END_BUG> for ( IColumn column : columns ) { bf . add ( column . name ( ) ) ; if ( column instanceof SuperColumn ) { Collection < IColumn > subColumns = column . getSubColumns ( ) ; for ( IColumn subColumn : subColumns ) { bf . add ( subColumn . name ( ) ) ; } } } return bf ; } private static void doIndexing ( AbstractType comparator , Collection < IColumn > columns , DataOutput dos ) throws IOException { } } 
public class JavadocArgumentExpression extends Expression { public char [ ] token ; public Argument argument ; public JavadocArgumentExpression ( char [ ] name , int startPos , int endPos , TypeReference typeRef ) { } private TypeBinding internalResolveType ( Scope scope ) { this . constant = Constant . NotAConstant ; if ( ( this . resolvedType ) != null ) return this . resolvedType . isValidBinding ( ) ? this . resolvedType : null ; if ( ( this . argument ) != null ) { TypeReference typeRef = this . argument . type ; if ( typeRef != null ) { this . resolvedType = typeRef . getTypeBinding ( scope ) ; typeRef . resolvedType = this . resolvedType ; if ( ( ( typeRef instanceof SingleTypeReference ) && ( ( this . resolvedType . leafComponentType ( ) . enclosingType ( ) ) != null ) ) && ( ( scope . compilerOptions ( ) . complianceLevel ) <= ( ClassFileConstants . JDK1_4 ) ) ) { scope . problemReporter ( ) . javadocInvalidMemberTypeQualification ( this . sourceStart , this . sourceEnd , scope . getDeclarationModifiers ( ) ) ; return null ; } if ( ! ( this . resolvedType . isValidBinding ( ) ) ) { scope . problemReporter ( ) . javadocInvalidType ( typeRef , this . resolvedType , scope . getDeclarationModifiers ( ) ) ; return null ; } if ( isTypeUseDeprecated ( this . resolvedType , scope ) ) { scope . problemReporter ( ) . javadocDeprecatedType ( this . resolvedType , typeRef , scope . getDeclarationModifiers ( ) ) ; } <START_BUG> return this . resolvedType = scope . environment ( ) . convertToRawType ( this . resolvedType ) ; <END_BUG> } } return null ; } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public void resolve ( BlockScope scope ) { } public TypeBinding resolveType ( BlockScope scope ) { } public TypeBinding resolveType ( ClassScope scope ) { } public void traverse ( ASTVisitor visitor , BlockScope blockScope ) { } public void traverse ( ASTVisitor visitor , ClassScope blockScope ) { } } 
@ RunWith ( Arquillian . class ) public class InflowTestCase extends ContainerResourceMgmtTestBase { @ Deployment public static ResourceAdapterArchive createDeployment ( ) throws Exception { } @ ArquillianResource ServiceContainer serviceContainer ; @ Test public void testRegistryConfiguration ( ) throws Throwable { ServiceController < ? > controller = serviceContainer . getService ( RA_REPOSITORY_SERVICE ) ; assertNotNull ( controller ) ; ResourceAdapterRepository repository = ( ( ResourceAdapterRepository ) ( controller . getValue ( ) ) ) ; assertNotNull ( repository ) ; Set < String > ids = repository . getResourceAdapters ( MessageListener . class ) ; assertNotNull ( ids ) ; <START_BUG> assertEquals ( 1 , ids . size ( ) ) ; <END_BUG> String piId = ids . iterator ( ) . next ( ) ; assertNotNull ( piId ) ; Endpoint endpoint = repository . getEndpoint ( piId ) ; assertNotNull ( endpoint ) ; List < MessageListener > listeners = repository . getMessageListeners ( piId ) ; assertNotNull ( listeners ) ; assertEquals ( 1 , listeners . size ( ) ) ; MessageListener listener = listeners . get ( 0 ) ; ActivationSpec as = listener . getActivation ( ) . createInstance ( ) ; assertNotNull ( as ) ; assertNotNull ( as . getResourceAdapter ( ) ) ; } @ Test public void testMetadataConfiguration ( ) throws Throwable { } } 
public class ThrowStatement extends Statement { public Expression exception ; public TypeBinding exceptionType ; public ThrowStatement ( Expression exception , int startPosition ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { exception . analyseCode ( currentScope , flowContext , flowInfo ) ; flowContext . checkExceptionHandlers ( exceptionType , this , flowInfo , currentScope ) ; <START_BUG> return DeadEnd ; <END_BUG> } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void resolve ( BlockScope scope ) { } public String toString ( int tab ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope blockScope ) { } } 
public class WildcardType extends Type { public static final ChildPropertyDescriptor BOUND_PROPERTY = new ChildPropertyDescriptor ( WildcardType . class , "bound" , Type . class , ASTNode . OPTIONAL , ASTNode . CYCLE_RISK ) ; public static final SimplePropertyDescriptor UPPER_BOUND_PROPERTY = new SimplePropertyDescriptor ( WildcardType . class , "upperBound" , boolean . class , ASTNode . MANDATORY ) ; private static final List PROPERTY_DESCRIPTORS ; public static List propertyDescriptors ( int apiLevel ) { } private Type optionalBound = null ; private boolean isUpperBound = true ; WildcardType ( AST ast ) { } final List internalStructuralPropertiesForType ( int apiLevel ) { } final boolean internalGetSetBooleanProperty ( SimplePropertyDescriptor property , boolean get , boolean value ) { } final ASTNode internalGetSetChildProperty ( ChildPropertyDescriptor property , boolean get , ASTNode child ) { } final int getNodeType0 ( ) { } ASTNode clone0 ( AST target ) { WildcardType result = new WildcardType ( target ) ; <START_BUG> result . setSourceRange ( this . getStartPosition ( ) , this . getLength ( ) ) ; <END_BUG> result . setBound ( ( ( Type ) ( ASTNode . copySubtree ( target , getBound ( ) ) ) ) , isUpperBound ( ) ) ; return result ; } final boolean subtreeMatch0 ( ASTMatcher matcher , Object other ) { } void accept0 ( ASTVisitor visitor ) { } public boolean isUpperBound ( ) { } public Type getBound ( ) { } public void setBound ( Type type , boolean isUpperBound ) { } public void setBound ( Type type ) { } public void setUpperBound ( boolean isUpperBound ) { } int memSize ( ) { } int treeSize ( ) { } } 
class ProcessDestroyer implements Runnable { private Vector processes = new Vector ( ) ; private Method addShutdownHookMethod ; private Method removeShutdownHookMethod ; private ProcessDestroyer . ProcessDestroyerImpl destroyProcessThread = null ; private boolean added = false ; private class ProcessDestroyerImpl extends Thread { private boolean shouldDestroy = true ; public ProcessDestroyerImpl ( ) { } public void run ( ) { } public void setShouldDestroy ( boolean shouldDestroy ) { } } public ProcessDestroyer ( ) { } private void addShutdownHook ( ) { } private void removeShutdownHook ( ) { } public boolean isAddedAsShutdownHook ( ) { } public boolean add ( Process process ) { } public boolean remove ( Process process ) { synchronized ( processes ) { boolean processRemoved = processes . removeElement ( process ) ; if ( ( processes . size ( ) ) == 0 ) { <START_BUG> processes . notify ( ) ; <END_BUG> removeShutdownHook ( ) ; } return processRemoved ; } } public void run ( ) { } } 
public class QuickVerificationCommand extends AbstractHandler { private String signatureId ; private boolean preferencesComplete = false ; private ExecutionEvent event ; private IFile file = null ; public Object execute ( ExecutionEvent event ) throws ExecutionException { } private void createVerification ( ) throws Exception { VerifySignature verify = new VerifySignature ( ) ; ArrayList < VerificationResult > results = new ArrayList < VerificationResult > ( ) ; if ( ( HandlerUtil . getActivePart ( event ) ) instanceof IEditorPart ) { final IEditorPart editorPart = ( ( IEditorPart ) ( HandlerUtil . getActivePart ( event ) ) ) ; if ( editorPart . isDirty ( ) ) { if ( ( null != ( editorPart . getTitle ( ) ) ) && ( ( editorPart . getTitle ( ) . length ( ) ) > 0 ) ) { IRunnableWithProgress op = new IRunnableWithProgress ( ) { public void run ( final IProgressMonitor monitor ) { editorPart . doSave ( monitor ) ; } } ; try { PlatformUI . getWorkbench ( ) . getProgressService ( ) . runInUI ( XSTUIPlugin . getActiveWorkbenchWindow ( ) , op , ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ) ; } catch ( InvocationTargetException ite ) { Utils . log ( "Error<seq2seq4repair_space>while<seq2seq4repair_space>saving<seq2seq4repair_space>editor<seq2seq4repair_space>content" , ite ) ; } catch ( InterruptedException ie ) { Utils . log ( "Error<seq2seq4repair_space>while<seq2seq4repair_space>saving<seq2seq4repair_space>editor<seq2seq4repair_space>content" , ie ) ; } } else { editorPart . doSaveAs ( ) ; } } file = ( ( IFile ) ( editorPart . getEditorInput ( ) . getAdapter ( IFile . class ) ) ) ; } else { ISelection selection = HandlerUtil . getCurrentSelection ( event ) ; if ( selection instanceof IStructuredSelection ) { file = ( ( IFile ) ( ( ( IStructuredSelection ) ( selection ) ) . getFirstElement ( ) ) ) ; } } if ( ( ( file ) != null ) && ( file . isAccessible ( ) ) ) { results = verify . verify ( file . getLocation ( ) . toString ( ) , signatureId ) ; } else { MessageDialog . openInformation ( HandlerUtil . getActiveShell ( event ) , QuickVerificationCommand_0 , NLS . bind ( RemoveReadOnlyFlag , QuickVerificationCommand_5 ) ) ; } if ( ( results . size ( ) ) == 1 ) { VerificationResult result = ( ( VerificationResult ) ( results . get ( 0 ) ) ) ; if ( ( result . getSignature ( ) ) != null ) { <START_BUG> Verification . showVerificationResult ( result , HandlerUtil . getActiveShell ( event ) ) ; <END_BUG> } else { MessageDialog . openError ( HandlerUtil . getActiveShell ( event ) , QuickVerificationCommand_0 , NLS . bind ( QuickVerificationCommand_4 , signatureId ) ) ; } } else { MessageDialog . openError ( HandlerUtil . getActiveShell ( event ) , QuickVerificationCommand_0 , NLS . bind ( QuickVerificationCommand_4 , signatureId ) ) ; } } private void getPreferenceValues ( ) { } private boolean checkPreferences ( ) { } } 
public class JMXProtocolPackager implements DeploymentPackager { private static final List < String > defaultDependencies = new ArrayList < String > ( ) ; private static final Logger log = Logger . getLogger ( JMXProtocolPackager . class ) ; private ServiceArchiveHolder archiveHolder ; JMXProtocolPackager ( ServiceArchiveHolder archiveHolder ) { } @ Override public Archive < ? > generateDeployment ( TestDeployment testDeployment , Collection < ProtocolArchiveProcessor > protocolProcessors ) { } private JavaArchive generateArquillianServiceArchive ( Collection < Archive < ? > > auxArchives ) throws Exception { final JavaArchive archive = ShrinkWrap . create ( JavaArchive . class , "arquillian-service" ) ; JMXProtocolPackager . log . debugf ( "Generating:<seq2seq4repair_space>%s" , archive . getName ( ) ) ; archive . addPackage ( ArquillianService . class . getPackage ( ) ) ; archive . addPackage ( AbstractJMXProtocol . class . getPackage ( ) ) ; archive . addClasses ( ServerSetup . class , ServerSetupTask . class , ManagementClient . class , Authentication . class , NetworkUtils . class ) ; final Set < ModuleIdentifier > archiveDependencies = new LinkedHashSet < ModuleIdentifier > ( ) ; archiveDependencies . add ( ModuleIdentifier . create ( "org.jboss.as.jmx" ) ) ; archiveDependencies . add ( ModuleIdentifier . create ( "org.jboss.as.server" ) ) ; archiveDependencies . add ( ModuleIdentifier . create ( "org.jboss.as.controller-client" ) ) ; archiveDependencies . add ( ModuleIdentifier . create ( "org.jboss.jandex" ) ) ; archiveDependencies . add ( ModuleIdentifier . create ( "org.jboss.logging" ) ) ; archiveDependencies . add ( ModuleIdentifier . create ( "org.jboss.modules" ) ) ; archiveDependencies . add ( ModuleIdentifier . create ( "org.jboss.dmr" ) ) ; archiveDependencies . add ( ModuleIdentifier . create ( "org.jboss.msc" ) ) ; archiveDependencies . add ( ModuleIdentifier . create ( "org.osgi.core" ) ) ; archiveDependencies . add ( ModuleIdentifier . create ( "org.wildfly.security.manager" ) ) ; final Set < String > loadableExtensions = new HashSet < String > ( ) ; final String loadableExtensionsPath = "META-INF/services/" + ( RemoteLoadableExtension . class . getName ( ) ) ; for ( Archive < ? > aux : auxArchives ) { Node node = aux . get ( loadableExtensionsPath ) ; if ( node != null ) { BufferedReader br = new BufferedReader ( new InputStreamReader ( node . getAsset ( ) . openStream ( ) ) ) ; String line = br . readLine ( ) ; while ( line != null ) { loadableExtensions . add ( line ) ; ClassLoader classLoader = getClass ( ) . getClassLoader ( ) ; Object extension = classLoader . loadClass ( line ) . newInstance ( ) ; if ( extension instanceof DependenciesProvider ) { DependenciesProvider provider = ( ( DependenciesProvider ) ( extension ) ) ; archiveDependencies . addAll ( provider . getDependencies ( ) ) ; } line = br . readLine ( ) ; } } JMXProtocolPackager . log . debugf ( "Merging<seq2seq4repair_space>archive:<seq2seq4repair_space>%s" , aux ) ; archive . merge ( aux ) ; } loadableExtensions . add ( JMXProtocolEndpointExtension . class . getName ( ) ) ; loadableExtensions . add ( InContainerManagementClientExtension . class . getName ( ) ) ; archive . setManifest ( new Asset ( ) { public InputStream openStream ( ) { ManifestBuilder builder = ManifestBuilder . newInstance ( ) ; Iterator < ModuleIdentifier > itdep = archiveDependencies . iterator ( ) ; StringBuffer depspec = new StringBuffer ( ( "" + ( itdep . next ( ) ) ) ) ; while ( itdep . hasNext ( ) ) { depspec . append ( ( "," + ( itdep . next ( ) ) ) ) ; } builder . addManifestHeader ( "Dependencies" , depspec . toString ( ) ) ; return builder . openStream ( ) ; } } ) ; String serviceActivatorPath = "META-INF/services/" + ( ServiceActivator . class . getName ( ) ) ; final URL serviceActivatorURL = this . getClass ( ) . getClassLoader ( ) . getResource ( ( "arquillian-service/" + serviceActivatorPath ) ) ; if ( serviceActivatorURL == null ) { throw new RuntimeException ( ( ( ( "No<seq2seq4repair_space>arquillian-service/" + serviceActivatorPath ) + "<seq2seq4repair_space>found<seq2seq4repair_space>by<seq2seq4repair_space>classloader:<seq2seq4repair_space>" ) + ( this . getClass ( ) . getClassLoader ( ) ) ) ) ; } archive . addAsResource ( new UrlAsset ( serviceActivatorURL ) , serviceActivatorPath ) ; archive . addAsResource ( new Asset ( ) { public InputStream openStream ( ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { Properties props = new Properties ( ) ; props . setProperty ( Constants . BUNDLE_SYMBOLICNAME , "arquillian-service" ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( "org.jboss.arquillian.container.test.api,org.jboss.arquillian.junit," ) ; builder . append ( "org.jboss.arquillian.osgi,org.jboss.arquillian.test.api," ) ; <START_BUG> builder . append ( "org.jboss.as.arquillian.api,org.jboss.as.arquillian.container,org.jboss.as.osgi," ) ; <END_BUG> builder . append ( "org.jboss.shrinkwrap.api,org.jboss.shrinkwrap.api.asset,org.jboss.shrinkwrap.api.spec," ) ; builder . append ( "org.junit,org.junit.runner" ) ; props . setProperty ( Constants . EXPORT_PACKAGE , builder . toString ( ) ) ; props . store ( baos , null ) ; } catch ( IOException ex ) { throw new IllegalStateException ( "Cannot<seq2seq4repair_space>write<seq2seq4repair_space>osgi<seq2seq4repair_space>metadata" , ex ) ; } return new ByteArrayInputStream ( baos . toByteArray ( ) ) ; } } , "META-INF/jbosgi-xservice.properties" ) ; archive . delete ( ArchivePaths . create ( loadableExtensionsPath ) ) ; archive . addAsResource ( new Asset ( ) { @ Override public InputStream openStream ( ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( baos ) ) ; for ( String line : loadableExtensions ) { pw . println ( line ) ; } pw . close ( ) ; return new ByteArrayInputStream ( baos . toByteArray ( ) ) ; } } , loadableExtensionsPath ) ; JMXProtocolPackager . log . debugf ( "Loadable<seq2seq4repair_space>extensions:<seq2seq4repair_space>%s" , loadableExtensions ) ; JMXProtocolPackager . log . tracef ( "Archive<seq2seq4repair_space>content:<seq2seq4repair_space>%s\n%s" , archive , archive . toString ( true ) ) ; return archive ; } private void addModulesManifestDependencies ( Archive < ? > appArchive ) { } } 
public class OverseerCollectionProcessor implements Runnable , ClosableThread { public static final String NUM_SLICES = "numShards" ; public static final String REPLICATION_FACTOR = "replicationFactor" ; public static final String MAX_SHARDS_PER_NODE = "maxShardsPerNode" ; public static final String CREATE_NODE_SET = "createNodeSet" ; public static final String DELETECOLLECTION = "deletecollection" ; public static final String CREATECOLLECTION = "createcollection" ; public static final String RELOADCOLLECTION = "reloadcollection" ; private static final String QUEUE_OPERATION = "operation" ; private static Logger log = LoggerFactory . getLogger ( OverseerCollectionProcessor . class ) ; private DistributedQueue workQueue ; private String myId ; private ShardHandler shardHandler ; private String adminPath ; private ZkStateReader zkStateReader ; private boolean isClosed ; public OverseerCollectionProcessor ( ZkStateReader zkStateReader , String myId , ShardHandler shardHandler , String adminPath ) { } protected OverseerCollectionProcessor ( ZkStateReader zkStateReader , String myId , ShardHandler shardHandler , String adminPath , DistributedQueue workQueue ) { } @ Override public void run ( ) { } public void close ( ) { } protected boolean amILeader ( ) { } protected SolrResponse processMessage ( ZkNodeProps message , String operation ) { NamedList results = new NamedList ( ) ; try { if ( OverseerCollectionProcessor . CREATECOLLECTION . equals ( operation ) ) { createCollection ( zkStateReader . getClusterState ( ) , message ) ; } else if ( OverseerCollectionProcessor . DELETECOLLECTION . equals ( operation ) ) { ModifiableSolrParams params = new ModifiableSolrParams ( ) ; params . set ( ACTION , UNLOAD . toString ( ) ) ; params . set ( DELETE_INSTANCE_DIR , true ) ; collectionCmd ( zkStateReader . getClusterState ( ) , message , params ) ; } else if ( OverseerCollectionProcessor . RELOADCOLLECTION . equals ( operation ) ) { ModifiableSolrParams params = new ModifiableSolrParams ( ) ; params . set ( ACTION , RELOAD . toString ( ) ) ; collectionCmd ( zkStateReader . getClusterState ( ) , message , params ) ; } else { throw new SolrException ( ErrorCode . BAD_REQUEST , ( "Unknow<seq2seq4repair_space>the<seq2seq4repair_space>operation:" + operation ) ) ; } int failed = 0 ; ShardResponse srsp ; do { srsp = shardHandler . takeCompletedIncludingErrors ( ) ; if ( srsp != null ) { Throwable e = srsp . getException ( ) ; if ( e != null ) { failed ++ ; OverseerCollectionProcessor . log . error ( ( "Error<seq2seq4repair_space>talking<seq2seq4repair_space>to<seq2seq4repair_space>shard:<seq2seq4repair_space>" + ( srsp . getShard ( ) ) ) , e ) ; results . add ( srsp . getShard ( ) , e ) ; } else { results . add ( srsp . getShard ( ) , srsp . getSolrResponse ( ) . getResponse ( ) ) ; } } } while ( srsp != null ) ; } catch ( SolrException ex ) { SolrException . log ( OverseerCollectionProcessor . log , ( ( ( ( "Collection<seq2seq4repair_space>" + operation ) + "<seq2seq4repair_space>of<seq2seq4repair_space>" ) + operation ) + "<seq2seq4repair_space>failed" ) ) ; <START_BUG> results . add ( ( ( "Operation<seq2seq4repair_space>" + operation ) + "<seq2seq4repair_space>cause<seq2seq4repair_space>exception:" ) , ex ) ; <END_BUG> } finally { return new OverseerSolrResponse ( results ) ; } } private boolean createCollection ( ClusterState clusterState , ZkNodeProps message ) { } private boolean collectionCmd ( ClusterState clusterState , ZkNodeProps message , ModifiableSolrParams params ) { } private int msgStrToInt ( ZkNodeProps message , String key , Integer def ) throws Exception { } @ Override public boolean isClosed ( ) { } } 
public class OutputAttribute extends ProjectComponent { public static final String STDOUT = "stdout" ; public static final String STDERR = "stderr" ; protected String value ; public OutputAttribute ( String value ) { } public OutputStream getOutputStream ( ) { if ( OutputAttribute . STDOUT . equals ( value ) ) { return new KeepAliveOutputStream ( System . out ) ; } else if ( OutputAttribute . STDERR . equals ( value ) ) { return new KeepAliveOutputStream ( System . err ) ; } <START_BUG> File f = project . resolveFile ( value ) ; <END_BUG> try { return new FileOutputStream ( f ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } 
public class LookAndFeelCommand implements Command { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final String JMETER_LAF = "jmeter.laf" ; private static final Set < String > commands = new HashSet < String > ( ) ; private static String getJMeterLaf ( ) { } private static String checkLafName ( String laf ) { } public LookAndFeelCommand ( ) { } public void doAction ( ActionEvent ev ) { try { <START_BUG> String className = ev . getActionCommand ( ) . substring ( 4 ) . replace ( '/' , '.' ) ; <END_BUG> UIManager . setLookAndFeel ( className ) ; SwingUtilities . updateComponentTreeUI ( GuiPackage . getInstance ( ) . getMainFrame ( ) ) ; } catch ( UnsupportedLookAndFeelException e ) { JMeterUtils . reportErrorToUser ( ( "Look<seq2seq4repair_space>and<seq2seq4repair_space>Feel<seq2seq4repair_space>unavailable:" + ( e . toString ( ) ) ) ) ; } catch ( InstantiationException e ) { JMeterUtils . reportErrorToUser ( ( "Look<seq2seq4repair_space>and<seq2seq4repair_space>Feel<seq2seq4repair_space>unavailable:" + ( e . toString ( ) ) ) ) ; } catch ( ClassNotFoundException e ) { JMeterUtils . reportErrorToUser ( ( "Look<seq2seq4repair_space>and<seq2seq4repair_space>Feel<seq2seq4repair_space>unavailable:" + ( e . toString ( ) ) ) ) ; } catch ( IllegalAccessException e ) { JMeterUtils . reportErrorToUser ( ( "Look<seq2seq4repair_space>and<seq2seq4repair_space>Feel<seq2seq4repair_space>unavailable:" + ( e . toString ( ) ) ) ) ; } } public Set < String > getActionNames ( ) { } } 
public class SSLTest extends BaseJDBCTestCase { private InputStream [ ] _inputStreamHolder ; private NetworkServerTestSetup nsTestSetup ; public SSLTest ( String testName ) { } public static Test suite ( ) { } protected void tearDown ( ) throws Exception { } private static Test decorateTest ( String testName ) { } private static String [ ] getStartupProperties ( ) { } public void testSSLBasicDSConnect ( ) throws Exception { } public void testSSLBasicDSPlainConnect ( ) throws Exception { DataSource ds = JDBCDataSource . getDataSource ( ) ; JDBCDataSource . setBeanProperty ( ds , "createDatabase" , "create" ) ; try { Connection c2 = ds . getConnection ( ) ; c2 . close ( ) ; fail ( ) ; } catch ( SQLException e ) { <START_BUG> assertSQLState ( "58009" , e ) ; <END_BUG> } } } 
public final class TagTypeHandler extends AbstractMarkupFilter { private final ArrayListStack < ComponentTag > stack = new ArrayListStack < ComponentTag > ( ) ; private static final Map < String , Boolean > requireOpenBodyCloseTag = new HashMap < String , Boolean > ( ) ; public TagTypeHandler ( final IMarkupFilter parent ) { } public MarkupElement nextTag ( ) throws ParseException { while ( ( stack . size ( ) ) > 0 ) { final ComponentTag top = stack . pop ( ) ; return top ; } final ComponentTag tag = nextComponentTag ( ) ; if ( tag == null ) { return tag ; } if ( tag . isOpenClose ( ) ) { String name = tag . getName ( ) ; if ( ( tag . getNamespace ( ) ) != null ) { name = ( ( tag . getNamespace ( ) ) + ":" ) + ( tag . getName ( ) ) ; } if ( TagTypeHandler . requiresOpenBodyCloseTag ( name ) ) { tag . setType ( OPEN ) ; <START_BUG> XmlTag closeTag = new XmlTag ( ) ; <END_BUG> closeTag . setType ( CLOSE ) ; closeTag . setName ( tag . getName ( ) ) ; closeTag . setNamespace ( tag . getNamespace ( ) ) ; closeTag . closes ( tag ) ; stack . push ( new ComponentTag ( closeTag ) ) ; } } return tag ; } public static boolean requiresOpenBodyCloseTag ( final String name ) { } } 
public class SolrDispatchFilter implements Filter { final Logger log = LoggerFactory . getLogger ( SolrDispatchFilter . class ) ; protected CoreContainer cores ; protected String pathPrefix = null ; protected String abortErrorMessage = null ; protected String solrConfigFilename = null ; protected final Map < SolrConfig , SolrRequestParsers > parsers = new WeakHashMap < SolrConfig , SolrRequestParsers > ( ) ; protected final SolrRequestParsers adminRequestParser ; private static final Charset UTF8 = Charset . forName ( "UTF-8" ) ; public SolrDispatchFilter ( ) { } public void init ( FilterConfig config ) throws ServletException { log . info ( "SolrDispatchFilter.init()" ) ; boolean abortOnConfigurationError = true ; CoreContainer . Initializer init = createInitializer ( ) ; try { this . pathPrefix = config . getInitParameter ( "path-prefix" ) ; init . setSolrConfigFilename ( config . getInitParameter ( "solrconfig-filename" ) ) ; this . cores = init . initialize ( ) ; abortOnConfigurationError = init . isAbortOnConfigurationError ( ) ; log . info ( ( "user.dir=" + ( System . getProperty ( "user.dir" ) ) ) ) ; } catch ( Throwable t ) { <START_BUG> log . error ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>start<seq2seq4repair_space>Solr.<seq2seq4repair_space>Check<seq2seq4repair_space>solr/home<seq2seq4repair_space>property" , t ) ; <END_BUG> severeErrors . add ( t ) ; SolrCore . log ( t ) ; } if ( abortOnConfigurationError && ( ( severeErrors . size ( ) ) > 0 ) ) { StringWriter sw = new StringWriter ( ) ; PrintWriter out = new PrintWriter ( sw ) ; out . println ( "Severe<seq2seq4repair_space>errors<seq2seq4repair_space>in<seq2seq4repair_space>solr<seq2seq4repair_space>configuration.\n" ) ; out . println ( "Check<seq2seq4repair_space>your<seq2seq4repair_space>log<seq2seq4repair_space>files<seq2seq4repair_space>for<seq2seq4repair_space>more<seq2seq4repair_space>detailed<seq2seq4repair_space>information<seq2seq4repair_space>on<seq2seq4repair_space>what<seq2seq4repair_space>may<seq2seq4repair_space>be<seq2seq4repair_space>wrong.\n" ) ; out . println ( "If<seq2seq4repair_space>you<seq2seq4repair_space>want<seq2seq4repair_space>solr<seq2seq4repair_space>to<seq2seq4repair_space>continue<seq2seq4repair_space>after<seq2seq4repair_space>configuration<seq2seq4repair_space>errors,<seq2seq4repair_space>change:<seq2seq4repair_space>\n" ) ; out . println ( "<seq2seq4repair_space><abortOnConfigurationError>false</abortOnConfigurationError>\n" ) ; out . println ( ( ( "in<seq2seq4repair_space>" + ( init . getSolrConfigFilename ( ) ) ) + "\n" ) ) ; for ( Throwable t : SolrConfig . severeErrors ) { out . println ( "-------------------------------------------------------------" ) ; t . printStackTrace ( out ) ; } out . flush ( ) ; abortErrorMessage = sw . toString ( ) ; } log . info ( "SolrDispatchFilter.init()<seq2seq4repair_space>done" ) ; } protected Initializer createInitializer ( ) { } public void destroy ( ) { } public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { } private void handleAdminRequest ( HttpServletRequest req , ServletResponse response , SolrRequestHandler handler , SolrQueryRequest solrReq ) throws IOException { } private void writeResponse ( SolrQueryResponse solrRsp , ServletResponse response , QueryResponseWriter responseWriter , SolrQueryRequest solrReq , Method reqMethod ) throws IOException { } protected void execute ( HttpServletRequest req , SolrRequestHandler handler , SolrQueryRequest sreq , SolrQueryResponse rsp ) { } protected void sendError ( HttpServletResponse res , Throwable ex ) throws IOException { } public void setPathPrefix ( String pathPrefix ) { } public String getPathPrefix ( ) { } } 
public class BCodec extends RFC1522Codec implements StringDecoder , StringEncoder { private final String charset ; public BCodec ( ) { } public BCodec ( final String charset ) { } protected String getEncoding ( ) { } protected byte [ ] doEncoding ( byte [ ] bytes ) { } protected byte [ ] doDecoding ( byte [ ] bytes ) { } public String encode ( final String value , final String charset ) throws EncoderException { if ( value == null ) { return null ; } try { return encodeText ( value , charset ) ; } catch ( UnsupportedEncodingException e ) { <START_BUG> throw new EncoderException ( e . getMessage ( ) ) ; <END_BUG> } } public String encode ( String value ) throws EncoderException { } public String decode ( String value ) throws DecoderException { } public Object encode ( Object value ) throws EncoderException { } public Object decode ( Object value ) throws DecoderException { } public String getDefaultCharset ( ) { } } 
public class HttpManagementWriteAttributeHandler extends AbstractWriteAttributeHandler < Void > { private final LocalHostControllerInfoImpl hostControllerInfo ; private final HostControllerEnvironment environment ; public HttpManagementWriteAttributeHandler ( final LocalHostControllerInfoImpl hostControllerInfo , final HostControllerEnvironment environment ) { } @ Override protected boolean applyUpdateToRuntime ( OperationContext context , ModelNode operation , String attributeName , ModelNode resolvedValue , ModelNode currentValue , HandbackHolder < Void > handbackHolder ) throws OperationFailedException { } @ Override protected void revertUpdateToRuntime ( final OperationContext context , final ModelNode operation , final String attributeName , final ModelNode valueToRestore , final ModelNode valueToRevert , final Void handback ) throws OperationFailedException { } static void updateHttpManagementService ( final OperationContext context , final ModelNode subModel , final LocalHostControllerInfoImpl hostControllerInfo , final HostControllerEnvironment environment , final ServiceVerificationHandler verificationHandler ) throws OperationFailedException { HttpManagementRemoveHandler . removeHttpManagementService ( context ) ; HttpManagementAddHandler . populateHostControllerInfo ( hostControllerInfo , context , subModel ) ; <START_BUG> HttpManagementAddHandler . installHttpManagementServices ( context . getRunningMode ( ) , context . getServiceTarget ( ) , hostControllerInfo , environment , verificationHandler ) ; <END_BUG> } } 
public class ModuleContextProcessor implements DeploymentUnitProcessor { public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; if ( DeploymentTypeMarker . isType ( EAR , deploymentUnit ) ) { return ; } EEModuleDescription moduleDescription = deploymentUnit . getAttachment ( EE_MODULE_DESCRIPTION ) ; final ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; final ServiceName appContextServiceName = ContextNames . contextServiceNameOfApplication ( moduleDescription . getApplicationName ( ) ) ; final ServiceName moduleContextServiceName = ContextNames . contextServiceNameOfModule ( moduleDescription . getApplicationName ( ) , moduleDescription . getModuleName ( ) ) ; final NamingStoreService contextService = new NamingStoreService ( ) ; serviceTarget . addService ( moduleContextServiceName , contextService ) . install ( ) ; final BinderService moduleNameBinder = new BinderService ( "ModuleName" ) ; serviceTarget . addService ( moduleContextServiceName . append ( "ModuleName" ) , moduleNameBinder ) . addInjection ( moduleNameBinder . getManagedObjectInjector ( ) , new org . jboss . as . naming . ValueManagedReferenceFactory ( Values . immediateValue ( moduleDescription . getModuleName ( ) ) ) ) . addDependency ( moduleContextServiceName , ServiceBasedNamingStore . class , moduleNameBinder . getNamingStoreInjector ( ) ) . install ( ) ; deploymentUnit . putAttachment ( Attachments . MODULE_CONTEXT_CONFIG , moduleContextServiceName ) ; final InjectedEENamespaceContextSelector selector = new InjectedEENamespaceContextSelector ( ) ; phaseContext . addDependency ( appContextServiceName , NamingStore . class , selector . getAppContextInjector ( ) ) ; phaseContext . addDependency ( moduleContextServiceName , NamingStore . class , selector . getModuleContextInjector ( ) ) ; phaseContext . addDependency ( moduleContextServiceName , NamingStore . class , selector . getCompContextInjector ( ) ) ; phaseContext . addDependency ( JBOSS_CONTEXT_SERVICE_NAME , NamingStore . class , selector . getJbossContextInjector ( ) ) ; phaseContext . addDependency ( GLOBAL_CONTEXT_SERVICE_NAME , NamingStore . class , selector . getGlobalContextInjector ( ) ) ; moduleDescription . setNamespaceContextSelector ( selector ) ; final Set < ServiceName > serviceNames = new HashSet < ServiceName > ( ) ; serviceNames . add ( appContextServiceName ) ; serviceNames . add ( moduleContextServiceName ) ; serviceNames . add ( JBOSS_CONTEXT_SERVICE_NAME ) ; serviceNames . add ( GLOBAL_CONTEXT_SERVICE_NAME ) ; final JavaNamespaceSetup setupAction = new JavaNamespaceSetup ( selector , serviceTarget ) ; deploymentUnit . addToAttachmentList ( org . jboss . as . server . deployment . Attachments . SETUP_ACTIONS , setupAction ) ; <START_BUG> deploymentUnit . addToAttachmentList ( EE_SETUP_ACTIONS , setupAction ) ; <END_BUG> } public void undeploy ( DeploymentUnit context ) { } } 
public class HttpRequestHdr { Logger log = LoggingManager . getLoggerFor ( HTTP ) ; public String method = new String ( ) ; public String url = new String ( ) ; public String version = new String ( ) ; public String postData = "" ; static String CR = "\r\n" ; private Map headers = new HashMap ( ) ; public byte [ ] parse ( InputStream in ) throws IOException { } public void parseFirstLine ( String firstLine ) { } public int parseLine ( String nextLine ) { } public HeaderManager getHeaderManager ( ) { HeaderManager manager = new HeaderManager ( ) ; Iterator keys = headers . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { String key = ( ( String ) ( keys . next ( ) ) ) ; <START_BUG> if ( ( ( ! ( key . equals ( "proxy-connection" ) ) ) && ( ! ( key . equals ( "content-length" ) ) ) ) && ( ! ( key . equals ( "accept-encoding" ) ) ) ) { <END_BUG> manager . add ( ( ( Header ) ( headers . get ( key ) ) ) ) ; } } manager . setName ( "Browser-derived<seq2seq4repair_space>headers" ) ; manager . setProperty ( TEST_CLASS , HeaderManager . class . getName ( ) ) ; manager . setProperty ( GUI_CLASS , HeaderPanel . class . getName ( ) ) ; return manager ; } public HTTPSampler getSampler ( ) throws IOException , MalformedURLException , ProtocolException { } public String getContentType ( ) { } public static MultipartUrlConfig isMultipart ( String contentType ) { } private HTTPSampler createSampler ( ) { } public String serverName ( ) { } public int serverPort ( ) { } public String serverUrl ( ) { } String getToken ( StringTokenizer tk ) { } String getRemainder ( StringTokenizer tk ) { } public static class Test extends TestCase { public Test ( String name ) { } public void setUp ( ) { } public void testRepeatedArguments ( ) throws Exception { } } } 
public class SaveAttachmentCommand extends FolderCommand { File tempFile = null ; MimePart part ; static File lastDir = null ; public SaveAttachmentCommand ( DefaultCommandReference [ ] references ) { } public void updateGUI ( ) throws Exception { } public void execute ( Worker worker ) throws Exception { FolderCommandReference [ ] r = ( ( FolderCommandReference [ ] ) ( getReferences ( ) ) ) ; Folder folder = ( ( Folder ) ( r [ 0 ] . getFolder ( ) ) ) ; Object [ ] uids = r [ 0 ] . getUids ( ) ; Integer [ ] address = r [ 0 ] . getAddress ( ) ; <START_BUG> part = folder . getMimePart ( uids [ 0 ] , address , worker ) ; <END_BUG> String fileName = part . getHeader ( ) . getContentParameter ( "name" ) ; if ( fileName == null ) fileName = part . getHeader ( ) . getDispositionParameter ( "filename" ) ; cFileChooser fileChooser ; if ( ( SaveAttachmentCommand . lastDir ) == null ) fileChooser = new cFileChooser ( ) ; else fileChooser = new cFileChooser ( SaveAttachmentCommand . lastDir ) ; cFileFilter fileFilter = new cFileFilter ( ) ; fileFilter . acceptFilesWithProperty ( FILEPROPERTY_FILE ) ; fileChooser . setDialogTitle ( "Save<seq2seq4repair_space>Attachment<seq2seq4repair_space>as<seq2seq4repair_space>..." ) ; if ( fileName != null ) fileChooser . forceSelectedFile ( new File ( fileName ) ) ; fileChooser . setSelectFilter ( fileFilter ) ; while ( true ) { if ( ( fileChooser . showSaveDialog ( null ) ) != ( JFileChooser . APPROVE_OPTION ) ) { return ; } tempFile = fileChooser . getSelectedFile ( ) ; SaveAttachmentCommand . lastDir = tempFile . getParentFile ( ) ; if ( tempFile . exists ( ) ) { if ( ( JOptionPane . showConfirmDialog ( null , "Overwrite<seq2seq4repair_space>File?" , "Warning" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ) == ( JOptionPane . YES_OPTION ) ) { break ; } } else { break ; } } Decoder decoder ; MimeHeader header ; header = part . getHeader ( ) ; try { decoder = CoderRouter . getDecoder ( header . contentTransferEncoding ) ; decoder . decode ( new ByteArrayInputStream ( part . getBody ( ) . getBytes ( "ISO_8859_1" ) ) , new FileOutputStream ( tempFile ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } } 
public class ContactGenerator { private static ContactGenerator instance = new ContactGenerator ( ) ; private static long nextId = 1 ; public static ContactGenerator getInstance ( ) { } private final String [ ] firstNames = new String [ ] { "Jacob" , "Emily" , "Michael" , "Sarah" , "Matthew" , "Brianna" , "Nicholas" , "Samantha" , "Christopher" , "Hailey" , "Abner" , "Abby" , "Joshua" , "Douglas" , "Jack" , "Keith" , "Gerald" , "Samuel" , "Willie" , "Larry" , "Jose" , "Timothy" , "Sandra" , "Kathleen" , "Pamela" , "Virginia" , "Debra" , "Maria" , "Linda" } ; private final String [ ] lastNames = new String [ ] { "Smiith" , "Johnson" , "Williams" , "Jones" , "Brown" , "Donahue" , "Bailey" , "Rose" , "Allen" , "Black" , "Davis" , "Clark" , "Hall" , "Lee" , "Baker" , "Gonzalez" , "Nelson" , "Moore" , "Wilson" , "Graham" , "Fisher" , "Cruz" , "Ortiz" , "Gomez" , "Murray" } ; private ContactGenerator ( ) { } public synchronized long generateId ( ) { } public Contact generate ( ) { } public void generate ( Collection < Contact > collection , int count ) { } private String generatePhoneNumber ( ) { <START_BUG> return new StringBuffer ( ) . append ( rint ( 2 , 9 ) ) . append ( rint ( 0 , 9 ) ) . append ( rint ( 0 , 9 ) ) . append ( "-555-" ) . append ( rint ( 1 , 9 ) ) . append ( rint ( 0 , 9 ) ) . append ( rint ( 0 , 9 ) ) . append ( rint ( 0 , 9 ) ) . toString ( ) ; <END_BUG> } private int rint ( int min , int max ) { } private String randomString ( String [ ] choices ) { } } 
public class AutoWebApp extends BaseInterceptor { int debug = 0 ; Hashtable hosts = new Hashtable ( ) ; String appsD = "webapps" ; String defaultHost = null ; boolean flat = true ; char hostSeparator = '@' ; char dotReplacement = '_' ; char slashReplacement = '_' ; public AutoWebApp ( ) { } public void setDir ( String d ) { } public void setHost ( String h ) { } public void setFlat ( boolean b ) { } public void engineInit ( ContextManager cm ) throws TomcatException { } private void addWebApp ( ContextManager cm , File dir , String host , String name ) throws TomcatException { host = unEscapeHost ( host ) ; if ( host == null ) host = "DEFAULT" ; String path = "/" + ( unEscapePath ( name ) ) ; log ( ( ( ( ( ( "Auto-Adding<seq2seq4repair_space>" + name ) + "<seq2seq4repair_space>" ) + host ) + "<seq2seq4repair_space>" ) + path ) ) ; if ( path . equals ( "/ROOT" ) ) path = "" ; Hashtable loaded = ( ( Hashtable ) ( hosts . get ( host ) ) ) ; <START_BUG> if ( ( loaded . get ( path ) ) != null ) { <END_BUG> log ( "Already<seq2seq4repair_space>loaded" ) ; return ; } if ( dir . isDirectory ( ) ) { Context ctx = new Context ( ) ; ctx . setContextManager ( cm ) ; ctx . setPath ( path ) ; if ( ! ( "DEFAULT" . equals ( host ) ) ) ctx . setHost ( host ) ; try { ctx . setDocBase ( dir . getCanonicalPath ( ) ) ; } catch ( IOException ex ) { ctx . setDocBase ( dir . getAbsolutePath ( ) ) ; } if ( ( debug ) > 0 ) log ( ( ( ( ( ( "automatic<seq2seq4repair_space>add<seq2seq4repair_space>" + host ) + ":" ) + ( ctx . toString ( ) ) ) + "<seq2seq4repair_space>" ) + path ) ) ; cm . addContext ( ctx ) ; } else { log ( ( "Not<seq2seq4repair_space>a<seq2seq4repair_space>dir<seq2seq4repair_space>" + ( dir . getAbsolutePath ( ) ) ) ) ; } } private void addVHost ( ContextManager cm , File dir , String host ) throws TomcatException { } private String unEscapeHost ( String hostName ) { } private String unEscapePath ( String pathDir ) { } private String unEscapeString ( String s , char esc , char repl ) { } } 
public class LocalizerTest extends WicketTestCase { private IResourceSettings settings ; private Localizer localizer ; public LocalizerTest ( String message ) { } @ Override protected void setUp ( ) throws Exception { } public void testGetStringValidString ( ) { } public void testGetStringMissingStringReturnDefault ( ) { } public void testGetStringMissingStringNoDefault ( ) { } public void testGetStringMissingStringDoNotUseDefault ( ) { } public void testGetStringMissingStringExceptionThrown ( ) { } public void testGetStringPropertySubstitution ( ) { } public void testInComponentConstructor ( ) { <START_BUG> new LocalizerTest . MyLabel ( new EmptyPage ( ) , "myLabel" ) ; <END_BUG> } public void testTwoComponents ( ) { } public static class MyLabel extends Label { private static final long serialVersionUID = 1L ; public MyLabel ( MarkupContainer parent , final String id ) { } } } 
public class GammaTest extends TestCase { public GammaTest ( String name ) { } private void testRegularizedGamma ( double expected , double a , double x ) { } private void testLogGamma ( double expected , double x ) { <START_BUG> double actual = Gamma . logGamma ( x , 1.0E-4 , Integer . MAX_VALUE ) ; <END_BUG> TestUtils . assertEquals ( expected , actual , 1.0E-4 ) ; } public void testRegularizedGammaNanPositive ( ) { } public void testRegularizedGammaPositiveNan ( ) { } public void testRegularizedGammaNegativePositive ( ) { } public void testRegularizedGammaPositiveNegative ( ) { } public void testRegularizedGammaZeroPositive ( ) { } public void testRegularizedGammaPositiveZero ( ) { } public void testRegularizedGammaPositivePositive ( ) { } public void testLogGammaNan ( ) { } public void testLogGammaNegative ( ) { } public void testLogGammaZero ( ) { } public void testLogGammaPositive ( ) { } } 
public abstract class ParentNode extends NodeImpl { static final long serialVersionUID = 2815829867152120872L ; protected DocumentImpl ownerDocument ; protected ChildNode firstChild = null ; protected int changes = 0 ; protected transient int nodeListLength = - 1 ; protected transient ChildNode nodeListNode ; protected transient int nodeListIndex = - 1 ; protected ParentNode ( DocumentImpl ownerDocument ) { } public ParentNode ( ) { } public Node cloneNode ( boolean deep ) { } public Document getOwnerDocument ( ) { } DocumentImpl ownerDocument ( ) { } void setOwnerDocument ( DocumentImpl doc ) { } public boolean hasChildNodes ( ) { } public NodeList getChildNodes ( ) { } public Node getFirstChild ( ) { } public Node getLastChild ( ) { } final ChildNode lastChild ( ) { } final void lastChild ( ChildNode node ) { } public Node insertBefore ( Node newChild , Node refChild ) throws DOMException { } Node internalInsertBefore ( Node newChild , Node refChild , int mutationMask ) throws DOMException { } public Node removeChild ( Node oldChild ) throws DOMException { } Node internalRemoveChild ( Node oldChild , int mutationMask ) throws DOMException { } public Node replaceChild ( Node newChild , Node oldChild ) throws DOMException { } public int getLength ( ) { } public Node item ( int index ) { } public void normalize ( ) { } public void setReadOnly ( boolean readOnly , boolean deep ) { } protected void changed ( ) { } protected int changes ( ) { } protected void synchronizeChildren ( ) { } protected final void synchronizeChildren ( int nodeIndex ) { } private void writeObject ( ObjectOutputStream out ) throws IOException { <START_BUG> if ( syncChildren ( ) ) { <END_BUG> synchronizeChildren ( ) ; } out . defaultWriteObject ( ) ; } private void readObject ( ObjectInputStream ois ) throws IOException , ClassNotFoundException { } } 
public abstract class QueryNodeImpl implements Cloneable , QueryNode { public static final String PLAINTEXT_FIELD_NAME = "_plain" ; private boolean isLeaf = true ; private Hashtable < String , Object > tags = new Hashtable < String , Object > ( ) ; private List < QueryNode > clauses = null ; protected void allocate ( ) { } public final void add ( QueryNode child ) { } public final void add ( List < QueryNode > children ) { } public boolean isLeaf ( ) { } public final void set ( List < QueryNode > children ) { } public QueryNode cloneTree ( ) throws CloneNotSupportedException { } @ Override public Object clone ( ) throws CloneNotSupportedException { } protected void setLeaf ( boolean isLeaf ) { } public final List < QueryNode > getChildren ( ) { } public void setTag ( String tagName , Object value ) { } public void unsetTag ( String tagName ) { } public boolean containsTag ( String tagName ) { <START_BUG> return this . tags . containsKey ( tagName ) ; <END_BUG> } public Object getTag ( String tagName ) { } private QueryNode parent = null ; private void setParent ( QueryNode parent ) { } public QueryNode getParent ( ) { } protected boolean isRoot ( ) { } protected boolean toQueryStringIgnoreFields = false ; protected boolean isDefaultField ( CharSequence fld ) { } @ Override public String toString ( ) { } @ SuppressWarnings ( "unchecked" ) public Map < String , Object > getTagMap ( ) { } } 
public class UMLAction extends AbstractAction { protected static Category cat = Category . getInstance ( UMLAction . class ) ; public static boolean HAS_ICON = true ; public static boolean NO_ICON = false ; public UMLAction ( String name ) { } public UMLAction ( String name , boolean hasIcon ) { } public UMLAction ( String name , boolean global , boolean hasIcon ) { } public void actionPerformed ( ActionEvent e ) { } public void markNeedsSave ( ) { if ( ( ProjectBrowser . TheInstance ) != null ) { <START_BUG> Project p = TheInstance . getProject ( ) ; <END_BUG> if ( p != null ) { p . setNeedsSave ( true ) ; } } } public void updateEnabled ( Object target ) { } public void updateEnabled ( ) { } public boolean shouldBeEnabled ( ) { } protected static String stripJunk ( String s ) { } public static final KeyStroke getShortcut ( String key ) { } public static final String getMnemonic ( String key ) { } public boolean isEnabled ( ) { } } 
final class Persistence { static final String PACKAGE_BASE = "activities" ; static final String PACKAGE_FULL = "org.eclipse.ui." + ( Persistence . PACKAGE_BASE ) ; static final String TAG_ACTIVITY_BINDING = "activityBinding" ; static final String TAG_ACTIVITY_ID = "activityId" ; static final String TAG_DESCRIPTION = "description" ; static final String TAG_ID = "id" ; static final String TAG_NAME = "name" ; static final String TAG_PARENT_ID = "parentId" ; static final String TAG_PATTERN = "pattern" ; static final String TAG_PLUGIN_ID = "pluginId" ; static final String TAG_ACTIVITY = "activity" ; static IActivityPatternBindingDefinition readActivityBindingDefinition ( IMemento memento , String pluginIdOverride ) { if ( memento == null ) throw new NullPointerException ( ) ; String activityId = memento . getString ( Persistence . TAG_ACTIVITY_ID ) ; String pluginId = ( pluginIdOverride != null ) ? pluginIdOverride : memento . getString ( Persistence . TAG_PLUGIN_ID ) ; String pattern = memento . getString ( Persistence . TAG_PATTERN ) ; <START_BUG> return new ActivityPatternBindingDefinition ( activityId , pluginId , activityId ) ; <END_BUG> } static List readActivityBindingDefinitions ( IMemento memento , String name , String pluginIdOverride ) { } static IActivityDefinition readActivityDefinition ( IMemento memento , String pluginIdOverride ) { } static List readActivityDefinitions ( IMemento memento , String name , String pluginIdOverride ) { } static void writeActivityBindingDefinition ( IMemento memento , IActivityPatternBindingDefinition activityBindingDefinition ) { } static void writeActivityBindingDefinitions ( IMemento memento , String name , List activityBindingDefinitions ) { } static void writeActivityDefinition ( IMemento memento , IActivityDefinition activityDefinition ) { } static void writeActivityDefinitions ( IMemento memento , String name , List activityDefinitions ) { } private Persistence ( ) { } } 
public class FileUploadFieldTest extends WicketTestCase { public FileUploadFieldTest ( ) { } public void testInternalDetach ( ) throws Exception { final MockPageWithFormAndUploadField page = new MockPageWithFormAndUploadField ( ) ; FileUploadField field = new FileUploadField ( page . getForm ( ) , "upload" ) ; tester . startPage ( new ITestPageSource ( ) { private static final long serialVersionUID = 1L ; public Page getTestPage ( ) { return page ; } } ) ; RequestCycle requestCycle = tester . createRequestCycle ( ) ; MockHttpServletRequest servletRequest = tester . getServletRequest ( ) ; servletRequest . setMethod ( "POST" ) ; servletRequest . setParameter ( "form2:hf:fs" , "" ) ; servletRequest . setParameter ( "wicketState" , "" ) ; servletRequest . addFile ( "upload" , new File ( "pom.xml" ) , "text/xml" ) ; requestCycle . setRequest ( new wicket . protocol . http . servlet . MultipartServletWebRequest ( servletRequest , Bytes . MAX ) ) ; FileUpload fileUpload = field . getFileUpload ( ) ; assertNotNull ( fileUpload ) ; InputStream is = fileUpload . getInputStream ( ) ; assertTrue ( ( ( is . read ( ) ) != ( - 1 ) ) ) ; <START_BUG> field . internalOnDetach ( ) ; <END_BUG> try { is . read ( ) ; fail ( ) ; } catch ( IOException e ) { } catch ( Exception e ) { fail ( ) ; } } } 
public class CLIWrapper { private final CommandContext ctx ; private ByteArrayOutputStream consoleOut ; public CLIWrapper ( ) throws Exception { } public CLIWrapper ( boolean connect ) throws Exception { } public CLIWrapper ( boolean connect , String cliAddress ) throws CliInitializationException { } protected InputStream createConsoleInput ( ) { } public boolean isConnected ( ) { } public boolean sendConnect ( ) { } public boolean sendConnect ( String cliAddress ) { String addr = ( cliAddress != null ) ? cliAddress : TestSuiteEnvironment . getServerAddress ( ) ; try { <START_BUG> ctx . connectController ( addr , TestSuiteEnvironment . getServerPort ( ) ) ; <END_BUG> return true ; } catch ( CommandLineException e ) { e . printStackTrace ( ) ; return false ; } } public boolean sendLine ( String line , boolean ignoreError ) { } public void sendLine ( String line ) { } public String readOutput ( ) { } public CLIOpResult readAllAsOpResult ( ) throws IOException { } public synchronized void quit ( ) { } public boolean hasQuit ( ) { } protected String getUsername ( ) { } protected String getPassword ( ) { } } 
public class CharacterLiteral extends Expression { private String escapedValue = "\'X\'" ; CharacterLiteral ( AST ast ) { } public int getNodeType ( ) { } ASTNode clone ( AST target ) { } public boolean subtreeMatch ( ASTMatcher matcher , Object other ) { } void accept0 ( ASTVisitor visitor ) { <START_BUG> boolean visitChildren = visitor . visit ( this ) ; <END_BUG> visitor . endVisit ( this ) ; } public String getEscapedValue ( ) { } public void setEscapedValue ( String value ) { } public char charValue ( ) { } public void setCharValue ( char value ) { } int memSize ( ) { } int treeSize ( ) { } } 
class XSDAttributeGroupTraverser extends XSDAbstractTraverser { XSDAttributeGroupTraverser ( XSDHandler handler , XSAttributeChecker gAttrCheck ) { } XSAttributeGroupDecl traverseLocal ( Element elmNode , XSDocumentInfo schemaDoc , SchemaGrammar grammar ) { } XSAttributeGroupDecl traverseGlobal ( Element elmNode , XSDocumentInfo schemaDoc , SchemaGrammar grammar ) { XSAttributeGroupDecl attrGrp = new XSAttributeGroupDecl ( ) ; Object [ ] attrValues = fAttrChecker . checkAttributes ( elmNode , true , schemaDoc ) ; String nameAttr = ( ( String ) ( attrValues [ XSAttributeChecker . ATTIDX_NAME ] ) ) ; if ( nameAttr == null ) { reportSchemaError ( "s4s-att-must-appear" , new Object [ ] { "attributeGroup<seq2seq4repair_space>(global)" , "name" } , elmNode ) ; nameAttr = "no<seq2seq4repair_space>name" ; } attrGrp . fName = nameAttr ; attrGrp . fTargetNamespace = schemaDoc . fTargetNamespace ; Element child = DOMUtil . getFirstChildElement ( elmNode ) ; XSAnnotationImpl annotation = null ; if ( ( child != null ) && ( DOMUtil . getLocalName ( child ) . equals ( ELT_ANNOTATION ) ) ) { annotation = traverseAnnotationDecl ( child , attrValues , false , schemaDoc ) ; child = DOMUtil . getNextSiblingElement ( child ) ; } else { String text = DOMUtil . getSyntheticAnnotation ( elmNode ) ; if ( text != null ) { annotation = traverseSyntheticAnnotation ( elmNode , text , attrValues , false , schemaDoc ) ; } } Element nextNode = traverseAttrsAndAttrGrps ( child , attrGrp , schemaDoc , grammar , null ) ; if ( nextNode != null ) { Object [ ] args = new Object [ ] { nameAttr , "(annotation?,<seq2seq4repair_space>((attribute<seq2seq4repair_space>|<seq2seq4repair_space>attributeGroup)*,<seq2seq4repair_space>anyAttribute?))" , DOMUtil . getLocalName ( nextNode ) } ; reportSchemaError ( "s4s-elt-must-match.1" , args , nextNode ) ; } attrGrp . removeProhibitedAttrs ( ) ; XSAttributeGroupDecl redefinedAttrGrp = ( ( XSAttributeGroupDecl ) ( fSchemaHandler . getGrpOrAttrGrpRedefinedByRestriction ( ATTRIBUTEGROUP_TYPE , new org . apache . xerces . xni . QName ( XMLSymbols . EMPTY_STRING , nameAttr , nameAttr , schemaDoc . fTargetNamespace ) , schemaDoc , elmNode ) ) ) ; if ( redefinedAttrGrp != null ) { Object [ ] errArgs = attrGrp . validRestrictionOf ( nameAttr , redefinedAttrGrp ) ; if ( errArgs != null ) { reportSchemaError ( ( ( String ) ( errArgs [ ( ( errArgs . length ) - 1 ) ] ) ) , errArgs , child ) ; reportSchemaError ( "src-redefine.7.2.2" , new Object [ ] { nameAttr , errArgs [ ( ( errArgs . length ) - 1 ) ] } , child ) ; } } XSObjectList annotations ; if ( annotation != null ) { annotations = new XSObjectListImpl ( ) ; <START_BUG> ( ( XSObjectListImpl ) ( annotations ) ) . add ( annotation ) ; <END_BUG> } else { annotations = XSObjectListImpl . EMPTY_LIST ; } attrGrp . fAnnotations = annotations ; grammar . addGlobalAttributeGroupDecl ( attrGrp ) ; fAttrChecker . returnAttrArray ( attrValues , schemaDoc ) ; return attrGrp ; } } 
public class EvaluationTest { public LeastSquaresBuilder builder ( StatisticalReferenceDataset dataset ) { } @ Test public void testComputeResiduals ( ) { } @ Test public void testComputeCovariance ( ) throws IOException { } @ Test public void testComputeValueAndJacobian ( ) { } @ Test public void testComputeCost ( ) throws IOException { } @ Test public void testComputeRMS ( ) throws IOException { } @ Test public void testComputeSigma ( ) throws IOException { } @ Test public void testEvaluateCopiesPoint ( ) throws IOException { } @ Test public void testLazyEvaluation ( ) { } @ Test public void testLazyEvaluationPrecondition ( ) { } @ Test public void testDirectEvaluation ( ) { final RealVector dummy = new ArrayRealVector ( new double [ ] { 0 } ) ; final LeastSquaresProblem p = LeastSquaresFactory . create ( LeastSquaresFactory . model ( dummyModel ( ) , dummyJacobian ( ) ) , dummy , dummy , null , 0 , 0 , false ) ; try { <START_BUG> final Evaluation eval = p . evaluate ( dummy ) ; <END_BUG> Assert . fail ( "Exception<seq2seq4repair_space>expected" ) ; } catch ( RuntimeException e ) { final String msg = e . getMessage ( ) ; Assert . assertTrue ( ( ( msg . equals ( "dummyModel" ) ) || ( msg . equals ( "dummyJacobian" ) ) ) ) ; } } private MultivariateVectorFunction dummyModel ( ) { } private MultivariateMatrixFunction dummyJacobian ( ) { } } 
public class AuthorizationInterceptor implements Interceptor { private static final Logger logger = Logger . getLogger ( AuthorizationInterceptor . class ) ; private final EJBMethodSecurityMetaData ejbMethodSecurityMetaData ; private final String viewClassName ; private final Method viewMethod ; public AuthorizationInterceptor ( final EJBMethodSecurityMetaData ejbMethodSecurityMetaData , final String viewClassName , final Method viewMethod ) { } @ Override public Object processInvocation ( InterceptorContext context ) throws Exception { final Component component = context . getPrivateData ( Component . class ) ; if ( ( component instanceof EJBComponent ) == false ) { throw new IllegalStateException ( ( ( ( "Unexpected<seq2seq4repair_space>component<seq2seq4repair_space>type:<seq2seq4repair_space>" + ( component . getClass ( ) ) ) + "<seq2seq4repair_space>expected:<seq2seq4repair_space>" ) + ( EJBComponent . class ) ) ) ; } final Method invokedMethod = context . getMethod ( ) ; final ComponentView componentView = context . getPrivateData ( ComponentView . class ) ; final String viewClassOfInvokedMethod = componentView . getViewClass ( ) . getName ( ) ; if ( ( ! ( this . viewClassName . equals ( viewClassOfInvokedMethod ) ) ) || ( ! ( this . viewMethod . equals ( invokedMethod ) ) ) ) { throw new IllegalStateException ( ( ( ( ( ( ( ( ( ( ( this . getClass ( ) . getName ( ) ) + "<seq2seq4repair_space>cannot<seq2seq4repair_space>handle<seq2seq4repair_space>method<seq2seq4repair_space>" ) + invokedMethod ) + "<seq2seq4repair_space>of<seq2seq4repair_space>view<seq2seq4repair_space>class<seq2seq4repair_space>" ) + viewClassOfInvokedMethod ) + ".Expected<seq2seq4repair_space>view<seq2seq4repair_space>" ) + "method<seq2seq4repair_space>to<seq2seq4repair_space>be<seq2seq4repair_space>" ) + ( viewMethod ) ) + "<seq2seq4repair_space>on<seq2seq4repair_space>view<seq2seq4repair_space>class<seq2seq4repair_space>" ) + ( viewClassName ) ) ) ; } final EJBComponent ejbComponent = ( ( EJBComponent ) ( component ) ) ; if ( ejbMethodSecurityMetaData . isAccessDenied ( ) ) { throw new javax . ejb . EJBAccessException ( ( ( ( ( "Invocation<seq2seq4repair_space>on<seq2seq4repair_space>method:<seq2seq4repair_space>" + invokedMethod ) + "<seq2seq4repair_space>of<seq2seq4repair_space>bean:<seq2seq4repair_space>" ) + ( ejbComponent . getComponentName ( ) ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>allowed" ) ) ; } if ( ! ( ejbMethodSecurityMetaData . isPermitAll ( ) ) ) { final Collection < String > allowedRoles = ejbMethodSecurityMetaData . getRolesAllowed ( ) ; if ( ! ( allowedRoles . isEmpty ( ) ) ) { final SimpleSecurityManager securityManager = ejbComponent . getSecurityManager ( ) ; <START_BUG> if ( ! ( securityManager . isCallerInRole ( allowedRoles . toArray ( new String [ allowedRoles . size ( ) ] ) ) ) ) { <END_BUG> throw new javax . ejb . EJBAccessException ( ( ( ( ( "Invocation<seq2seq4repair_space>on<seq2seq4repair_space>method:<seq2seq4repair_space>" + invokedMethod ) + "<seq2seq4repair_space>of<seq2seq4repair_space>bean:<seq2seq4repair_space>" ) + ( ejbComponent . getComponentName ( ) ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>allowed" ) ) ; } } } return context . proceed ( ) ; } } 
public class WebMvcConfigurationSupportTests { @ Test public void requestMappingHandlerMapping ( ) throws Exception { } @ Test public void emptyViewControllerHandlerMapping ( ) { } @ Test public void beanNameHandlerMapping ( ) throws Exception { } @ Test public void emptyResourceHandlerMapping ( ) { } @ Test public void emptyDefaultServletHandlerMapping ( ) { } @ Test public void requestMappingHandlerAdapter ( ) throws Exception { ApplicationContext context = initContext ( WebMvcConfigurationSupportTests . WebConfig . class ) ; RequestMappingHandlerAdapter adapter = context . getBean ( RequestMappingHandlerAdapter . class ) ; List < HttpMessageConverter < ? > > converters = adapter . getMessageConverters ( ) ; assertEquals ( 9 , converters . size ( ) ) ; for ( HttpMessageConverter < ? > converter : converters ) { if ( converter instanceof AbstractJackson2HttpMessageConverter ) { ObjectMapper objectMapper = ( ( AbstractJackson2HttpMessageConverter ) ( converter ) ) . getObjectMapper ( ) ; assertTrue ( objectMapper . getDeserializationConfig ( ) . isEnabled ( MapperFeature . DEFAULT_VIEW_INCLUSION ) ) ; assertTrue ( objectMapper . getSerializationConfig ( ) . isEnabled ( MapperFeature . DEFAULT_VIEW_INCLUSION ) ) ; <START_BUG> assertTrue ( objectMapper . getDeserializationConfig ( ) . isEnabled ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES ) ) ; <END_BUG> if ( converter instanceof MappingJackson2XmlHttpMessageConverter ) { assertEquals ( XmlMapper . class , objectMapper . getClass ( ) ) ; } } } ConfigurableWebBindingInitializer initializer = ( ( ConfigurableWebBindingInitializer ) ( adapter . getWebBindingInitializer ( ) ) ) ; assertNotNull ( initializer ) ; ConversionService conversionService = initializer . getConversionService ( ) ; assertNotNull ( conversionService ) ; assertTrue ( ( conversionService instanceof FormattingConversionService ) ) ; Validator validator = initializer . getValidator ( ) ; assertNotNull ( validator ) ; assertTrue ( ( validator instanceof LocalValidatorFactoryBean ) ) ; DirectFieldAccessor fieldAccessor = new DirectFieldAccessor ( adapter ) ; List < Object > interceptors = ( ( List < Object > ) ( fieldAccessor . getPropertyValue ( "responseBodyAdvice" ) ) ) ; assertEquals ( 1 , interceptors . size ( ) ) ; assertEquals ( JsonViewResponseBodyAdvice . class , interceptors . get ( 0 ) . getClass ( ) ) ; } @ Test public void uriComponentsContributor ( ) throws Exception { } @ Test public void handlerExceptionResolver ( ) throws Exception { } @ Test public void mvcViewResolver ( ) { } @ Test public void mvcViewResolverWithExistingResolver ( ) throws Exception { } @ Test public void defaultPathMatchConfiguration ( ) throws Exception { } private ApplicationContext initContext ( Class ... configClasses ) { } @ EnableWebMvc @ Configuration public static class WebConfig { @ Bean ( name = "/testController" ) public WebMvcConfigurationSupportTests . TestController testController ( ) { } } @ Configuration public static class ViewResolverConfig { @ Bean public ViewResolver beanNameViewResolver ( ) { } } @ Controller public static class TestController { @ RequestMapping ( "/" ) public void handle ( ) { } @ RequestMapping ( "/foo/{id}/bar/{date}" ) public HttpEntity < Void > methodWithTwoPathVariables ( @ PathVariable Integer id , @ DateTimeFormat ( iso = ISO . DATE ) @ PathVariable DateTime date ) { } } @ Controller @ Scope ( "prototype" ) public static class ScopedController { @ RequestMapping ( "/scoped" ) public void handle ( ) { } } @ Controller @ Scope ( value = "prototype" , proxyMode = ScopedProxyMode . TARGET_CLASS ) public static class ScopedProxyController { @ RequestMapping ( "/scopedProxy" ) public void handle ( ) { } } } 
public class BasicModelP extends BasicModel { protected static double LOG2_E = SimilarityBase . log2 ( Math . E ) ; @ Override public final float score ( BasicStats stats , float tfn ) { <START_BUG> float lambda = ( ( float ) ( stats . getTotalTermFreq ( ) ) ) / ( stats . getNumberOfDocuments ( ) ) ; <END_BUG> return ( ( float ) ( ( ( tfn * ( SimilarityBase . log2 ( ( tfn / lambda ) ) ) ) + ( ( ( lambda + ( 1 / ( 12 * tfn ) ) ) - tfn ) * ( BasicModelP . LOG2_E ) ) ) + ( 0.5 * ( SimilarityBase . log2 ( ( ( 2 * ( Math . PI ) ) * tfn ) ) ) ) ) ) ; } @ Override public String toString ( ) { } } 
public final class Main { public static final void main ( final String [ ] args ) throws Exception { try { final File installDirectory = Main . findInstallDir ( ) ; System . setProperty ( "ant.home" , installDirectory . toString ( ) ) ; final File libDir = new File ( installDirectory , "lib" ) ; final URL [ ] urls = Main . buildURLList ( libDir ) ; final LauncherClassLoader classLoader = new LauncherClassLoader ( urls ) ; <START_BUG> final Class clazz = classLoader . loadClass ( "org.apache.ant.Main" ) ; <END_BUG> final Method method = clazz . getMethod ( "main" , new Class [ ] { args . getClass ( ) } ) ; method . invoke ( null , new Object [ ] { args } ) ; } catch ( final InvocationTargetException ite ) { System . err . println ( ( "Error:<seq2seq4repair_space>" + ( ite . getTargetException ( ) . getMessage ( ) ) ) ) ; ite . getTargetException ( ) . printStackTrace ( ) ; } catch ( final Throwable throwable ) { System . err . println ( ( "Error:<seq2seq4repair_space>" + ( throwable . getMessage ( ) ) ) ) ; throwable . printStackTrace ( ) ; } } private static final URL [ ] buildURLList ( final File dir ) throws Exception { } private static final File findInstallDir ( ) throws Exception { } } 
public class ClassUtils { public static final char PACKAGE_SEPARATOR_CHAR = '.' ; public static final String PACKAGE_SEPARATOR = String . valueOf ( ClassUtils . PACKAGE_SEPARATOR_CHAR ) ; public static final char INNER_CLASS_SEPARATOR_CHAR = '$' ; public static final String INNER_CLASS_SEPARATOR = String . valueOf ( ClassUtils . INNER_CLASS_SEPARATOR_CHAR ) ; private static final Map < Class < ? > , Class < ? > > primitiveWrapperMap = new HashMap < Class < ? > , Class < ? > > ( ) ; private static final Map < Class < ? > , Class < ? > > wrapperPrimitiveMap = new HashMap < Class < ? > , Class < ? > > ( ) ; private static final Map < String , String > abbreviationMap = new HashMap < String , String > ( ) ; private static final Map < String , String > reverseAbbreviationMap = new HashMap < String , String > ( ) ; private static void addAbbreviation ( String primitive , String abbreviation ) { } public ClassUtils ( ) { } public static String getShortClassName ( Object object , String valueIfNull ) { } public static String getShortClassName ( Class < ? > cls ) { } public static String getShortClassName ( String className ) { } public static String getPackageName ( Object object , String valueIfNull ) { } public static String getPackageName ( Class < ? > cls ) { if ( cls == null ) { return StringUtils . EMPTY ; } <START_BUG> return ClassUtils . getPackageName ( cls . getName ( ) ) ; <END_BUG> } public static String getPackageName ( String className ) { } public static List < Class < ? > > getAllSuperclasses ( Class < ? > cls ) { } public static List < Class < ? > > getAllInterfaces ( Class < ? > cls ) { } public static List < Class < ? > > convertClassNamesToClasses ( List < String > classNames ) { } public static List < String > convertClassesToClassNames ( List < Class < ? > > classes ) { } public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray ) { } public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { } public static boolean isAssignable ( Class < ? > cls , Class < ? > toClass ) { } public static boolean isAssignable ( Class < ? > cls , Class < ? > toClass , boolean autoboxing ) { } public static Class < ? > primitiveToWrapper ( Class < ? > cls ) { } public static Class < ? > [ ] primitivesToWrappers ( Class < ? > [ ] classes ) { } public static Class < ? > wrapperToPrimitive ( Class < ? > cls ) { } public static Class < ? > [ ] wrappersToPrimitives ( Class < ? > [ ] classes ) { } public static boolean isInnerClass ( Class < ? > cls ) { } public static Class < ? > getClass ( ClassLoader classLoader , String className , boolean initialize ) throws ClassNotFoundException { } public static Class < ? > getClass ( ClassLoader classLoader , String className ) throws ClassNotFoundException { } public static Class < ? > getClass ( String className ) throws ClassNotFoundException { } public static Class < ? > getClass ( String className , boolean initialize ) throws ClassNotFoundException { } public static Method getPublicMethod ( Class < ? > cls , String methodName , Class < ? > [ ] parameterTypes ) throws NoSuchMethodException , SecurityException { } private static String toCanonicalName ( String className ) { } public static Class < ? > [ ] toClass ( Object [ ] array ) { } public static String getShortCanonicalName ( Object object , String valueIfNull ) { } public static String getShortCanonicalName ( Class < ? > cls ) { } public static String getShortCanonicalName ( String canonicalName ) { } public static String getPackageCanonicalName ( Object object , String valueIfNull ) { } public static String getPackageCanonicalName ( Class < ? > cls ) { } public static String getPackageCanonicalName ( String canonicalName ) { } private static String getCanonicalName ( String className ) { } } 
public class CompilationUnitDeclaration extends ASTNode implements ReferenceContext , ProblemSeverities { private static final Comparator STRING_LITERAL_COMPARATOR = new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { } } ; private static final int STRING_LITERALS_INCREMENT = 10 ; public ImportReference currentPackage ; public ImportReference [ ] imports ; public TypeDeclaration [ ] types ; public int [ ] [ ] comments ; public boolean ignoreFurtherInvestigation = false ; public boolean ignoreMethodBodies = false ; public CompilationUnitScope scope ; public ProblemReporter problemReporter ; public CompilationResult compilationResult ; public LocalTypeBinding [ ] localTypes ; public int localTypeCount = 0 ; public boolean isPropagatingInnerClassEmulation ; public Javadoc javadoc ; public NLSTag [ ] nlsTags ; private StringLiteral [ ] stringLiterals ; private int stringLiteralsPtr ; public CompilationUnitDeclaration ( ProblemReporter problemReporter , CompilationResult compilationResult , int sourceLength ) { } public void abort ( int abortLevel , CategorizedProblem problem ) { } public void analyseCode ( ) { } public void cleanUp ( ) { } private void cleanUp ( TypeDeclaration type ) { } public void checkUnusedImports ( ) { if ( ( this . scope . imports ) != null ) { for ( int i = 0 , max = this . scope . imports . length ; i < max ; i ++ ) { ImportBinding importBinding = this . scope . imports [ i ] ; ImportReference importReference = importBinding . reference ; <START_BUG> if ( ( importReference != null ) && ( ! ( importReference . used ) ) ) { <END_BUG> scope . problemReporter ( ) . unusedImport ( importReference ) ; } } } } public CompilationResult compilationResult ( ) { } public TypeDeclaration declarationOfType ( char [ ] [ ] typeName ) { } public void generateCode ( ) { } public char [ ] getFileName ( ) { } public char [ ] getMainTypeName ( ) { } public boolean isEmpty ( ) { } public boolean isPackageInfo ( ) { } public boolean hasErrors ( ) { } public StringBuffer print ( int indent , StringBuffer output ) { } public void propagateInnerEmulationForAllLocalTypes ( ) { } public void recordStringLiteral ( StringLiteral literal ) { } public void record ( LocalTypeBinding localType ) { } public void resolve ( ) { } private void reportNLSProblems ( ) { } public void tagAsHavingErrors ( ) { } public void traverse ( ASTVisitor visitor , CompilationUnitScope unitScope ) { } } 
public class PageCreateKey extends WizardPage implements Listener { public static final String PAGE_NAME = "SignPageCreateKey" ; private String keystoreName ; private String project ; private boolean generated = false ; private Button bOpen = null ; private Button bGenerate = null ; private Button bEchoKeystorePassword = null ; private Button bEchoKeyPassword = null ; private Combo cAlgorithm = null ; private Label lPreview = null ; private Label lResult = null ; private Text tCommonName = null ; private Text tOrganizationalUnit = null ; private Text tOrganization = null ; private Text tLocation = null ; private Text tState = null ; private Text tCountry = null ; private Text tKeyName = null ; private Text tKeystore = null ; private Text tKeystorePassword = null ; private Text tKeyPassword = null ; private static final int LABELWIDTH = 160 ; private static final int TEXTHEIGHT = 40 ; private Signature signature = null ; private Keystore keystore = null ; public PageCreateKey ( final Signature signature , final String project ) { } public void createControl ( final Composite parent ) { } private void createPageContent ( final Composite parent ) { } private void addListeners ( ) { } private void dialogChanged ( ) { } private void updateStatus ( final String message , final int status ) { } public void handleEvent ( final Event e ) { } private void echoPassword ( final Event e ) { } private void openKeystore ( ) { } private void generateCertificate ( ) throws Exception { } public void onEnterPage ( ) { } public IWizardPage getNextPage ( ) { } private void saveDataToModel ( ) { signature . setKeystore ( keystore ) ; signature . setKeystorePassword ( tKeystorePassword . getText ( ) . toCharArray ( ) ) ; signature . setKeyPassword ( tKeyPassword . getText ( ) . toCharArray ( ) ) ; <START_BUG> signature . setKeyAlias ( tKeyName . getText ( ) ) ; <END_BUG> if ( cAlgorithm . getText ( ) . equals ( "DSA" ) ) { signature . setKeyAlgorithm ( "SHA1withDSA" ) ; } else if ( cAlgorithm . getText ( ) . equals ( "EC" ) ) { signature . setKeyAlgorithm ( "SHA1withECDSA" ) ; } else if ( cAlgorithm . getText ( ) . equals ( "RSA" ) ) { signature . setKeyAlgorithm ( "SHA1withRSA" ) ; } } } 
public class ArgsAnnotationPointcut extends NameBindingPointcut { private AnnotationPatternList arguments ; private String declarationText ; public ArgsAnnotationPointcut ( AnnotationPatternList arguments ) { } public AnnotationPatternList getArguments ( ) { } public Set couldMatchKinds ( ) { } public Pointcut parameterizeWith ( Map typeVariableMap ) { } public FuzzyBoolean fastMatch ( FastMatchInfo info ) { } protected FuzzyBoolean matchInternal ( Shadow shadow ) { } protected void resolveBindings ( IScope scope , Bindings bindings ) { } protected Pointcut concretize1 ( ResolvedType inAspect , ResolvedType declaringType , IntMap bindings ) { } protected Test findResidueInternal ( Shadow shadow , ExposedState state ) { int len = shadow . getArgCount ( ) ; int numArgsMatchedByEllipsis = ( len + ( arguments . ellipsisCount ) ) - ( arguments . size ( ) ) ; if ( numArgsMatchedByEllipsis < 0 ) return Literal . FALSE ; if ( ( numArgsMatchedByEllipsis > 0 ) && ( ( arguments . ellipsisCount ) == 0 ) ) { return Literal . FALSE ; } Test ret = Literal . TRUE ; int argsIndex = 0 ; for ( int i = 0 ; i < ( arguments . size ( ) ) ; i ++ ) { if ( ( arguments . get ( i ) ) == ( AnnotationTypePattern . ELLIPSIS ) ) { argsIndex += numArgsMatchedByEllipsis ; } else if ( ( arguments . get ( i ) ) == ( AnnotationTypePattern . ANY ) ) { argsIndex ++ ; } else { ExactAnnotationTypePattern ap = ( ( ExactAnnotationTypePattern ) ( arguments . get ( i ) ) ) ; UnresolvedType argType = shadow . getArgType ( argsIndex ) ; ResolvedType rArgType = argType . resolve ( shadow . getIWorld ( ) ) ; <START_BUG> if ( rArgType == ( ResolvedType . MISSING ) ) { <END_BUG> shadow . getIWorld ( ) . getLint ( ) . cantFindType . signal ( new String [ ] { WeaverMessages . format ( CANT_FIND_TYPE_ARG_TYPE , argType . getName ( ) ) } , shadow . getSourceLocation ( ) , new ISourceLocation [ ] { getSourceLocation ( ) } ) ; } ResolvedType rAnnType = ap . getAnnotationType ( ) . resolve ( shadow . getIWorld ( ) ) ; if ( ap instanceof BindingAnnotationTypePattern ) { BindingAnnotationTypePattern btp = ( ( BindingAnnotationTypePattern ) ( ap ) ) ; Var annvar = shadow . getArgAnnotationVar ( argsIndex , rAnnType ) ; state . set ( btp . getFormalIndex ( ) , annvar ) ; } if ( ! ( ap . matches ( rArgType ) . alwaysTrue ( ) ) ) { ret = Test . makeAnd ( ret , Test . makeHasAnnotation ( shadow . getArgVar ( argsIndex ) , rAnnType ) ) ; } argsIndex ++ ; } } return ret ; } public List getBindingAnnotationTypePatterns ( ) { } public List getBindingTypePatterns ( ) { } public void write ( DataOutputStream s ) throws IOException { } public static Pointcut read ( VersionedDataInputStream s , ISourceContext context ) throws IOException { } public boolean equals ( Object obj ) { } public int hashCode ( ) { } private void buildDeclarationText ( ) { } public String toString ( ) { } public Object accept ( PatternNodeVisitor visitor , Object data ) { } } 
public class CorrelatedRandomVectorGeneratorTest { private double [ ] mean ; private RealMatrix covariance ; private CorrelatedRandomVectorGenerator generator ; public CorrelatedRandomVectorGeneratorTest ( ) { } @ Test public void testRank ( ) { <START_BUG> Assert . assertEquals ( 3 , generator . getRank ( ) ) ; <END_BUG> } @ Test public void testMath226 ( ) { } @ Test public void testRootMatrix ( ) { } @ Test public void testMeanAndCovariance ( ) { } @ Test public void testSampleWithZeroCovariance ( ) { } private CorrelatedRandomVectorGenerator createSampler ( double [ ] [ ] cov ) { } private void testSampler ( final double [ ] [ ] covMatrix , int samples , double epsilon ) { } } 
public abstract class AbstractDistributionTest extends ContainerAbstractTestCase implements RemoteServicePublication , IDistributionConstants { protected IRemoteServiceContainerAdapter [ ] adapters = null ; protected abstract String getClientContainerName ( ) { } protected void tearDown ( ) throws Exception { } protected void setClientCount ( int count ) { } protected void setupRemoteServiceAdapters ( ) throws Exception { } protected BundleContext getContext ( ) { } protected IRemoteServiceContainerAdapter [ ] getRemoteServiceAdapters ( ) { } protected IRemoteServiceListener createRemoteServiceListener ( final boolean server ) { } protected void addRemoteServiceListeners ( ) { } protected IRemoteServiceRegistration registerRemoteService ( IRemoteServiceContainerAdapter adapter , String serviceInterface , Object service , Dictionary serviceProperties , int sleepTime ) { } protected IRemoteServiceReference [ ] getRemoteServiceReferences ( IRemoteServiceContainerAdapter adapter , String clazz , String filter ) { } protected IRemoteService getRemoteService ( IRemoteServiceContainerAdapter adapter , String clazz , String filter ) { } protected String getFilterFromServiceProperties ( Dictionary serviceProperties ) { } protected String [ ] getDefaultServiceClasses ( ) { } protected Object getDefaultService ( ) { } protected ServiceRegistration registerService ( String [ ] clazzes , Object service , Properties props ) throws Exception { } protected ServiceRegistration registerService ( String clazz , Object service , Properties props ) throws Exception { } protected ServiceRegistration registerDefaultService ( Properties props ) throws Exception { } public ServiceReference getReference ( ) { } protected void assertReferenceHasCorrectType ( ServiceReference sr , String classname ) { } protected void assertReferencesValidAndFirstHasCorrectType ( ServiceReference [ ] references , String classname ) { } protected void assertReferencesValid ( ServiceReference [ ] references ) { } protected void assertStringResultValid ( Object result , String compare ) { } protected void assertProxyValid ( Object proxy ) { } protected ServiceTracker createProxyServiceTracker ( String clazz ) throws InvalidSyntaxException { ServiceTracker st = new ServiceTracker ( getContext ( ) , getContext ( ) . createFilter ( ( ( ( ( ( ( "(&(" + ( Constants . OBJECTCLASS ) ) + "=" ) + clazz ) + ")(" ) + ( SERVICE_IMPORTED ) ) + "=*))" ) ) , new ServiceTrackerCustomizer ( ) { public Object addingService ( ServiceReference reference ) { Trace . trace ( PLUGIN_ID , ( "addingService=" + reference ) ) ; return getContext ( ) . getService ( reference ) ; } public void modifiedService ( ServiceReference reference , Object service ) { Trace . trace ( PLUGIN_ID , ( "modifiedService=" + reference ) ) ; } public void removedService ( ServiceReference reference , Object service ) { Trace . trace ( PLUGIN_ID , ( ( ( "removedService=" + reference ) + ",svc=" ) + service ) ) ; } } ) ; <START_BUG> st . open ( ) ; <END_BUG> return st ; } protected IRemoteService getRemoteServiceFromProxy ( Object proxy ) { } } 
public class MembershipCleanerVerbHandler implements IVerbHandler { private static Logger logger_ = Logger . getLogger ( MembershipCleanerVerbHandler . class ) ; public void doVerb ( Message message ) { byte [ ] body = message . getMessageBody ( ) ; try { DataInputBuffer bufIn = new DataInputBuffer ( ) ; bufIn . reset ( body , body . length ) ; MembershipCleaner . MembershipCleanerMessage mcMessage = MembershipCleanerMessage . serializer ( ) . deserialize ( bufIn ) ; String target = mcMessage . getTarget ( ) ; MembershipCleanerVerbHandler . logger_ . info ( ( ( "Removing<seq2seq4repair_space>the<seq2seq4repair_space>node<seq2seq4repair_space>[" + target ) + "]<seq2seq4repair_space>from<seq2seq4repair_space>membership" ) ) ; EndPoint targetEndPoint = new EndPoint ( target , DatabaseDescriptor . getControlPort ( ) ) ; StorageService . instance ( ) . removeTokenState ( targetEndPoint ) ; Map < String , byte [ ] > headers = message . getHeaders ( ) ; headers . remove ( StorageService . getLocalStorageEndPoint ( ) . getHost ( ) ) ; if ( MembershipCleanerVerbHandler . logger_ . isDebugEnabled ( ) ) MembershipCleanerVerbHandler . logger_ . debug ( ( "Number<seq2seq4repair_space>of<seq2seq4repair_space>nodes<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>header<seq2seq4repair_space>" + ( headers . size ( ) ) ) ) ; Set < String > nodes = headers . keySet ( ) ; for ( String node : nodes ) { if ( MembershipCleanerVerbHandler . logger_ . isDebugEnabled ( ) ) MembershipCleanerVerbHandler . logger_ . debug ( ( "Processing<seq2seq4repair_space>node<seq2seq4repair_space>" + node ) ) ; <START_BUG> byte [ ] bytes = headers . remove ( node ) ; <END_BUG> EndPoint targetNode = new EndPoint ( node , DatabaseDescriptor . getStoragePort ( ) ) ; if ( MembershipCleanerVerbHandler . logger_ . isDebugEnabled ( ) ) MembershipCleanerVerbHandler . logger_ . debug ( ( "Sending<seq2seq4repair_space>a<seq2seq4repair_space>membership<seq2seq4repair_space>clean<seq2seq4repair_space>message<seq2seq4repair_space>to<seq2seq4repair_space>" + targetNode ) ) ; MessagingService . getMessagingInstance ( ) . sendOneWay ( message , targetNode ) ; break ; } } catch ( IOException ex ) { if ( MembershipCleanerVerbHandler . logger_ . isDebugEnabled ( ) ) MembershipCleanerVerbHandler . logger_ . debug ( LogUtil . throwableToString ( ex ) ) ; } } } 
public class Inserter extends Operation { public Inserter ( int index ) { } public void run ( Cassandra . Client client ) throws IOException { List < ByteBuffer > values = generateValues ( ) ; List < Column > columns = new ArrayList < Column > ( ) ; List < SuperColumn > superColumns = new ArrayList < SuperColumn > ( ) ; String format = ( "%0" + ( session . getTotalKeysLength ( ) ) ) + "d" ; for ( int i = 0 ; i < ( session . getColumnsPerKey ( ) ) ; i ++ ) { String columnName = "C" + ( Integer . toString ( i ) ) ; ByteBuffer columnValue = values . get ( ( i % ( values . size ( ) ) ) ) ; columns . add ( new Column ( ByteBufferUtil . bytes ( columnName ) , columnValue , System . currentTimeMillis ( ) ) ) ; } if ( ( session . getColumnFamilyType ( ) ) == ( ColumnFamilyType . Super ) ) { for ( int i = 0 ; i < ( session . getSuperColumns ( ) ) ; i ++ ) { String superColumnName = "S" + ( Integer . toString ( i ) ) ; <START_BUG> superColumns . add ( new SuperColumn ( ByteBuffer . wrap ( superColumnName . getBytes ( ) ) , columns ) ) ; <END_BUG> } } String rawKey = String . format ( format , index ) ; Map < ByteBuffer , Map < String , List < Mutation > > > record = new HashMap < ByteBuffer , Map < String , List < Mutation > > > ( ) ; record . put ( ByteBufferUtil . bytes ( rawKey ) , ( ( session . getColumnFamilyType ( ) ) == ( ColumnFamilyType . Super ) ? getSuperColumnsMutationMap ( superColumns ) : getColumnsMutationMap ( columns ) ) ) ; long start = System . currentTimeMillis ( ) ; boolean success = false ; String exceptionMessage = null ; for ( int t = 0 ; t < ( session . getRetryTimes ( ) ) ; t ++ ) { if ( success ) break ; try { client . batch_mutate ( record , session . getConsistencyLevel ( ) ) ; success = true ; } catch ( Exception e ) { exceptionMessage = getExceptionMessage ( e ) ; success = false ; } } if ( ! success ) { error ( String . format ( "Operation<seq2seq4repair_space>[%d]<seq2seq4repair_space>retried<seq2seq4repair_space>%d<seq2seq4repair_space>times<seq2seq4repair_space>-<seq2seq4repair_space>error<seq2seq4repair_space>inserting<seq2seq4repair_space>key<seq2seq4repair_space>%s<seq2seq4repair_space>%s%n" , index , session . getRetryTimes ( ) , rawKey , ( exceptionMessage == null ? "" : ( "(" + exceptionMessage ) + ")" ) ) ) ; } operations . getAndIncrement ( ) ; keys . getAndIncrement ( ) ; latency . getAndAdd ( ( ( System . currentTimeMillis ( ) ) - start ) ) ; } private Map < String , List < Mutation > > getSuperColumnsMutationMap ( List < SuperColumn > superColumns ) { } private Map < String , List < Mutation > > getColumnsMutationMap ( List < Column > columns ) { } } 
public class RequestLogger implements RequestLoggerMBean { private final Application application ; private final WebApplication webApplication ; public RequestLogger ( org . apache . wicket . Application application ) { } public Integer getNumberOfCreatedSessions ( ) throws IOException { } public Integer getNumberOfLiveSessions ( ) throws IOException { } public Integer getPeakNumberOfSessions ( ) throws IOException { } public void restart ( ) throws IOException { } public void stop ( ) throws IOException { } protected IRequestLogger getRequestLogger ( ) { if ( ( application ) instanceof WebApplication ) { <START_BUG> return ( ( WebApplication ) ( application ) ) . getRequestLogger ( ) ; <END_BUG> } return null ; } } 
public class MapKey extends AbstractVal { private final Val _key ; private ClassMetaData _meta = null ; private Class _cast = null ; private Class _type = null ; public MapKey ( Val key ) { } public static class KeyExpState extends ExpState { public ExpState key ; public ExpState val ; KeyExpState ( ExpState key ) { } } public void appendTo ( Select sel , ExpContext ctx , ExpState state , SQLBuffer sql , int index ) { } public void calculateValue ( Select sel , ExpContext ctx , ExpState state , Val other , ExpState otherState ) { } public void groupBy ( Select sel , ExpContext ctx , ExpState state ) { } public void orderBy ( Select sel , ExpContext ctx , ExpState state , boolean asc ) { } public ExpState initialize ( Select sel , ExpContext ctx , int flags ) { } public int length ( Select sel , ExpContext ctx , ExpState state ) { } public Object load ( ExpContext ctx , ExpState state , Result res ) throws SQLException { } public void select ( Select sel , ExpContext ctx , ExpState state , boolean pks ) { } public void selectColumns ( Select sel , ExpContext ctx , ExpState state , boolean pks ) { } public ClassMetaData getMetaData ( ) { } public Class getType ( ) { <START_BUG> return Object . class ; <END_BUG> } public void setImplicitType ( Class type ) { } public void setMetaData ( ClassMetaData meta ) { } } 
public class UrlConfigGui extends JPanel implements ChangeListener { private static final long serialVersionUID = 240L ; private static final int TAB_PARAMETERS = 0 ; private static final int TAB_RAW_BODY = 1 ; private HTTPArgumentsPanel argsPanel ; private JTextField domain ; private JTextField port ; private JTextField proxyHost ; private JTextField proxyPort ; private JTextField proxyUser ; private JPasswordField proxyPass ; private JTextField connectTimeOut ; private JTextField responseTimeOut ; private JTextField protocol ; private JTextField contentEncoding ; private JTextField path ; private JCheckBox followRedirects ; private JCheckBox autoRedirects ; private JCheckBox useKeepAlive ; private JCheckBox useMultipartForPost ; private JCheckBox useBrowserCompatibleMultipartMode ; private JLabeledChoice method ; private JLabeledChoice httpImplementation ; private final boolean notConfigOnly ; private final boolean showImplementation ; private JLabeledTextArea postBodyContent ; private UrlConfigGui . ValidationTabbedPane postContentTabbedPane ; private boolean showRawBodyPane ; public UrlConfigGui ( ) { } public UrlConfigGui ( boolean showSamplerFields ) { } public UrlConfigGui ( boolean showSamplerFields , boolean showImplementation , boolean showRawBodyPane ) { } public void clear ( ) { } public TestElement createTestElement ( ) { } public void modifyTestElement ( TestElement element ) { boolean useRaw = ( postContentTabbedPane . getSelectedIndex ( ) ) == ( UrlConfigGui . TAB_RAW_BODY ) ; Arguments args ; if ( useRaw ) { args = new Arguments ( ) ; String text = postBodyContent . getText ( ) ; <START_BUG> HTTPArgument arg = new HTTPArgument ( "" , text . replaceAll ( "\n" , "\r\n" ) , true ) ; <END_BUG> arg . setAlwaysEncoded ( false ) ; args . addArgument ( arg ) ; } else { args = ( ( Arguments ) ( argsPanel . createTestElement ( ) ) ) ; HTTPArgument . convertArgumentsToHTTP ( args ) ; } element . setProperty ( POST_BODY_RAW , useRaw , POST_BODY_RAW_DEFAULT ) ; element . setProperty ( new org . apache . jmeter . testelement . property . TestElementProperty ( HTTPSamplerBase . ARGUMENTS , args ) ) ; element . setProperty ( DOMAIN , domain . getText ( ) ) ; element . setProperty ( PORT , port . getText ( ) ) ; element . setProperty ( PROXYHOST , proxyHost . getText ( ) , "" ) ; element . setProperty ( PROXYPORT , proxyPort . getText ( ) , "" ) ; element . setProperty ( PROXYUSER , proxyUser . getText ( ) , "" ) ; element . setProperty ( PROXYPASS , String . valueOf ( proxyPass . getPassword ( ) ) , "" ) ; element . setProperty ( CONNECT_TIMEOUT , connectTimeOut . getText ( ) ) ; element . setProperty ( RESPONSE_TIMEOUT , responseTimeOut . getText ( ) ) ; element . setProperty ( PROTOCOL , protocol . getText ( ) ) ; element . setProperty ( CONTENT_ENCODING , contentEncoding . getText ( ) ) ; element . setProperty ( PATH , path . getText ( ) ) ; if ( notConfigOnly ) { element . setProperty ( METHOD , method . getText ( ) ) ; element . setProperty ( new org . apache . jmeter . testelement . property . BooleanProperty ( HTTPSamplerBase . FOLLOW_REDIRECTS , followRedirects . isSelected ( ) ) ) ; element . setProperty ( new org . apache . jmeter . testelement . property . BooleanProperty ( HTTPSamplerBase . AUTO_REDIRECTS , autoRedirects . isSelected ( ) ) ) ; element . setProperty ( new org . apache . jmeter . testelement . property . BooleanProperty ( HTTPSamplerBase . USE_KEEPALIVE , useKeepAlive . isSelected ( ) ) ) ; element . setProperty ( new org . apache . jmeter . testelement . property . BooleanProperty ( HTTPSamplerBase . DO_MULTIPART_POST , useMultipartForPost . isSelected ( ) ) ) ; element . setProperty ( BROWSER_COMPATIBLE_MULTIPART , useBrowserCompatibleMultipartMode . isSelected ( ) , BROWSER_COMPATIBLE_MULTIPART_MODE_DEFAULT ) ; } if ( showImplementation ) { element . setProperty ( IMPLEMENTATION , httpImplementation . getText ( ) , "" ) ; } } private static final String computePostBody ( Arguments arguments ) { } private static final String computePostBody ( Arguments arguments , boolean crlfToLF ) { } public void configure ( TestElement el ) { } private void init ( ) { } protected final JPanel getWebServerTimeoutPanel ( ) { } protected final JPanel getProxyServerPanel ( ) { } private JPanel getPortPanel ( ) { } private JPanel getProxyPortPanel ( ) { } private JPanel getConnectTimeOutPanel ( ) { } private JPanel getResponseTimeOutPanel ( ) { } private JPanel getDomainPanel ( ) { } private JPanel getProxyHostPanel ( ) { } private JPanel getProxyUserPanel ( ) { } private JPanel getProxyPassPanel ( ) { } protected Component getPathPanel ( ) { } protected JPanel getProtocolAndMethodPanel ( ) { } protected JTabbedPane getParameterPanel ( ) { } class ValidationTabbedPane extends JTabbedPane { private static final long serialVersionUID = 7014311238367882880L ; @ Override public void setSelectedIndex ( int index ) { } public void setSelectedIndex ( int index , boolean check ) { } } public void stateChanged ( ChangeEvent e ) { } void convertParametersToRaw ( ) { } boolean canConvertParameters ( ) { } boolean noData ( int oldSelectedIndex ) { } } 
public class AllowedMethodsInformation { public static final AllowedMethodsInformation INSTANCE_BMT = new AllowedMethodsInformation ( true ) ; public static final AllowedMethodsInformation INSTANCE_CMT = new AllowedMethodsInformation ( false ) ; private final Set < DeniedMethodKey > denied ; private final Set < AllowedMethodsInformation . DeniedSyncMethodKey > deniedSyncMethods ; private final boolean beanManagedTransaction ; protected AllowedMethodsInformation ( boolean beanManagedTransaction ) { } protected void setup ( Set < DeniedMethodKey > denied ) { } protected static void add ( Set < DeniedMethodKey > otherDenied , InvocationType setEntityContext , MethodType timerServiceMethod ) { } protected static void add ( Set < AllowedMethodsInformation . DeniedSyncMethodKey > otherDenied , CurrentSynchronizationCallback . CallbackType callbackType , MethodType timerServiceMethod ) { } public static void checkAllowed ( final MethodType methodType ) { } private void checkTransactionSync ( MethodType methodType ) { } protected void realCheckPermission ( MethodType methodType , InvocationType invocationType ) { checkTransactionSync ( methodType ) ; if ( invocationType != null ) { if ( denied . contains ( new DeniedMethodKey ( invocationType , methodType ) ) ) { throwException ( methodType , invocationType ) ; } } <START_BUG> if ( ( ! ( beanManagedTransaction ) ) && ( methodType == ( MethodType . GET_USER_TRANSACTION ) ) ) { <END_BUG> throw MESSAGES . unauthorizedAccessToUserTransaction ( ) ; } } protected void throwException ( MethodType methodType , InvocationType invocationType ) { } protected void throwException ( MethodType methodType , CurrentSynchronizationCallback . CallbackType callback ) { } private static class DeniedSyncMethodKey { private final CallbackType callbackType ; private final MethodType methodType ; public DeniedSyncMethodKey ( CurrentSynchronizationCallback . CallbackType callbackType , MethodType methodType ) { } public CallbackType getCallbackType ( ) { } public MethodType getMethodType ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } } } 
public class ChannelMetricsHandler extends AbstractRuntimeOnlyHandler { @ Override protected void executeRuntimeStep ( OperationContext context , ModelNode operation ) throws OperationFailedException { <START_BUG> String channelName = context . getCurrentAddressValue ( ) ; <END_BUG> String name = Operations . getAttributeName ( operation ) ; ChannelMetric metric = ChannelMetric . forName ( name ) ; if ( metric == null ) { context . getFailureDescription ( ) . set ( ROOT_LOGGER . unknownMetric ( name ) ) ; } else { JChannel channel = ServiceContainerHelper . findValue ( context . getServiceRegistry ( false ) , CHANNEL . getServiceName ( channelName ) ) ; if ( channel != null ) { context . getResult ( ) . set ( metric . getValue ( channel ) ) ; } } context . completeStep ( NOOP_RESULT_HANDLER ) ; } } 
public class JavaScript extends AbstractFunction { private static final List < String > desc = new LinkedList < String > ( ) ; private static final String KEY = "__javaScript" ; private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private Object [ ] values ; public JavaScript ( ) { } @ Override public synchronized String execute ( SampleResult previousResult , Sampler currentSampler ) throws InvalidVariableException { JMeterContext jmctx = JMeterContextService . getContext ( ) ; JMeterVariables vars = jmctx . getVariables ( ) ; String script = ( ( CompoundVariable ) ( values [ 0 ] ) ) . execute ( ) ; String varName = ( ( values . length ) < 2 ) ? null : ( ( CompoundVariable ) ( values [ 1 ] ) ) . execute ( ) . trim ( ) ; String resultStr = "" ; Context cx = Context . enter ( ) ; try { Scriptable scope = cx . initStandardObjects ( null ) ; scope . put ( "log" , scope , JavaScript . log ) ; scope . put ( "ctx" , scope , jmctx ) ; scope . put ( "vars" , scope , vars ) ; scope . put ( "props" , scope , JMeterUtils . getJMeterProperties ( ) ) ; scope . put ( "threadName" , scope , Thread . currentThread ( ) . getName ( ) ) ; scope . put ( "sampler" , scope , currentSampler ) ; scope . put ( "sampleResult" , scope , previousResult ) ; Object result = cx . evaluateString ( scope , script , "<cmd>" , 1 , null ) ; resultStr = Context . toString ( result ) ; if ( ( varName != null ) && ( vars != null ) ) { vars . put ( varName , resultStr ) ; } } catch ( RhinoException e ) { JavaScript . log . error ( ( ( "Error<seq2seq4repair_space>processing<seq2seq4repair_space>Javascript:<seq2seq4repair_space>[" + script ) + "]\n" ) , e ) ; <START_BUG> throw new InvalidVariableException ( ) ; <END_BUG> } finally { Context . exit ( ) ; } return resultStr ; } @ Override public synchronized void setParameters ( Collection < CompoundVariable > parameters ) throws InvalidVariableException { } @ Override public String getReferenceKey ( ) { } public List < String > getArgumentDesc ( ) { } } 
public class ThisJoinPointVisitor extends ASTVisitor { boolean needsDynamic = false ; boolean needsStatic = false ; boolean needsStaticEnclosing = false ; boolean hasEffectivelyStaticRef = false ; LocalVariableBinding thisJoinPointDec ; LocalVariableBinding thisJoinPointStaticPartDec ; LocalVariableBinding thisEnclosingJoinPointStaticPartDec ; LocalVariableBinding thisJoinPointDecLocal ; LocalVariableBinding thisJoinPointStaticPartDecLocal ; LocalVariableBinding thisEnclosingJoinPointStaticPartDecLocal ; boolean replaceEffectivelyStaticRefs = false ; AbstractMethodDeclaration method ; ThisJoinPointVisitor ( AbstractMethodDeclaration method ) { } public void computeJoinPointParams ( ) { } boolean isRef ( NameReference ref , Binding binding ) { } boolean isRef ( Expression expr , Binding binding ) { } public void endVisit ( SingleNameReference ref , BlockScope scope ) { } boolean canTreatAsStatic ( String id ) { } boolean inBlockThatCantRun = false ; public boolean visit ( MessageSend call , BlockScope scope ) { } private void replaceEffectivelyStaticRef ( MessageSend call ) { NameReference receiver = ( ( NameReference ) ( call . receiver ) ) ; if ( ( call . binding ) == null ) return ; receiver . binding = thisJoinPointStaticPartDecLocal ; receiver . codegenBinding = thisJoinPointStaticPartDecLocal ; ReferenceBinding thisJoinPointStaticPartType = ( ( ReferenceBinding ) ( thisJoinPointStaticPartDec . type ) ) ; <START_BUG> receiver . receiverType = receiver . actualReceiverType = receiver . resolvedType = thisJoinPointStaticPartType ; <END_BUG> call . setActualReceiverType ( thisJoinPointStaticPartType ) ; AstUtil . replaceMethodBinding ( call , getEquivalentStaticBinding ( call . binding ) ) ; } private MethodBinding getEquivalentStaticBinding ( MethodBinding template ) { } public int removeUnusedExtraArguments ( ) { } private void removeParameter ( int indexToRemove ) { } private static TypeBinding [ ] removeParameter ( int index , TypeBinding [ ] bindings ) { } private static LocalVariableBinding [ ] removeLocalBinding ( int index , LocalVariableBinding [ ] bindings ) { } } 
public class TableController implements TreeSelectionListener , FolderListener , FocusOwner { private TableView view ; private AddressbookFrameMediator mediator ; private AddressbookTableModel addressbookModel ; private SortDecorator sortDecorator ; private FilterDecorator filterDecorator ; private AddressbookTreeNode selectedFolder ; public TableController ( AddressbookFrameMediator mediator ) { } protected void addMouseListenerToHeaderInTable ( ) { } public AddressbookFrameMediator getMediator ( ) { } public TableView getView ( ) { } public void valueChanged ( TreeSelectionEvent e ) { AddressbookTreeNode node = ( ( AddressbookTreeNode ) ( e . getPath ( ) . getLastPathComponent ( ) ) ) ; if ( node == null ) { return ; } if ( node instanceof IContactStorage ) { try { ( ( org . columba . addressbook . folder . AbstractFolder ) ( node ) ) . removeFolderListener ( this ) ; selectedFolder = node ; ( ( org . columba . addressbook . folder . AbstractFolder ) ( node ) ) . addFolderListener ( this ) ; filterDecorator . setContactItemMap ( ( ( org . columba . addressbook . folder . AbstractFolder ) ( selectedFolder ) ) . getContactItemMap ( ) ) ; } catch ( Exception e1 ) { if ( Logging . DEBUG ) e1 . printStackTrace ( ) ; <START_BUG> new ErrorDialog ( e1 . getMessage ( ) , e1 ) ; <END_BUG> } } else { filterDecorator . setContactItemMap ( null ) ; } } public Object [ ] getUids ( ) { } public AddressbookTableModel getAddressbookModel ( ) { } public IContactItem getSelectedItem ( ) { } public void itemAdded ( IFolderEvent e ) { } public void itemChanged ( IFolderEvent e ) { } public void itemRemoved ( IFolderEvent e ) { } public void copy ( ) { } public void cut ( ) { } public void delete ( ) { } public JComponent getComponent ( ) { } public boolean isCopyActionEnabled ( ) { } public boolean isCutActionEnabled ( ) { } public boolean isDeleteActionEnabled ( ) { } public boolean isPasteActionEnabled ( ) { } public boolean isRedoActionEnabled ( ) { } public boolean isSelectAllActionEnabled ( ) { } public boolean isUndoActionEnabled ( ) { } public void paste ( ) { } public void redo ( ) { } public void selectAll ( ) { } public void undo ( ) { } public SortDecorator getSortDecorator ( ) { } public FilterDecorator getFilterDecorator ( ) { } } 
class PeriodicRotatingFileHandlerAdd implements ModelAddOperationHandler { static final PeriodicRotatingFileHandlerAdd INSTANCE = new PeriodicRotatingFileHandlerAdd ( ) ; @ Override public OperationResult execute ( final OperationContext context , final ModelNode operation , final ResultHandler resultHandler ) throws OperationFailedException { final PathAddress address = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) ; final String name = address . getLastElement ( ) . getValue ( ) ; final ModelNode compensatingOperation = new ModelNode ( ) ; compensatingOperation . get ( OP_ADDR ) . set ( operation . require ( OP_ADDR ) ) ; compensatingOperation . get ( OP ) . set ( REMOVE ) ; final ModelNode subModel = context . getSubModel ( ) ; subModel . get ( CommonAttributes . AUTOFLUSH ) . set ( operation . get ( CommonAttributes . AUTOFLUSH ) ) ; subModel . get ( CommonAttributes . ENCODING ) . set ( operation . get ( CommonAttributes . ENCODING ) ) ; subModel . get ( CommonAttributes . FORMATTER ) . set ( operation . get ( CommonAttributes . FORMATTER ) ) ; subModel . get ( CommonAttributes . LEVEL ) . set ( operation . get ( CommonAttributes . LEVEL ) ) ; subModel . get ( CommonAttributes . FILE ) . set ( operation . get ( CommonAttributes . FILE ) ) ; subModel . get ( CommonAttributes . SUFFIX ) . set ( operation . get ( CommonAttributes . SUFFIX ) ) ; if ( ( context . getRuntimeContext ( ) ) != null ) { context . getRuntimeContext ( ) . setRuntimeTask ( new RuntimeTask ( ) { public void execute ( RuntimeTaskContext context ) throws OperationFailedException { final ServiceTarget serviceTarget = context . getServiceTarget ( ) ; try { final PeriodicRotatingFileHandlerService service = new PeriodicRotatingFileHandlerService ( ) ; final ServiceBuilder < Handler > serviceBuilder = serviceTarget . addService ( LogServices . handlerName ( name ) , service ) ; if ( operation . hasDefined ( CommonAttributes . FILE ) ) { final HandlerFileService fileService = new HandlerFileService ( operation . get ( CommonAttributes . FILE , CommonAttributes . PATH ) . asString ( ) ) ; final ServiceBuilder < ? > fileBuilder = serviceTarget . addService ( LogServices . handlerFileName ( name ) , fileService ) ; <START_BUG> if ( operation . hasDefined ( RELATIVE_TO ) ) { <END_BUG> fileBuilder . addDependency ( AbstractPathService . pathNameOf ( operation . get ( CommonAttributes . FILE , CommonAttributes . RELATIVE_TO ) . asString ( ) ) , String . class , fileService . getRelativeToInjector ( ) ) ; } fileBuilder . setInitialMode ( ACTIVE ) . install ( ) ; serviceBuilder . addDependency ( LogServices . handlerFileName ( name ) , String . class , service . getFileNameInjector ( ) ) ; } service . setLevel ( Level . parse ( operation . get ( CommonAttributes . LEVEL ) . asString ( ) ) ) ; final Boolean autoFlush = operation . get ( CommonAttributes . AUTOFLUSH ) . asBoolean ( ) ; if ( autoFlush != null ) service . setAutoflush ( autoFlush . booleanValue ( ) ) ; if ( operation . hasDefined ( CommonAttributes . SUFFIX ) ) service . setSuffix ( operation . get ( CommonAttributes . SUFFIX ) . asString ( ) ) ; if ( operation . hasDefined ( CommonAttributes . ENCODING ) ) service . setEncoding ( operation . get ( CommonAttributes . ENCODING ) . asString ( ) ) ; if ( operation . hasDefined ( CommonAttributes . FORMATTER ) ) service . setFormatterSpec ( PeriodicRotatingFileHandlerAdd . createFormatterSpec ( operation ) ) ; serviceBuilder . setInitialMode ( ACTIVE ) ; serviceBuilder . install ( ) ; resultHandler . handleResultComplete ( ) ; } catch ( Throwable t ) { throw new OperationFailedException ( new ModelNode ( ) . set ( t . getLocalizedMessage ( ) ) ) ; } } } ) ; } else { resultHandler . handleResultComplete ( ) ; } return new org . jboss . as . controller . BasicOperationResult ( compensatingOperation ) ; } static AbstractFormatterSpec createFormatterSpec ( final ModelNode operation ) { } } 
public abstract class PassivationStoreRemove extends AbstractRemoveStepHandler { private final PassivationStoreAdd add ; PassivationStoreRemove ( PassivationStoreAdd add ) { } @ Override protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model ) throws OperationFailedException { } @ Override protected void recoverServices ( OperationContext context , ModelNode operation , ModelNode model ) throws OperationFailedException { if ( context . isResourceServiceRestartAllowed ( ) ) { <START_BUG> this . add . installRuntimeService ( context , model , null ) ; <END_BUG> } else { context . revertReloadRequired ( ) ; } } void removeRuntimeService ( OperationContext context , ModelNode operation ) { } } 
class DefaultBindingResolver extends BindingResolver { Map compilerBindingsToASTBindings ; Map newAstToOldAst ; Map bindingsToAstNodes ; Map astNodesToBindings ; DefaultBindingResolver ( ) { } IBinding resolveName ( Name name ) { } private IBinding resolveNameForMessageSend ( Name name , AstNode node ) { } private IBinding resolveNameForMessageSend ( Name name , AstNode node , int index ) { } private IBinding resolveNameForNameReference ( Name name , AstNode node ) { } private IBinding resolveNameForPackageDeclaration ( Name name ) { } ITypeBinding resolveType ( Type type ) { } ITypeBinding resolveWellKnownType ( String name ) { } ITypeBinding resolveType ( TypeDeclaration type ) { } IMethodBinding resolveMethod ( MethodDeclaration method ) { } IVariableBinding resolveVariable ( VariableDeclaration variable ) { AbstractVariableDeclaration abstractVariableDeclaration = ( ( AbstractVariableDeclaration ) ( this . newAstToOldAst . get ( variable ) ) ) ; if ( abstractVariableDeclaration instanceof FieldDeclaration ) { <START_BUG> FieldDeclaration fieldDeclaration = ( ( FieldDeclaration ) ( this . newAstToOldAst . get ( variable ) ) ) ; <END_BUG> return this . getVariableBinding ( fieldDeclaration . binding ) ; } return this . getVariableBinding ( ( ( LocalDeclaration ) ( abstractVariableDeclaration ) ) . binding ) ; } IVariableBinding resolveVariable ( FieldDeclaration variable ) { } ITypeBinding resolveExpressionType ( Expression expression ) { } public ASTNode findDeclaringNode ( IBinding binding ) { } void store ( ASTNode node , AstNode oldASTNode ) { } protected ITypeBinding getTypeBinding ( TypeBinding referenceBinding ) { } protected IPackageBinding getPackageBinding ( PackageBinding packageBinding ) { } protected IVariableBinding getVariableBinding ( VariableBinding variableBinding ) { } protected IMethodBinding getMethodBinding ( MethodBinding methodBinding ) { } private BlockScope retrieveEnclosingScope ( ASTNode node ) { } } 
public class BlockScope extends Scope { public LocalVariableBinding [ ] locals ; public int localIndex ; public int startIndex ; public int offset ; public int maxOffset ; public BlockScope [ ] shiftScopes ; public static final VariableBinding [ ] EmulationPathToImplicitThis = new VariableBinding [ ] { } ; public static final VariableBinding [ ] NoEnclosingInstanceInConstructorCall = new VariableBinding [ ] { } ; public static final VariableBinding [ ] NoEnclosingInstanceInStaticContext = new VariableBinding [ ] { } ; public Scope [ ] subscopes = new Scope [ 1 ] ; public int subscopeCount = 0 ; public CaseStatement enclosingCase ; protected BlockScope ( int kind , Scope parent ) { } public BlockScope ( BlockScope parent ) { } public BlockScope ( BlockScope parent , boolean addToParentScope ) { } public BlockScope ( BlockScope parent , int variableCount ) { } public final void addAnonymousType ( TypeDeclaration anonymousType , ReferenceBinding superBinding ) { } public final void addLocalType ( TypeDeclaration localType ) { } public final void addLocalVariable ( LocalVariableBinding binding ) { } public void addSubscope ( Scope childScope ) { } public final boolean allowBlankFinalFieldAssignment ( FieldBinding binding ) { } String basicToString ( int tab ) { } private void checkAndSetModifiersForVariable ( LocalVariableBinding varBinding ) { } void computeLocalVariablePositions ( int ilocal , int initOffset , CodeStream codeStream ) { this . offset = initOffset ; this . maxOffset = initOffset ; int maxLocals = this . localIndex ; boolean hasMoreVariables = ilocal < maxLocals ; int iscope = 0 ; int maxScopes = this . subscopeCount ; boolean hasMoreScopes = maxScopes > 0 ; while ( hasMoreVariables || hasMoreScopes ) { if ( hasMoreScopes && ( ( ! hasMoreVariables ) || ( ( subscopes [ iscope ] . startIndex ( ) ) <= ilocal ) ) ) { if ( ( subscopes [ iscope ] ) instanceof BlockScope ) { BlockScope subscope = ( ( BlockScope ) ( subscopes [ iscope ] ) ) ; int subOffset = ( ( subscope . shiftScopes ) == null ) ? this . offset : subscope . maxShiftedOffset ( ) ; subscope . computeLocalVariablePositions ( 0 , subOffset , codeStream ) ; if ( ( subscope . maxOffset ) > ( this . maxOffset ) ) this . maxOffset = subscope . maxOffset ; } hasMoreScopes = ( ++ iscope ) < maxScopes ; } else { LocalVariableBinding local = locals [ ilocal ] ; boolean generateCurrentLocalVar = ( ( local . useFlag ) == ( LocalVariableBinding . USED ) ) && ( ( local . constant ( ) ) == ( Constant . NotAConstant ) ) ; if ( ( ( ( local . useFlag ) == ( LocalVariableBinding . UNUSED ) ) && ( ( local . declaration ) != null ) ) && ( ( ( local . declaration . bits ) & ( ASTNode . IsLocalDeclarationReachable ) ) != 0 ) ) { if ( ! ( ( local . declaration ) instanceof Argument ) ) this . problemReporter ( ) . unusedLocalVariable ( local . declaration ) ; } if ( ! generateCurrentLocalVar ) { if ( ( ( local . declaration ) != null ) && ( compilerOptions ( ) . preserveAllLocalVariables ) ) { generateCurrentLocalVar = true ; local . useFlag = LocalVariableBinding . USED ; } } if ( generateCurrentLocalVar ) { if ( ( local . declaration ) != null ) { codeStream . record ( local ) ; } local . resolvedPosition = this . offset ; <START_BUG> if ( ( ( local . type ) == ( LongBinding ) ) || ( ( local . type ) == ( DoubleBinding ) ) ) { <END_BUG> this . offset += 2 ; } else { ( this . offset ) ++ ; } if ( ( this . offset ) > 65535 ) { this . problemReporter ( ) . noMoreAvailableSpaceForLocal ( local , ( ( local . declaration ) == null ? ( ( ASTNode ) ( this . methodScope ( ) . referenceContext ) ) : local . declaration ) ) ; } } else { local . resolvedPosition = - 1 ; } hasMoreVariables = ( ++ ilocal ) < maxLocals ; } } if ( ( this . offset ) > ( this . maxOffset ) ) this . maxOffset = this . offset ; } public void emulateOuterAccess ( LocalVariableBinding outerLocalVariable ) { } public LocalDeclaration [ ] findLocalVariableDeclarations ( int position ) { } public final ReferenceBinding findLocalType ( char [ ] name ) { } public LocalVariableBinding findVariable ( char [ ] variable ) { } public Binding getBinding ( char [ ] [ ] compoundName , int mask , InvocationSite invocationSite , boolean needResolve ) { } public final Binding getBinding ( char [ ] [ ] compoundName , InvocationSite invocationSite ) { } public VariableBinding [ ] getEmulationPath ( LocalVariableBinding outerLocalVariable ) { } public Object [ ] getEmulationPath ( ReferenceBinding targetEnclosingType , boolean onlyExactMatch , boolean denyEnclosingArgInConstructorCall ) { } public final boolean isDuplicateLocalVariable ( char [ ] name ) { } public int maxShiftedOffset ( ) { } public ProblemReporter problemReporter ( ) { } public void propagateInnerEmulation ( ReferenceBinding targetType , boolean isEnclosingInstanceSupplied ) { } public TypeDeclaration referenceType ( ) { } public int scopeIndex ( ) { } int startIndex ( ) { } public String toString ( ) { } public String toString ( int tab ) { } } 
public class PageInstanceMapper extends AbstractComponentMapper { public PageInstanceMapper ( ) { } public IRequestHandler mapRequest ( Request request ) { } public Url mapHandler ( IRequestHandler requestHandler ) { PageComponentInfo info = null ; if ( requestHandler instanceof RenderPageRequestHandler ) { IRequestablePage page = ( ( RenderPageRequestHandler ) ( requestHandler ) ) . getPage ( ) ; PageInfo i = new PageInfo ( page . getPageId ( ) ) ; info = new PageComponentInfo ( i , null ) ; } else if ( requestHandler instanceof ListenerInterfaceRequestHandler ) { ListenerInterfaceRequestHandler handler = ( ( ListenerInterfaceRequestHandler ) ( requestHandler ) ) ; IRequestablePage page = handler . getPage ( ) ; <START_BUG> String componentPath = handler . getComponent ( ) . getPageRelativePath ( ) ; <END_BUG> RequestListenerInterface listenerInterface = handler . getListenerInterface ( ) ; Integer renderCount = null ; if ( listenerInterface . isIncludeRenderCount ( ) ) { renderCount = page . getRenderCount ( ) ; } PageInfo pageInfo = new PageInfo ( page . getPageId ( ) ) ; ComponentInfo componentInfo = new ComponentInfo ( renderCount , requestListenerInterfaceToString ( listenerInterface ) , componentPath , handler . getBehaviorIndex ( ) ) ; info = new PageComponentInfo ( pageInfo , componentInfo ) ; } if ( info != null ) { Url url = new Url ( ) ; url . getSegments ( ) . add ( getContext ( ) . getNamespace ( ) ) ; url . getSegments ( ) . add ( getContext ( ) . getPageIdentifier ( ) ) ; encodePageComponentInfo ( url , info ) ; return url ; } else { return null ; } } public int getCompatibilityScore ( Request request ) { } } 
void createWidget ( ) { } Color defaultBackground ( ) { } NSFont defaultNSFont ( ) { } Color defaultForeground ( ) { } public void deselectAll ( ) { } void deregister ( ) { } public void deselect ( TreeItem item ) { } void destroyItem ( TreeColumn column ) { } void destroyItem ( TreeItem item ) { } boolean dragDetect ( int x , int y , boolean filter , boolean [ ] consume ) { } void drawInteriorWithFrame_inView ( int id , int sel , int cellFrame , int view ) { } int getCheckColumnWidth ( ) { } TreeColumn getColumn ( id id ) { } public TreeColumn getColumn ( int index ) { } public int getColumnCount ( ) { } public int [ ] getColumnOrder ( ) { } public TreeColumn [ ] getColumns ( ) { } public int getGridLineWidth ( ) { } public int getHeaderHeight ( ) { } public boolean getHeaderVisible ( ) { } public TreeItem getItem ( int index ) { } public TreeItem getItem ( Point point ) { } public int getItemCount ( ) { } int getItemCount ( TreeItem item ) { } public int getItemHeight ( ) { } public TreeItem [ ] getItems ( ) { } public boolean getLinesVisible ( ) { } public TreeItem getParentItem ( ) { } public TreeItem [ ] getSelection ( ) { } public int getSelectionCount ( ) { } public TreeColumn getSortColumn ( ) { } public int getSortDirection ( ) { } public TreeItem getTopItem ( ) { } void highlightSelectionInClipRect ( int id , int sel , int rect ) { } public int indexOf ( TreeColumn column ) { } public int indexOf ( TreeItem item ) { } boolean isTrim ( NSView view ) { } int menuForEvent ( int id , int sel , int theEvent ) { } int outlineView_child_ofItem ( int id , int sel , int outlineView , int index , int itemID ) { } void outlineView_didClickTableColumn ( int id , int sel , int outlineView , int tableColumn ) { } int outlineView_objectValueForTableColumn_byItem ( int id , int sel , int outlineView , int tableColumn , int itemID ) { } boolean outlineView_isItemExpandable ( int id , int sel , int outlineView , int item ) { } int outlineView_numberOfChildrenOfItem ( int id , int sel , int outlineView , int item ) { } void outlineView_willDisplayCell_forTableColumn_item ( int id , int sel , int outlineView , int cell , int tableColumn , int itemID ) { } void outlineViewColumnDidMove ( int id , int sel , int aNotification ) { } void outlineViewColumnDidResize ( int id , int sel , int aNotification ) { } void outlineViewItemDidExpand ( int id , int sel , int notification ) { } void outlineViewSelectionDidChange ( int id , int sel , int notification ) { } boolean outlineView_shouldCollapseItem ( int id , int sel , int outlineView , int itemID ) { } boolean outlineView_shouldExpandItem ( int id , int sel , int outlineView , int itemID ) { } void outlineView_setObjectValue_forTableColumn_byItem ( int id , int sel , int outlineView , int object , int tableColumn , int itemID ) { } void register ( ) { } void releaseChildren ( boolean destroy ) { } void releaseHandle ( ) { } void releaseWidget ( ) { } void reloadItem ( TreeItem item , boolean recurse ) { } public void removeAll ( ) { } public void removeSelectionListener ( SelectionListener listener ) { } public void removeTreeListener ( TreeListener listener ) { } public void setInsertMark ( TreeItem item , boolean before ) { } public void selectAll ( ) { } public void select ( TreeItem item ) { } void sendDoubleSelection ( ) { } boolean sendKeyEvent ( NSEvent nsEvent , int type ) { } void setBackground ( float [ ] color ) { } public void setColumnOrder ( int [ ] order ) { } void setFont ( NSFont font ) { } public void setHeaderVisible ( boolean show ) { } public void setItemCount ( int count ) { } void setItemCount ( TreeItem parentItem , int count ) { } void setItemHeight ( int itemHeight ) { } void setItemHeight ( Image image , NSFont font , boolean set ) { } public void setLinesVisible ( boolean show ) { } public void setRedraw ( boolean redraw ) { } boolean setScrollWidth ( ) { } boolean setScrollWidth ( boolean set , TreeItem [ ] items , boolean recurse ) { if ( items == null ) return false ; if ( ( ignoreRedraw ) || ( ( drawCount ) != 0 ) ) return false ; <START_BUG> if ( ( ( columnCount ) != 0 ) || ( items == null ) ) <END_BUG> return false ; GC gc = new GC ( this ) ; int newWidth = calculateWidth ( items , 0 , gc , recurse ) ; gc . dispose ( ) ; if ( ! set ) { int oldWidth = ( ( int ) ( firstColumn . width ( ) ) ) ; if ( oldWidth >= newWidth ) return false ; } firstColumn . setWidth ( newWidth ) ; return true ; } boolean setScrollWidth ( TreeItem item ) { } public void setSelection ( TreeItem item ) { } public void setSelection ( TreeItem [ ] items ) { } void setSmallSize ( ) { } public void setSortColumn ( TreeColumn column ) { } public void setSortDirection ( int direction ) { } public void setTopItem ( TreeItem item ) { } public void showColumn ( TreeColumn column ) { } public void showItem ( TreeItem item ) { } void showItem ( TreeItem item , boolean scroll ) { } public void showSelection ( ) { } } 
public class HeaderManager extends ConfigTestElement implements Serializable { public static final String HEADERS = "HeaderManager.headers" ; private static final int columnCount = 2 ; private static final String [ ] columnNames = new String [ ] { JMeterUtils . getResString ( "name" ) , JMeterUtils . getResString ( "value" ) } ; private Object SOAPHeader = null ; public HeaderManager ( ) { } public CollectionProperty getHeaders ( ) { } public int getColumnCount ( ) { } public String getColumnName ( int column ) { } public Class getColumnClass ( int column ) { } public Header getHeader ( int row ) { } public void save ( String headFile ) throws IOException { } public void addFile ( String headerFile ) throws IOException { } public void add ( Header h ) { } public void add ( ) { } public void remove ( int index ) { } public int size ( ) { } public Header get ( int i ) { } public void removeHeaderNamed ( String name ) { Vector removeIndices = new Vector ( ) ; <START_BUG> for ( int i = ( getHeaders ( ) . size ( ) ) - 1 ; i > 0 ; i -- ) { <END_BUG> Header header = ( ( Header ) ( getHeaders ( ) . get ( i ) . getObjectValue ( ) ) ) ; if ( header == null ) { continue ; } if ( header . getName ( ) . equalsIgnoreCase ( name ) ) { removeIndices . addElement ( new Integer ( i ) ) ; } } for ( Enumeration e = removeIndices . elements ( ) ; e . hasMoreElements ( ) ; ) { getHeaders ( ) . remove ( ( ( Integer ) ( e . nextElement ( ) ) ) . intValue ( ) ) ; } } public String [ ] split ( String splittee , String splitChar , String def ) { } public String getClassLabel ( ) { } public Object getSOAPHeader ( ) { } public void setSOAPHeader ( Object header ) { } } 
public class BuildArgParser extends Main { private static final String BUNDLE_NAME = "org.aspectj.ajdt.ajc.messages" ; private static boolean LOADED_BUNDLE = false ; private static class StringPrintWriter extends PrintWriter { public final StringWriter stringWriter ; StringPrintWriter ( StringWriter sw ) { } } public static String getUsage ( ) { } private final StringBuffer errorSink ; public BuildArgParser ( PrintWriter writer ) { } public BuildArgParser ( ) { } public AjBuildConfig genBuildConfig ( String [ ] args , IMessageHandler handler ) { } public String getOtherMessages ( boolean flush ) { } private void setDebugOptions ( ) { } private Collection collectSourceRootFiles ( File dir ) { } public List getClasspath ( BuildArgParser . AjcConfigParser parser ) { } private void addExtDirs ( String extdirs , List classpathCollector ) { } private void addClasspath ( String classpath , List classpathCollector ) { } private class AjcConfigParser extends ConfigParser { private String bootclasspath = null ; private String classpath = null ; private String extdirs = null ; private List unparsedArgs = new ArrayList ( ) ; private AjBuildConfig buildConfig ; private IMessageHandler handler ; public AjcConfigParser ( AjBuildConfig buildConfig , IMessageHandler handler ) { } public List getUnparsedArgs ( ) { } public void parseOption ( String arg , LinkedList args ) { } protected void dirLookahead ( String arg , LinkedList argList , int nextArgIndex ) { } public void showError ( String message ) { <START_BUG> MessageUtil . error ( handler , message ) ; <END_BUG> } protected void showWarning ( String message ) { } } } 
public class MultiPassIndexSplitter { public void split ( Version version , IndexReader in , Directory [ ] outputs , boolean seq ) throws IOException { if ( ( outputs == null ) || ( ( outputs . length ) < 2 ) ) { throw new IOException ( "Invalid<seq2seq4repair_space>number<seq2seq4repair_space>of<seq2seq4repair_space>outputs." ) ; } if ( ( in == null ) || ( ( in . numDocs ( ) ) < 2 ) ) { throw new IOException ( "Not<seq2seq4repair_space>enough<seq2seq4repair_space>documents<seq2seq4repair_space>for<seq2seq4repair_space>splitting" ) ; } int numParts = outputs . length ; MultiPassIndexSplitter . FakeDeleteIndexReader input = new MultiPassIndexSplitter . FakeDeleteIndexReader ( in ) ; int maxDoc = input . maxDoc ( ) ; int partLen = maxDoc / numParts ; for ( int i = 0 ; i < numParts ; i ++ ) { input . undeleteAll ( ) ; if ( seq ) { int lo = partLen * i ; int hi = lo + partLen ; for ( int j = 0 ; j < lo ; j ++ ) { input . deleteDocument ( j ) ; } if ( i < ( numParts - 1 ) ) { for ( int j = hi ; j < maxDoc ; j ++ ) { input . deleteDocument ( j ) ; } } } else { for ( int j = 0 ; j < maxDoc ; j ++ ) { if ( ( ( ( j + numParts ) - i ) % numParts ) != 0 ) { input . deleteDocument ( j ) ; } } } IndexWriter w = new IndexWriter ( outputs [ i ] , new IndexWriterConfig ( version , null ) . setOpenMode ( CREATE ) ) ; System . err . println ( ( ( "Writing<seq2seq4repair_space>part<seq2seq4repair_space>" + ( i + 1 ) ) + "<seq2seq4repair_space>..." ) ) ; final List < ? extends MultiPassIndexSplitter . FakeDeleteAtomicIndexReader > sr = input . getSequentialSubReaders ( ) ; w . addIndexes ( sr . toArray ( new IndexReader [ sr . size ( ) ] ) ) ; <START_BUG> w . close ( ) ; <END_BUG> } System . err . println ( "Done." ) ; } @ SuppressWarnings ( "deprecation" ) public static void main ( String [ ] args ) throws Exception { } private static final class FakeDeleteIndexReader extends BaseCompositeReader < MultiPassIndexSplitter . FakeDeleteAtomicIndexReader > { public FakeDeleteIndexReader ( IndexReader reader ) { } private static MultiPassIndexSplitter . FakeDeleteAtomicIndexReader [ ] initSubReaders ( IndexReader reader ) { } public void deleteDocument ( int docID ) { } public void undeleteAll ( ) { } @ Override protected void doClose ( ) { } } private static final class FakeDeleteAtomicIndexReader extends FilterAtomicReader { FixedBitSet liveDocs ; public FakeDeleteAtomicIndexReader ( AtomicReader reader ) { } @ Override public int numDocs ( ) { } public void undeleteAll ( ) { } public void deleteDocument ( int n ) { } @ Override public Bits getLiveDocs ( ) { } } } 
@ Entity @ Table ( name = "EMP_MBI" ) @ IdClass ( EmpId . class ) public class Employee { @ Id int empId ; @ Id @ Enumerated Employee . EmpType empType ; @ OneToOne PhoneNumber phoneNumber ; public PhoneNumber getPhoneNumber ( ) { } public void setPhoneNumber ( PhoneNumber phoneNumber ) { } public int getEmpId ( ) { } public void setEmpId ( int empId ) { } public Employee . EmpType getEmpType ( ) { } public void setEmpType ( Employee . EmpType empType ) { } public boolean equals ( Object o ) { Employee e = ( ( Employee ) ( o ) ) ; PhoneNumber p = e . getPhoneNumber ( ) ; <START_BUG> if ( ( p . getNumber ( ) ) != ( phoneNumber . getNumber ( ) ) ) <END_BUG> return false ; return true ; } public enum EmpType { A1 , A2 , A3 , A4 ; } } 
public final class DeferredAttrNSImpl extends AttrNSImpl implements DeferredNode { static final long serialVersionUID = 6074924934945957154L ; protected transient int fNodeIndex ; DeferredAttrNSImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { } public int getNodeIndex ( ) { } protected void synchronizeData ( ) { needsSyncData ( false ) ; DeferredDocumentImpl ownerDocument = ( ( DeferredDocumentImpl ) ( ownerDocument ( ) ) ) ; name = ownerDocument . getNodeName ( fNodeIndex ) ; int index = name . indexOf ( ':' ) ; String prefix ; if ( index < 0 ) { prefix = null ; localName = name ; } else { prefix = name . substring ( 0 , index ) ; localName = name . substring ( ( index + 1 ) ) ; } isSpecified ( ( ( ownerDocument . getNodeExtra ( fNodeIndex ) ) == 1 ) ) ; namespaceURI = ownerDocument . getNodeURI ( fNodeIndex ) ; <START_BUG> if ( ( namespaceURI . length ( ) ) == 0 ) { <END_BUG> namespaceURI = null ; } if ( ( namespaceURI ) == null ) { if ( prefix != null ) { if ( prefix . equals ( "xmlns" ) ) { namespaceURI = "http://www.w3.org/2000/xmlns/" ; } } else if ( name . equals ( "xmlns" ) ) { namespaceURI = "http://www.w3.org/2000/xmlns/" ; } } } protected void synchronizeChildren ( ) { } } 
@ SuppressWarnings ( "serial" ) public class SessionConnectEvent extends ApplicationEvent { private final Message < byte [ ] > message ; public SessionConnectEvent ( Object source , Message < byte [ ] > message ) { } public Message < byte [ ] > getMessage ( ) { } @ Override public String toString ( ) { <START_BUG> return "SessionConnectEvent:<seq2seq4repair_space>message=" + ( message ) ; <END_BUG> } } 
public class TableMouseListener extends DoubleClickListener { private TableController controller = null ; private AddressbookFrameMediator mediator = null ; public TableMouseListener ( TableController tableController ) { } public void doubleClick ( MouseEvent e ) { if ( ( ( e . getButton ( ) ) == ( MouseEvent . BUTTON1 ) ) && ( ( e . getClickCount ( ) ) > 1 ) ) { <START_BUG> Object [ ] uids = mediator . getTable ( ) . getUids ( ) ; <END_BUG> IContactStorage folder = ( ( IContactStorage ) ( mediator . getTree ( ) . getSelectedFolder ( ) ) ) ; if ( ( uids . length ) == 0 ) return ; IContactModel card = null ; try { card = ( ( IContactModel ) ( folder . get ( uids [ 0 ] ) ) ) ; } catch ( Exception ex ) { if ( Logging . DEBUG ) ex . printStackTrace ( ) ; ErrorDialog . createDialog ( ex . getMessage ( ) , ex ) ; } ContactEditorDialog dialog = new ContactEditorDialog ( mediator . getView ( ) . getFrame ( ) , ( ( ContactModel ) ( card ) ) ) ; if ( dialog . getResult ( ) ) { try { folder . modify ( uids [ 0 ] , card ) ; } catch ( Exception e1 ) { if ( Logging . DEBUG ) e1 . printStackTrace ( ) ; ErrorDialog . createDialog ( e1 . getMessage ( ) , e1 ) ; } if ( folder instanceof GroupFolder ) mediator . getTree ( ) . setSelectedFolder ( ( ( AbstractFolder ) ( folder ) ) ) ; } } } } 
public class DebugComponent extends SearchComponent { public static final String COMPONENT_NAME = "debug" ; @ Override public void prepare ( ResponseBuilder rb ) throws IOException { } @ SuppressWarnings ( "unchecked" ) @ Override public void process ( ResponseBuilder rb ) throws IOException { } public void modifyRequest ( ResponseBuilder rb , SearchComponent who , ShardRequest sreq ) { } @ Override public void handleResponses ( ResponseBuilder rb , ShardRequest sreq ) { } private Set < String > excludeSet = new HashSet < String > ( Arrays . asList ( "explain" ) ) ; @ Override public void finishStage ( ResponseBuilder rb ) { if ( ( rb . isDebug ( ) ) && ( ( rb . stage ) == ( ResponseBuilder . STAGE_GET_FIELDS ) ) ) { NamedList info = null ; NamedList explain = new SimpleOrderedMap ( ) ; Object [ ] arr = new Object [ ( rb . resultIds . size ( ) ) * 2 ] ; for ( ShardRequest sreq : rb . finished ) { if ( ( ( sreq . purpose ) & ( ShardRequest . PURPOSE_GET_DEBUG ) ) == 0 ) continue ; for ( ShardResponse srsp : sreq . responses ) { <START_BUG> NamedList sdebug = ( ( NamedList ) ( srsp . rsp . getResponse ( ) . get ( "debug" ) ) ) ; <END_BUG> info = ( ( NamedList ) ( merge ( sdebug , info , excludeSet ) ) ) ; NamedList sexplain = ( ( NamedList ) ( sdebug . get ( "explain" ) ) ) ; for ( int i = 0 ; i < ( sexplain . size ( ) ) ; i ++ ) { String id = sexplain . getName ( i ) ; ShardDoc sdoc = rb . resultIds . get ( id ) ; int idx = sdoc . positionInResponse ; arr [ ( idx << 1 ) ] = id ; arr [ ( ( idx << 1 ) + 1 ) ] = sexplain . getVal ( i ) ; } } } explain = HighlightComponent . removeNulls ( new SimpleOrderedMap ( Arrays . asList ( arr ) ) ) ; if ( info == null ) { info = new SimpleOrderedMap ( ) ; } int idx = info . indexOf ( "explain" , 0 ) ; if ( idx >= 0 ) { info . setVal ( idx , explain ) ; } else { info . add ( "explain" , explain ) ; } rb . setDebugInfo ( info ) ; rb . rsp . add ( "debug" , rb . getDebugInfo ( ) ) ; } } Object merge ( Object source , Object dest , Set < String > exclude ) { } @ Override public String getDescription ( ) { } @ Override public String getVersion ( ) { } @ Override public String getSourceId ( ) { } @ Override public String getSource ( ) { } @ Override public URL [ ] getDocs ( ) { } } 
public class SingleSignOnEntry extends org . apache . catalina . authenticator . SingleSignOnEntry { public SingleSignOnEntry ( Principal principal , String authType , String username , String password ) { } synchronized boolean addSession2 ( SingleSignOn sso , Session session ) { } synchronized boolean removeSession2 ( Session session ) { } void setPrincipal ( Principal principal ) { } int getSessionCount ( ) { } @ Override public void updateCredentials ( Principal principal , String authType , String username , String password ) { } public synchronized boolean updateCredentials2 ( Principal principal , String authType , String username , String password ) { boolean changed = ( ( ( safeEquals ( this . principal , principal ) ) || ( safeEquals ( this . authType , authType ) ) ) || ( safeEquals ( this . username , username ) ) ) || ( safeEquals ( this . password , password ) ) ; this . principal = principal ; this . authType = authType ; this . username = username ; this . password = password ; <START_BUG> this . canReauthenticate = ( BASIC_AUTH . equals ( authType ) ) || ( FORM_AUTH . equals ( authType ) ) ; <END_BUG> return changed ; } private boolean safeEquals ( Object a , Object b ) { } } 
public class closed implements Runnable { private static boolean jsr169_test = false ; public static void main ( String [ ] args ) { } static boolean shutdownTest ( String databaseName , String shutdownString ) throws SQLException { } private Connection cc ; private String sql ; String result ; private closed ( Connection cc , String sql ) { } public void run ( ) { try { cc . createStatement ( ) . execute ( sql ) ; result = "Sleep<seq2seq4repair_space>thread<seq2seq4repair_space>completed<seq2seq4repair_space>" + ( sql ) ; } catch ( SQLException sqle ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( sql ) ; sb . append ( "<seq2seq4repair_space>-<seq2seq4repair_space>" ) ; sb . append ( sqle . getSQLState ( ) ) ; while ( sqle != null ) { if ( sqle != null ) { sb . append ( ",<seq2seq4repair_space>" ) ; sb . append ( sqle . getSQLState ( ) ) ; sb . append ( "<seq2seq4repair_space>--<seq2seq4repair_space>" ) ; if ( ( sqle . getMessage ( ) . indexOf ( "InterruptedException" ) ) != ( - 1 ) ) sb . append ( "InterruptedException" ) ; else { sb . append ( sqle . getMessage ( ) ) ; <START_BUG> sqle . printStackTrace ( ) ; <END_BUG> } } else { sb . append ( sqle . getMessage ( ) ) ; } sqle = sqle . getNextException ( ) ; } result = sb . toString ( ) ; } } static boolean testStatement ( Connection conn ) throws SQLException { } static boolean testPreparedStatement ( Connection conn ) throws SQLException { } static boolean testResultSet ( Connection conn ) throws SQLException { } static boolean testConnection ( Connection conn ) throws SQLException { } static boolean testDerby62 ( Connection conn ) throws SQLException { } } 
public class JPADependencyProcessor implements DeploymentUnitProcessor { private static ModuleIdentifier JAVAX_PERSISTENCE_API_ID = ModuleIdentifier . create ( "javax.persistence.api" ) ; private static ModuleIdentifier JAVAEE_API_ID = ModuleIdentifier . create ( "javaee.api" ) ; private static ModuleIdentifier JBOSS_AS_JPA_ID = ModuleIdentifier . create ( "org.jboss.as.jpa" ) ; private static ModuleIdentifier JBOSS_HIBERNATE_ID = ModuleIdentifier . create ( "org.hibernate" ) ; private static ModuleIdentifier JAVASSIST_ID = ModuleIdentifier . create ( "org.javassist" ) ; private static ModuleIdentifier NAMING_ID = ModuleIdentifier . create ( "org.jboss.as.naming" ) ; public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { } private void addDependency ( ModuleSpecification moduleSpecification , ModuleLoader moduleLoader , ModuleIdentifier moduleIdentifier ) { <START_BUG> moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , moduleIdentifier , false , false , false ) ) ; <END_BUG> } @ Override public void undeploy ( DeploymentUnit context ) { } } 
public class ClusterCompiler { private int nbClassArgs ; private Vector classes ; public ClusterCompiler ( ) { } public static void main ( String [ ] args ) { } public void generate ( String [ ] args ) throws Exception { ClusterConf cconf = new ClusterConf ( ) ; CompilerContext cmpCtx = new CompilerContext ( ) ; prepare ( args , cmpCtx , cconf ) ; if ( ( cmpCtx . clusterCfgGen ) != null ) { FileWriter f = new FileWriter ( cmpCtx . clusterCfgGen ) ; f . write ( "<!DOCTYPE<seq2seq4repair_space>cluster-config<seq2seq4repair_space>PUBLIC\n" ) ; f . write ( "\t\"\"\n" ) ; <START_BUG> f . write ( "\t\"cluster-config.dtd\">\n\n" ) ; <END_BUG> f . write ( "<cluster-config>\n\n" ) ; for ( int i = 0 ; i < ( nbClassArgs ) ; i ++ ) { String className = ( ( String ) ( classes . elementAt ( i ) ) ) ; if ( ( className == null ) || ( className == "" ) ) { throw new Exception ( "Cluster<seq2seq4repair_space>stub<seq2seq4repair_space>compiler<seq2seq4repair_space>error:<seq2seq4repair_space>empty<seq2seq4repair_space>class<seq2seq4repair_space>name" ) ; } f . write ( ( ( "<class>\n\t<name>" + className ) + "</name>\n\n" ) ) ; ClassContext clCtx = new ClassContext ( cmpCtx , className ) ; MethodContext [ ] remMths = clCtx . getRemoteMethodContexts ( ) ; for ( int j = 0 ; j < ( remMths . length ) ; j ++ ) { f . write ( "\t<method>\n\t\t<signature>" ) ; f . write ( remMths [ j ] . mth . toString ( ) ) ; f . write ( "</signature>\n\t\t<one-choice/>\n\t</method>\n\n" ) ; } f . write ( "</class>\n\n" ) ; } f . write ( "</cluster-config>\n" ) ; f . close ( ) ; } else { for ( int i = 0 ; i < ( nbClassArgs ) ; i ++ ) { String className = ( ( String ) ( classes . elementAt ( i ) ) ) ; if ( ( className == null ) || ( className == "" ) ) { throw new Exception ( "Cluster<seq2seq4repair_space>stub<seq2seq4repair_space>compiler<seq2seq4repair_space>error:<seq2seq4repair_space>empty<seq2seq4repair_space>class<seq2seq4repair_space>name" ) ; } ClusterConfigCompiler ccc = new ClusterConfigCompiler ( cmpCtx ) ; ccc . run ( className , cconf ) ; ClusterStubCompiler csc = new ClusterStubCompiler ( cmpCtx ) ; csc . run ( className , cconf ) ; } } } private void prepare ( String [ ] args , CompilerContext ctxt , ClusterConf cconf ) throws Exception { } private void usage ( CompilerContext ctxt ) { } private static void warning ( String str ) { } } 
class ClasspathDirectory extends ClasspathLocation { String binaryPath ; LookupTable missingPackages ; LookupTable directoryCache ; ClasspathDirectory ( String binaryPath ) { } void clear ( ) { } String [ ] directoryList ( String pathPrefix , char [ ] [ ] compoundName , char [ ] packageName ) { } public boolean equals ( Object o ) { } boolean exists ( String pathPrefix , String filename , char [ ] [ ] packageName ) { } NameEnvironmentAnswer findClass ( char [ ] className , char [ ] [ ] packageName ) { } boolean isPackage ( char [ ] [ ] compoundName , char [ ] packageName ) { } void reset ( ) { } public String toString ( ) { <START_BUG> return "ClasspathDirectory<seq2seq4repair_space>" + ( binaryPath ) ; <END_BUG> } } 
public class JcaExtension implements Extension { public static String SUBSYSTEM_NAME = "jca" ; @ Override public void initialize ( final ExtensionContext context ) { } @ Override public void initializeParsers ( final ExtensionParsingContext context ) { } private static ModelNode createEmptyAddOperation ( ) { } static final class ConnectorSubsystemParser implements XMLStreamConstants , XMLElementReader < List < ModelNode > > , XMLElementWriter < SubsystemMarshallingContext > { static final JcaExtension . ConnectorSubsystemParser INSTANCE = new JcaExtension . ConnectorSubsystemParser ( ) ; @ Override public void writeContent ( XMLExtendedStreamWriter writer , SubsystemMarshallingContext context ) throws XMLStreamException { } private void writeArchiveValidation ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } private void writeBeanValidation ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } private void writeCachedConnectionManager ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } private void writeWorkManagers ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { if ( ( parentNode . hasDefined ( Constants . WORKMANAGER ) ) && ( ( parentNode . get ( Constants . WORKMANAGER ) . asList ( ) . size ( ) ) != 0 ) ) { for ( Property property : parentNode . get ( Constants . WORKMANAGER ) . asPropertyList ( ) ) { if ( "default" . equals ( property . getValue ( ) . get ( NAME ) . asString ( ) ) ) { writer . writeStartElement ( DEFAULT_WORKMANAGER . getLocalName ( ) ) ; } else { writer . writeStartElement ( WORKMANAGER . getLocalName ( ) ) ; WorkManagerAdd . WmParameters . NAME . getAttribute ( ) . marshallAsAttribute ( property . getValue ( ) , writer ) ; } for ( Property prop : property . getValue ( ) . asPropertyList ( ) ) { <START_BUG> if ( Constants . WORKMANAGER_LONG_RUNNING . equals ( prop . getName ( ) ) ) { <END_BUG> ThreadsParser . getInstance ( ) . writeBoundedQueueThreadPool ( writer , prop . getValue ( ) . asProperty ( ) . getValue ( ) , LONG_RUNNING_THREADS . getLocalName ( ) , false ) ; } if ( Constants . WORKMANAGER_SHORT_RUNNING . equals ( prop . getName ( ) ) ) { ThreadsParser . getInstance ( ) . writeBoundedQueueThreadPool ( writer , prop . getValue ( ) . asProperty ( ) . getValue ( ) , SHORT_RUNNING_THREADS . getLocalName ( ) , false ) ; } } writer . writeEndElement ( ) ; } } } private void writeBootstrapContexts ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } private boolean hasAnyOf ( ModelNode node , String ... names ) { } private boolean has ( ModelNode node , String name ) { } private void writeAttribute ( final XMLExtendedStreamWriter writer , final Attribute attr , final ModelNode value ) throws XMLStreamException { } @ Override public void readElement ( final XMLExtendedStreamReader reader , final List < ModelNode > list ) throws XMLStreamException { } private ModelNode parseArchiveValidation ( final XMLExtendedStreamReader reader , final ModelNode parentOperation ) throws XMLStreamException { } private void parseWorkManager ( final XMLExtendedStreamReader reader , final ModelNode parentAddress , final List < ModelNode > list , final ModelNode node , boolean defaultWm ) throws XMLStreamException { } private ModelNode parseBeanValidation ( final XMLExtendedStreamReader reader , final ModelNode parentOperation ) throws XMLStreamException { } private ModelNode parseCcm ( final XMLExtendedStreamReader reader , final ModelNode parentOperation ) throws XMLStreamException { } private ModelNode parseBootstrapContexts ( final XMLExtendedStreamReader reader , final ModelNode parentAddress ) throws XMLStreamException { } public String rawElementText ( XMLStreamReader reader ) throws XMLStreamException { } public String rawAttributeText ( XMLStreamReader reader , String attributeName ) { } } } 
public void addPropertyEditorRegistrar ( PropertyEditorRegistrar registrar ) { } public Set < PropertyEditorRegistrar > getPropertyEditorRegistrars ( ) { } public void registerCustomEditor ( Class requiredType , Class < ? extends PropertyEditor > propertyEditorClass ) { } public void copyRegisteredEditorsTo ( PropertyEditorRegistry registry ) { } public Map < Class , Class < ? extends PropertyEditor > > getCustomEditors ( ) { } public void setTypeConverter ( TypeConverter typeConverter ) { } protected TypeConverter getCustomTypeConverter ( ) { } public TypeConverter getTypeConverter ( ) { } public void addEmbeddedValueResolver ( StringValueResolver valueResolver ) { } public String resolveEmbeddedValue ( String value ) { } public void addBeanPostProcessor ( BeanPostProcessor beanPostProcessor ) { } public int getBeanPostProcessorCount ( ) { } public List < BeanPostProcessor > getBeanPostProcessors ( ) { } protected boolean hasInstantiationAwareBeanPostProcessors ( ) { } protected boolean hasDestructionAwareBeanPostProcessors ( ) { } public void registerScope ( String scopeName , Scope scope ) { } public String [ ] getRegisteredScopeNames ( ) { } public Scope getRegisteredScope ( String scopeName ) { } public void setSecurityContextProvider ( SecurityContextProvider securityProvider ) { } @ Override public AccessControlContext getAccessControlContext ( ) { } public void copyConfigurationFrom ( ConfigurableBeanFactory otherFactory ) { } public BeanDefinition getMergedBeanDefinition ( String name ) throws BeansException { } public boolean isFactoryBean ( String name ) throws NoSuchBeanDefinitionException { } @ SuppressWarnings ( "unchecked" ) protected void beforePrototypeCreation ( String beanName ) { } @ SuppressWarnings ( "unchecked" ) protected void afterPrototypeCreation ( String beanName ) { } protected final boolean isPrototypeCurrentlyInCreation ( String beanName ) { } public boolean isCurrentlyInCreation ( String beanName ) { } public void destroyBean ( String beanName , Object beanInstance ) { } protected void destroyBean ( String beanName , Object beanInstance , RootBeanDefinition mbd ) { } public void destroyScopedBean ( String beanName ) { } protected String transformedBeanName ( String name ) { } protected String originalBeanName ( String name ) { } protected void initBeanWrapper ( BeanWrapper bw ) { } protected void registerCustomEditors ( PropertyEditorRegistry registry ) { } protected RootBeanDefinition getMergedLocalBeanDefinition ( String beanName ) throws BeansException { } protected RootBeanDefinition getMergedBeanDefinition ( String beanName , BeanDefinition bd ) throws BeanDefinitionStoreException { } protected RootBeanDefinition getMergedBeanDefinition ( String beanName , BeanDefinition bd , BeanDefinition containingBd ) throws BeanDefinitionStoreException { synchronized ( this . mergedBeanDefinitions ) { RootBeanDefinition mbd = null ; if ( containingBd == null ) { mbd = this . mergedBeanDefinitions . get ( beanName ) ; } if ( mbd == null ) { if ( ( bd . getParentName ( ) ) == null ) { if ( bd instanceof RootBeanDefinition ) { mbd = ( ( RootBeanDefinition ) ( bd ) ) . cloneBeanDefinition ( ) ; } else { mbd = new RootBeanDefinition ( bd ) ; } } else { BeanDefinition pbd ; try { String parentBeanName = transformedBeanName ( bd . getParentName ( ) ) ; if ( ! ( beanName . equals ( parentBeanName ) ) ) { pbd = getMergedBeanDefinition ( parentBeanName ) ; } else { if ( ( getParentBeanFactory ( ) ) instanceof ConfigurableBeanFactory ) { pbd = ( ( ConfigurableBeanFactory ) ( getParentBeanFactory ( ) ) ) . getMergedBeanDefinition ( parentBeanName ) ; } else { throw new NoSuchBeanDefinitionException ( bd . getParentName ( ) , ( ( ( ( "Parent<seq2seq4repair_space>name<seq2seq4repair_space>'" + ( bd . getParentName ( ) ) ) + "'<seq2seq4repair_space>is<seq2seq4repair_space>equal<seq2seq4repair_space>to<seq2seq4repair_space>bean<seq2seq4repair_space>name<seq2seq4repair_space>'" ) + beanName ) + "':<seq2seq4repair_space>cannot<seq2seq4repair_space>be<seq2seq4repair_space>resolved<seq2seq4repair_space>without<seq2seq4repair_space>an<seq2seq4repair_space>AbstractBeanFactory<seq2seq4repair_space>parent" ) ) ; } } } catch ( NoSuchBeanDefinitionException ex ) { throw new BeanDefinitionStoreException ( bd . getResourceDescription ( ) , beanName , ( ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>resolve<seq2seq4repair_space>parent<seq2seq4repair_space>bean<seq2seq4repair_space>definition<seq2seq4repair_space>'" + ( bd . getParentName ( ) ) ) + "'" ) , ex ) ; } mbd = new RootBeanDefinition ( pbd ) ; mbd . overrideFrom ( bd ) ; } <START_BUG> if ( ( mbd . getScope ( ) ) == null ) { <END_BUG> mbd . setScope ( SCOPE_SINGLETON ) ; } if ( ( ( containingBd != null ) && ( ! ( containingBd . isSingleton ( ) ) ) ) && ( mbd . isSingleton ( ) ) ) { mbd . setScope ( containingBd . getScope ( ) ) ; } if ( ( ( containingBd == null ) && ( isCacheBeanMetadata ( ) ) ) && ( isBeanEligibleForMetadataCaching ( beanName ) ) ) { this . mergedBeanDefinitions . put ( beanName , mbd ) ; } } return mbd ; } } protected void checkMergedBeanDefinition ( RootBeanDefinition mbd , String beanName , Object [ ] args ) throws BeanDefinitionStoreException { } protected void clearMergedBeanDefinition ( String beanName ) { } protected Class resolveBeanClass ( RootBeanDefinition mbd , String beanName ) { } protected Class resolveBeanClass ( final RootBeanDefinition mbd , String beanName , final Class [ ] typesToMatch ) throws CannotLoadBeanClassException { } private Class doResolveBeanClass ( final RootBeanDefinition mbd , final Class [ ] typesToMatch ) throws ClassNotFoundException { } protected Object evaluateBeanDefinitionString ( String value , BeanDefinition beanDefinition ) { } protected Class predictBeanType ( String beanName , RootBeanDefinition mbd , Class [ ] typesToMatch ) { } protected boolean isFactoryBean ( String beanName , RootBeanDefinition mbd ) { } protected Class getTypeForFactoryBean ( String beanName , RootBeanDefinition mbd ) { } protected void markBeanAsCreated ( String beanName ) { } protected boolean isBeanEligibleForMetadataCaching ( String beanName ) { } protected boolean removeSingletonIfCreatedForTypeCheckOnly ( String beanName ) { } protected Object getObjectForBeanInstance ( Object beanInstance , String name , String beanName , RootBeanDefinition mbd ) { } public boolean isBeanNameInUse ( String beanName ) { } protected boolean requiresDestruction ( Object bean , RootBeanDefinition mbd ) { } protected void registerDisposableBeanIfNecessary ( String beanName , Object bean , RootBeanDefinition mbd ) { } protected abstract boolean containsBeanDefinition ( String beanName ) { } protected abstract BeanDefinition getBeanDefinition ( String beanName ) throws BeansException { } protected abstract Object createBean ( String beanName , RootBeanDefinition mbd , Object [ ] args ) throws BeanCreationException { } } 
public abstract class AbstractType implements Comparator < byte [ ] > { public abstract String getString ( byte [ ] bytes ) { } public void validate ( byte [ ] bytes ) { } public Comparator < byte [ ] > getReverseComparator ( ) { } public String getString ( Collection < byte [ ] > names ) { } public String getColumnsString ( Collection < IColumn > columns ) { StringBuilder builder = new StringBuilder ( ) ; for ( IColumn column : columns ) { <START_BUG> builder . append ( getString ( column . name ( ) ) ) . append ( "," ) ; <END_BUG> } return builder . toString ( ) ; } } 
public class ActionAddOperation extends UMLChangeAction { public static ActionAddOperation SINGLETON = new ActionAddOperation ( ) ; public ActionAddOperation ( ) { } public void actionPerformed ( ActionEvent ae ) { ProjectBrowser pb = ProjectBrowser . getInstance ( ) ; Project p = ProjectManager . getManager ( ) . getCurrentProject ( ) ; Object target = TargetManager . getInstance ( ) . getModelTarget ( ) ; if ( ! ( target instanceof MClassifier ) ) return ; MClassifier cls = ( ( MClassifier ) ( target ) ) ; MOperation oper = UmlFactory . getFactory ( ) . getCore ( ) . buildOperation ( cls ) ; <START_BUG> pb . setTarget ( oper ) ; <END_BUG> Iterator it = pb . getEditorPane ( ) . findPresentationsFor ( cls , p . getDiagrams ( ) ) . iterator ( ) ; while ( it . hasNext ( ) ) { MElementListener listener = ( ( MElementListener ) ( it . next ( ) ) ) ; UmlModelEventPump . getPump ( ) . removeModelEventListener ( listener , oper ) ; UmlModelEventPump . getPump ( ) . addModelEventListener ( listener , oper ) ; } super . actionPerformed ( ae ) ; } public boolean shouldBeEnabled ( ) { } } 
public abstract class AbstractDefinition extends SyntaxElement implements XpandDefinition { private Template owner = null ; private DeclaredParameter [ ] params ; private Identifier name ; private Identifier type ; private Statement [ ] body ; protected String _stringRepresentation = null ; protected boolean wildParams = false ; public AbstractDefinition ( final Identifier name , final Identifier type , final DeclaredParameter [ ] params , final Statement [ ] body ) { } public XpandResource getOwner ( ) { } public void setOwner ( final Template owner ) { } public DeclaredParameter [ ] getParams ( ) { } public List < DeclaredParameter > getParamsAsList ( ) { } public Identifier getType ( ) { } public String getTargetType ( ) { } public Identifier getDefName ( ) { } public String getName ( ) { } public String getQualifiedName ( ) { } public String getParamString ( boolean typesOnly ) { if ( ( ( params ) == null ) || ( ( params . length ) == 0 ) ) return wildParams ? "(*)" : "" ; <START_BUG> final StringBuffer buff = new StringBuffer ( "(" ) ; <END_BUG> for ( int i = 0 ; i < ( params . length ) ; i ++ ) { final DeclaredParameter p = params [ i ] ; buff . append ( p . getType ( ) . getValue ( ) ) ; if ( ! typesOnly ) { buff . append ( "<seq2seq4repair_space>" ) . append ( p . getName ( ) . getValue ( ) ) ; } if ( ( i + 1 ) < ( params . length ) ) { buff . append ( "," ) ; } } if ( wildParams ) { buff . append ( ",*" ) ; } return buff . append ( ")" ) . toString ( ) ; } public Statement [ ] getBody ( ) { } public List < Statement > getBodyAsList ( ) { } public void analyze ( XpandExecutionContext ctx , final Set < AnalysationIssue > issues ) { } public void evaluate ( XpandExecutionContext ctx , Object _this , Object ... params ) { } protected XpandExecutionContext prepareDeclaredParameters ( Object _this , XpandExecutionContext context , Object ... params ) { } @ Override public String toString ( ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object obj ) { } } 
public class ConfigurationTest extends AbstractTasklet implements Configurable { protected String m_message ; public void configure ( final Configuration configuration ) throws ConfigurationException { } public void run ( ) throws AntException { <START_BUG> getLogger ( ) . info ( m_message ) ; <END_BUG> } } 
public class XSElementDecl { public static final short NO_CONSTRAINT = 0 ; public static final short DEFAULT_VALUE = 1 ; public static final short FIXED_VALUE = 2 ; public String fName = null ; public String fTargetNamespace = null ; public XSTypeDecl fType = null ; short fMiscFlags = 0 ; public short fBlock = SchemaSymbols . EMPTY_SET ; public short fFinal = SchemaSymbols . EMPTY_SET ; public Object fDefault = null ; public XSElementDecl fSubGroup = null ; static final int INITIAL_SIZE = 2 ; int fIDCPos = 0 ; IdentityConstraint [ ] fIDConstraints = new IdentityConstraint [ XSElementDecl . INITIAL_SIZE ] ; private static final short CONSTRAINT_MASK = 3 ; private static final short NILLABLE = 4 ; private static final short ABSTRACT = 8 ; public short getConstraintType ( ) { } public boolean isNillable ( ) { } public boolean isAbstract ( ) { } public void setConstraintType ( short constraintType ) { } public void setIsNillable ( ) { } public void setIsAbstract ( ) { } public void addIDConstaint ( IdentityConstraint idc ) { } public IdentityConstraint [ ] getIDConstraints ( ) { } static final IdentityConstraint [ ] resize ( IdentityConstraint [ ] oldArray , int newSize ) { } public String toString ( ) { <START_BUG> return ( ( fTargetNamespace ) + "," ) + ( fName ) ; <END_BUG> } } 
public StringBuffer printExpression ( int indent , StringBuffer output ) { } public abstract MemberValuePair [ ] memberValuePairs ( ) { } public TypeBinding resolveType ( BlockScope scope ) { this . constant = NotAConstant ; TypeBinding typeBinding = this . type . resolveType ( scope ) ; if ( typeBinding == null ) return null ; this . resolvedType = typeBinding ; if ( ! ( typeBinding . isAnnotationType ( ) ) ) { scope . problemReporter ( ) . typeMismatchError ( typeBinding , scope . getJavaLangAnnotationAnnotation ( ) , this . type ) ; return null ; } ReferenceBinding annotationType = ( ( ReferenceBinding ) ( this . resolvedType ) ) ; MethodBinding [ ] methods = annotationType . methods ( ) ; MemberValuePair [ ] valuePairs = memberValuePairs ( ) ; MemberValuePair valueAttribute = null ; MemberValuePair [ ] usedValuePairs ; int pairsLength = valuePairs . length ; System . arraycopy ( valuePairs , 0 , ( usedValuePairs = new MemberValuePair [ pairsLength ] ) , 0 , pairsLength ) ; nextMember : for ( int i = 0 , requiredLength = methods . length ; i < requiredLength ; i ++ ) { MethodBinding method = methods [ i ] ; char [ ] selector = method . selector ; boolean foundValue = false ; nextPair : for ( int j = 0 ; j < pairsLength ; j ++ ) { MemberValuePair valuePair = usedValuePairs [ j ] ; if ( valuePair == null ) continue nextPair ; char [ ] memberName = valuePair . name ; if ( CharOperation . equals ( memberName , selector ) ) { if ( ( valueAttribute == null ) && ( CharOperation . equals ( memberName , TypeConstants . VALUE ) ) ) { valueAttribute = valuePair ; } valuePair . binding = method ; usedValuePairs [ j ] = null ; foundValue = true ; boolean foundDuplicate = false ; for ( int k = j + 1 ; k < pairsLength ; k ++ ) { if ( CharOperation . equals ( usedValuePairs [ k ] . name , selector ) ) { foundDuplicate = true ; scope . problemReporter ( ) . duplicateAnnotationValue ( annotationType , usedValuePairs [ k ] ) ; usedValuePairs [ k ] . binding = method ; usedValuePairs [ k ] = null ; } } if ( foundDuplicate ) { scope . problemReporter ( ) . duplicateAnnotationValue ( annotationType , valuePair ) ; continue nextMember ; } valuePair . resolveTypeExpecting ( scope , method . returnType ) ; } } if ( ( ! foundValue ) && ( ( ( method . modifiers ) & ( AccAnnotationDefault ) ) == 0 ) ) { scope . problemReporter ( ) . missingValueForAnnotationMember ( this , method . selector ) ; } } for ( int i = 0 ; i < pairsLength ; i ++ ) { if ( ( usedValuePairs [ i ] ) != null ) { scope . problemReporter ( ) . undefinedAnnotationValue ( annotationType , usedValuePairs [ i ] ) ; } } long tagBits = detectStandardAnnotation ( scope , annotationType , valueAttribute ) ; if ( ( this . recipient ) != null ) { if ( tagBits != 0 ) { switch ( this . recipient . kind ( ) ) { case Binding . PACKAGE : break ; case Binding . TYPE : case Binding . GENERIC_TYPE : case Binding . TYPE_PARAMETER : ( ( ReferenceBinding ) ( this . recipient ) ) . tagBits |= tagBits ; break ; case Binding . METHOD : ( ( MethodBinding ) ( this . recipient ) ) . tagBits |= tagBits ; break ; case Binding . FIELD : ( ( FieldBinding ) ( this . recipient ) ) . tagBits |= tagBits ; break ; case Binding . LOCAL : ( ( LocalVariableBinding ) ( this . recipient ) ) . tagBits |= tagBits ; break ; } } checkTargetCompatibility : { <START_BUG> long metaTagBits = annotationType . tagBits ; <END_BUG> if ( ( metaTagBits & ( TagBits . AnnotationTargetMASK ) ) == 0 ) break checkTargetCompatibility ; switch ( recipient . kind ( ) ) { case Binding . PACKAGE : if ( ( metaTagBits & ( TagBits . AnnotationForPackage ) ) != 0 ) break checkTargetCompatibility ; break ; case Binding . TYPE : case Binding . GENERIC_TYPE : if ( ( ( ReferenceBinding ) ( this . recipient ) ) . isAnnotationType ( ) ) { if ( ( metaTagBits & ( ( TagBits . AnnotationForAnnotationType ) | ( TagBits . AnnotationForType ) ) ) != 0 ) break checkTargetCompatibility ; } else if ( ( metaTagBits & ( TagBits . AnnotationForType ) ) != 0 ) break checkTargetCompatibility ; break ; case Binding . METHOD : if ( ( ( MethodBinding ) ( this . recipient ) ) . isConstructor ( ) ) { if ( ( metaTagBits & ( TagBits . AnnotationForConstructor ) ) != 0 ) break checkTargetCompatibility ; } else if ( ( metaTagBits & ( TagBits . AnnotationForMethod ) ) != 0 ) break checkTargetCompatibility ; break ; case Binding . FIELD : if ( ( metaTagBits & ( TagBits . AnnotationForField ) ) != 0 ) break checkTargetCompatibility ; break ; case Binding . LOCAL : if ( ( ( LocalVariableBinding ) ( this . recipient ) ) . isArgument ) { if ( ( metaTagBits & ( TagBits . AnnotationForParameter ) ) != 0 ) break checkTargetCompatibility ; } else if ( ( ( annotationType . tagBits ) & ( TagBits . AnnotationForLocalVariable ) ) != 0 ) break checkTargetCompatibility ; break ; } scope . problemReporter ( ) . disallowedTargetForAnnotation ( this ) ; } } return this . resolvedType ; } public abstract void traverse ( ASTVisitor visitor , BlockScope scope ) { } public abstract void traverse ( ASTVisitor visitor , CompilationUnitScope scope ) { } } 
public class CheckForNewMessagesCommand extends FolderCommand { FolderCommandAdapter adapter ; IMAPFolder inboxFolder ; boolean needGUIUpdate ; public CheckForNewMessagesCommand ( DefaultCommandReference [ ] references ) { } public CheckForNewMessagesCommand ( AbstractFrameController frame , DefaultCommandReference [ ] references ) { } public void execute ( Worker worker ) throws Exception { FolderCommandReference [ ] references = ( ( FolderCommandReference [ ] ) ( getReferences ( ) ) ) ; adapter = new FolderCommandAdapter ( references ) ; FolderCommandReference [ ] r = adapter . getSourceFolderReferences ( ) ; IMAPRootFolder srcFolder = ( ( IMAPRootFolder ) ( r [ 0 ] . getFolder ( ) ) ) ; ( ( StatusObservableImpl ) ( srcFolder . getObservable ( ) ) ) . setWorker ( worker ) ; <START_BUG> inboxFolder = ( ( IMAPFolder ) ( srcFolder . getChild ( "Inbox" ) ) ) ; <END_BUG> int total = inboxFolder . getMessageFolderInfo ( ) . getExists ( ) ; int recent = inboxFolder . getMessageFolderInfo ( ) . getRecent ( ) ; int unseen = inboxFolder . getMessageFolderInfo ( ) . getUnseen ( ) ; inboxFolder . getHeaderList ( ) ; int newTotal = inboxFolder . getMessageFolderInfo ( ) . getExists ( ) ; int newRecent = inboxFolder . getMessageFolderInfo ( ) . getRecent ( ) ; int newUnseen = inboxFolder . getMessageFolderInfo ( ) . getUnseen ( ) ; if ( ( ( newRecent != recent ) || ( newTotal != total ) ) || ( newUnseen != unseen ) ) { needGUIUpdate = true ; ImapItem item = srcFolder . getAccountItem ( ) . getImapItem ( ) ; if ( ( newRecent != recent ) && ( item . getBoolean ( "enable_sound" ) ) ) { String file = item . get ( "sound_file" ) ; log . info ( ( "playing<seq2seq4repair_space>sound<seq2seq4repair_space>file=" + file ) ) ; if ( file . equalsIgnoreCase ( "default" ) ) { PlaySound . play ( "newmail.wav" ) ; } else { try { PlaySound . play ( new URL ( file ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } } } } public void updateGUI ( ) throws Exception { } } 
public abstract class Scrollable extends Control { ScrollBar horizontalBar ; ScrollBar verticalBar ; int scrolledHandle ; Scrollable ( ) { } public Scrollable ( Composite parent , int style ) { } int clientHandle ( ) { } public Rectangle computeTrim ( int x , int y , int width , int height ) { } ScrollBar createScrollBar ( int type ) { } void createWidget ( ) { } void deregister ( ) { } int findScrollViewer ( int current , int scrollViewerType ) { } public Rectangle getClientArea ( ) { } public ScrollBar getHorizontalBar ( ) { } int getScrollBarHandle ( int style ) { } public ScrollBar getVerticalBar ( ) { } void HandlePreviewMouseWheel ( int sender , int e ) { super . HandlePreviewMouseWheel ( sender , e ) ; if ( ! ( checkEvent ( e ) ) ) return ; if ( ( ( state ) & ( CANVAS ) ) != 0 ) { if ( ( verticalBar ) != null ) { int vHandle = verticalBar . handle ; int delta = OS . MouseWheelEventArgs_Delta ( e ) ; int lines = OS . SystemParameters_WheelScrollLines ( ) ; double value = OS . RangeBase_Value ( vHandle ) ; double newValue = value ; Event event = new Event ( ) ; if ( lines != ( - 1 ) ) { double smallIncrement = OS . RangeBase_SmallChange ( vHandle ) ; newValue += ( smallIncrement * ( ( - delta ) / 120 ) ) * lines ; event . detail = ( delta < 0 ) ? SWT . ARROW_DOWN : SWT . ARROW_UP ; } else { double largeIncrement = OS . RangeBase_LargeChange ( vHandle ) ; newValue += largeIncrement * ( ( - delta ) / 120 ) ; event . detail = ( delta < 0 ) ? SWT . PAGE_DOWN : SWT . PAGE_UP ; } OS . RangeBase_Value ( vHandle , newValue ) ; newValue = OS . RangeBase_Value ( vHandle ) ; if ( value != newValue ) { <START_BUG> verticalBar . sendEvent ( Selection ) ; <END_BUG> } } } } void register ( ) { } void releaseChildren ( boolean destroy ) { } void releaseHandle ( ) { } int topHandle ( ) { } } 
public class TestTimeLimitingCollector extends LuceneTestCase { private static final int SLOW_DOWN = 3 ; private static final long TIME_ALLOWED = 17 * ( TestTimeLimitingCollector . SLOW_DOWN ) ; private static final double MULTI_THREAD_SLACK = 7 ; private static final int N_DOCS = 3000 ; private static final int N_THREADS = 50 ; private IndexSearcher searcher ; private Directory directory ; private IndexReader reader ; private final String FIELD_NAME = "body" ; private Query query ; private Counter counter ; private TimerThread counterThread ; @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; counter = Counter . newCounter ( true ) ; counterThread = new TimerThread ( counter ) ; counterThread . start ( ) ; final String [ ] docText = new String [ ] { "docThatNeverMatchesSoWeCanRequireLastDocCollectedToBeGreaterThanZero" , "one<seq2seq4repair_space>blah<seq2seq4repair_space>three" , "one<seq2seq4repair_space>foo<seq2seq4repair_space>three<seq2seq4repair_space>multiOne" , "one<seq2seq4repair_space>foobar<seq2seq4repair_space>three<seq2seq4repair_space>multiThree" , "blueberry<seq2seq4repair_space>pancakes" , "blueberry<seq2seq4repair_space>pie" , "blueberry<seq2seq4repair_space>strudel" , "blueberry<seq2seq4repair_space>pizza" } ; directory = newDirectory ( ) ; RandomIndexWriter iw = new RandomIndexWriter ( random ( ) , directory , newIndexWriterConfig ( TEST_VERSION_CURRENT , new org . apache . lucene . analysis . MockAnalyzer ( random ( ) ) ) . setMergePolicy ( newLogMergePolicy ( ) ) ) ; for ( int i = 0 ; i < ( TestTimeLimitingCollector . N_DOCS ) ; i ++ ) { add ( docText [ ( i % ( docText . length ) ) ] , iw ) ; } reader = iw . getReader ( ) ; <START_BUG> iw . close ( ) ; <END_BUG> searcher = newSearcher ( reader ) ; BooleanQuery booleanQuery = new BooleanQuery ( ) ; booleanQuery . add ( new TermQuery ( new Term ( FIELD_NAME , "one" ) ) , SHOULD ) ; for ( int i = 1 ; i < ( docText . length ) ; i ++ ) { String [ ] docTextParts = docText [ i ] . split ( "\\s+" ) ; for ( String docTextPart : docTextParts ) { booleanQuery . add ( new TermQuery ( new Term ( FIELD_NAME , docTextPart ) ) , SHOULD ) ; } } query = booleanQuery ; searcher . search ( query , null , 1000 ) ; } @ Override public void tearDown ( ) throws Exception { } private void add ( String value , RandomIndexWriter iw ) throws IOException { } private void search ( Collector collector ) throws Exception { } public void testSearch ( ) { } private void doTestSearch ( ) { } private Collector createTimedCollector ( TestTimeLimitingCollector . MyHitCollector hc , long timeAllowed , boolean greedy ) { } public void testTimeoutGreedy ( ) { } public void testTimeoutNotGreedy ( ) { } private void doTestTimeout ( boolean multiThreaded , boolean greedy ) { } private long maxTime ( boolean multiThreaded ) { } private String maxTimeStr ( boolean multiThreaded ) { } public void testModifyResolution ( ) { } public void testSearchMultiThreaded ( ) throws Exception { } public void testTimeoutMultiThreaded ( ) throws Exception { } private void doTestMultiThreads ( final boolean withTimeout ) throws Exception { } private class MyHitCollector extends SimpleCollector { private final BitSet bits = new BitSet ( ) ; private int slowdown = 0 ; private int lastDocCollected = - 1 ; private int docBase = 0 ; public void setSlowDown ( int milliseconds ) { } public int hitCount ( ) { } public int getLastDocCollected ( ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void collect ( final int doc ) throws IOException { } @ Override protected void doSetNextReader ( AtomicReaderContext context ) throws IOException { } @ Override public boolean acceptsDocsOutOfOrder ( ) { } } } 
public class TypeDeclaration extends BodyDeclaration { private static final int LEGAL_MODIFIERS = ( ( ( ( ( ( Modifier . PUBLIC ) | ( Modifier . PRIVATE ) ) | ( Modifier . PROTECTED ) ) | ( Modifier . STATIC ) ) | ( Modifier . FINAL ) ) | ( Modifier . ABSTRACT ) ) | ( Modifier . STRICTFP ) ; private boolean isInterface = false ; private int modifiers = Modifier . NONE ; private SimpleName typeName = null ; private Name optionalSuperclassName = null ; private ASTNode . NodeList superInterfaceNames = new ASTNode . NodeList ( false , Name . class ) ; private ASTNode . NodeList bodyDeclarations = new ASTNode . NodeList ( true , BodyDeclaration . class ) ; TypeDeclaration ( AST ast ) { } ASTNode clone ( AST target ) { } boolean equalSubtrees ( Object other ) { } void accept0 ( ASTVisitor visitor ) { } public boolean isInterface ( ) { } public void setInterface ( boolean isInterface ) { } public int getModifiers ( ) { } public void setModifiers ( int modifiers ) { <START_BUG> modifiers &= ~ ( IConstants . AccDeprecated ) ; <END_BUG> if ( ( modifiers & ( ~ ( TypeDeclaration . LEGAL_MODIFIERS ) ) ) != 0 ) { throw new IllegalArgumentException ( ) ; } modifying ( ) ; this . modifiers = modifiers ; } public SimpleName getName ( ) { } public void setName ( SimpleName typeName ) { } public Name getSuperclass ( ) { } public void setSuperclass ( Name superclassName ) { } public List superInterfaces ( ) { } public List bodyDeclarations ( ) { } public SingleVariableDeclaration [ ] getFields ( ) { } public MethodDeclaration [ ] getMethods ( ) { } public TypeDeclaration [ ] getTypes ( ) { } public boolean isPackageMemberTypeDeclaration ( ) { } public boolean isMemberTypeDeclaration ( ) { } public boolean isLocalTypeDeclaration ( ) { } public ITypeBinding resolveBinding ( ) { } int memSize ( ) { } int treeSize ( ) { } } 
public class LogFactoryImpl implements Configurable , GenericConfigurable , LogFactory { private static Localizer _loc = Localizer . forPackage ( LogFactoryImpl . class ) ; public static final String TRACE_STR = LogFactoryImpl . _loc . get ( "log-trace" ) . getMessage ( ) ; public static final String INFO_STR = LogFactoryImpl . _loc . get ( "log-info" ) . getMessage ( ) ; public static final String WARN_STR = LogFactoryImpl . _loc . get ( "log-warn" ) . getMessage ( ) ; public static final String ERROR_STR = LogFactoryImpl . _loc . get ( "log-error" ) . getMessage ( ) ; public static final String FATAL_STR = LogFactoryImpl . _loc . get ( "log-fatal" ) . getMessage ( ) ; public static final String STDOUT = "stdout" ; public static final String STDERR = "stderr" ; private static final String NEWLINE = System . getProperty ( "line.separator" ) ; protected final long initializationMillis ; private Map _logs = new ConcurrentHashMap ( ) ; private short _defaultLogLevel = Log . INFO ; private Map _configuredLevels = new HashMap ( ) ; private PrintStream _out = System . err ; private String _diagContext = null ; private boolean _diagContextComputed = false ; private Configuration _conf ; public LogFactoryImpl ( ) { } public Log getLog ( String channel ) { } protected LogFactoryImpl . LogImpl newLogImpl ( ) { } public void setDefaultLevel ( String level ) { } public short getDefaultLevel ( ) { } public void setDefaultLevel ( short level ) { } public void setDiagnosticContext ( String val ) { } public String getDiagnosticContext ( ) { if ( ! ( _diagContextComputed ) ) { <START_BUG> if ( ( _diagContext ) == null ) { <END_BUG> _diagContext = _conf . getId ( ) ; } if ( "" . equals ( _diagContext ) ) _diagContext = null ; _diagContextComputed = true ; } return _diagContext ; } public void setFile ( String file ) { } public PrintStream getStream ( ) { } public void setStream ( PrintStream stream ) { } public static String getLevelName ( short level ) { } public static short getLevel ( String str ) { } public void setConfiguration ( Configuration conf ) { } public void startConfiguration ( ) { } public void endConfiguration ( ) { } public void setInto ( Options opts ) { } private static String shorten ( String channel ) { } public class LogImpl extends AbstractLog { private short _level = INFO ; private String _channel ; protected boolean isEnabled ( short level ) { } protected void log ( short level , String message , Throwable t ) { } protected String formatMessage ( short level , String message , Throwable t ) { } private long getOffset ( ) { } public void setChannel ( String val ) { } public String getChannel ( ) { } public void setLevel ( short val ) { } public short getLevel ( ) { } } } 
public abstract class PoolOperations implements OperationStepHandler { private final PoolOperations . PoolMatcher matcher ; protected PoolOperations ( PoolOperations . PoolMatcher matcher ) { } public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { final PathAddress address = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) ; final String jndiName ; if ( address . getElement ( 0 ) . getKey ( ) . equals ( DEPLOYMENT ) ) { jndiName = address . getLastElement ( ) . getValue ( ) ; } else { jndiName = Util . getJndiName ( context . readModel ( EMPTY_ADDRESS ) ) ; } <START_BUG> if ( ( context . getType ( ) ) == ( Type . SERVER ) ) { <END_BUG> context . addStep ( new OperationStepHandler ( ) { public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { final ServiceController < ? > managementRepoService = context . getServiceRegistry ( false ) . getService ( MANAGEMENT_REPOSITORY_SERVICE ) ; if ( managementRepoService != null ) { ModelNode operationResult = null ; try { final ManagementRepository repository = ( ( ManagementRepository ) ( managementRepoService . getValue ( ) ) ) ; final List < Pool > pools = matcher . match ( jndiName , repository ) ; if ( pools . isEmpty ( ) ) { throw ConnectorMessages . MESSAGES . failedToMatchPool ( jndiName ) ; } for ( Pool pool : pools ) { operationResult = invokeCommandOn ( pool ) ; } } catch ( Exception e ) { throw new OperationFailedException ( new ModelNode ( ) . set ( ConnectorMessages . MESSAGES . failedToInvokeOperation ( e . getLocalizedMessage ( ) ) ) ) ; } if ( operationResult != null ) { context . getResult ( ) . set ( operationResult ) ; } } context . completeStep ( ) ; } } , RUNTIME ) ; } context . completeStep ( ) ; } protected abstract ModelNode invokeCommandOn ( Pool pool ) throws Exception { } public static class FlushIdleConnectionInPool extends PoolOperations { public static PoolOperations . FlushIdleConnectionInPool DS_INSTANCE = new PoolOperations . FlushIdleConnectionInPool ( new PoolOperations . DsPoolMatcher ( ) ) ; public static PoolOperations . FlushIdleConnectionInPool RA_INSTANCE = new PoolOperations . FlushIdleConnectionInPool ( new PoolOperations . RaPoolMatcher ( ) ) ; protected FlushIdleConnectionInPool ( PoolOperations . PoolMatcher matcher ) { } @ Override protected ModelNode invokeCommandOn ( Pool pool ) { } } public static class FlushAllConnectionInPool extends PoolOperations { public static PoolOperations . FlushAllConnectionInPool DS_INSTANCE = new PoolOperations . FlushAllConnectionInPool ( new PoolOperations . DsPoolMatcher ( ) ) ; public static PoolOperations . FlushAllConnectionInPool RA_INSTANCE = new PoolOperations . FlushAllConnectionInPool ( new PoolOperations . RaPoolMatcher ( ) ) ; protected FlushAllConnectionInPool ( PoolOperations . PoolMatcher matcher ) { } @ Override protected ModelNode invokeCommandOn ( Pool pool ) { } } public static class TestConnectionInPool extends PoolOperations { public static PoolOperations . TestConnectionInPool DS_INSTANCE = new PoolOperations . TestConnectionInPool ( new PoolOperations . DsPoolMatcher ( ) ) ; public static PoolOperations . TestConnectionInPool RA_INSTANCE = new PoolOperations . TestConnectionInPool ( new PoolOperations . RaPoolMatcher ( ) ) ; protected TestConnectionInPool ( PoolOperations . PoolMatcher matcher ) { } @ Override protected ModelNode invokeCommandOn ( Pool pool ) throws Exception { } } private static interface PoolMatcher { List < Pool > match ( String jndiName , ManagementRepository repository ) { } } private static class DsPoolMatcher implements PoolOperations . PoolMatcher { public List < Pool > match ( String jndiName , ManagementRepository repository ) { } } private static class RaPoolMatcher implements PoolOperations . PoolMatcher { public List < Pool > match ( String jndiName , ManagementRepository repository ) { } } } 
public class TransactionalTopologyBuilder { String _id ; String _spoutId ; ITransactionalSpout _spout ; Map < String , TransactionalTopologyBuilder . Component > _bolts = new HashMap < String , TransactionalTopologyBuilder . Component > ( ) ; Integer _spoutParallelism ; List < Map > _spoutConfs = new ArrayList ( ) ; public TransactionalTopologyBuilder ( String id , String spoutId , ITransactionalSpout spout , Integer spoutParallelism ) { } public TransactionalTopologyBuilder ( String id , String spoutId , IPartitionedTransactionalSpout spout , Integer spoutParallelism ) { } public SpoutDeclarer getSpoutDeclarer ( ) { } public BoltDeclarer setBolt ( String id , IBatchBolt bolt ) { } public BoltDeclarer setBolt ( String id , IBatchBolt bolt , Integer parallelism ) { } public BoltDeclarer setBolt ( String id , ICommitterBolt bolt ) { } public BoltDeclarer setBolt ( String id , ICommitterBolt bolt , Integer parallelism ) { <START_BUG> return setBolt ( id , new CommitterBoltExecutor ( bolt ) , parallelism , true ) ; <END_BUG> } public BoltDeclarer setBolt ( String id , IBasicBolt bolt ) { } public BoltDeclarer setBolt ( String id , IBasicBolt bolt , Integer parallelism ) { } private BoltDeclarer setBolt ( String id , IRichBolt bolt , Integer parallelism , boolean committer ) { } public StormTopology buildTopology ( ) { } private Set < String > componentBoltSubscriptions ( TransactionalTopologyBuilder . Component component ) { } private static class Component { public IRichBolt bolt ; public int parallelism ; public List < TransactionalTopologyBuilder . InputDeclaration > declarations = new ArrayList < TransactionalTopologyBuilder . InputDeclaration > ( ) ; public List < Map > componentConfs = new ArrayList < Map > ( ) ; public boolean committer ; public Component ( IRichBolt bolt , int parallelism , boolean committer ) { } } private static interface InputDeclaration { void declare ( InputDeclarer declarer ) { } String getComponent ( ) { } } private class SpoutDeclarerImpl extends BaseConfigurationDeclarer < SpoutDeclarer > implements SpoutDeclarer { @ Override public SpoutDeclarer addConfigurations ( Map conf ) { } } private class BoltDeclarerImpl extends BaseConfigurationDeclarer < BoltDeclarer > implements BoltDeclarer { TransactionalTopologyBuilder . Component _component ; public BoltDeclarerImpl ( TransactionalTopologyBuilder . Component component ) { } @ Override public BoltDeclarer fieldsGrouping ( final String component , final Fields fields ) { } @ Override public BoltDeclarer fieldsGrouping ( final String component , final String streamId , final Fields fields ) { } @ Override public BoltDeclarer globalGrouping ( final String component ) { } @ Override public BoltDeclarer globalGrouping ( final String component , final String streamId ) { } @ Override public BoltDeclarer shuffleGrouping ( final String component ) { } @ Override public BoltDeclarer shuffleGrouping ( final String component , final String streamId ) { } @ Override public BoltDeclarer noneGrouping ( final String component ) { } @ Override public BoltDeclarer noneGrouping ( final String component , final String streamId ) { } @ Override public BoltDeclarer allGrouping ( final String component ) { } @ Override public BoltDeclarer allGrouping ( final String component , final String streamId ) { } @ Override public BoltDeclarer directGrouping ( final String component ) { } @ Override public BoltDeclarer directGrouping ( final String component , final String streamId ) { } @ Override public BoltDeclarer customGrouping ( final String component , final CustomStreamGrouping grouping ) { } @ Override public BoltDeclarer customGrouping ( final String component , final String streamId , final CustomStreamGrouping grouping ) { } @ Override public BoltDeclarer grouping ( final GlobalStreamId stream , final Grouping grouping ) { } private void addDeclaration ( TransactionalTopologyBuilder . InputDeclaration declaration ) { } @ Override public BoltDeclarer addConfigurations ( Map conf ) { } } } 
public class CloseAllPerspectivesAction extends Action implements ActionFactory . IWorkbenchAction { private IWorkbenchWindow workbenchWindow ; public CloseAllPerspectivesAction ( IWorkbenchWindow window ) { } public void run ( ) { if ( ( workbenchWindow ) == null ) { return ; } IWorkbenchPage page = workbenchWindow . getActivePage ( ) ; if ( page != null ) { <START_BUG> ( ( WorkbenchPage ) ( page ) ) . closeAllPerspectives ( ) ; <END_BUG> } } public void dispose ( ) { } } 
public class SignaturePatternTestCase extends TestCase { public SignaturePatternTestCase ( String name ) { } BcelWorld world = new BcelWorld ( ) ; public void testThrowsMatch ( ) throws IOException { } public void testInstanceMethodMatch ( ) throws IOException { } public void testStaticMethodMatch ( ) throws IOException { } public void testFieldMatch ( ) throws IOException { } public void testConstructorMatch ( ) throws IOException { } public void checkMatch ( SignaturePattern p , Member [ ] yes , Member [ ] no ) throws IOException { } private void checkMatch ( SignaturePattern p , Member member , boolean b ) { <START_BUG> boolean matches = p . matches ( member , world ) ; <END_BUG> assertEquals ( ( ( ( p . toString ( ) ) + "<seq2seq4repair_space>matches<seq2seq4repair_space>" ) + ( member . toString ( ) ) ) , b , matches ) ; } private SignaturePattern makeMethodPat ( String pattern ) { } private SignaturePattern makeFieldPat ( String pattern ) { } private void checkSerialization ( SignaturePattern p ) throws IOException { } } 
class StubFileGenerator { static Hashtable declIDTable = null ; static void doFiles ( Hashtable table , SymbolManager symbolManager , File [ ] inputFiles , File [ ] signatureFiles ) throws DocException { } static void processFile ( SymbolManager symbolManager , File inputFile , File signatureFile ) throws DocException { } private static void processImportDeclaration ( IProgramElement node , PrintWriter writer ) throws IOException { } private static void processTypeDeclaration ( IProgramElement classNode , PrintWriter writer ) throws DocException { } private static void processMembers ( List members , PrintWriter writer , boolean declaringTypeIsInterface ) throws DocException { } private static String genSourceSignature ( IProgramElement classNode ) { String signature = classNode . getSourceSignature ( ) ; if ( signature != null ) { int index = signature . indexOf ( "aspect" ) ; <START_BUG> if ( ( index != ( - 1 ) ) && ( ( signature . charAt ( ( index - 1 ) ) ) != '.' ) ) { <END_BUG> signature = ( ( signature . substring ( 0 , index ) ) + "class<seq2seq4repair_space>" ) + ( signature . substring ( ( index + 6 ) , signature . length ( ) ) ) ; } } return signature ; } static int nextDeclID = 0 ; static String addDeclID ( IProgramElement decl , String formalComment ) { } static String addToFormal ( String formalComment , String string ) { } } 
public class WeldBootstrapService implements Service < WeldBootstrapService > { public static final ServiceName SERVICE_NAME = ServiceName . of ( "WeldBootstrapService" ) ; private final WeldBootstrap bootstrap ; private final WeldDeployment deployment ; private final Environment environment ; private final Map < String , BeanDeploymentArchive > beanDeploymentArchives ; private final BeanDeploymentArchiveImpl rootBeanDeploymentArchive ; private final String deploymentName ; private final InjectedValue < WeldSecurityServices > securityServices = new InjectedValue < WeldSecurityServices > ( ) ; private final InjectedValue < WeldTransactionServices > weldTransactionServices = new InjectedValue < WeldTransactionServices > ( ) ; private volatile boolean started ; public WeldBootstrapService ( WeldDeployment deployment , Environment environment , final String deploymentName ) { } public synchronized void start ( final StartContext context ) { if ( started ) { throw MESSAGES . alreadyRunning ( "WeldContainer" ) ; } started = true ; DEPLOYMENT_LOGGER . startingWeldService ( deploymentName ) ; addWeldService ( SecurityServices . class , securityServices . getValue ( ) ) ; addWeldService ( TransactionServices . class , weldTransactionServices . getValue ( ) ) ; ModuleGroupSingletonProvider . addClassLoaders ( deployment . getModule ( ) . getClassLoader ( ) , deployment . getSubDeploymentClassLoaders ( ) ) ; ClassLoader oldTccl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; try { WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( deployment . getModule ( ) . getClassLoader ( ) ) ; <START_BUG> bootstrap . startContainer ( environment , deployment ) ; <END_BUG> } finally { WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl ) ; } } public synchronized void stop ( final StopContext context ) { } public BeanManagerImpl getBeanManager ( String beanArchiveId ) { } public < T extends Service > void addWeldService ( Class < T > type , T service ) { } public BeanManager getBeanManager ( ) { } public Set < BeanDeploymentArchive > getBeanDeploymentArchives ( ) { } public boolean isStarted ( ) { } WeldBootstrap getBootstrap ( ) { } @ Override public WeldBootstrapService getValue ( ) throws IllegalArgumentException , IllegalStateException { } public InjectedValue < WeldSecurityServices > getSecurityServices ( ) { } public InjectedValue < WeldTransactionServices > getWeldTransactionServices ( ) { } } 
public class ConfigFrame implements ActionListener , ListSelectionListener { private JDialog dialog ; private AccountListTable listView ; private AccountList accountList ; private AccountItem accountItem ; JTextField nameTextField = new JTextField ( ) ; JButton addButton ; JButton removeButton ; JButton editButton ; private int index ; public ConfigFrame ( ) { } public AccountItem getSelected ( ) { } public void setSelected ( AccountItem item ) { } public void initComponents ( ) { } public void valueChanged ( ListSelectionEvent e ) { } public void showAccountDialog ( ) { } public void actionPerformed ( ActionEvent e ) { String action = e . getActionCommand ( ) ; if ( action . equals ( "CLOSE" ) ) { try { config . save ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } dialog . setVisible ( false ) ; } else if ( action . equals ( "ADD" ) ) { try { <START_BUG> new AccountWizardLauncher ( ) . launchWizard ( ) ; <END_BUG> listView . update ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } else if ( action . equals ( "REMOVE" ) ) { Object [ ] options = new Object [ ] { "Delete" , "No" } ; int n = JOptionPane . showOptionDialog ( null , "Would<seq2seq4repair_space>you<seq2seq4repair_space>really<seq2seq4repair_space>like<seq2seq4repair_space>to<seq2seq4repair_space>delete<seq2seq4repair_space>this<seq2seq4repair_space>account?" , "Question" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE , null , options , options [ 1 ] ) ; if ( n == ( JOptionPane . NO_OPTION ) ) { return ; } AccountItem item = accountList . remove ( index ) ; if ( item . isPopAccount ( ) ) { popServerCollection . removePopServer ( item . getUid ( ) ) ; } else { FolderTreeNode folder = ( ( FolderTreeNode ) ( treeModel . getImapFolder ( item . getUid ( ) ) ) ) ; try { FolderTreeNode parentFolder = ( ( FolderTreeNode ) ( folder . getParent ( ) ) ) ; folder . removeFolder ( ) ; treeModel . nodeStructureChanged ( parentFolder ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } mailCheckingManager . remove ( item . getUid ( ) ) ; removeButton . setEnabled ( false ) ; editButton . setEnabled ( false ) ; listView . update ( ) ; } else if ( action . equals ( "EDIT" ) ) { showAccountDialog ( ) ; listView . update ( ) ; } } } 
public class MappingJackson2MessageConverter implements MessageConverter < Object > { private ObjectMapper objectMapper = new ObjectMapper ( ) ; private Type defaultObjectType = Map . class ; private Class < ? > defaultMessagePayloadClass = byte [ ] . class ; public void setDefaultObjectClass ( Type defaultObjectType ) { } public void setDefaultTargetPayloadClass ( Class < ? > payloadClass ) { } @ Override public Object fromMessage ( Message < ? > message , Type objectType ) { JavaType javaType = ( objectType != null ) ? this . objectMapper . constructType ( objectType ) : this . objectMapper . constructType ( this . defaultObjectType ) ; Object payload = message . getPayload ( ) ; try { if ( payload instanceof byte [ ] ) { return this . objectMapper . readValue ( ( ( byte [ ] ) ( payload ) ) , javaType ) ; } else if ( payload instanceof String ) { return this . objectMapper . readValue ( ( ( String ) ( payload ) ) , javaType ) ; } else { throw new IllegalArgumentException ( ( "Unexpected<seq2seq4repair_space>message<seq2seq4repair_space>payload<seq2seq4repair_space>type:<seq2seq4repair_space>" + payload ) ) ; } } catch ( IOException ex ) { <START_BUG> throw new MessageConversionException ( ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>read<seq2seq4repair_space>JSON:<seq2seq4repair_space>" + ( ex . getMessage ( ) ) ) , ex ) ; <END_BUG> } } @ SuppressWarnings ( "unchecked" ) @ Override public < P > Message < P > toMessage ( Object object ) { } } 
public class SubqueryImpl < T > extends ExpressionImpl < T > implements Subquery < T > { private final AbstractQuery < ? > _parent ; private final CriteriaQueryImpl < T > _delegate ; private final MetamodelImpl _model ; private Set < Join < ? , ? > > _joins ; private Expression < T > _select ; private Subquery _subq ; public SubqueryImpl ( Class < T > cls , AbstractQuery < ? > parent ) { } public AbstractQuery < ? > getParent ( ) { } public CriteriaQueryImpl < T > getDelegate ( ) { } public MetamodelImpl getMetamodel ( ) { } public CriteriaQueryImpl < ? > getInnermostParent ( ) { } public Subquery < T > select ( Expression < T > expression ) { } public Expression < T > getSelection ( ) { } public < X > Root < X > from ( EntityType < X > entity ) { } public < X > Root < X > from ( Class < X > entityClass ) { } public Set < Root < ? > > getRoots ( ) { } public Root < ? > getRoot ( ) { } public Subquery < T > where ( Expression < Boolean > restriction ) { } public Subquery < T > where ( Predicate ... restrictions ) { } public Subquery < T > groupBy ( Expression < ? > ... grouping ) { } public Subquery < T > having ( Expression < Boolean > restriction ) { } public Subquery < T > having ( Predicate ... restrictions ) { } public Subquery < T > distinct ( boolean distinct ) { } public List < Expression < ? > > getGroupList ( ) { } public Predicate getRestriction ( ) { } public Predicate getGroupRestriction ( ) { } public boolean isDistinct ( ) { } public < U > Subquery < U > subquery ( Class < U > type ) { } public < Y > Root < Y > correlate ( Root < Y > root ) { } public < X , Y > Join < X , Y > correlate ( Join < X , Y > join ) { } public < X , Y > CollectionJoin < X , Y > correlate ( CollectionJoin < X , Y > join ) { } public < X , Y > SetJoin < X , Y > correlate ( SetJoin < X , Y > join ) { } public < X , Y > ListJoin < X , Y > correlate ( ListJoin < X , Y > join ) { } public < X , K , V > MapJoin < X , K , V > correlate ( MapJoin < X , K , V > join ) { } public Set < Join < ? , ? > > getJoins ( ) { } public Subquery getSubQ ( ) { } @ Override public Value toValue ( ExpressionFactory factory , MetamodelImpl model , CriteriaQueryImpl < ? > q ) { } private ClassMetaData getCandidate ( ) { RootImpl < ? > root = ( ( RootImpl < ? > ) ( getRoot ( ) ) ) ; <START_BUG> RootImpl < ? > correlatedRoot = ( ( RootImpl < ? > ) ( root . getCorrelatedParent ( ) ) ) ; <END_BUG> if ( ( correlatedRoot != null ) && ( ( root . getJoins ( ) ) != null ) ) { Join < ? , ? > join = root . getJoins ( ) . iterator ( ) . next ( ) ; FieldMetaData fmd = ( ( Members . Member < ? , ? > ) ( join . getAttribute ( ) ) ) . fmd ; if ( join . getAttribute ( ) . isCollection ( ) ) { return fmd . isElementCollection ( ) ? fmd . getEmbeddedMetaData ( ) : fmd . getElement ( ) . getDeclaredTypeMetaData ( ) ; } else { return fmd . getDeclaredTypeMetaData ( ) ; } } return ( ( AbstractManagedType < ? > ) ( root . getModel ( ) ) ) . meta ; } } 
public abstract class Border < T > extends WebMarkupContainerWithAssociatedMarkup < T > implements IComponentResolver { private static final String BODY = "body" ; private static final String BORDER = "border" ; private boolean bodyVisible = true ; private MarkupContainer body ; public Border ( MarkupContainer parent , final String id ) { } public Border ( MarkupContainer parent , final String id , final IModel < T > model ) { } protected MarkupContainer getBodyContainer ( ) { } protected MarkupContainer newBorderBodyContainer ( final MarkupContainer parent ) { } public Border setBorderBodyVisible ( boolean bodyVisible ) { } @ Override public MarkupFragment getMarkupFragment ( String path ) { <START_BUG> MarkupFragment fragment = Border . getAssociatedMarkupFragment ( false ) ; <END_BUG> if ( fragment != null ) { fragment = fragment . getChildFragment ( path , false ) ; } if ( fragment == null ) { fragment = super . getMarkupFragment ( path ) ; } return fragment ; } @ Override protected final void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } public boolean resolve ( final MarkupContainer container , final MarkupStream markupStream , final ComponentTag tag ) { } @ Override public void renderHead ( HeaderContainer container ) { } private class BorderBody extends WebMarkupContainer implements IComponentResolver { private static final long serialVersionUID = 1L ; private transient boolean wasOpenClose = false ; public BorderBody ( final MarkupContainer parent ) { } @ Override public MarkupFragment getMarkupFragment ( ) { } @ Override protected void onComponentTag ( final ComponentTag tag ) { } @ Override protected void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } public boolean resolve ( final MarkupContainer container , final MarkupStream markupStream , final ComponentTag tag ) { } } } 
class StressCategory { static Priority [ ] priority = new Priority [ ] { Priority . DEBUG , Priority . INFO , Priority . WARN , Priority . ERROR , Priority . FATAL } ; static Priority defaultPriority = Category . getRoot ( ) . getPriority ( ) ; static int LENGTH ; static String [ ] names ; static Category [ ] cat ; static StressCategory . CT [ ] ct ; static Random random = new Random ( 10 ) ; public static void main ( String [ ] args ) { } static void permute ( int n ) { } static void swap ( String [ ] names , int i , int j ) { } public static void permutationDump ( ) { } static void createLoop ( int n ) { if ( n == ( StressCategory . LENGTH ) ) { for ( int i = 0 ; i < ( StressCategory . LENGTH ) ; i ++ ) { if ( ( StressCategory . ct [ i ] ) == null ) StressCategory . cat [ i ] = null ; else { StressCategory . cat [ i ] = Category . getInstance ( StressCategory . ct [ i ] . catstr ) ; StressCategory . cat [ i ] . setPriority ( StressCategory . ct [ i ] . priority ) ; } } StressCategory . test ( ) ; <START_BUG> _default . clear ( ) ; <END_BUG> } else { StressCategory . ct [ n ] = null ; StressCategory . createLoop ( ( n + 1 ) ) ; StressCategory . ct [ n ] = new StressCategory . CT ( StressCategory . names [ n ] , null ) ; StressCategory . createLoop ( ( n + 1 ) ) ; int r = StressCategory . random . nextInt ( ) ; if ( r < 0 ) r = - r ; StressCategory . ct [ n ] = new StressCategory . CT ( StressCategory . names [ n ] , StressCategory . priority [ ( r % 5 ) ] ) ; StressCategory . createLoop ( ( n + 1 ) ) ; } } static void test ( ) { } static void ctDump ( ) { } static void catDump ( ) { } static boolean checkCorrectness ( int i ) { } static Priority getExpectedPrioriy ( StressCategory . CT ctParam ) { } static class CT { public String catstr ; public Priority priority ; CT ( String catstr , Priority priority ) { } } } 
public abstract class AbstractRemoteService implements InvocationHandler , IRemoteService { protected static final Object [ ] EMPTY_ARGS = new Object [ 0 ] ; protected abstract String [ ] getInterfaceClassNames ( ) { } protected abstract IRemoteServiceID getRemoteServiceID ( ) { } protected abstract IRemoteServiceReference getRemoteServiceReference ( ) { } protected Class loadInterfaceClass ( String className ) throws ClassNotFoundException { } protected IRemoteService getRemoteService ( ) { } protected long getDefaultTimeout ( ) { } public IFuture callAsync ( final IRemoteCall call ) { } @ SuppressWarnings ( "unchecked" ) public Object getProxy ( ) throws ECFException { try { final String [ ] clazzes = getInterfaceClassNames ( ) ; List classes = new ArrayList ( ) ; for ( int i = 0 ; i < ( clazzes . length ) ; i ++ ) { Class c = loadInterfaceClass ( clazzes [ i ] ) ; classes . add ( c ) ; Class asyncRemoteServiceProxyClass = findAsyncRemoteServiceProxyClass ( c ) ; if ( ( asyncRemoteServiceProxyClass != null ) && ( asyncRemoteServiceProxyClass . isInterface ( ) ) ) classes . add ( asyncRemoteServiceProxyClass ) ; } classes . add ( IRemoteServiceProxy . class ) ; return createProxy ( ( ( Class [ ] ) ( classes . toArray ( new Class [ ] { } ) ) ) ) ; } catch ( final Exception e ) { throw new ECFException ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>create<seq2seq4repair_space>proxy" , e ) ; } catch ( final NoClassDefFoundError e ) { <START_BUG> throw new ECFException ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>load<seq2seq4repair_space>proxy<seq2seq4repair_space>interface" , e ) ; <END_BUG> } } protected Object createProxy ( Class [ ] classes ) { } protected Class findAsyncRemoteServiceProxyClass ( Class c ) { } protected String convertInterfaceNameToAsyncInterfaceName ( String interfaceName ) { } protected Object [ ] getCallParametersForProxyInvoke ( String callMethod , Method proxyMethod , Object [ ] args ) { } protected long getCallTimeoutForProxyInvoke ( String callMethod , Method proxyMethod , Object [ ] args ) { } protected String getCallMethodNameForProxyInvoke ( Method method , Object [ ] args ) { } protected Object invokeObject ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { } protected Object invokeSync ( IRemoteCall call ) throws ECFException { } public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { } protected class AsyncArgs { private IRemoteCallListener listener ; private Object [ ] args ; public AsyncArgs ( IRemoteCallListener listener , Object [ ] originalArgs ) { } public IRemoteCallListener getListener ( ) { } public Object [ ] getArgs ( ) { } } protected Object invokeAsync ( final Method method , final Object [ ] args ) throws Throwable { } protected AbstractRemoteService . AsyncArgs getAsyncArgs ( Method method , Object [ ] args ) { } protected String getAsyncInvokeMethodName ( Method method ) { } } 
public final class Java2WSWidgetFactory { private Java2WSWidgetFactory ( ) { } public static Label createSOAPBindingLabel ( Composite parent ) { } public static Combo createSOAPBingCombo ( Composite parent , final Java2WSContext context ) { } public static Button createXSDImportsButton ( Composite parent , final Java2WSContext context ) { } public static Label createFrontendLabel ( Composite parent ) { } public static Combo createFrontendCombo ( Composite parent , final Java2WSContext context ) { } public static Label createDatabindingLabel ( Composite parent ) { } public static Combo createDatabindingCombo ( Composite parent , final Java2WSContext context ) { } public static Button createGenerateClientButton ( Composite parent , final Java2WSContext context ) { } public static Button createGenerateServerButton ( Composite parent , final Java2WSContext context ) { } public static Button createGenerateWrapperFaultBeanButton ( Composite parent , final Java2WSContext context ) { } public static Button createGenerateWSDLButton ( Composite parent , final Java2WSContext context ) { } public static Label createWSDLFileNameLabel ( Composite parent ) { } public static Text createWSDLFileNameText ( Composite parent , final Java2WSDataModel model ) { } public static Button createUseSEIButton ( Composite parent ) { } public static Label createInformationLabel ( Composite parent , IType startingPointType ) { } public static Label createPaddingLabel ( Composite parent ) { } public static Button createSelectSEIButton ( Composite parent ) { } public static Label createSelectSEILabel ( Composite parent ) { } public static Combo createSelectSEICombo ( Composite parent , final Java2WSDataModel model , IType javaStartingPointType ) { <START_BUG> final Combo seiCombo = new Combo ( parent , SWT . READ_ONLY ) ; <END_BUG> seiCombo . setToolTipText ( JAVA2WS_SELECT_SEI_TOOLTIP ) ; IJavaProject javaProject = JDTUtils . getJavaProject ( model . getProjectName ( ) ) ; try { ITypeHierarchy typeHierarchy = javaStartingPointType . newTypeHierarchy ( javaProject , null ) ; IType [ ] allInterfaces = typeHierarchy . getAllInterfaces ( ) ; for ( int i = 0 ; i < ( allInterfaces . length ) ; i ++ ) { IType itype = allInterfaces [ i ] ; if ( ( ! ( itype . isBinary ( ) ) ) && ( itype . getResource ( ) . getProject ( ) . equals ( javaProject . getProject ( ) ) ) ) { seiCombo . add ( itype . getFullyQualifiedName ( ) ) ; } } } catch ( JavaModelException jme ) { CXFUIPlugin . log ( jme . getStatus ( ) ) ; } seiCombo . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { String seiInterfaceName = seiCombo . getText ( ) ; model . setFullyQualifiedJavaInterfaceName ( seiInterfaceName ) ; } } ) ; seiCombo . select ( ( - 1 ) ) ; return seiCombo ; } public static Button createExtractSEIButton ( Composite parent ) { } public static Label createExtractSEILabel ( Composite parent ) { } public static Text createSEIInterfaceNameText ( Composite parent ) { } public static Label createMemebersToExtractLabel ( Composite parent ) { } public static CheckboxTableViewer createSEIMembersToExtractTableViewer ( Composite parent ) { } public static Button createSelectAllButton ( Composite parent ) { } public static Button createDeselectAllButton ( Composite parent ) { } public static Label createSelectImplementationLabel ( Composite parent ) { } public static Combo createSelectImplementationCombo ( Composite parent , final Java2WSDataModel model , IType javaStartingPointType ) { } } 
public class BindingKeyResolver extends BindingKeyParser { Compiler compiler ; Binding compilerBinding ; char [ ] [ ] compoundName ; int dimension ; LookupEnvironment environment ; ReferenceBinding genericType ; MethodBinding methodBinding ; CompilationUnitDeclaration parsedUnit ; BlockScope scope ; TypeBinding typeBinding ; TypeDeclaration typeDeclaration ; ArrayList types = new ArrayList ( ) ; private BindingKeyResolver ( BindingKeyParser parser , Compiler compiler , LookupEnvironment environment ) { } public BindingKeyResolver ( String key ) { } public BindingKeyResolver ( String key , Compiler compiler , LookupEnvironment environment ) { } public char [ ] [ ] compoundName ( ) { } public void consumeArrayDimension ( char [ ] brakets ) { } public void consumeField ( char [ ] fieldName ) { } public void consumeParameterizedMethod ( ) { } public void consumeLocalType ( char [ ] uniqueKey ) { } public void consumeLocalVar ( char [ ] varName ) { } public void consumeMethod ( char [ ] selector , char [ ] signature ) { } public void consumeMemberType ( char [ ] simpleTypeName ) { } public void consumePackage ( char [ ] pkgName ) { } public void consumeParameterizedType ( char [ ] simpleTypeName , boolean isRaw ) { } public void consumeParser ( BindingKeyParser parser ) { } public void consumeScope ( int scopeNumber ) { } public void consumeRawType ( ) { } public void consumeSecondaryType ( char [ ] simpleTypeName ) { } public void consumeFullyQualifiedName ( char [ ] fullyQualifiedName ) { } public void consumeTopLevelType ( ) { } public void consumeType ( ) { } public void consumeTypeVariable ( char [ ] typeVariableName ) { <START_BUG> TypeVariableBinding [ ] typeVariableBindings = this . typeBinding . typeVariables ( ) ; <END_BUG> for ( int i = 0 , length = typeVariableBindings . length ; i < length ; i ++ ) { TypeVariableBinding typeVariableBinding = typeVariableBindings [ i ] ; if ( CharOperation . equals ( typeVariableName , typeVariableBinding . sourceName ( ) ) ) { this . compilerBinding = typeVariableBinding ; return ; } } } public void consumeWildCard ( int kind , int rank ) { } private TypeBinding getArrayBinding ( int dim , TypeBinding binding ) { } private TypeBinding getBaseTypeBinding ( char [ ] signature ) { } private TypeBinding getBinaryBinding ( ) { } public CompilationUnitDeclaration getCompilationUnitDeclaration ( ) { } public Binding getCompilerBinding ( ) { } private TypeBinding getTypeBinding ( char [ ] simpleTypeName ) { } private TypeBinding [ ] getTypeBindingArguments ( ) { } public void malformedKey ( ) { } public BindingKeyParser newParser ( ) { } public String toString ( ) { } } 
public class UpToDate extends MatchingTask implements Condition { private ArrayList sourceFileSets = new ArrayList ( ) ; protected Mapper mapperElement = null ; private String _property ; private File _targetFile ; private String _value ; public void setProperty ( String property ) { } public void setTargetFile ( File file ) { } public void setValue ( String value ) { } public void addSrcfiles ( FileSet fs ) { } public Mapper createMapper ( ) throws TaskException { if ( ( mapperElement ) != null ) { throw new TaskException ( "Cannot<seq2seq4repair_space>define<seq2seq4repair_space>more<seq2seq4repair_space>than<seq2seq4repair_space>one<seq2seq4repair_space>mapper" ) ; } <START_BUG> mapperElement = new Mapper ( getProject ( ) ) ; <END_BUG> return mapperElement ; } public boolean eval ( ) throws TaskException { } public void execute ( ) throws TaskException { } protected boolean scanDir ( File srcDir , String [ ] files ) throws TaskException { } private String getValue ( ) { } } 
public class TwoPhaseCommitEventProcessor implements IEventProcessor , ISharedObjectContainerTransaction { BaseSharedObject sharedObject = null ; byte transactionState = ISharedObjectContainerTransaction . ACTIVE ; Object lock = new Object ( ) ; List participants = new Vector ( ) ; Map failed = new HashMap ( ) ; int timeout = ISharedObjectTransactionConfig . DEFAULT_TIMEOUT ; int minFailedToAbort = 0 ; long identifier = 0 ; ISharedObjectTransactionParticipantsFilter participantsFilter = null ; public TwoPhaseCommitEventProcessor ( BaseSharedObject bse , ISharedObjectTransactionConfig config ) { } protected void trace ( String msg ) { } protected void traceStack ( String msg , Throwable t ) { } protected int getTimeout ( ) { } protected int getMinFailedToAbort ( ) { } protected boolean isPrimary ( ) { } protected BaseSharedObject getSharedObject ( ) { } protected ID getHomeID ( ) { } protected void addParticipants ( ID [ ] ids ) { } protected void removeParticipant ( ID id ) { } protected void addFailed ( ID remote , Throwable failure ) { } protected ISharedObjectContext getContext ( ) { } public boolean processEvent ( Event event ) { } protected void handleActivated ( ISharedObjectActivatedEvent event ) { } protected void replicateTo ( ID [ ] remotes ) { } protected void handlePrimaryActivated ( ISharedObjectActivatedEvent event ) { } private long getNextIdentifier ( ) { } protected void handleReplicaActivated ( ISharedObjectActivatedEvent event ) { } protected void handleJoined ( IContainerConnectedEvent event ) { } protected void handleCreateResponse ( ISharedObjectCreateResponseEvent event ) { } protected void handleDeparted ( IContainerDisconnectedEvent event ) { } protected void handleVotingCompletedCreateResponse ( ID fromID , Throwable e , long identifier1 ) { } protected void handlePostCommitFailure ( ID fromID , Throwable e , long identifier1 ) { } protected void sendCommit ( ) throws SharedObjectAddAbortException { } public byte getTransactionState ( ) { } protected void setTransactionState ( byte state ) { } public void waitToCommit ( ) throws SharedObjectAddAbortException { } protected void doTMAbort ( Throwable except ) throws SharedObjectAddAbortException { } protected void doTMCommit ( ) throws SharedObjectAddAbortException { trace ( "doTMCommit" ) ; <START_BUG> if ( ( getSharedObject ( ) . getGroupID ( ) ) != null ) { <END_BUG> sendCommit ( ) ; } localCommitted ( ) ; } protected void localCommitted ( ) { } protected boolean isVotingCompleted ( ) throws SharedObjectAddAbortException { } } 
public class CustomLoadMetricDefinition extends SimpleResourceDefinition { static final PathElement PATH = PathElement . pathElement ( CUSTOM_LOAD_METRIC ) ; protected static final CustomLoadMetricDefinition INSTANCE = new CustomLoadMetricDefinition ( ) ; static final SimpleAttributeDefinition CLASS = SimpleAttributeDefinitionBuilder . create ( CommonAttributes . CLASS , STRING , false ) . setAllowExpression ( false ) . setRestartAllServices ( ) . build ( ) ; static final AttributeDefinition [ ] ATTRIBUTES = new AttributeDefinition [ ] { CustomLoadMetricDefinition . CLASS , LoadMetricDefinition . WEIGHT , LoadMetricDefinition . CAPACITY , LoadMetricDefinition . PROPERTY } ; static void buildTransformation ( ModelVersion version , ResourceTransformationDescriptionBuilder builder ) { <START_BUG> if ( VERSION_1_2_0 . requiresTransformation ( version ) ) { <END_BUG> builder . addChildResource ( CustomLoadMetricDefinition . PATH ) . getAttributeBuilder ( ) . addRejectCheck ( SIMPLE_EXPRESSIONS , CustomLoadMetricDefinition . CLASS , LoadMetricDefinition . WEIGHT ) . addRejectCheck ( CapacityCheckerAndConverter . INSTANCE , LoadMetricDefinition . CAPACITY ) . setValueConverter ( CapacityCheckerAndConverter . INSTANCE , LoadMetricDefinition . CAPACITY ) . end ( ) ; } } private CustomLoadMetricDefinition ( ) { } @ Override public void registerAttributes ( ManagementResourceRegistration resourceRegistration ) { } } 
public class LineBreakHandler implements CharacterHandler { private final boolean fallbackToEscape ; private final boolean leaveOnLnBreak ; public LineBreakHandler ( boolean leaveOnLnBreak , boolean fallbackToEscape ) { } @ Override public void handle ( ParsingContext ctx ) throws CommandFormatException { if ( ( ctx . getCharacter ( ) ) == '\\' ) { if ( ( ( ctx . getInput ( ) . length ( ) ) > ( ( ctx . getLocation ( ) ) + ( LINE_SEPARATOR . length ( ) ) ) ) && ( ctx . getInput ( ) . startsWith ( LINE_SEPARATOR , ( ( ctx . getLocation ( ) ) + 1 ) ) ) ) { if ( leaveOnLnBreak ) { ctx . leaveState ( ) ; ctx . advanceLocation ( LINE_SEPARATOR . length ( ) ) ; } } else if ( fallbackToEscape ) { ctx . enterState ( INSTANCE ) ; } else { <START_BUG> doHandle ( ctx ) ; <END_BUG> } } else { doHandle ( ctx ) ; } } protected void doHandle ( ParsingContext ctx ) throws CommandFormatException { } } 
public class TestElementSaver implements TestElementTraverser { private String name ; private LinkedList stack = new LinkedList ( ) ; private DefaultConfiguration rootConfig = null ; public TestElementSaver ( String name ) { } public Configuration getConfiguration ( ) { } public void startTestElement ( TestElement el ) { } public void setConfigName ( DefaultConfiguration config ) { } public void endTestElement ( TestElement el ) { } public void simplePropertyValue ( JMeterProperty value ) { try { Object parent = stack . getLast ( ) ; if ( ! ( parent instanceof Configuration ) ) { DefaultConfiguration config = new DefaultConfiguration ( "property" , "property" ) ; config . setValue ( ( value != null ? value . toString ( ) : "" ) ) ; config . setAttribute ( "name" , parent . toString ( ) ) ; config . setAttribute ( XML_SPACE , PRESERVE ) ; stack . removeLast ( ) ; stack . add ( config ) ; } if ( ( parent instanceof DefaultConfiguration ) && ( value instanceof Configuration ) ) { ( ( DefaultConfiguration ) ( parent ) ) . addChild ( ( ( Configuration ) ( value ) ) ) ; } else if ( ( parent instanceof DefaultConfiguration ) && ( ! ( value instanceof Configuration ) ) ) { DefaultConfiguration config = new DefaultConfiguration ( "string" , "string" ) ; <START_BUG> config . setValue ( value . toString ( ) ) ; <END_BUG> config . setAttribute ( XML_SPACE , PRESERVE ) ; ( ( DefaultConfiguration ) ( parent ) ) . addChild ( config ) ; } } catch ( NoSuchElementException e ) { } } public void startMap ( MapProperty map ) { } public void startCollection ( CollectionProperty col ) { } public void endProperty ( JMeterProperty key ) { } private void finishConfig ( ) { } public void startProperty ( JMeterProperty key ) { } } 
public class CrosscuttingMembers { private ResolvedTypeX inAspect ; private World world ; private PerClause perClause ; private List shadowMungers = new ArrayList ( 4 ) ; private List typeMungers = new ArrayList ( 4 ) ; private List declareParents = new ArrayList ( 4 ) ; private List declareSofts = new ArrayList ( 0 ) ; private List declareDominates = new ArrayList ( 4 ) ; public CrosscuttingMembers ( ResolvedTypeX inAspect ) { } public void addConcreteShadowMunger ( ShadowMunger m ) { } public void addShadowMungers ( Collection c ) { } private void addShadowMunger ( ShadowMunger m ) { } public void addTypeMungers ( Collection c ) { } public void addTypeMunger ( ConcreteTypeMunger m ) { } public void addDeclares ( Collection c ) { } public void addDeclare ( Declare declare ) { if ( declare instanceof DeclareErrorOrWarning ) { ShadowMunger m = new Checker ( ( ( DeclareErrorOrWarning ) ( declare ) ) ) ; addShadowMunger ( m ) ; } else if ( declare instanceof DeclarePrecedence ) { declareDominates . add ( declare ) ; } else if ( declare instanceof DeclareParents ) { DeclareParents dp = ( ( DeclareParents ) ( declare ) ) ; exposeTypes ( dp . getParents ( ) . getExactTypes ( ) ) ; declareParents . add ( dp ) ; } else if ( declare instanceof DeclareSoft ) { DeclareSoft d = ( ( DeclareSoft ) ( declare ) ) ; <START_BUG> ShadowMunger m = Advice . makeSoftener ( world , d . getPointcut ( ) , d . getException ( ) , inAspect ) ; <END_BUG> Pointcut concretePointcut = d . getPointcut ( ) . concretize ( inAspect , 0 , m ) ; m . pointcut = concretePointcut ; declareSofts . add ( new DeclareSoft ( d . getException ( ) , concretePointcut ) ) ; addConcreteShadowMunger ( m ) ; } else { throw new RuntimeException ( "unimplemented" ) ; } } public void exposeTypes ( Collection typesToExpose ) { } public void exposeType ( TypeX typeToExpose ) { } public void addPrivilegedAccesses ( Collection accessedMembers ) { } private void addPrivilegedAccess ( ResolvedMember member ) { } public Collection getCflowEntries ( ) { } public boolean replaceWith ( CrosscuttingMembers other ) { } public PerClause getPerClause ( ) { } public void setPerClause ( PerClause perClause ) { } public List getDeclareDominates ( ) { } public List getDeclareParents ( ) { } public List getDeclareSofts ( ) { } public List getShadowMungers ( ) { } public List getTypeMungers ( ) { } } 
class RunUpdateProcessor extends UpdateRequestProcessor { private final SolrQueryRequest req ; private final UpdateHandler updateHandler ; private boolean changesSinceCommit = false ; public RunUpdateProcessor ( SolrQueryRequest req , UpdateRequestProcessor next ) { } @ Override public void processAdd ( AddUpdateCommand cmd ) throws IOException { } @ Override public void processDelete ( DeleteUpdateCommand cmd ) throws IOException { <START_BUG> if ( ( cmd . id ) != null ) { <END_BUG> updateHandler . delete ( cmd ) ; } else { updateHandler . deleteByQuery ( cmd ) ; } super . processDelete ( cmd ) ; changesSinceCommit = true ; } @ Override public void processMergeIndexes ( MergeIndexesCommand cmd ) throws IOException { } @ Override public void processCommit ( CommitUpdateCommand cmd ) throws IOException { } @ Override public void processRollback ( RollbackUpdateCommand cmd ) throws IOException { } @ Override public void finish ( ) throws IOException { } } 
public class MemberImpl implements Comparable , AnnotatedElement , Member { protected Kind kind ; protected UnresolvedType declaringType ; protected int modifiers ; protected UnresolvedType returnType ; protected String name ; protected UnresolvedType [ ] parameterTypes ; private final String signature ; private String paramSignature ; private JoinPointSignatureIterator joinPointSignatures = null ; public MemberImpl ( Kind kind , UnresolvedType declaringType , int modifiers , String name , String signature ) { } public MemberImpl ( Kind kind , UnresolvedType declaringType , int modifiers , UnresolvedType returnType , String name , UnresolvedType [ ] parameterTypes ) { } public ResolvedMember resolve ( World world ) { } public static String typesToSignature ( UnresolvedType returnType , UnresolvedType [ ] paramTypes , boolean useRawTypes ) { } public static String typesToSignature ( UnresolvedType [ ] paramTypes ) { } private static Object [ ] signatureToTypes ( String sig , boolean keepParameterizationInfo ) { } public static MemberImpl field ( String declaring , int mods , String name , String signature ) { } public static Member field ( UnresolvedType declaring , int mods , String name , UnresolvedType type ) { } public static MemberImpl method ( UnresolvedType declaring , int mods , String name , String signature ) { } public static MemberImpl monitorEnter ( ) { } public static MemberImpl monitorExit ( ) { } public static Member pointcut ( UnresolvedType declaring , String name , String signature ) { } private static MemberImpl field ( String declaring , int mods , UnresolvedType ty , String name ) { } public static MemberImpl method ( UnresolvedType declTy , int mods , UnresolvedType rTy , String name , UnresolvedType [ ] paramTys ) { } private static Member pointcut ( UnresolvedType declTy , int mods , UnresolvedType rTy , String name , UnresolvedType [ ] paramTys ) { } public static ResolvedMemberImpl makeExceptionHandlerSignature ( UnresolvedType inType , UnresolvedType catchType ) { } public static MemberImpl fieldFromString ( String str ) { } public static Member methodFromString ( String str ) { } private static String [ ] parseIds ( String str ) { } private static final String [ ] ZERO_STRINGS = new String [ 0 ] ; public boolean equals ( Object other ) { } private volatile int hashCode = 0 ; public int hashCode ( ) { } public int compareTo ( Object other ) { } public String toString ( ) { } public String toLongString ( ) { } public Kind getKind ( ) { } public UnresolvedType getDeclaringType ( ) { } public UnresolvedType getReturnType ( ) { } public UnresolvedType getGenericReturnType ( ) { } public UnresolvedType getType ( ) { } public String getName ( ) { } public UnresolvedType [ ] getParameterTypes ( ) { } public String getSignature ( ) { } public int getArity ( ) { } public String getParameterSignature ( ) { } public boolean isCompatibleWith ( Member am ) { } private static boolean equalTypes ( UnresolvedType [ ] a , UnresolvedType [ ] b ) { } public int getModifiers ( World world ) { } public UnresolvedType [ ] getExceptions ( World world ) { } public final boolean isProtected ( World world ) { } public final boolean isStatic ( World world ) { } public final boolean isStrict ( World world ) { } public final boolean isStatic ( ) { } public final boolean isInterface ( ) { } public final boolean isPrivate ( ) { } public boolean canBeParameterized ( ) { } public final int getCallsiteModifiers ( ) { } public int getModifiers ( ) { } public final String getExtractableName ( ) { } public boolean hasAnnotation ( UnresolvedType ofType ) { } public ResolvedType [ ] getAnnotationTypes ( ) { } public AnnotationX [ ] getAnnotations ( ) { <START_BUG> throw new UnsupportedOperationException ( "You<seq2seq4repair_space>should<seq2seq4repair_space>resolve<seq2seq4repair_space>this<seq2seq4repair_space>member<seq2seq4repair_space>and<seq2seq4repair_space>call<seq2seq4repair_space>getAnnotations()<seq2seq4repair_space>on<seq2seq4repair_space>the<seq2seq4repair_space>result..." ) ; <END_BUG> } public Collection getDeclaringTypes ( World world ) { } private boolean walkUp ( Collection acc , ResolvedType curr ) { } private boolean walkUpStatic ( Collection acc , ResolvedType curr ) { } public String getSignatureMakerName ( ) { } public String getSignatureType ( ) { } public String getSignatureString ( World world ) { } private String getHandlerSignatureString ( World world ) { } private String getStaticInitializationSignatureString ( World world ) { } protected String getAdviceSignatureString ( World world ) { } protected String getMethodSignatureString ( World world ) { } protected String getMonitorSignatureString ( World world ) { } protected String getConstructorSignatureString ( World world ) { } protected String getFieldSignatureString ( World world ) { } protected String makeString ( int i ) { } protected String makeString ( UnresolvedType t ) { } protected String makeString ( UnresolvedType [ ] types ) { } protected String makeString ( String [ ] names ) { } public String [ ] getParameterNames ( World world ) { } public Iterator getJoinPointSignatures ( World inAWorld ) { } } 
public class SourceTypeBinding extends ReferenceBinding { public ReferenceBinding superclass ; public ReferenceBinding [ ] superInterfaces ; private FieldBinding [ ] fields ; private MethodBinding [ ] methods ; public ReferenceBinding [ ] memberTypes ; public TypeVariableBinding [ ] typeVariables ; public ClassScope scope ; public static final int METHOD_EMUL = 0 ; public static final int FIELD_EMUL = 1 ; public static final int CLASS_LITERAL_EMUL = 2 ; public static final int RECEIVER_TYPE_EMUL = 3 ; HashMap [ ] synthetics ; char [ ] genericReferenceTypeSignature ; private SimpleLookupTable storedAnnotations = null ; public SourceTypeBinding ( char [ ] [ ] compoundName , PackageBinding fPackage , ClassScope scope ) { } private void addDefaultAbstractMethods ( ) { } public FieldBinding addSyntheticFieldForInnerclass ( LocalVariableBinding actualOuterLocalVariable ) { } public FieldBinding addSyntheticFieldForInnerclass ( ReferenceBinding enclosingType ) { } public FieldBinding addSyntheticFieldForClassLiteral ( TypeBinding targetType , BlockScope blockScope ) { } public FieldBinding addSyntheticFieldForAssert ( BlockScope blockScope ) { } public FieldBinding addSyntheticFieldForEnumValues ( ) { } public SyntheticMethodBinding addSyntheticMethod ( FieldBinding targetField , boolean isReadAccess ) { } public SyntheticMethodBinding addSyntheticEnumMethod ( char [ ] selector ) { } public SyntheticFieldBinding addSyntheticFieldForSwitchEnum ( char [ ] fieldName , String key ) { } public SyntheticMethodBinding addSyntheticMethodForSwitchEnum ( TypeBinding enumBinding ) { } public SyntheticMethodBinding addSyntheticMethod ( MethodBinding targetMethod , boolean isSuperAccess ) { } public SyntheticMethodBinding addSyntheticBridgeMethod ( MethodBinding inheritedMethodToBridge , MethodBinding targetMethod ) { } public int kind ( ) { } public char [ ] computeUniqueKey ( boolean isLeaf ) { } void faultInTypesForFieldsAndMethods ( ) { } public FieldBinding [ ] fields ( ) { } public char [ ] genericTypeSignature ( ) { } public char [ ] genericSignature ( ) { } public long getAnnotationTagBits ( ) { } public MethodBinding [ ] getDefaultAbstractMethods ( ) { } public MethodBinding getExactConstructor ( TypeBinding [ ] argumentTypes ) { } public MethodBinding getExactMethod ( char [ ] selector , TypeBinding [ ] argumentTypes , CompilationUnitScope refScope ) { } public FieldBinding getField ( char [ ] fieldName , boolean needResolve ) { } public MethodBinding [ ] getMethods ( char [ ] selector ) { } public FieldBinding getSyntheticField ( LocalVariableBinding actualOuterLocalVariable ) { } public FieldBinding getSyntheticField ( ReferenceBinding targetEnclosingType , boolean onlyExactMatch ) { } public SyntheticMethodBinding getSyntheticBridgeMethod ( MethodBinding inheritedMethodToBridge ) { } public void initializeDeprecatedAnnotationTagBits ( ) { } public boolean isEquivalentTo ( TypeBinding otherType ) { } public boolean isGenericType ( ) { } public ReferenceBinding [ ] memberTypes ( ) { } public FieldBinding getUpdatedFieldBinding ( FieldBinding targetField , ReferenceBinding newDeclaringClass ) { } public MethodBinding getUpdatedMethodBinding ( MethodBinding targetMethod , ReferenceBinding newDeclaringClass ) { } public boolean hasMemberTypes ( ) { } public MethodBinding [ ] methods ( ) { } private FieldBinding resolveTypeFor ( FieldBinding field ) { } private MethodBinding resolveTypesFor ( MethodBinding method ) { } AnnotationHolder retrieveAnnotationHolder ( Binding binding , boolean forceInitialization ) { } public void setFields ( FieldBinding [ ] fields ) { } public void setMethods ( MethodBinding [ ] methods ) { } public final int sourceEnd ( ) { } public final int sourceStart ( ) { } SimpleLookupTable storedAnnotations ( boolean forceInitialize ) { <START_BUG> if ( forceInitialize && ( ( this . storedAnnotations ) == null ) ) { <END_BUG> this . scope . referenceCompilationUnit ( ) . compilationResult . hasAnnotations = true ; if ( ! ( this . scope . environment ( ) . globalOptions . storeAnnotations ) ) return null ; this . storedAnnotations = new SimpleLookupTable ( 3 ) ; } return this . storedAnnotations ; } public ReferenceBinding superclass ( ) { } public ReferenceBinding [ ] superInterfaces ( ) { } public SyntheticMethodBinding [ ] syntheticMethods ( ) { } public FieldBinding [ ] syntheticFields ( ) { } public String toString ( ) { } public TypeVariableBinding [ ] typeVariables ( ) { } void verifyMethods ( MethodVerifier verifier ) { } } 
public class TestUtils { private TestUtils ( ) { } public static void assertEquals ( double expected , double actual , double delta ) { } public static void assertEquals ( String msg , double expected , double actual , double delta ) { } public static void assertSame ( double expected , double actual ) { } public static void assertSame ( Complex expected , Complex actual ) { } public static void assertEquals ( Complex expected , Complex actual , double delta ) { } public static void assertEquals ( double [ ] expected , double [ ] observed , double tolerance ) { } public static Object serializeAndRecover ( Object o ) { } public static void checkSerializedEquality ( Object object ) { } public static void assertRelativelyEquals ( double expected , double actual , double relativeError ) { } public static void assertRelativelyEquals ( String msg , double expected , double actual , double relativeError ) { } public static void assertContains ( String msg , Complex [ ] values , Complex z , double epsilon ) { } public static void assertContains ( Complex [ ] values , Complex z , double epsilon ) { } public static void assertContains ( String msg , double [ ] values , double x , double epsilon ) { } public static void assertContains ( double [ ] values , double x , double epsilon ) { } public static void assertEquals ( String msg , RealMatrix expected , RealMatrix observed , double tolerance ) { } public static void assertEquals ( FieldMatrix < ? extends FieldElement < ? > > expected , FieldMatrix < ? extends FieldElement < ? > > observed ) { } public static void assertEquals ( String msg , double [ ] expected , double [ ] observed , double tolerance ) { StringBuffer out = new StringBuffer ( msg ) ; if ( ( expected . length ) != ( observed . length ) ) { out . append ( "\n<seq2seq4repair_space>Arrays<seq2seq4repair_space>not<seq2seq4repair_space>same<seq2seq4repair_space>length.<seq2seq4repair_space>\n" ) ; out . append ( "expected<seq2seq4repair_space>has<seq2seq4repair_space>length<seq2seq4repair_space>" ) ; out . append ( expected . length ) ; out . append ( "<seq2seq4repair_space>observed<seq2seq4repair_space>length<seq2seq4repair_space>=<seq2seq4repair_space>" ) ; out . append ( observed . length ) ; Assert . fail ( out . toString ( ) ) ; } boolean failure = false ; for ( int i = 0 ; i < ( expected . length ) ; i ++ ) { try { <START_BUG> Assert . assertEquals ( expected [ i ] , observed [ i ] , tolerance ) ; <END_BUG> } catch ( AssertionFailedError ex ) { failure = true ; out . append ( "\n<seq2seq4repair_space>Elements<seq2seq4repair_space>at<seq2seq4repair_space>index<seq2seq4repair_space>" ) ; out . append ( i ) ; out . append ( "<seq2seq4repair_space>differ.<seq2seq4repair_space>" ) ; out . append ( "<seq2seq4repair_space>expected<seq2seq4repair_space>=<seq2seq4repair_space>" ) ; out . append ( expected [ i ] ) ; out . append ( "<seq2seq4repair_space>observed<seq2seq4repair_space>=<seq2seq4repair_space>" ) ; out . append ( observed [ i ] ) ; } } if ( failure ) { Assert . fail ( out . toString ( ) ) ; } } public static < T extends FieldElement < T > > void assertEquals ( T [ ] m , T [ ] n ) { } } 
class SearchableEnvironmentRequestor extends JavaElementRequestor { protected ISearchRequestor requestor ; protected ICompilationUnit unitToSkip ; protected IJavaProject project ; protected NameLookup nameLookup ; protected boolean checkAccessRestrictions ; public SearchableEnvironmentRequestor ( ISearchRequestor requestor ) { } public SearchableEnvironmentRequestor ( ISearchRequestor requestor , ICompilationUnit unitToSkip , IJavaProject project , NameLookup nameLookup ) { } public void acceptInitializer ( IInitializer initializer ) { } public void acceptPackageFragment ( IPackageFragment packageFragment ) { } public void acceptType ( IType type ) { try { if ( ( ( this . unitToSkip ) != null ) && ( this . unitToSkip . equals ( type . getCompilationUnit ( ) ) ) ) { return ; } char [ ] packageName = type . getPackageFragment ( ) . getElementName ( ) . toCharArray ( ) ; boolean isBinary = type instanceof BinaryType ; AccessRestriction accessRestriction = null ; if ( ( this . checkAccessRestrictions ) && ( isBinary || ( ! ( type . getJavaProject ( ) . equals ( this . project ) ) ) ) ) { PackageFragmentRoot root = ( ( PackageFragmentRoot ) ( type . getAncestor ( IJavaElement . PACKAGE_FRAGMENT_ROOT ) ) ) ; ClasspathEntry entry = ( ( ClasspathEntry ) ( this . nameLookup . rootToResolvedEntries . get ( root ) ) ) ; if ( entry != null ) { AccessRuleSet accessRuleSet = entry . getAccessRuleSet ( ) ; if ( accessRuleSet != null ) { char [ ] [ ] packageChars = CharOperation . splitOn ( '.' , packageName ) ; char [ ] fileChars = type . getParent ( ) . getElementName ( ) . toCharArray ( ) ; accessRestriction = accessRuleSet . getViolatedRestriction ( CharOperation . concatWith ( packageChars , fileChars , '/' ) ) ; } } } <START_BUG> this . requestor . acceptType ( packageName , type . getElementName ( ) . toCharArray ( ) , type . getFlags ( ) , accessRestriction ) ; <END_BUG> } catch ( JavaModelException jme ) { } } } 
public class ParenthesizedExpression extends Expression { public static final ChildPropertyDescriptor EXPRESSION_PROPERTY = new ChildPropertyDescriptor ( ParenthesizedExpression . class , "expression" , Expression . class , ASTNode . MANDATORY , ASTNode . CYCLE_RISK ) ; private static final List PROPERTY_DESCRIPTORS ; public static List propertyDescriptors ( int apiLevel ) { } private Expression expression = null ; ParenthesizedExpression ( AST ast ) { } final List internalStructuralPropertiesForType ( int apiLevel ) { } final ASTNode internalGetSetChildProperty ( ChildPropertyDescriptor property , boolean get , ASTNode child ) { } final int getNodeType0 ( ) { } ASTNode clone0 ( AST target ) { ParenthesizedExpression result = new ParenthesizedExpression ( target ) ; <START_BUG> result . setSourceRange ( this . getStartPosition ( ) , this . getLength ( ) ) ; <END_BUG> result . setExpression ( ( ( Expression ) ( getExpression ( ) . clone ( target ) ) ) ) ; return result ; } final boolean subtreeMatch0 ( ASTMatcher matcher , Object other ) { } void accept0 ( ASTVisitor visitor ) { } public Expression getExpression ( ) { } public void setExpression ( Expression expression ) { } int memSize ( ) { } int treeSize ( ) { } } 
public class TrecContentSourceTest extends LuceneTestCase { private static class StringableTrecSource extends TrecContentSource { private String docs = null ; public StringableTrecSource ( String docs , boolean forever ) { } @ Override void openNextFile ( ) throws IOException , NoMoreDataException { } @ Override public void setConfig ( Config config ) { } } private void assertDocData ( DocData dd , String expName , String expTitle , String expBody , Date expDate ) throws ParseException { } private void assertNoMoreDataException ( TrecContentSourceTest . StringableTrecSource stdm ) throws Exception { } public void testOneDocument ( ) throws Exception { } public void testTwoDocuments ( ) throws Exception { } public void testMissingDate ( ) throws Exception { } public void testBadDate ( ) throws Exception { } public void testForever ( ) throws Exception { } public void testTrecFeedDirAllTypes ( ) throws Exception { File dataDir = _TestUtil . getTempDir ( "trecFeedAllTypes" ) ; _TestUtil . unzip ( getDataFile ( "trecdocs.zip" ) , dataDir ) ; TrecContentSource tcs = new TrecContentSource ( ) ; Properties props = new Properties ( ) ; props . setProperty ( "print.props" , "false" ) ; props . setProperty ( "content.source.verbose" , "false" ) ; props . setProperty ( "content.source.excludeIteration" , "true" ) ; props . setProperty ( "doc.maker.forever" , "false" ) ; props . setProperty ( "docs.dir" , dataDir . getCanonicalPath ( ) . replace ( '\\' , '/' ) ) ; props . setProperty ( "trec.doc.parser" , TrecParserByPath . class . getName ( ) ) ; props . setProperty ( "content.source.forever" , "false" ) ; tcs . setConfig ( new Config ( props ) ) ; tcs . resetInputs ( ) ; DocData dd = new DocData ( ) ; int n = 0 ; boolean gotExpectedException = false ; HashSet < ParsePathType > unseenTypes = new HashSet < ParsePathType > ( Arrays . asList ( ParsePathType . values ( ) ) ) ; try { while ( n < 100 ) { dd = tcs . getNextDocData ( dd ) ; ++ n ; assertNotNull ( ( ( "doc<seq2seq4repair_space>data<seq2seq4repair_space>" + n ) + "<seq2seq4repair_space>should<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>null!" ) , dd ) ; unseenTypes . remove ( tcs . currPathType ) ; switch ( tcs . currPathType ) { case GOV2 : assertDocData ( dd , "TEST-000" , "TEST-000<seq2seq4repair_space>title" , "TEST-000<seq2seq4repair_space>text" , tcs . parseDate ( "Sun,<seq2seq4repair_space>11<seq2seq4repair_space>Jan<seq2seq4repair_space>2009<seq2seq4repair_space>08:00:00<seq2seq4repair_space>GMT" ) ) ; break ; case FBIS : assertDocData ( dd , "TEST-001" , "TEST-001<seq2seq4repair_space>Title" , "TEST-001<seq2seq4repair_space>text" , tcs . parseDate ( "1<seq2seq4repair_space>January<seq2seq4repair_space>1991" ) ) ; break ; case FR94 : assertDocData ( dd , "TEST-002" , null , "DEPARTMENT<seq2seq4repair_space>OF<seq2seq4repair_space>SOMETHING" , tcs . parseDate ( "February<seq2seq4repair_space>3,<seq2seq4repair_space>1994" ) ) ; break ; case FT : assertDocData ( dd , "TEST-003" , "Test-003<seq2seq4repair_space>title" , "Some<seq2seq4repair_space>pub<seq2seq4repair_space>text" , tcs . parseDate ( "980424" ) ) ; break ; case LATIMES : assertDocData ( dd , "TEST-004" , "Test-004<seq2seq4repair_space>Title" , "Some<seq2seq4repair_space>paragraph" , tcs . parseDate ( "January<seq2seq4repair_space>17,<seq2seq4repair_space>1997,<seq2seq4repair_space>Sunday" ) ) ; break ; default : assertTrue ( "Should<seq2seq4repair_space>never<seq2seq4repair_space>get<seq2seq4repair_space>here!" , false ) ; } } } catch ( NoMoreDataException e ) { gotExpectedException = true ; } assertTrue ( "Should<seq2seq4repair_space>have<seq2seq4repair_space>gotten<seq2seq4repair_space>NoMoreDataException!" , gotExpectedException ) ; <START_BUG> assertEquals ( "Wrong<seq2seq4repair_space>numbre<seq2seq4repair_space>of<seq2seq4repair_space>documents<seq2seq4repair_space>created<seq2seq4repair_space>by<seq2seq4repair_space>osurce!" , 5 , n ) ; <END_BUG> assertTrue ( "Did<seq2seq4repair_space>not<seq2seq4repair_space>see<seq2seq4repair_space>all<seq2seq4repair_space>types!" , unseenTypes . isEmpty ( ) ) ; } } 
public class TreeSelectionManager extends SelectionManager { protected FolderTreeNode folder ; protected Vector treeListenerList ; public TreeSelectionManager ( ) { } public FolderTreeNode getFolder ( ) { } public void addFolderSelectionListener ( FolderSelectionListener listener ) { } public void fireFolderSelectionEvent ( FolderTreeNode oldFolder , FolderTreeNode newFolder ) { } public DefaultCommandReference [ ] getSelection ( ) { log . info ( ( "folder=" + ( folder ) ) ) ; FolderCommandReference [ ] references = new FolderCommandReference [ 1 ] ; <START_BUG> references [ 0 ] = new FolderCommandReference ( ( ( Folder ) ( folder ) ) ) ; <END_BUG> return references ; } } 
public class Snippet83 extends ByteArrayTransfer { private static Snippet83 _instance = new Snippet83 ( ) ; private int [ ] ids ; private String [ ] names ; public static void main ( String [ ] args ) { Display display = new Display ( ) ; Shell shell = new Shell ( display ) ; shell . setLayout ( new FillLayout ( ) ) ; Canvas canvas = new Canvas ( shell , SWT . NONE ) ; DropTarget target = new DropTarget ( canvas , ( ( DND . DROP_DEFAULT ) | ( DND . DROP_LINK ) ) ) ; target . setTransfer ( new Transfer [ ] { Snippet83 . getInstance ( ) } ) ; target . addDropListener ( new DropTargetAdapter ( ) { public void dragEnter ( DropTargetEvent event ) { <START_BUG> String ops = null ; <END_BUG> if ( ( ( event . operations ) & ( DND . DROP_COPY ) ) != 0 ) ops += "Copy;" ; if ( ( ( event . operations ) & ( DND . DROP_MOVE ) ) != 0 ) ops += "Move;" ; if ( ( ( event . operations ) & ( DND . DROP_LINK ) ) != 0 ) ops += "Link;" ; System . out . println ( ( "Allowed<seq2seq4repair_space>Operations<seq2seq4repair_space>are<seq2seq4repair_space>" + ops ) ) ; TransferData [ ] data = event . dataTypes ; for ( int i = 0 ; i < ( data . length ) ; i ++ ) { int id = data [ i ] . type ; String name = Snippet83 . getNameFromId ( id ) ; System . out . println ( ( ( ( "Data<seq2seq4repair_space>type<seq2seq4repair_space>is<seq2seq4repair_space>" + id ) + "<seq2seq4repair_space>" ) + name ) ) ; } } } ) ; shell . setSize ( 400 , 400 ) ; shell . open ( ) ; while ( ! ( shell . isDisposed ( ) ) ) { if ( ! ( display . readAndDispatch ( ) ) ) display . sleep ( ) ; } display . dispose ( ) ; } public static Snippet83 getInstance ( ) { } Snippet83 ( ) { } public void javaToNative ( Object object , TransferData transferData ) { } public Object nativeToJava ( TransferData transferData ) { } protected String [ ] getTypeNames ( ) { } protected int [ ] getTypeIds ( ) { } static String getNameFromId ( int id ) { } } 
class CTabFolderTab extends Tab { int lastSelectedTab = 0 ; CTabFolder tabFolder1 ; Group tabFolderGroup ; Group itemGroup ; Button topButton ; Button bottomButton ; Button flatButton ; Button closeButton ; static String [ ] CTabItems1 = new String [ ] { ControlExample . getResourceString ( "CTabItem1_0" ) , ControlExample . getResourceString ( "CTabItem1_1" ) , ControlExample . getResourceString ( "CTabItem1_2" ) } ; Button foregroundSelectionButton ; Button backgroundSelectionButton ; Button itemFontButton ; Image foregroundSelectionImage ; Image backgroundSelectionImage ; Color foregroundSelectionColor ; Color backgroundSelectionColor ; Font itemFont ; Button simpleTabButton ; Button singleTabButton ; Button imageButton ; Button showMinButton ; Button showMaxButton ; Button unselectedCloseButton ; Button unselectedImageButton ; CTabFolderTab ( ControlExample instance ) { } void createColorGroup ( ) { } void createOtherGroup ( ) { } void createExampleGroup ( ) { } void createExampleWidgets ( ) { } void createStyleGroup ( ) { } String [ ] getCustomEventNames ( ) { } Item [ ] getExampleWidgetItems ( ) { } Control [ ] getExampleWidgets ( ) { } String getTabText ( ) { } void hookCustomListener ( final String eventName ) { if ( eventName == "CTabFolderEvent" ) { tabFolder1 . addCTabFolder2Listener ( new CTabFolder2Adapter ( ) { <START_BUG> public void itemClosed ( CTabFolderEvent event ) { <END_BUG> log ( eventName , event ) ; } } ) ; } } void resetColorsAndFonts ( ) { } void setExampleWidgetForeground ( ) { } void setExampleWidgetBackground ( ) { } void setExampleWidgetFont ( ) { } void setExampleWidgetState ( ) { } void setSimpleTabs ( ) { } void setSingleTabs ( ) { } void setImages ( ) { } void setMinimizeVisible ( ) { } void setMaximizeVisible ( ) { } void setUnselectedCloseVisible ( ) { } void setUnselectedImageVisible ( ) { } void setItemFont ( ) { } } 
public class ContextAdmin { private ContextManager cm ; private Request realRequest ; private String submit = null ; private String addContextPath = null ; private String addContextDocBase = null ; private String removeContextName = null ; public void setSubmit ( String s ) { } public void setAddContextPath ( String s ) { } public void setAddContextDocBase ( String s ) { } public void setRemoveContextName ( String s ) { } public void init ( HttpServletRequest request ) { } public Enumeration getContextNames ( ) { } public String [ ] getContextInfo ( String contextName ) { ( Enumeration ) ++ ; String key ; Context context ; Vector v = new Vector ( ) ; context = cm . getContext ( contextName ) ; v . addElement ( ( "DOC<seq2seq4repair_space>BASE:<seq2seq4repair_space>" + ( context . getDocBase ( ) ) ) ) ; <START_BUG> v . addElement ( ( "FULL<seq2seq4repair_space>DOC<seq2seq4repair_space>BASE:<seq2seq4repair_space>" + ( context . getDocumentBase ( ) . toString ( ) ) ) ) ; <END_BUG> v . addElement ( ( "PATH:<seq2seq4repair_space>" + ( context . getPath ( ) ) ) ) ; if ( ( context . getWorkDir ( ) ) != null ) v . addElement ( ( "WORK<seq2seq4repair_space>DIR:<seq2seq4repair_space>" + ( RequestUtil . URLDecode ( context . getWorkDir ( ) . getName ( ) ) ) ) ) ; v . addElement ( ( "DESCRIPTION:<seq2seq4repair_space>" + ( context . getDescription ( ) ) ) ) ; v . addElement ( ( "SESSION<seq2seq4repair_space>TIMEOUT:<seq2seq4repair_space>" + ( new Integer ( context . getSessionTimeOut ( ) ) . toString ( ) ) ) ) ; } public String addContext ( ) { } public String removeContext ( ) { } } 
public class FileUtils { private static Random rand = new Random ( System . currentTimeMillis ( ) ) ; private static Object lockReflection = new Object ( ) ; private static Method setLastModified = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; private static boolean [ ] isSpecial = new boolean [ 256 ] ; private static char [ ] escapedChar1 = new char [ 256 ] ; private static char [ ] escapedChar2 = new char [ 256 ] ; public static FileUtils newFileUtils ( ) { } protected FileUtils ( ) { } public URL getFileURL ( File file ) throws MalformedURLException { } public void copyFile ( String sourceFile , String destFile ) throws IOException { } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters ) throws IOException { } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { } public void copyFile ( File sourceFile , File destFile ) throws IOException { } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters ) throws IOException { } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified , String encoding ) throws IOException { } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String encoding , Project project ) throws IOException { } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , Vector filterChains , boolean overwrite , boolean preserveLastModified , String inputEncoding , String outputEncoding , Project project ) throws IOException { } protected final Method getSetLastModified ( ) { } public void setFileLastModified ( File file , long time ) throws BuildException { } public File resolveFile ( File file , String filename ) { } public File normalize ( String path ) { } public File createTempFile ( String prefix , String suffix , File parentDir ) { } public boolean contentEquals ( File f1 , File f2 ) throws IOException { } public File getParentFile ( File f ) { } public static final String readFully ( Reader rdr ) throws IOException { } public static final String readFully ( Reader rdr , int bufferSize ) throws IOException { } public boolean createNewFile ( File f ) throws IOException { } public boolean isSymbolicLink ( File parent , String name ) throws IOException { } public String removeLeadingPath ( File leading , File path ) { } public String toURI ( String path ) { boolean isDir = new File ( path ) . isDirectory ( ) ; StringBuffer sb = new StringBuffer ( "file:" ) ; try { path = normalize ( path ) . getAbsolutePath ( ) ; sb . append ( "//" ) ; <START_BUG> if ( ! ( path . startsWith ( "/" ) ) ) { <END_BUG> sb . append ( "/" ) ; } } catch ( BuildException e ) { } path = path . replace ( '\\' , '/' ) ; CharacterIterator iter = new StringCharacterIterator ( path ) ; for ( char c = iter . first ( ) ; c != ( CharacterIterator . DONE ) ; c = iter . next ( ) ) { if ( FileUtils . isSpecial [ c ] ) { sb . append ( '%' ) ; sb . append ( FileUtils . escapedChar1 [ c ] ) ; sb . append ( FileUtils . escapedChar2 [ c ] ) ; } else { sb . append ( c ) ; } } if ( isDir && ( ! ( path . endsWith ( "/" ) ) ) ) { sb . append ( '/' ) ; } return sb . toString ( ) ; } public String fromURI ( String uri ) { } public boolean fileNameEquals ( File f1 , File f2 ) { } public void rename ( File from , File to ) throws IOException { } } 
public class TestThreadedForceMerge extends LuceneTestCase { private static Analyzer ANALYZER ; private static final int NUM_THREADS = 3 ; private static final int NUM_ITER = 1 ; private static final int NUM_ITER2 = 1 ; private volatile boolean failed ; @ BeforeClass public static void setup ( ) { } private void setFailed ( ) { } public void runTest ( Random random , Directory directory ) throws Exception { IndexWriter writer = new IndexWriter ( directory , newIndexWriterConfig ( TEST_VERSION_CURRENT , TestThreadedForceMerge . ANALYZER ) . setOpenMode ( CREATE ) . setMaxBufferedDocs ( 2 ) . setMergePolicy ( newLogMergePolicy ( ) ) ) ; for ( int iter = 0 ; iter < ( TestThreadedForceMerge . NUM_ITER ) ; iter ++ ) { final int iterFinal = iter ; ( ( LogMergePolicy ) ( writer . getConfig ( ) . getMergePolicy ( ) ) ) . setMergeFactor ( 1000 ) ; final FieldType customType = new FieldType ( StringField . TYPE_STORED ) ; customType . setOmitNorms ( true ) ; for ( int i = 0 ; i < 200 ; i ++ ) { Document d = new Document ( ) ; d . add ( newField ( "id" , Integer . toString ( i ) , customType ) ) ; d . add ( newField ( "contents" , English . intToEnglish ( i ) , customType ) ) ; writer . addDocument ( d ) ; } ( ( LogMergePolicy ) ( writer . getConfig ( ) . getMergePolicy ( ) ) ) . setMergeFactor ( 4 ) ; Thread [ ] threads = new Thread [ TestThreadedForceMerge . NUM_THREADS ] ; for ( int i = 0 ; i < ( TestThreadedForceMerge . NUM_THREADS ) ; i ++ ) { final int iFinal = i ; final IndexWriter writerFinal = writer ; threads [ i ] = new Thread ( ) { @ Override public void run ( ) { try { for ( int j = 0 ; j < ( TestThreadedForceMerge . NUM_ITER2 ) ; j ++ ) { writerFinal . forceMerge ( 1 , false ) ; for ( int k = 0 ; k < ( 17 * ( 1 + iFinal ) ) ; k ++ ) { Document d = new Document ( ) ; d . add ( newField ( "id" , ( ( ( ( ( ( iterFinal + "_" ) + iFinal ) + "_" ) + j ) + "_" ) + k ) , customType ) ) ; d . add ( newField ( "contents" , English . intToEnglish ( ( iFinal + k ) ) , customType ) ) ; writerFinal . addDocument ( d ) ; } for ( int k = 0 ; k < ( 9 * ( 1 + iFinal ) ) ; k ++ ) writerFinal . deleteDocuments ( new Term ( "id" , ( ( ( ( ( ( iterFinal + "_" ) + iFinal ) + "_" ) + j ) + "_" ) + k ) ) ) ; writerFinal . forceMerge ( 1 ) ; } } catch ( Throwable t ) { setFailed ( ) ; System . out . println ( ( ( Thread . currentThread ( ) . getName ( ) ) + ":<seq2seq4repair_space>hit<seq2seq4repair_space>exception" ) ) ; t . printStackTrace ( System . out ) ; } } } ; } for ( int i = 0 ; i < ( TestThreadedForceMerge . NUM_THREADS ) ; i ++ ) threads [ i ] . start ( ) ; for ( int i = 0 ; i < ( TestThreadedForceMerge . NUM_THREADS ) ; i ++ ) threads [ i ] . join ( ) ; assertTrue ( ( ! ( failed ) ) ) ; final int expectedDocCount = ( ( int ) ( ( 1 + iter ) * ( 200 + ( ( ( 8 * ( TestThreadedForceMerge . NUM_ITER2 ) ) * ( ( TestThreadedForceMerge . NUM_THREADS ) / 2.0 ) ) * ( 1 + ( TestThreadedForceMerge . NUM_THREADS ) ) ) ) ) ) ; assertEquals ( ( ( ( ( ( ( ( "index=" + ( writer . segString ( ) ) ) + "<seq2seq4repair_space>numDocs=" ) + ( writer . numDocs ( ) ) ) + "<seq2seq4repair_space>maxDoc=" ) + ( writer . maxDoc ( ) ) ) + "<seq2seq4repair_space>config=" ) + ( writer . getConfig ( ) ) ) , expectedDocCount , writer . numDocs ( ) ) ; assertEquals ( ( ( ( ( ( ( ( "index=" + ( writer . segString ( ) ) ) + "<seq2seq4repair_space>numDocs=" ) + ( writer . numDocs ( ) ) ) + "<seq2seq4repair_space>maxDoc=" ) + ( writer . maxDoc ( ) ) ) + "<seq2seq4repair_space>config=" ) + ( writer . getConfig ( ) ) ) , expectedDocCount , writer . maxDoc ( ) ) ; writer . close ( ) ; writer = new IndexWriter ( directory , newIndexWriterConfig ( TEST_VERSION_CURRENT , TestThreadedForceMerge . ANALYZER ) . setOpenMode ( APPEND ) . setMaxBufferedDocs ( 2 ) ) ; DirectoryReader reader = DirectoryReader . open ( directory ) ; <START_BUG> assertEquals ( ( "reader=" + reader ) , 1 , reader . getSequentialSubReaders ( ) . size ( ) ) ; <END_BUG> assertEquals ( expectedDocCount , reader . numDocs ( ) ) ; reader . close ( ) ; } writer . close ( ) ; } public void testThreadedForceMerge ( ) throws Exception { } } 
public class KohonenUpdateActionTest { @ Test public void testUpdate ( ) { final FeatureInitializer init = new org . apache . commons . math3 . ml . neuralnet . OffsetFeatureInitializer ( FeatureInitializerFactory . uniform ( 0 , 0.1 ) ) ; final FeatureInitializer [ ] initArray = new FeatureInitializer [ ] { init } ; final int netSize = 3 ; final Network net = new org . apache . commons . math3 . ml . neuralnet . oned . NeuronString ( netSize , false , initArray ) . getNetwork ( ) ; final DistanceMeasure dist = new EuclideanDistance ( ) ; final LearningFactorFunction learning = LearningFactorFunctionFactory . exponentialDecay ( 1 , 0.1 , 100 ) ; final NeighbourhoodSizeFunction neighbourhood = NeighbourhoodSizeFunctionFactory . exponentialDecay ( 3 , 1 , 100 ) ; final UpdateAction update = new KohonenUpdateAction ( dist , learning , neighbourhood ) ; final double [ ] features = new double [ ] { 0.3 } ; final double [ ] distancesBefore = new double [ netSize ] ; int count = 0 ; for ( Neuron n : net ) { distancesBefore [ ( count ++ ) ] = dist . compute ( n . getFeatures ( ) , features ) ; } final Neuron bestBefore = MapUtils . findBest ( features , net , dist ) ; <START_BUG> Assert . assertTrue ( ( ( dist . compute ( bestBefore . getFeatures ( ) , features ) ) >= ( 0.2 * 0.2 ) ) ) ; <END_BUG> update . update ( net , features ) ; final double [ ] distancesAfter = new double [ netSize ] ; count = 0 ; for ( Neuron n : net ) { distancesAfter [ ( count ++ ) ] = dist . compute ( n . getFeatures ( ) , features ) ; } final Neuron bestAfter = MapUtils . findBest ( features , net , dist ) ; Assert . assertEquals ( bestBefore , bestAfter ) ; Assert . assertEquals ( 0 , dist . compute ( bestAfter . getFeatures ( ) , features ) , 0.0 ) ; for ( int i = 0 ; i < netSize ; i ++ ) { Assert . assertTrue ( ( ( distancesAfter [ i ] ) < ( distancesBefore [ i ] ) ) ) ; } } } 
public class BooleanLiteral extends Expression { private boolean value = false ; BooleanLiteral ( AST ast ) { } public int getNodeType ( ) { } ASTNode clone ( AST target ) { } public boolean subtreeMatch ( ASTMatcher matcher , Object other ) { } void accept0 ( ASTVisitor visitor ) { <START_BUG> boolean visitChildren = visitor . visit ( this ) ; <END_BUG> visitor . endVisit ( this ) ; } public boolean booleanValue ( ) { } public void setBooleanValue ( boolean value ) { } int memSize ( ) { } int treeSize ( ) { } } 
public class TryStatement extends Statement { public Block tryBlock ; public Block [ ] catchBlocks ; public Argument [ ] catchArguments ; public Block finallyBlock ; BlockScope scope ; public boolean subRoutineCannotReturn = true ; ReferenceBinding [ ] caughtExceptionTypes ; boolean tryBlockExit ; boolean [ ] catchExits ; public int [ ] preserveExceptionHandler ; Label subRoutineStartLabel ; public LocalVariableBinding anyExceptionVariable ; public LocalVariableBinding returnAddressVariable ; public LocalVariableBinding secretReturnValue ; public static final char [ ] SecretReturnName = "<seq2seq4repair_space>returnAddress" . toCharArray ( ) ; public static final char [ ] SecretAnyHandlerName = "<seq2seq4repair_space>anyExceptionHandler" . toCharArray ( ) ; public static final char [ ] SecretLocalDeclarationName = "<seq2seq4repair_space>returnValue" . toCharArray ( ) ; int preTryInitStateIndex = - 1 ; int mergedInitStateIndex = - 1 ; public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public boolean cannotReturn ( ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void resolve ( BlockScope upperScope ) { this . scope = new BlockScope ( upperScope ) ; BlockScope tryScope = new BlockScope ( scope ) ; BlockScope finallyScope = null ; if ( ( ( finallyBlock ) != null ) && ( ( finallyBlock . statements ) != null ) ) { finallyScope = new BlockScope ( scope , false ) ; MethodScope methodScope = scope . methodScope ( ) ; this . returnAddressVariable = new LocalVariableBinding ( TryStatement . SecretReturnName , upperScope . getJavaLangObject ( ) , AccDefault , false ) ; finallyScope . addLocalVariable ( returnAddressVariable ) ; this . returnAddressVariable . constant = NotAConstant ; this . subRoutineStartLabel = new Label ( ) ; this . anyExceptionVariable = new LocalVariableBinding ( TryStatement . SecretAnyHandlerName , scope . getJavaLangThrowable ( ) , AccDefault , false ) ; finallyScope . addLocalVariable ( this . anyExceptionVariable ) ; this . anyExceptionVariable . constant = NotAConstant ; if ( ! ( methodScope . isInsideInitializer ( ) ) ) { MethodBinding methodBinding = ( ( AbstractMethodDeclaration ) ( methodScope . referenceContext ) ) . binding ; if ( methodBinding != null ) { TypeBinding methodReturnType = methodBinding . returnType ; if ( ( methodReturnType . id ) != ( TypeIds . T_void ) ) { this . secretReturnValue = new LocalVariableBinding ( TryStatement . SecretLocalDeclarationName , methodReturnType , AccDefault , false ) ; finallyScope . addLocalVariable ( this . secretReturnValue ) ; this . secretReturnValue . constant = NotAConstant ; } } } finallyBlock . resolveUsing ( finallyScope ) ; finallyScope . shiftScopes = new BlockScope [ ( catchArguments ) == null ? 1 : ( catchArguments . length ) + 1 ] ; finallyScope . shiftScopes [ 0 ] = tryScope ; } this . tryBlock . resolveUsing ( tryScope ) ; if ( ( this . catchBlocks ) != null ) { int length = this . catchArguments . length ; TypeBinding [ ] argumentTypes = new TypeBinding [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { BlockScope catchScope = new BlockScope ( scope ) ; if ( finallyScope != null ) { finallyScope . shiftScopes [ ( i + 1 ) ] = catchScope ; } if ( ( argumentTypes [ i ] = catchArguments [ i ] . resolveForCatch ( catchScope ) ) == null ) return ; catchBlocks [ i ] . resolveUsing ( catchScope ) ; } this . caughtExceptionTypes = new ReferenceBinding [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { caughtExceptionTypes [ i ] = ( ( ReferenceBinding ) ( argumentTypes [ i ] ) ) ; for ( int j = 0 ; j < i ; j ++ ) { <START_BUG> if ( scope . areTypesCompatible ( caughtExceptionTypes [ i ] , argumentTypes [ j ] ) ) { <END_BUG> scope . problemReporter ( ) . wrongSequenceOfExceptionTypesError ( this , i , j ) ; } } } } else { caughtExceptionTypes = new ReferenceBinding [ 0 ] ; } if ( finallyScope != null ) { this . scope . addSubscope ( finallyScope ) ; } } public String toString ( int tab ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope blockScope ) { } } 
public final class SimilarityQueries { private SimilarityQueries ( ) { } public static Query formSimilarQuery ( String body , Analyzer a , String field , Set stop ) throws IOException { TokenStream ts = a . tokenStream ( field , new StringReader ( body ) ) ; Token t ; BooleanQuery tmp = new BooleanQuery ( ) ; Set already = new HashSet ( ) ; while ( ( t = ts . next ( ) ) != null ) { String word = t . termText ( ) ; if ( ( stop != null ) && ( stop . contains ( word ) ) ) continue ; if ( ! ( already . add ( word ) ) ) continue ; TermQuery tq = new TermQuery ( new Term ( field , word ) ) ; try { <START_BUG> tmp . add ( tq , false , false ) ; <END_BUG> } catch ( BooleanQuery too ) { break ; } } return tmp ; } } 
public class CompletionJavadoc extends Javadoc { Expression completionNode ; public CompletionJavadoc ( int sourceStart , int sourceEnd ) { } public Expression getCompletionNode ( ) { } private void internalResolve ( Scope scope ) { if ( ( this . completionNode ) != null ) { if ( ( this . completionNode ) instanceof CompletionOnJavadocTag ) { ( ( CompletionOnJavadocTag ) ( this . completionNode ) ) . filterPossibleTags ( scope ) ; } else { boolean resolve = true ; if ( ( this . completionNode ) instanceof CompletionOnJavadocParamNameReference ) { resolve = ( ( ( CompletionOnJavadocParamNameReference ) ( this . completionNode ) ) . token ) != null ; } else if ( ( this . completionNode ) instanceof CompletionOnJavadocTypeParamReference ) { resolve = ( ( ( CompletionOnJavadocTypeParamReference ) ( this . completionNode ) ) . token ) != null ; } if ( resolve ) { switch ( scope . kind ) { case Scope . CLASS_SCOPE : this . completionNode . resolveType ( ( ( ClassScope ) ( scope ) ) ) ; break ; case Scope . METHOD_SCOPE : this . completionNode . resolveType ( ( ( MethodScope ) ( scope ) ) ) ; break ; } } if ( ( this . completionNode ) instanceof CompletionOnJavadocParamNameReference ) { CompletionOnJavadocParamNameReference paramNameReference = ( ( CompletionOnJavadocParamNameReference ) ( this . completionNode ) ) ; if ( ( scope . kind ) == ( Scope . METHOD_SCOPE ) ) { paramNameReference . missingParams = missingParamTags ( paramNameReference . binding , ( ( MethodScope ) ( scope ) ) ) ; } <START_BUG> if ( ( paramNameReference . token ) == null ) { <END_BUG> paramNameReference . missingTypeParams = missingTypeParameterTags ( paramNameReference . binding , scope ) ; } } else if ( ( this . completionNode ) instanceof CompletionOnJavadocTypeParamReference ) { CompletionOnJavadocTypeParamReference typeParamReference = ( ( CompletionOnJavadocTypeParamReference ) ( this . completionNode ) ) ; typeParamReference . missingParams = missingTypeParameterTags ( typeParamReference . resolvedType , scope ) ; } } Binding qualifiedBinding = null ; if ( ( this . completionNode ) instanceof CompletionOnJavadocQualifiedTypeReference ) { CompletionOnJavadocQualifiedTypeReference typeRef = ( ( CompletionOnJavadocQualifiedTypeReference ) ( this . completionNode ) ) ; if ( ( typeRef . packageBinding ) == null ) { qualifiedBinding = typeRef . resolvedType ; } else { qualifiedBinding = typeRef . packageBinding ; } } else if ( ( this . completionNode ) instanceof CompletionOnJavadocMessageSend ) { CompletionOnJavadocMessageSend msg = ( ( CompletionOnJavadocMessageSend ) ( this . completionNode ) ) ; if ( ! ( msg . receiver . isThis ( ) ) ) qualifiedBinding = msg . receiver . resolvedType ; } else if ( ( this . completionNode ) instanceof CompletionOnJavadocAllocationExpression ) { CompletionOnJavadocAllocationExpression alloc = ( ( CompletionOnJavadocAllocationExpression ) ( this . completionNode ) ) ; qualifiedBinding = alloc . type . resolvedType ; } throw new CompletionNodeFound ( this . completionNode , qualifiedBinding , scope ) ; } } public StringBuffer print ( int indent , StringBuffer output ) { } public void resolve ( ClassScope scope ) { } public void resolve ( CompilationUnitScope scope ) { } public void resolve ( MethodScope scope ) { } private char [ ] [ ] missingParamTags ( Binding paramNameRefBinding , MethodScope methScope ) { } private char [ ] [ ] missingTypeParameterTags ( Binding paramNameRefBinding , Scope scope ) { } } 
final class EmbedBlob extends ConnectionChild implements Blob , EngineLOB { private boolean materialized ; private PositionedStoreStream myStream ; private int locator = 0 ; private long streamLength = - 1 ; private final int streamPositionOffset ; private boolean isValid = true ; private LOBStreamControl control ; EmbedBlob ( byte [ ] blobBytes , EmbedConnection con ) throws SQLException { } protected EmbedBlob ( DataValueDescriptor dvd , EmbedConnection con ) throws StandardException { } private long setBlobPosition ( long logicalPos ) throws IOException , StandardException { } private int read ( long pos ) throws IOException , StandardException { } public long length ( ) throws SQLException { } public byte [ ] getBytes ( long startPos , int length ) throws SQLException { } public InputStream getBinaryStream ( ) throws SQLException { } public long position ( byte [ ] pattern , long start ) throws SQLException { } private boolean checkMatch ( byte [ ] pattern , long pos ) throws IOException , StandardException { } public long position ( Blob pattern , long start ) throws SQLException { } private boolean checkMatch ( Blob pattern , long pos ) throws IOException , StandardException { } private SQLException handleMyExceptions ( Throwable t ) throws SQLException { } protected void finalize ( ) { } public int setBytes ( long pos , byte [ ] bytes ) throws SQLException { } public int setBytes ( long pos , byte [ ] bytes , int offset , int len ) throws SQLException { } public OutputStream setBinaryStream ( long pos ) throws SQLException { } public void truncate ( long len ) throws SQLException { } public void free ( ) throws SQLException { } public InputStream getBinaryStream ( long pos , long length ) throws SQLException { checkValidity ( ) ; if ( pos <= 0 ) { throw Util . generateCsSQLException ( BLOB_BAD_POSITION , new Long ( pos ) ) ; } if ( length < 0 ) { throw Util . generateCsSQLException ( BLOB_NONPOSITIVE_LENGTH , new Long ( length ) ) ; } <START_BUG> if ( length > ( ( this . length ( ) ) - pos ) ) { <END_BUG> throw Util . generateCsSQLException ( POS_AND_LENGTH_GREATER_THAN_LOB , new Long ( pos ) , new Long ( length ) ) ; } try { return new UpdatableBlobStream ( this , getBinaryStream ( ) , ( pos - 1 ) , length ) ; } catch ( IOException ioe ) { throw Util . setStreamFailure ( ioe ) ; } } private void checkValidity ( ) throws SQLException { } boolean isMaterialized ( ) { } public int getLocator ( ) { } } 
public abstract class RelationToManyTableFieldStrategy extends StoreCollectionFieldStrategy { private static final Localizer _loc = Localizer . forPackage ( RelationToManyTableFieldStrategy . class ) ; protected ClassMapping [ ] getIndependentElementMappings ( boolean traverse ) { } protected ForeignKey getJoinForeignKey ( ClassMapping elem ) { } protected void selectElement ( Select sel , ClassMapping elem , JDBCStore store , JDBCFetchConfiguration fetch , int eagerMode , Joins joins ) { } protected Object loadElement ( OpenJPAStateManager sm , JDBCStore store , JDBCFetchConfiguration fetch , Result res , Joins joins ) throws SQLException { } protected Joins join ( Joins joins , ClassMapping elem ) { } protected Joins joinElementRelation ( Joins joins , ClassMapping elem ) { } public void map ( boolean adapt ) { } public void insert ( OpenJPAStateManager sm , JDBCStore store , RowManager rm ) throws SQLException { } private void insert ( OpenJPAStateManager sm , RowManager rm , Object vals ) throws SQLException { Collection coll = toCollection ( vals ) ; if ( ( coll == null ) || ( coll . isEmpty ( ) ) ) return ; Row row = rm . getSecondaryRow ( field . getTable ( ) , ACTION_INSERT ) ; row . setForeignKey ( field . getJoinForeignKey ( ) , field . getJoinColumnIO ( ) , sm ) ; ValueMapping elem = field . getElementMapping ( ) ; StoreContext ctx = sm . getContext ( ) ; Column order = field . getOrderColumn ( ) ; boolean setOrder = field . getOrderColumnIO ( ) . isInsertable ( order , false ) ; <START_BUG> int idx = ( setOrder && ( order != null ) ) ? order . getBase ( ) : 0 ; <END_BUG> OpenJPAStateManager esm ; for ( Iterator itr = coll . iterator ( ) ; itr . hasNext ( ) ; idx ++ ) { esm = RelationStrategies . getStateManager ( itr . next ( ) , ctx ) ; elem . setForeignKey ( row , esm ) ; if ( setOrder ) row . setInt ( order , idx ) ; rm . flushSecondaryRow ( row ) ; } } public void update ( OpenJPAStateManager sm , JDBCStore store , RowManager rm ) throws SQLException { } public void delete ( OpenJPAStateManager sm , JDBCStore store , RowManager rm ) throws SQLException { } public Object toDataStoreValue ( Object val , JDBCStore store ) { } public Joins join ( Joins joins , boolean forceOuter ) { } public Joins joinRelation ( Joins joins , boolean forceOuter , boolean traverse ) { } } 
public void update ( ) { } void update ( boolean all ) { } void updateFont ( Font oldFont , Font newFont ) { } CREATESTRUCT widgetCreateStruct ( ) { } int widgetExtStyle ( ) { } int widgetParent ( ) { } int widgetStyle ( ) { } public boolean setParent ( Composite parent ) { } abstract TCHAR windowClass ( ) { } abstract int windowProc ( ) { } int windowProc ( int hwnd , int msg , int wParam , int lParam ) { } LRESULT WM_ACTIVATE ( int wParam , int lParam ) { } LRESULT WM_CHAR ( int wParam , int lParam ) { } LRESULT WM_CLEAR ( int wParam , int lParam ) { } LRESULT WM_CLOSE ( int wParam , int lParam ) { } LRESULT WM_COMMAND ( int wParam , int lParam ) { } LRESULT WM_CONTEXTMENU ( int wParam , int lParam ) { } LRESULT WM_CTLCOLOR ( int wParam , int lParam ) { } LRESULT WM_CUT ( int wParam , int lParam ) { } LRESULT WM_DESTROY ( int wParam , int lParam ) { } LRESULT WM_DRAWITEM ( int wParam , int lParam ) { } LRESULT WM_ENDSESSION ( int wParam , int lParam ) { } LRESULT WM_ENTERIDLE ( int wParam , int lParam ) { } LRESULT WM_ERASEBKGND ( int wParam , int lParam ) { } LRESULT WM_GETDLGCODE ( int wParam , int lParam ) { } LRESULT WM_GETFONT ( int wParam , int lParam ) { } LRESULT WM_GETOBJECT ( int wParam , int lParam ) { } LRESULT WM_GETMINMAXINFO ( int wParam , int lParam ) { } LRESULT WM_HOTKEY ( int wParam , int lParam ) { } LRESULT WM_HELP ( int wParam , int lParam ) { } LRESULT WM_HSCROLL ( int wParam , int lParam ) { } LRESULT WM_IME_CHAR ( int wParam , int lParam ) { } LRESULT WM_IME_COMPOSITION ( int wParam , int lParam ) { } LRESULT WM_INITMENUPOPUP ( int wParam , int lParam ) { } LRESULT WM_INPUTLANGCHANGE ( int wParam , int lParam ) { } LRESULT WM_KEYDOWN ( int wParam , int lParam ) { } LRESULT WM_KEYUP ( int wParam , int lParam ) { } LRESULT WM_KILLFOCUS ( int wParam , int lParam ) { } LRESULT WM_LBUTTONDBLCLK ( int wParam , int lParam ) { } LRESULT WM_LBUTTONDOWN ( int wParam , int lParam ) { } LRESULT WM_LBUTTONUP ( int wParam , int lParam ) { } LRESULT WM_MBUTTONDBLCLK ( int wParam , int lParam ) { } LRESULT WM_MBUTTONDOWN ( int wParam , int lParam ) { } LRESULT WM_MBUTTONUP ( int wParam , int lParam ) { } LRESULT WM_MEASUREITEM ( int wParam , int lParam ) { } LRESULT WM_MENUCHAR ( int wParam , int lParam ) { } LRESULT WM_MENUSELECT ( int wParam , int lParam ) { } LRESULT WM_MOUSEACTIVATE ( int wParam , int lParam ) { } LRESULT WM_MOUSEHOVER ( int wParam , int lParam ) { } LRESULT WM_MOUSELEAVE ( int wParam , int lParam ) { } LRESULT WM_MOUSEMOVE ( int wParam , int lParam ) { } LRESULT WM_MOUSEWHEEL ( int wParam , int lParam ) { } LRESULT WM_MOVE ( int wParam , int lParam ) { } LRESULT WM_NCACTIVATE ( int wParam , int lParam ) { } LRESULT WM_NCCALCSIZE ( int wParam , int lParam ) { } LRESULT WM_NCHITTEST ( int wParam , int lParam ) { } LRESULT WM_NCLBUTTONDOWN ( int wParam , int lParam ) { } LRESULT WM_NOTIFY ( int wParam , int lParam ) { } LRESULT WM_PAINT ( int wParam , int lParam ) { } LRESULT WM_PALETTECHANGED ( int wParam , int lParam ) { } LRESULT WM_PARENTNOTIFY ( int wParam , int lParam ) { } LRESULT WM_PASTE ( int wParam , int lParam ) { } LRESULT WM_PRINTCLIENT ( int wParam , int lParam ) { } LRESULT WM_QUERYENDSESSION ( int wParam , int lParam ) { } LRESULT WM_QUERYNEWPALETTE ( int wParam , int lParam ) { } LRESULT WM_QUERYOPEN ( int wParam , int lParam ) { } LRESULT WM_RBUTTONDBLCLK ( int wParam , int lParam ) { } LRESULT WM_RBUTTONDOWN ( int wParam , int lParam ) { } LRESULT WM_RBUTTONUP ( int wParam , int lParam ) { } LRESULT WM_SETCURSOR ( int wParam , int lParam ) { } LRESULT WM_SETFOCUS ( int wParam , int lParam ) { } LRESULT WM_SETTINGCHANGE ( int wParam , int lParam ) { } LRESULT WM_SETFONT ( int wParam , int lParam ) { } LRESULT WM_SETREDRAW ( int wParam , int lParam ) { } LRESULT WM_SHOWWINDOW ( int wParam , int lParam ) { } LRESULT WM_SIZE ( int wParam , int lParam ) { } LRESULT WM_SYSCHAR ( int wParam , int lParam ) { <START_BUG> return wmSysChar ( windowProc ( ) , handle , wParam , lParam ) ; <END_BUG> } LRESULT WM_SYSCOLORCHANGE ( int wParam , int lParam ) { } LRESULT WM_SYSCOMMAND ( int wParam , int lParam ) { } LRESULT WM_SYSKEYDOWN ( int wParam , int lParam ) { } LRESULT WM_SYSKEYUP ( int wParam , int lParam ) { } LRESULT WM_TIMER ( int wParam , int lParam ) { } LRESULT WM_UNDO ( int wParam , int lParam ) { } LRESULT WM_VSCROLL ( int wParam , int lParam ) { } LRESULT WM_WINDOWPOSCHANGED ( int wParam , int lParam ) { } LRESULT WM_WINDOWPOSCHANGING ( int wParam , int lParam ) { } LRESULT wmColorChild ( int wParam , int lParam ) { } LRESULT wmCommandChild ( int wParam , int lParam ) { } LRESULT wmDrawChild ( int wParam , int lParam ) { } LRESULT wmMeasureChild ( int wParam , int lParam ) { } LRESULT wmNotifyChild ( int wParam , int lParam ) { } LRESULT wmScrollChild ( int wParam , int lParam ) { } } 
public class RowTest { @ Test public void testDiffColumnFamily ( ) { } @ Test public void testDiffSuperColumn ( ) { SuperColumn sc1 = new SuperColumn ( "one" ) ; <START_BUG> sc1 . addColumn ( "subcolumn" , new Column ( "subcolumn" , "A" . getBytes ( ) , 0 ) ) ; <END_BUG> SuperColumn sc2 = new SuperColumn ( "one" ) ; sc2 . markForDeleteAt ( 0 , 0 ) ; SuperColumn scDiff = ( ( SuperColumn ) ( sc1 . diff ( sc2 ) ) ) ; assertEquals ( scDiff . getSubColumns ( ) . size ( ) , 0 ) ; assertEquals ( scDiff . getMarkedForDeleteAt ( ) , 0 ) ; } @ Test public void testRepair ( ) { } } 
public class TestBlockJoinSorter extends LuceneTestCase { private static class FixedBitSetCachingWrapperFilter extends CachingWrapperFilter { public FixedBitSetCachingWrapperFilter ( Filter filter ) { } @ Override protected DocIdSet cacheImpl ( DocIdSetIterator iterator , AtomicReader reader ) throws IOException { } } public void test ( ) throws IOException { final int numParents = atLeast ( 200 ) ; IndexWriterConfig cfg = newIndexWriterConfig ( TEST_VERSION_CURRENT , new org . apache . lucene . analysis . MockAnalyzer ( random ( ) ) ) ; cfg . setMergePolicy ( newLogMergePolicy ( ) ) ; final RandomIndexWriter writer = new RandomIndexWriter ( random ( ) , newDirectory ( ) , cfg ) ; final Document parentDoc = new Document ( ) ; final NumericDocValuesField parentVal = new NumericDocValuesField ( "parent_val" , 0L ) ; parentDoc . add ( parentVal ) ; final StringField parent = new StringField ( "parent" , "true" , Store . YES ) ; parentDoc . add ( parent ) ; for ( int i = 0 ; i < numParents ; ++ i ) { List < Document > documents = new ArrayList < > ( ) ; final int numChildren = random ( ) . nextInt ( 10 ) ; for ( int j = 0 ; j < numChildren ; ++ j ) { final Document childDoc = new Document ( ) ; childDoc . add ( new NumericDocValuesField ( "child_val" , random ( ) . nextInt ( 5 ) ) ) ; documents . add ( childDoc ) ; } parentVal . setLongValue ( random ( ) . nextInt ( 50 ) ) ; documents . add ( parentDoc ) ; writer . addDocuments ( documents ) ; } writer . forceMerge ( 1 ) ; final DirectoryReader indexReader = writer . getReader ( ) ; <START_BUG> writer . close ( ) ; <END_BUG> final AtomicReader reader = getOnlySegmentReader ( indexReader ) ; final Filter parentsFilter = new TestBlockJoinSorter . FixedBitSetCachingWrapperFilter ( new QueryWrapperFilter ( new org . apache . lucene . search . TermQuery ( new Term ( "parent" , "true" ) ) ) ) ; final FixedBitSet parentBits = ( ( FixedBitSet ) ( parentsFilter . getDocIdSet ( reader . getContext ( ) , null ) ) ) ; final NumericDocValues parentValues = reader . getNumericDocValues ( "parent_val" ) ; final NumericDocValues childValues = reader . getNumericDocValues ( "child_val" ) ; final Sort parentSort = new Sort ( new SortField ( "parent_val" , Type . LONG ) ) ; final Sort childSort = new Sort ( new SortField ( "child_val" , Type . LONG ) ) ; final Sort sort = new Sort ( new SortField ( "custom" , new BlockJoinComparatorSource ( parentsFilter , parentSort , childSort ) ) ) ; final Sorter sorter = new Sorter ( sort ) ; final Sorter . DocMap docMap = sorter . sort ( reader ) ; assertEquals ( reader . maxDoc ( ) , docMap . size ( ) ) ; int [ ] children = new int [ 1 ] ; int numChildren = 0 ; int previousParent = - 1 ; for ( int i = 0 ; i < ( docMap . size ( ) ) ; ++ i ) { final int oldID = docMap . newToOld ( i ) ; if ( parentBits . get ( oldID ) ) { for ( int j = 0 ; j < numChildren ; ++ j ) { assertEquals ( oldID , parentBits . nextSetBit ( children [ j ] ) ) ; } for ( int j = 1 ; j < numChildren ; ++ j ) { final int doc1 = children [ ( j - 1 ) ] ; final int doc2 = children [ j ] ; if ( ( childValues . get ( doc1 ) ) == ( childValues . get ( doc2 ) ) ) { assertTrue ( ( doc1 < doc2 ) ) ; } else { assertTrue ( ( ( childValues . get ( doc1 ) ) < ( childValues . get ( doc2 ) ) ) ) ; } } if ( previousParent != ( - 1 ) ) { if ( ( parentValues . get ( previousParent ) ) == ( parentValues . get ( oldID ) ) ) { assertTrue ( ( previousParent < oldID ) ) ; } else { assertTrue ( ( ( parentValues . get ( previousParent ) ) < ( parentValues . get ( oldID ) ) ) ) ; } } previousParent = oldID ; numChildren = 0 ; } else { children = ArrayUtil . grow ( children , ( numChildren + 1 ) ) ; children [ ( numChildren ++ ) ] = oldID ; } } indexReader . close ( ) ; writer . w . getDirectory ( ) . close ( ) ; } } 
public class TestSameScoresWithThreads extends LuceneTestCase { public void test ( ) throws Exception { final Directory dir = newDirectory ( ) ; MockAnalyzer analyzer = new MockAnalyzer ( random ( ) ) ; analyzer . setMaxTokenLength ( TestUtil . nextInt ( random ( ) , 1 , MAX_TERM_LENGTH ) ) ; final RandomIndexWriter w = new RandomIndexWriter ( random ( ) , dir , analyzer ) ; LineFileDocs docs = new LineFileDocs ( random ( ) ) ; int charsToIndex = atLeast ( 100000 ) ; int charsIndexed = 0 ; while ( charsIndexed < charsToIndex ) { Document doc = docs . nextDoc ( ) ; charsIndexed += doc . get ( "body" ) . length ( ) ; w . addDocument ( doc ) ; } IndexReader r = w . getReader ( ) ; <START_BUG> w . close ( ) ; <END_BUG> final IndexSearcher s = newSearcher ( r ) ; Terms terms = org . apache . lucene . index . MultiFields . getFields ( r ) . terms ( "body" ) ; int termCount = 0 ; TermsEnum termsEnum = terms . iterator ( null ) ; while ( ( termsEnum . next ( ) ) != null ) { termCount ++ ; } assertTrue ( ( termCount > 0 ) ) ; double chance = 10.0 / termCount ; termsEnum = terms . iterator ( termsEnum ) ; final Map < BytesRef , TopDocs > answers = new HashMap < > ( ) ; while ( ( termsEnum . next ( ) ) != null ) { if ( ( random ( ) . nextDouble ( ) ) <= chance ) { BytesRef term = BytesRef . deepCopyOf ( termsEnum . term ( ) ) ; answers . put ( term , s . search ( new TermQuery ( new org . apache . lucene . index . Term ( "body" , term ) ) , 100 ) ) ; } } if ( ! ( answers . isEmpty ( ) ) ) { final CountDownLatch startingGun = new CountDownLatch ( 1 ) ; int numThreads = TestUtil . nextInt ( random ( ) , 2 , 5 ) ; Thread [ ] threads = new Thread [ numThreads ] ; for ( int threadID = 0 ; threadID < numThreads ; threadID ++ ) { Thread thread = new Thread ( ) { @ Override public void run ( ) { try { startingGun . await ( ) ; for ( int i = 0 ; i < 20 ; i ++ ) { List < Map . Entry < BytesRef , TopDocs > > shuffled = new java . util . ArrayList ( answers . entrySet ( ) ) ; Collections . shuffle ( shuffled ) ; for ( Map . Entry < BytesRef , TopDocs > ent : shuffled ) { TopDocs actual = s . search ( new TermQuery ( new org . apache . lucene . index . Term ( "body" , ent . getKey ( ) ) ) , 100 ) ; TopDocs expected = ent . getValue ( ) ; assertEquals ( expected . totalHits , actual . totalHits ) ; assertEquals ( ( "query=" + ( ent . getKey ( ) . utf8ToString ( ) ) ) , expected . scoreDocs . length , actual . scoreDocs . length ) ; for ( int hit = 0 ; hit < ( expected . scoreDocs . length ) ; hit ++ ) { assertEquals ( expected . scoreDocs [ hit ] . doc , actual . scoreDocs [ hit ] . doc ) ; assertTrue ( ( ( expected . scoreDocs [ hit ] . score ) == ( actual . scoreDocs [ hit ] . score ) ) ) ; } } } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } ; threads [ threadID ] = thread ; thread . start ( ) ; } startingGun . countDown ( ) ; for ( Thread thread : threads ) { thread . join ( ) ; } } r . close ( ) ; dir . close ( ) ; } } 
class ClipboardProxy { Display display ; int shellHandle ; int atomAtom ; int clipboardAtom ; int motifClipboardAtom ; int primaryAtom ; int targetsAtom ; int [ ] [ ] convertData = new int [ 10 ] [ 3 ] ; Clipboard activeClipboard = null ; Clipboard activePrimaryClipboard = null ; Object [ ] clipboardData ; Transfer [ ] clipboardDataTypes ; Object [ ] primaryClipboardData ; Transfer [ ] primaryClipboardDataTypes ; boolean done = false ; Object selectionValue ; Transfer selectionTransfer ; Callback XtConvertSelectionCallback ; Callback XtLoseSelectionCallback ; Callback XtSelectionDoneCallback ; Callback XtSelectionCallbackCallback ; static byte [ ] ATOM = Converter . wcsToMbcs ( null , "ATOM" , true ) ; static byte [ ] CLIPBOARD = Converter . wcsToMbcs ( null , "CLIPBOARD" , true ) ; static byte [ ] PRIMARY = Converter . wcsToMbcs ( null , "PRIMARY" , true ) ; static byte [ ] TARGETS = Converter . wcsToMbcs ( null , "TARGETS" , true ) ; static byte [ ] _MOTIF_CLIPBOARD_TARGETS = Converter . wcsToMbcs ( null , "_MOTIF_CLIPBOARD_TARGETS" , true ) ; static String ID = "CLIPBOARD<seq2seq4repair_space>PROXY<seq2seq4repair_space>OBJECT" ; static ClipboardProxy _getInstance ( final Display display ) { } ClipboardProxy ( Display display ) { } void clear ( Clipboard owner , int clipboards ) { } void dispose ( ) { } Object getContents ( Transfer transfer , int clipboardType ) { } int [ ] getAvailableTypes ( int clipboardType ) { } void setContents ( Clipboard owner , Object [ ] data , Transfer [ ] dataTypes , int clipboards ) { } void storePtr ( int ptr , int selection , int target ) { int index = - 1 ; for ( int i = 0 ; i < ( convertData . length ) ; i ++ ) { if ( ( convertData [ i ] [ 0 ] ) == 0 ) { index = i ; break ; } } if ( index == ( - 1 ) ) { <START_BUG> int [ ] [ ] newConvertData = new int [ convertData . length ] [ 3 ] ; <END_BUG> System . arraycopy ( convertData , 0 , newConvertData , 0 , convertData . length ) ; index = convertData . length ; convertData = newConvertData ; } convertData [ index ] [ 0 ] = selection ; convertData [ index ] [ 1 ] = target ; convertData [ index ] [ 2 ] = ptr ; } void wait ( int timeout ) { } int checkEvent ( int display , int event , int arg ) { } int XtConvertSelection ( int widget , int selection , int target , int type , int value , int length , int format ) { } int XtLoseSelection ( int widget , int selection ) { } int XtSelectionCallback ( int widget , int client_data , int selection , int type , int value , int length , int format ) { } int XtSelectionDone ( int widget , int selection , int target ) { } } 
public class AjaxTimerBehaviorTest extends WicketTestCase { private static final Logger log = LoggerFactory . getLogger ( AjaxTimerBehaviorTest . class ) ; public void testAddToAjaxUpdate ( ) { } public void testAddToWebPage ( ) { Duration dur = Duration . seconds ( 20 ) ; final AjaxTimerBehaviorTest . MyAjaxSelfUpdatingTimerBehavior timer = new AjaxTimerBehaviorTest . MyAjaxSelfUpdatingTimerBehavior ( dur ) ; final MockPageWithLinkAndComponent page = new MockPageWithLinkAndComponent ( ) ; Label label = new Label ( MockPageWithLinkAndComponent . COMPONENT_ID , "Hello" ) ; page . add ( label ) ; <START_BUG> page . add ( new Link ( MockPageWithLinkAndComponent . LINK_ID ) { <END_BUG> private static final long serialVersionUID = 1L ; @ Override public void onClick ( ) { } } ) ; label . setOutputMarkupId ( true ) ; label . add ( timer ) ; tester . startPage ( page ) ; validate ( timer , true ) ; tester . clickLink ( LINK_ID ) ; validate ( timer , true ) ; } private void validate ( AjaxTimerBehaviorTest . MyAjaxSelfUpdatingTimerBehavior timer , boolean inBodyOnLoad ) { } private void validateTimerScript ( String document , String updateScript ) { } private static final String quote ( String s ) { } static class MyAjaxSelfUpdatingTimerBehavior extends AjaxSelfUpdatingTimerBehavior { private static final long serialVersionUID = 1L ; private final Duration duration ; String updateScript ; public MyAjaxSelfUpdatingTimerBehavior ( Duration updateInterval ) { } @ Override protected void onComponentRendered ( ) { } public String getUpdateScript ( ) { } } } 
public final class ScheduledThreadPoolAdd extends AbstractExecutorAdd { private static final long serialVersionUID = 5597662601486525937L ; public ScheduledThreadPoolAdd ( final String name , final ScaledCount maxThreads ) { } @ Override protected < P > void applyUpdate ( final UpdateContext updateContext , final UpdateResultHandler < ? super Void , P > handler , final P param ) { <START_BUG> final BatchBuilder builder = updateContext . getBatchBuilder ( ) ; <END_BUG> final ScaledCount maxThreadsCount = getMaxThreads ( ) ; final int maxThreads = maxThreadsCount . getScaledCount ( ) ; final String name = getName ( ) ; final ServiceName serviceName = ThreadsServices . executorName ( name ) ; final UnboundedQueueThreadPoolService service = new UnboundedQueueThreadPoolService ( maxThreads , getKeepaliveTime ( ) ) ; final ServiceBuilder < ExecutorService > serviceBuilder = builder . addService ( serviceName , service ) ; addThreadFactoryDependency ( serviceName , serviceBuilder , service . getThreadFactoryInjector ( ) , builder ) ; serviceBuilder . install ( ) ; } @ Override protected void applyUpdate ( final ThreadsSubsystemElement element ) throws UpdateFailedException { } } 
public class GeneralTopologyContext implements JSONAware { private StormTopology _topology ; private Map < Integer , String > _taskToComponent ; private Map < String , List < Integer > > _componentToTasks ; private Map < String , Map < String , Fields > > _componentToStreamToFields ; private String _stormId ; protected Map _stormConf ; public GeneralTopologyContext ( StormTopology topology , Map stormConf , Map < Integer , String > taskToComponent , Map < String , List < Integer > > componentToSortedTasks , Map < String , Map < String , Fields > > componentToStreamToFields , String stormId ) { } public String getStormId ( ) { } public StormTopology getRawTopology ( ) { } public String getComponentId ( int taskId ) { <START_BUG> if ( taskId == ( Constants . SYSTEM_TASK_ID ) ) { <END_BUG> return Constants . SYSTEM_COMPONENT_ID ; } else { return _taskToComponent . get ( taskId ) ; } } public Set < String > getComponentStreams ( String componentId ) { } public List < Integer > getComponentTasks ( String componentId ) { } public Fields getComponentOutputFields ( String componentId , String streamId ) { } public Fields getComponentOutputFields ( GlobalStreamId id ) { } public Map < GlobalStreamId , Grouping > getSources ( String componentId ) { } public Map < String , Map < String , Grouping > > getTargets ( String componentId ) { } @ Override public String toJSONString ( ) { } public Map < Integer , String > getTaskToComponent ( ) { } public Set < String > getComponentIds ( ) { } public ComponentCommon getComponentCommon ( String componentId ) { } public int maxTopologyMessageTimeout ( ) { } } 
public class ResourceLink extends Link implements IResourceListener { private static final long serialVersionUID = 1L ; private final ResourceReference resourceReference ; private final Resource resource ; public ResourceLink ( final String id , final ResourceReference resourceReference ) { } public ResourceLink ( final String id , final Resource resource ) { } public void onClick ( ) { } protected final String getURL ( ) { if ( ( resourceReference ) != null ) { resourceReference . setLocale ( getLocale ( ) ) ; resourceReference . setStyle ( getStyle ( ) ) ; resourceReference . bind ( getApplication ( ) ) ; return getRequestCycle ( ) . urlFor ( resourceReference ) ; } <START_BUG> return urlFor ( IResourceListener . class ) ; <END_BUG> } public final void onResourceRequested ( ) { } } 
public class PersistenceProviderImpl implements PersistenceProvider , ProviderUtil { static final String CLASS_TRANSFORMER_OPTIONS = "ClassTransformerOptions" ; private static final String EMF_POOL = "EntityManagerFactoryPool" ; private static final Localizer _loc = Localizer . forPackage ( PersistenceProviderImpl . class ) ; private Log _log ; public OpenJPAEntityManagerFactory createEntityManagerFactory ( String name , String resource , Map m ) { } private BrokerFactory getBrokerFactory ( ConfigurationProvider cp , Object poolValue , ClassLoader loader ) { } public OpenJPAEntityManagerFactory createEntityManagerFactory ( String name , Map m ) { } public OpenJPAEntityManagerFactory createContainerEntityManagerFactory ( PersistenceUnitInfo pui , Map m ) { PersistenceProductDerivation pd = new PersistenceProductDerivation ( ) ; try { Object poolValue = Configurations . removeProperty ( PersistenceProviderImpl . EMF_POOL , m ) ; ConfigurationProvider cp = pd . load ( pui , m ) ; if ( cp == null ) return null ; Exception transformerException = null ; String ctOpts = ( ( String ) ( Configurations . getProperty ( PersistenceProviderImpl . CLASS_TRANSFORMER_OPTIONS , pui . getProperties ( ) ) ) ) ; try { pui . addTransformer ( new PersistenceProviderImpl . ClassTransformerImpl ( cp , ctOpts , pui . getNewTempClassLoader ( ) , newConfigurationImpl ( ) ) ) ; } catch ( Exception e ) { transformerException = e ; } if ( ! ( Configurations . containsProperty ( KEY , cp . getProperties ( ) ) ) ) { cp . addProperty ( ( "openjpa." + ( BrokerValue . KEY ) ) , getDefaultBrokerAlias ( ) ) ; } BrokerFactory factory = getBrokerFactory ( cp , poolValue , pui . getClassLoader ( ) ) ; if ( transformerException != null ) { Log log = factory . getConfiguration ( ) . getLog ( LOG_RUNTIME ) ; if ( log . isTraceEnabled ( ) ) { log . warn ( PersistenceProviderImpl . _loc . get ( "transformer-registration-error-ex" , pui ) , transformerException ) ; } else { log . warn ( PersistenceProviderImpl . _loc . get ( "transformer-registration-error" , pui ) ) ; } } OpenJPAConfiguration conf = factory . getConfiguration ( ) ; _log = conf . getLog ( LOG_RUNTIME ) ; loadValidator ( _log , conf ) ; Options o = Configurations . parseProperties ( Configurations . getProperties ( "openjpa.MetaDataRepository" ) ) ; if ( o . getBooleanProperty ( "Preload" ) ) { <START_BUG> conf . getAbstractBrokerFactoryInstance ( ) . preload ( ) ; <END_BUG> } return JPAFacadeHelper . toEntityManagerFactory ( factory ) ; } catch ( Exception e ) { throw PersistenceExceptions . toPersistenceException ( e ) ; } } public ProviderUtil getProviderUtil ( ) { } protected String getDefaultBrokerAlias ( ) { } protected OpenJPAConfiguration newConfigurationImpl ( ) { } private static class ClassTransformerImpl implements ClassTransformer { private final ClassFileTransformer _trans ; private ClassTransformerImpl ( ConfigurationProvider cp , String props , final ClassLoader tmpLoader , OpenJPAConfiguration conf ) { } public byte [ ] transform ( ClassLoader cl , String name , Class < ? > previousVersion , ProtectionDomain pd , byte [ ] bytes ) throws IllegalClassFormatException { } } private void loadAgent ( Log log , OpenJPAConfiguration conf ) { } private void loadValidator ( Log log , OpenJPAConfiguration conf ) { } public LoadState isLoaded ( Object obj ) { } public LoadState isLoadedWithReference ( Object obj , String attr ) { } public LoadState isLoadedWithoutReference ( Object obj , String attr ) { } } 
public class EudoraMailImportFilter extends AbstractMailboxImporter { private static final Logger LOG = Logger . getLogger ( "org.columba.mail" ) ; private static final String TIME_ZONE = new SimpleDateFormat ( "Z" ) . format ( new Date ( ) ) ; private static final String DEFAULT_CHARSET = System . getProperty ( "file.encoding" ) ; public EudoraMailImportFilter ( ) { } public EudoraMailImportFilter ( IMailbox destinationFolder , File [ ] sourceFiles ) { } public int getType ( ) { } public String getDescription ( ) { } public void importMailboxFile ( File file , IWorkerStatusController worker , IMailbox destFolder ) throws Exception { } private String getNewDateHeader ( String dateStr , String timeZone ) { } private boolean convertAndSaveMessage ( String msg , String replacementDate , IWorkerStatusController worker , IMailbox destFolder ) { String [ ] divided = divideMessage ( msg ) ; if ( divided == null ) { EudoraMailImportFilter . LOG . severe ( "Error<seq2seq4repair_space>splitting<seq2seq4repair_space>message<seq2seq4repair_space>into<seq2seq4repair_space>headers<seq2seq4repair_space>and<seq2seq4repair_space>body" ) ; return false ; } String headers = divided [ 0 ] ; String body = divided [ 1 ] ; HeaderTokenizer tokenizer = new HeaderTokenizer ( headers ) ; EncodedWord decoder = new EncodedWord ( ) ; StringBuffer headerBuf = new StringBuffer ( ) ; boolean dateFound = false ; boolean contentTypeFound = false ; String line = tokenizer . nextLine ( ) ; while ( line != null ) { if ( ( line . indexOf ( ':' ) ) != ( - 1 ) ) { String key = line . substring ( 0 , line . indexOf ( ':' ) ) ; <START_BUG> String header = decoder . decode ( ( ( CharSequence ) ( line . substring ( ( ( line . indexOf ( ':' ) ) + 1 ) ) . trim ( ) ) ) ) . toString ( ) ; <END_BUG> if ( key . equalsIgnoreCase ( "Date" ) ) { dateFound = true ; } else if ( key . equalsIgnoreCase ( "Content-Type" ) ) { contentTypeFound = true ; ContentType conType = new ContentType ( header ) ; if ( ( conType . getType ( ) . equalsIgnoreCase ( "multipart" ) ) && ( ( body . indexOf ( ( "--" + ( conType . getBoundary ( ) ) ) ) ) == ( - 1 ) ) ) { if ( conType . getSubType ( ) . equalsIgnoreCase ( "alternative" ) ) { header = guessBodyContentType ( body ) ; EudoraMailImportFilter . LOG . fine ( ( "Content-Type:<seq2seq4repair_space>multipart/alternative<seq2seq4repair_space>replaced<seq2seq4repair_space>with<seq2seq4repair_space>" + header ) ) ; } else { String [ ] split = createAttachmentListFromAttachmentConverted ( body ) ; if ( ( split == null ) || ( ( split . length ) == 1 ) ) { header = guessBodyContentType ( body ) ; EudoraMailImportFilter . LOG . fine ( ( ( ( "Content-Type:<seq2seq4repair_space>multipart/" + ( conType . getSubType ( ) ) ) + "<seq2seq4repair_space>replaced<seq2seq4repair_space>by<seq2seq4repair_space>" ) + header ) ) ; } else { header = "multipart/mixed;\n\tboundary=" + ( conType . getBoundary ( ) ) ; body = createBodyFromParts ( split , conType . getBoundary ( ) ) ; EudoraMailImportFilter . LOG . fine ( "Content-Type:<seq2seq4repair_space>multipart/mixed.<seq2seq4repair_space>Boundaries<seq2seq4repair_space>added<seq2seq4repair_space>to<seq2seq4repair_space>msg<seq2seq4repair_space>body" ) ; } } } } else if ( key . equalsIgnoreCase ( "X-Attachments" ) ) { if ( ( header . length ( ) ) > 0 ) { String [ ] split = createAttachmentListFromHeader ( body , header ) ; if ( ( split == null ) || ( ( split . length ) == 1 ) ) { headerBuf . append ( "MIME-Version:<seq2seq4repair_space>1.0\n" ) ; key = "Content-Type" ; header = guessBodyContentType ( body ) ; contentTypeFound = true ; EudoraMailImportFilter . LOG . fine ( ( "X-Attachments<seq2seq4repair_space>header<seq2seq4repair_space>replaced<seq2seq4repair_space>by<seq2seq4repair_space>Content-Type:<seq2seq4repair_space>" + header ) ) ; } else { String unique = getUniqueBoundary ( body ) ; headerBuf . append ( "MIME-Version:<seq2seq4repair_space>1.0\n" ) ; key = "Content-Type" ; header = "multipart/mixed;\n\tboundary=" + unique ; contentTypeFound = true ; body = createBodyFromParts ( split , unique ) ; EudoraMailImportFilter . LOG . fine ( "X-Attachments<seq2seq4repair_space>header<seq2seq4repair_space>replaced<seq2seq4repair_space>by<seq2seq4repair_space>Content-Type:<seq2seq4repair_space>multipart/mixed" ) ; } } } headerBuf . append ( ( ( ( key + ":<seq2seq4repair_space>" ) + header ) + "\n" ) ) ; } line = tokenizer . nextLine ( ) ; } if ( ! dateFound ) { EudoraMailImportFilter . LOG . fine ( "Date<seq2seq4repair_space>header<seq2seq4repair_space>missing<seq2seq4repair_space>-<seq2seq4repair_space>constructing<seq2seq4repair_space>new<seq2seq4repair_space>one" ) ; String dateHeader = getNewDateHeader ( replacementDate , EudoraMailImportFilter . TIME_ZONE ) ; if ( dateHeader != null ) headerBuf . append ( ( dateHeader + "\n" ) ) ; } if ( ! contentTypeFound ) { EudoraMailImportFilter . LOG . fine ( "Content-Type<seq2seq4repair_space>header<seq2seq4repair_space>missing<seq2seq4repair_space>-<seq2seq4repair_space>constructing<seq2seq4repair_space>new<seq2seq4repair_space>one" ) ; String contHeader = "Content-Type:<seq2seq4repair_space>" + ( guessBodyContentType ( body ) ) ; headerBuf . append ( "MIME-Version:<seq2seq4repair_space>1.0\n" ) ; headerBuf . append ( ( contHeader + "\n" ) ) ; } return saveMessage ( headerBuf . toString ( ) , body , worker , destFolder ) ; } private boolean saveMessage ( String headers , String body , IWorkerStatusController worker , IMailbox destFolder ) { } private String createBodyFromParts ( String [ ] parts , String boundary ) { } private String getUniqueBoundary ( String body ) { } private String [ ] divideMessage ( String input ) { } private String guessBodyContentType ( String body ) { } private String [ ] createAttachmentListFromHeader ( String body , String xAttachments ) { } private String [ ] createAttachmentListFromAttachmentConverted ( String body ) { } } 
public class NSText extends NSView { public NSText ( ) { } public NSText ( int id ) { } public static int static_class ( ) { } public NSData RTFDFromRange ( NSRange range ) { } public NSData RTFFromRange ( NSRange range ) { } public void alignCenter ( id sender ) { } public void alignLeft ( id sender ) { } public void alignRight ( id sender ) { } public int alignment ( ) { } public NSColor backgroundColor ( ) { } public int baseWritingDirection ( ) { } public void changeFont ( id sender ) { } public void checkSpelling ( id sender ) { } public void copy ( id sender ) { } public void copyFont ( id sender ) { } public void copyRuler ( id sender ) { } public void cut ( id sender ) { } public id delegate ( ) { } public void delete ( id sender ) { } public boolean drawsBackground ( ) { } public NSFont font ( ) { } public boolean importsGraphics ( ) { } public boolean isEditable ( ) { } public boolean isFieldEditor ( ) { } public boolean isHorizontallyResizable ( ) { } public boolean isRichText ( ) { } public boolean isRulerVisible ( ) { } public boolean isSelectable ( ) { } public boolean isVerticallyResizable ( ) { } public NSSize maxSize ( ) { } public NSSize minSize ( ) { } public void paste ( id sender ) { } public void pasteFont ( id sender ) { } public void pasteRuler ( id sender ) { } public boolean readRTFDFromFile ( NSString path ) { } public void replaceCharactersInRange_withRTF_ ( NSRange range , NSData rtfData ) { } public void replaceCharactersInRange_withRTFD_ ( NSRange range , NSData rtfdData ) { } public void replaceCharactersInRange_withString_ ( NSRange range , NSString aString ) { } public void scrollRangeToVisible ( NSRange range ) { } public void selectAll ( id sender ) { } public NSRange selectedRange ( ) { NSRange result = new NSRange ( ) ; <START_BUG> OS . objc_msgSend_struct ( result , this . id , sel_selectedRange ) ; <END_BUG> return result ; } public void setAlignment ( int mode ) { } public void setBackgroundColor ( NSColor color ) { } public void setBaseWritingDirection ( int writingDirection ) { } public void setDelegate ( id anObject ) { } public void setDrawsBackground ( boolean flag ) { } public void setEditable ( boolean flag ) { } public void setFieldEditor ( boolean flag ) { } public void setFont_ ( NSFont obj ) { } public void setFont_range_ ( NSFont font , NSRange range ) { } public void setHorizontallyResizable ( boolean flag ) { } public void setImportsGraphics ( boolean flag ) { } public void setMaxSize ( NSSize newMaxSize ) { } public void setMinSize ( NSSize newMinSize ) { } public void setRichText ( boolean flag ) { } public void setSelectable ( boolean flag ) { } public void setSelectedRange ( NSRange range ) { } public void setString ( NSString string ) { } public void setTextColor_ ( NSColor color ) { } public void setTextColor_range_ ( NSColor color , NSRange range ) { } public void setUsesFontPanel ( boolean flag ) { } public void setVerticallyResizable ( boolean flag ) { } public void showGuessPanel ( id sender ) { } public void sizeToFit ( ) { } public NSString string ( ) { } public void subscript ( id sender ) { } public void superscript ( id sender ) { } public NSColor textColor ( ) { } public void toggleRuler ( id sender ) { } public void underline ( id sender ) { } public void unscript ( id sender ) { } public boolean usesFontPanel ( ) { } public boolean writeRTFDToFile ( NSString path , boolean flag ) { } } 
public class JoinDocFreqValueSource extends FieldCacheSource { public static final String NAME = "joindf" ; protected final String qfield ; public JoinDocFreqValueSource ( String field , String qfield ) { } @ Override public String description ( ) { } @ Override public FunctionValues getValues ( Map context , AtomicReaderContext readerContext ) throws IOException { <START_BUG> final BinaryDocValues terms = cache . getTerms ( readerContext . reader ( ) , field , FAST ) ; <END_BUG> final IndexReader top = ReaderUtil . getTopLevelContext ( readerContext ) . reader ( ) ; Terms t = MultiFields . getTerms ( top , qfield ) ; final TermsEnum termsEnum = ( t == null ) ? TermsEnum . EMPTY : t . iterator ( null ) ; return new IntDocValues ( this ) { final BytesRef ref = new BytesRef ( ) ; @ Override public int intVal ( int doc ) { try { terms . get ( doc , ref ) ; if ( termsEnum . seekExact ( ref ) ) { return termsEnum . docFreq ( ) ; } else { return 0 ; } } catch ( IOException e ) { throw new RuntimeException ( ( ( ( "caught<seq2seq4repair_space>exception<seq2seq4repair_space>in<seq2seq4repair_space>function<seq2seq4repair_space>" + ( description ( ) ) ) + "<seq2seq4repair_space>:<seq2seq4repair_space>doc=" ) + doc ) , e ) ; } } } ; } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } } 
public class ExceptionHandlerExceptionResolver extends AbstractHandlerMethodExceptionResolver implements InitializingBean { private List < HandlerMethodArgumentResolver > customArgumentResolvers ; private List < HandlerMethodReturnValueHandler > customReturnValueHandlers ; private List < HttpMessageConverter < ? > > messageConverters ; private final Map < Class < ? > , ExceptionHandlerMethodResolver > exceptionHandlerMethodResolvers = new ConcurrentHashMap < Class < ? > , ExceptionHandlerMethodResolver > ( ) ; private HandlerMethodArgumentResolverComposite argumentResolvers ; private HandlerMethodReturnValueHandlerComposite returnValueHandlers ; public ExceptionHandlerExceptionResolver ( ) { } public void setCustomArgumentResolvers ( List < HandlerMethodArgumentResolver > argumentResolvers ) { } public void setArgumentResolvers ( List < HandlerMethodArgumentResolver > argumentResolvers ) { } public void setCustomReturnValueHandlers ( List < HandlerMethodReturnValueHandler > returnValueHandlers ) { } public void setReturnValueHandlers ( List < HandlerMethodReturnValueHandler > returnValueHandlers ) { } public void setMessageConverters ( List < HttpMessageConverter < ? > > messageConverters ) { } public void afterPropertiesSet ( ) { } public static List < HandlerMethodArgumentResolver > getDefaultArgumentResolvers ( ) { } public static List < HandlerMethodReturnValueHandler > getDefaultReturnValueHandlers ( List < HttpMessageConverter < ? > > messageConverters ) { } @ Override protected ModelAndView doResolveHandlerMethodException ( HttpServletRequest request , HttpServletResponse response , HandlerMethod handlerMethod , Exception exception ) { if ( handlerMethod == null ) { return null ; } ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod ( handlerMethod , exception ) ; if ( exceptionHandlerMethod == null ) { return null ; } exceptionHandlerMethod . setHandlerMethodArgumentResolvers ( this . argumentResolvers ) ; exceptionHandlerMethod . setHandlerMethodReturnValueHandlers ( this . returnValueHandlers ) ; ServletWebRequest webRequest = new ServletWebRequest ( request , response ) ; ModelAndViewContainer mavContainer = new ModelAndViewContainer ( ) ; try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( ( "Invoking<seq2seq4repair_space>@ExceptionHandler<seq2seq4repair_space>method:<seq2seq4repair_space>" + exceptionHandlerMethod ) ) ; } exceptionHandlerMethod . invokeAndHandle ( webRequest , mavContainer , exception ) ; } catch ( Exception invocationEx ) { logger . error ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>invoke<seq2seq4repair_space>@ExceptionHandler<seq2seq4repair_space>method:<seq2seq4repair_space>" + exceptionHandlerMethod ) , invocationEx ) ; return null ; } <START_BUG> if ( ! ( mavContainer . isResolveView ( ) ) ) { <END_BUG> return new ModelAndView ( ) ; } else { ModelAndView mav = new ModelAndView ( ) . addAllObjects ( mavContainer . getModel ( ) ) ; mav . setViewName ( mavContainer . getViewName ( ) ) ; if ( ! ( mavContainer . isViewReference ( ) ) ) { mav . setView ( ( ( View ) ( mavContainer . getView ( ) ) ) ) ; } return mav ; } } protected ServletInvocableHandlerMethod getExceptionHandlerMethod ( HandlerMethod handlerMethod , Exception exception ) { } private ExceptionHandlerMethodResolver getExceptionHandlerMethodResolver ( Class < ? > handlerType ) { } } 
public class ProjectBrowser extends JFrame implements IStatusBar { public static ProjectBrowser TheInstance ; protected static Action _actionNew = Actions . New ; protected static Action _actionOpen = Actions . Open ; protected static Action _actionSave = Actions . Save ; protected static Action _actionSaveAs = Actions . SaveAs ; protected static Action _actionAddToProj = Actions . AddToProj ; protected static Action _actionPrint = Actions . Print ; protected static Action _actionExit = Actions . Exit ; protected static Action _actionUndo = Actions . Undo ; protected static Action _actionRedo = Actions . Redo ; protected static Action _actionCut = Actions . Cut ; protected static Action _actionCopy = Actions . Copy ; protected static Action _actionPaste = Actions . Paste ; protected static Action _actionDelete = new CmdDelete ( ) ; protected static Action _actionDispose = new CmdDispose ( ) ; protected static Action _actionNavUp = Actions . NavUp ; protected static Action _actionNavDown = Actions . NavDown ; protected static Action _actionNextTab = Actions . NextTab ; protected static Action _actionPrevTab = Actions . PrevTab ; protected static Action _actionShowDiagramTab = Actions . ShowDiagramTab ; protected static Action _actionShowTableTab = Actions . ShowTableTab ; protected static Action _actionShowTextTab = Actions . ShowTextTab ; protected static Action _actionAddToFavs = Actions . AddToFavs ; protected static Action _actionCreateMultiple = Actions . CreateMultiple ; protected static Action _actionClassDiagram = Actions . ClassDiagram ; protected static Action _actionUseCaseDiagram = Actions . UseCaseDiagram ; protected static Action _actionStateDiagram = Actions . StateDiagram ; protected static Action _actionModel = Actions . Model ; protected static Action _actionClass = Actions . Class ; protected static Action _actionInterface = Actions . Interface ; protected static Action _actionActor = Actions . Actor ; protected static Action _actionUseCase = Actions . UseCase ; protected static Action _actionState = Actions . State ; protected static Action _actionPseudostate = Actions . Pseudostate ; protected static Action _actionAttr = Actions . Attr ; protected static Action _actionOper = Actions . Oper ; protected static Action _actionRectangle = new CmdSetMode ( ModeCreateFigRect . class , "Rectangle" ) ; protected static Action _actionRRectangle = new CmdSetMode ( ModeCreateFigRRect . class , "RRect" ) ; protected static Action _actionCircle = new CmdSetMode ( ModeCreateFigCircle . class , "Circle" ) ; protected static Action _actionLine = new CmdSetMode ( ModeCreateFigLine . class , "Line" ) ; protected static Action _actionText = new CmdSetMode ( ModeCreateFigText . class , "Text" ) ; protected static Action _actionPoly = new CmdSetMode ( ModeCreateFigPoly . class , "Polygon" ) ; protected static Action _actionInk = new CmdSetMode ( ModeCreateFigInk . class , "Ink" ) ; protected static Action _actionAutoCritique = Actions . AutoCritique ; protected static Action _actionOpenDecisions = Actions . OpenDecisions ; protected static Action _actionOpenGoals = Actions . OpenGoals ; protected static Action _actionOpenCritics = Actions . OpenCritics ; protected static Action _actionAboutArgoUML = Actions . AboutArgoUML ; protected String _appName = "ProjectBrowser" ; protected Project _project = null ; protected NavigatorPane _navPane = new NavigatorPane ( ) ; public ToDoPane _toDoPane = new ToDoPane ( ) ; protected MultiEditorPane _multiPane = new MultiEditorPane ( ) ; protected DetailsPane _detailsPane = new DetailsPane ( ) ; protected JMenuBar _menuBar = new JMenuBar ( ) ; protected StatusBar _statusBar = new StatusBar ( ) ; public Font defaultFont = new Font ( "Dialog" , Font . PLAIN , 10 ) ; protected JSplitPane _mainSplit ; protected JSplitPane _topSplit ; protected JSplitPane _botSplit ; public ProjectBrowser ( String appName ) { } protected void initMenus ( ) { } protected Component createPanels ( ) { _topSplit = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT , _navPane , _multiPane ) ; _botSplit = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT , _toDoPane , _detailsPane ) ; _mainSplit = new JSplitPane ( JSplitPane . VERTICAL_SPLIT , _topSplit , _botSplit ) ; _topSplit . setDividerSize ( 2 ) ; <START_BUG> _topSplit . setDividerLocation ( 250 ) ; <END_BUG> _botSplit . setDividerSize ( 2 ) ; _mainSplit . setDividerSize ( 2 ) ; return _mainSplit ; } public void setProject ( Project p ) { } public Project getProject ( ) { } public String getAppName ( ) { } public void setAppName ( String n ) { } public void setPerspectives ( Vector v ) { } public Vector getPerspectives ( ) { } public void setCurPerspective ( NavPerspective tm ) { } public NavPerspective getCurPerspective ( ) { } public void setToDoPerspectives ( Vector v ) { } public Vector getToDoPerspectives ( ) { } public void setToDoCurPerspective ( TreeModel tm ) { } public void select ( Object o ) { } public void setTarget ( Object o ) { } public Object getTarget ( ) { } public void setToDoItem ( Object o ) { } public void setDetalsTarget ( Object o ) { } public StatusBar getStatusBar ( ) { } public ToDoPane getToDoPane ( ) { } public NavigatorPane getNavPane ( ) { } public void setVisible ( boolean b ) { } public void showStatus ( String s ) { } } 
public class SingularValueDecompositionImpl implements SingularValueDecomposition { private static final long serialVersionUID = - 3532767302235568872L ; private int m ; private int n ; private BiDiagonalTransformer transformer ; private double [ ] mainBidiagonal ; private double [ ] secondaryBidiagonal ; private double [ ] mainTridiagonal ; private double [ ] secondaryTridiagonal ; private EigenDecomposition eigenDecomposition ; private double [ ] singularValues ; private RealMatrix cachedU ; private RealMatrix cachedUt ; private RealMatrix cachedS ; private RealMatrix cachedV ; private RealMatrix cachedVt ; public SingularValueDecompositionImpl ( RealMatrix matrix ) throws InvalidMatrixException { } public RealMatrix getU ( ) throws InvalidMatrixException { } public RealMatrix getUT ( ) throws InvalidMatrixException { } public RealMatrix getS ( ) throws InvalidMatrixException { } public double [ ] getSingularValues ( ) throws InvalidMatrixException { } public RealMatrix getV ( ) throws InvalidMatrixException { } public RealMatrix getVT ( ) throws InvalidMatrixException { } public double getNorm ( ) throws InvalidMatrixException { } public double getConditionNumber ( ) throws InvalidMatrixException { } public int getRank ( ) throws IllegalStateException { } public DecompositionSolver getSolver ( ) { } private static class Solver implements DecompositionSolver { private static final long serialVersionUID = - 1959408026708904378L ; private final double [ ] singularValues ; private final RealMatrix uT ; private final RealMatrix v ; private boolean nonSingular ; private Solver ( final double [ ] singularValues , final RealMatrix uT , final RealMatrix v , final boolean nonSingular ) { } public double [ ] solve ( final double [ ] b ) throws IllegalArgumentException , InvalidMatrixException { } public RealVector solve ( final RealVector b ) throws IllegalArgumentException , InvalidMatrixException { if ( ( b . getDimension ( ) ) != ( singularValues . length ) ) { throw new IllegalArgumentException ( "constant<seq2seq4repair_space>vector<seq2seq4repair_space>has<seq2seq4repair_space>wrong<seq2seq4repair_space>length" ) ; } final RealVector w = uT . operate ( b ) ; for ( int i = 0 ; i < ( singularValues . length ) ; ++ i ) { final double si = singularValues [ i ] ; if ( si == 0 ) { throw new SingularMatrixException ( ) ; } <START_BUG> w . set ( i , ( ( w . getEntry ( i ) ) / si ) ) ; <END_BUG> } return v . operate ( w ) ; } public RealMatrix solve ( final RealMatrix b ) throws IllegalArgumentException , InvalidMatrixException { } public boolean isNonSingular ( ) { } public RealMatrix getInverse ( ) throws InvalidMatrixException { } } } 
public class DefinitionMetadataEqualsHashCodeTests extends TestCase { public void testRootBeanDefinitionEqualsAndHashCode ( ) throws Exception { } public void testChildBeanDefinitionEqualsAndHashCode ( ) throws Exception { } public void testRuntimeBeanReference ( ) throws Exception { } private void setBaseProperties ( AbstractBeanDefinition definition ) { definition . setAbstract ( true ) ; definition . setAttribute ( "foo" , "bar" ) ; definition . setAutowireCandidate ( false ) ; definition . setAutowireMode ( AUTOWIRE_BY_TYPE ) ; definition . setDependencyCheck ( DEPENDENCY_CHECK_OBJECTS ) ; definition . setDependsOn ( new String [ ] { "foo" , "bar" } ) ; definition . setDestroyMethodName ( "destroy" ) ; definition . setEnforceDestroyMethod ( false ) ; definition . setEnforceInitMethod ( true ) ; definition . setFactoryBeanName ( "factoryBean" ) ; definition . setFactoryMethodName ( "factoryMethod" ) ; definition . setInitMethodName ( "init" ) ; definition . setLazyInit ( true ) ; definition . getMethodOverrides ( ) . addOverride ( new LookupOverride ( "foo" , "bar" ) ) ; definition . getMethodOverrides ( ) . addOverride ( new ReplaceOverride ( "foo" , "bar" ) ) ; <START_BUG> definition . getPropertyValues ( ) . addPropertyValue ( "foo" , "bar" ) ; <END_BUG> definition . setResourceDescription ( "desc" ) ; definition . setRole ( ROLE_APPLICATION ) ; definition . setScope ( SCOPE_PROTOTYPE ) ; definition . setSource ( "foo" ) ; } private void assertEqualsContract ( Object master , Object equal , Object notEqual , Object subclass ) { } } 
public class TestJapaneseKatakanaStemFilter extends BaseTokenStreamTestCase { private Analyzer analyzer = new Analyzer ( ) { @ Override protected TokenStreamComponents createComponents ( String fieldName , Reader reader ) { } } ; public void testStemVariants ( ) throws IOException { } public void testUnsupportedHalfWidthVariants ( ) throws IOException { } public void testRandomData ( ) throws IOException { <START_BUG> checkRandomData ( random ( ) , analyzer , ( 10000 * ( RANDOM_MULTIPLIER ) ) ) ; <END_BUG> } public void testEmptyTerm ( ) throws IOException { } } 
public class DomainModelUtil { public static void updateCoreModel ( final Resource rootResource ) { } public static ExtensionContext initializeMasterDomainRegistry ( final ManagementResourceRegistration root , final ExtensibleConfigurationPersister configurationPersister , final ContentRepository contentRepository , final FileRepository fileRepository , final DomainController domainController , final UnregisteredHostChannelRegistry registry ) { } public static ExtensionContext initializeSlaveDomainRegistry ( final ManagementResourceRegistration root , final ExtensibleConfigurationPersister configurationPersister , final ContentRepository contentRepository , final FileRepository fileRepository , final LocalHostControllerInfo hostControllerInfo ) { } private static ExtensionContext initializeDomainRegistry ( final ManagementResourceRegistration root , final ExtensibleConfigurationPersister configurationPersister , final ContentRepository contentRepo , final FileRepository fileRepository , final boolean isMaster , final DomainController domainController , final UnregisteredHostChannelRegistry registry , final LocalHostControllerInfo hostControllerInfo ) { } public static void validateRolloutPlanStructure ( ModelNode plan ) throws OperationFailedException { if ( plan == null ) { <START_BUG> throw new OperationFailedException ( "rolloutPlan<seq2seq4repair_space>argument<seq2seq4repair_space>is<seq2seq4repair_space>null." ) ; <END_BUG> } if ( ! ( plan . hasDefined ( ROLLOUT_PLAN ) ) ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . requiredChildIsMissing ( ROLLOUT_PLAN , ROLLOUT_PLAN , plan . toString ( ) ) ) ; } ModelNode rolloutPlan1 = plan . get ( ROLLOUT_PLAN ) ; final Set < String > keys ; try { keys = rolloutPlan1 . keys ( ) ; } catch ( IllegalArgumentException e ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . requiredChildIsMissing ( ROLLOUT_PLAN , IN_SERIES , plan . toString ( ) ) ) ; } if ( ! ( keys . contains ( IN_SERIES ) ) ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . requiredChildIsMissing ( ROLLOUT_PLAN , IN_SERIES , plan . toString ( ) ) ) ; } if ( ( ( keys . size ( ) ) > 2 ) || ( ( ( keys . size ( ) ) == 2 ) && ( ! ( keys . contains ( ROLLBACK_ACROSS_GROUPS ) ) ) ) ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . unrecognizedChildren ( ROLLOUT_PLAN , ( ( ( IN_SERIES ) + ",<seq2seq4repair_space>" ) + ( ROLLBACK_ACROSS_GROUPS ) ) , plan . toString ( ) ) ) ; } final ModelNode inSeries = rolloutPlan1 . get ( IN_SERIES ) ; if ( ! ( inSeries . isDefined ( ) ) ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . requiredChildIsMissing ( ROLLOUT_PLAN , IN_SERIES , plan . toString ( ) ) ) ; } final List < ModelNode > groups = inSeries . asList ( ) ; if ( groups . isEmpty ( ) ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . inSeriesIsMissingGroups ( plan . toString ( ) ) ) ; } for ( ModelNode group : groups ) { if ( group . hasDefined ( SERVER_GROUP ) ) { final ModelNode serverGroup = group . get ( SERVER_GROUP ) ; final Set < String > groupKeys ; try { groupKeys = serverGroup . keys ( ) ; } catch ( IllegalArgumentException e ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . serverGroupExpectsSingleChild ( plan . toString ( ) ) ) ; } if ( ( groupKeys . size ( ) ) != 1 ) { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . serverGroupExpectsSingleChild ( plan . toString ( ) ) ) ; } DomainModelUtil . validateInSeriesServerGroup ( serverGroup . asProperty ( ) . getValue ( ) ) ; } else if ( group . hasDefined ( CONCURRENT_GROUPS ) ) { final ModelNode concurrent = group . get ( CONCURRENT_GROUPS ) ; for ( ModelNode child : concurrent . asList ( ) ) { DomainModelUtil . validateInSeriesServerGroup ( child . asProperty ( ) . getValue ( ) ) ; } } else { throw new OperationFailedException ( DomainControllerMessages . MESSAGES . unexpectedInSeriesGroup ( plan . toString ( ) ) ) ; } } } private static final List < String > ALLOWED_SERVER_GROUP_CHILDREN = Arrays . asList ( new String [ ] { ROLLING_TO_SERVERS , MAX_FAILURE_PERCENTAGE , MAX_FAILED_SERVERS } ) ; private static void validateInSeriesServerGroup ( ModelNode serverGroup ) throws OperationFailedException { } } 
case Opcodes . OPC_aload_0 : VerificationTypeInfo locals0 = frame . locals [ 0 ] ; <START_BUG> if ( ( locals0 . tag ) != ( VerificationTypeInfo . ITEM_UNINITIALIZED_THIS ) ) { <END_BUG>
public class Validator { private final Stack handlers ; private final ArrayList tempFiles ; private final ArrayList sandboxes ; boolean abortOnFailure ; private Object locker ; public Validator ( IMessageHandler handler ) { } public void pushHandler ( IMessageHandler handler ) { } public void popHandler ( IMessageHandler handler ) { } public boolean lock ( Object requestor ) { } public boolean unlock ( Object requestor ) { } public void setAbortOnFailure ( boolean abortOnFailure ) { } public boolean nullcheck ( Object [ ] ra , String message ) { } public boolean nullcheck ( Collection list , int atLeast , int atMost , String message ) { } public boolean nullcheck ( Collection list , String message ) { } public Object nulldefault ( Object o , String message , Object def ) { } public boolean nullcheck ( Object o , String message ) { } public boolean canRead ( File baseDir , String [ ] paths , String message ) { } public boolean canRead ( File [ ] files , String message ) { } public boolean canRead ( File file , String message ) { } public boolean canWrite ( File file , String message ) { } public boolean canReadDir ( File file , String message ) { } public boolean canWriteDir ( File file , String message ) { } public boolean canReadFiles ( Object [ ] dirs , String message ) { } public boolean canReadFiles ( Collection dirs , String message ) { } public boolean canReadDirs ( Object [ ] dirs , String message ) { } public boolean canReadDirs ( Collection dirs , String message ) { } public boolean canWriteFiles ( Object [ ] dirs , String message ) { } public boolean canWriteFiles ( Collection dirs , String message ) { } public boolean canWriteDirs ( Object [ ] dirs , String message ) { } public boolean canWriteDirs ( Collection dirs , String message ) { } public void info ( String message ) { } public void fail ( String message ) { } public void fail ( String message , Throwable thrown ) { } public void registerTempFile ( File file ) { } public File getWritableDir ( File dir , String name , boolean deleteContents , boolean register , String failMessage ) { if ( null == dir ) { if ( null == name ) { name = "Validator" ; } dir = FileUtil . getTempDir ( name ) ; } else { if ( ! ( dir . exists ( ) ) ) { dir . mkdirs ( ) ; } } if ( ( null == dir ) || ( ! ( dir . exists ( ) ) ) ) { if ( null != failMessage ) { fail ( ( ( failMessage + ":<seq2seq4repair_space>unable<seq2seq4repair_space>to<seq2seq4repair_space>get<seq2seq4repair_space>parent<seq2seq4repair_space>" ) + dir ) ) ; } } else { <START_BUG> File result = FileUtil . makeNewChildDir ( dir , name ) ; <END_BUG> if ( deleteContents ) { FileUtil . deleteContents ( dir ) ; } if ( register ) { tempFiles . add ( dir ) ; } } return dir ; } public void deleteTempFiles ( boolean reportFailures ) { } public void registerSandbox ( Sandbox sandbox ) { } private boolean deleteFile ( File file , boolean reportFailures ) { } private IMessageHandler getHandler ( ) { } } 
public abstract class MSVSS extends Task { private static final String SS_EXE = "ss" ; public static final String PROJECT_PREFIX = "$" ; public static final String COMMAND_GET = "Get" ; public static final String COMMAND_CHECKOUT = "Checkout" ; public static final String COMMAND_CHECKIN = "Checkin" ; public static final String COMMAND_LABEL = "Label" ; public static final String COMMAND_HISTORY = "History" ; public static final String FLAG_LOGIN = "-Y" ; public static final String FLAG_OVERRIDE_WORKING_DIR = "-GL" ; public static final String FLAG_AUTORESPONSE_DEF = "-I-" ; public static final String FLAG_AUTORESPONSE_YES = "-I-Y" ; public static final String FLAG_AUTORESPONSE_NO = "-I-N" ; public static final String FLAG_RECURSION = "-R" ; public static final String FLAG_VERSION = "-V" ; public static final String FLAG_VERSION_DATE = "-Vd" ; public static final String FLAG_VERSION_LABEL = "-VL" ; public static final String FLAG_WRITABLE = "-W" ; public static final String VALUE_NO = "-N" ; public static final String VALUE_YES = "-Y" ; public static final String FLAG_QUIET = "-O-" ; private String m_SSDir = "" ; private String m_vssLogin = null ; private String m_vssPath = null ; private String m_serverPath = null ; public final void setLogin ( String login ) { } public final void setServerpath ( String serverPath ) { } public final void setSsdir ( final File dir ) { } public final void setVsspath ( String vssPath ) { } public final String getSSCommand ( ) { } public void getLoginCommand ( Commandline cmd ) { } public String getVsspath ( ) { } protected int run ( Commandline cmd ) throws TaskException { try { final Execute2 exe = new Execute2 ( ) ; setupLogger ( exe ) ; if ( ( m_serverPath ) != null ) { final Properties env = new Properties ( ) ; env . setProperty ( "SSDIR" , m_serverPath ) ; exe . setEnvironment ( env ) ; } exe . setWorkingDirectory ( getBaseDirectory ( ) ) ; <START_BUG> exe . setCommandline ( cmd . getCommandline ( ) ) ; <END_BUG> return exe . execute ( ) ; } catch ( IOException e ) { throw new TaskException ( "Error" , e ) ; } } } 
public class LuceneSegmentInputFormatTest extends AbstractLuceneStorageTest { private LuceneSegmentInputFormat inputFormat ; private JobContext jobContext ; private Configuration conf ; @ Before public void before ( ) throws Exception { } @ After public void after ( ) throws IOException { } @ Test public void testGetSplits ( ) throws IOException , InterruptedException { } private JobContext getJobContext ( Configuration conf , JobID jobID ) throws ClassNotFoundException , IllegalAccessException , InstantiationException , NoSuchMethodException , InvocationTargetException { <START_BUG> Class < ? extends JobContext > clazz = null ; <END_BUG> if ( ! ( JobContext . class . isInterface ( ) ) ) { clazz = JobContext . class ; } else { clazz = ( ( Class < ? extends JobContext > ) ( Class . forName ( "org.apache.hadoop.mapreduce.task.JobContextImpl" ) ) ) ; } return clazz . getConstructor ( Configuration . class , JobID . class ) . newInstance ( conf , jobID ) ; } } 
public class RackAwareStrategy extends AbstractReplicationStrategy { public RackAwareStrategy ( TokenMetadata tokenMetadata , int replicas ) { } public ArrayList < InetAddress > getNaturalEndpoints ( Token token , TokenMetadata metadata ) { int startIndex ; ArrayList < InetAddress > endpoints = new ArrayList < InetAddress > ( ) ; boolean bDataCenter = false ; boolean bOtherRack = false ; int foundCount = 0 ; List tokens = metadata . sortedTokens ( ) ; if ( tokens . isEmpty ( ) ) return endpoints ; int index = Collections . binarySearch ( tokens , token ) ; if ( index < 0 ) { index = ( index + 1 ) * ( - 1 ) ; if ( index >= ( tokens . size ( ) ) ) index = 0 ; } int totalNodes = tokens . size ( ) ; Token primaryToken = ( ( Token ) ( tokens . get ( index ) ) ) ; endpoints . add ( metadata . getEndPoint ( primaryToken ) ) ; foundCount ++ ; if ( ( replicas_ ) == 1 ) { return endpoints ; } startIndex = ( index + 1 ) % totalNodes ; <START_BUG> EndPointSnitch endPointSnitch = ( ( EndPointSnitch ) ( StorageService . instance ( ) . getEndPointSnitch ( ) ) ) ; <END_BUG> for ( int i = startIndex , count = 1 ; ( count < totalNodes ) && ( foundCount < ( replicas_ ) ) ; ++ count , i = ( i + 1 ) % totalNodes ) { try { Token t = ( ( Token ) ( tokens . get ( i ) ) ) ; if ( ! ( endPointSnitch . isInSameDataCenter ( metadata . getEndPoint ( primaryToken ) , metadata . getEndPoint ( t ) ) ) ) { if ( ! bDataCenter ) { endpoints . add ( metadata . getEndPoint ( t ) ) ; bDataCenter = true ; foundCount ++ ; } continue ; } if ( ( ! ( endPointSnitch . isOnSameRack ( metadata . getEndPoint ( primaryToken ) , metadata . getEndPoint ( t ) ) ) ) && ( endPointSnitch . isInSameDataCenter ( metadata . getEndPoint ( primaryToken ) , metadata . getEndPoint ( t ) ) ) ) { if ( ! bOtherRack ) { endpoints . add ( metadata . getEndPoint ( t ) ) ; bOtherRack = true ; foundCount ++ ; } } } catch ( UnknownHostException e ) { throw new RuntimeException ( e ) ; } } for ( int i = startIndex , count = 1 ; ( count < totalNodes ) && ( foundCount < ( replicas_ ) ) ; ++ count , i = ( i + 1 ) % totalNodes ) { Token t = ( ( Token ) ( tokens . get ( i ) ) ) ; if ( ! ( endpoints . contains ( metadata . getEndPoint ( t ) ) ) ) { endpoints . add ( metadata . getEndPoint ( t ) ) ; foundCount ++ ; } } return endpoints ; } } 
public class RecoveredStatement extends RecoveredElement { public Statement statement ; public RecoveredStatement ( Statement statement , RecoveredElement parent , int bracketBalance ) { } public AstNode parseTree ( ) { } public int sourceEnd ( ) { } public String toString ( int tab ) { <START_BUG> return ( ( tabString ( tab ) ) + "Recovered<seq2seq4repair_space>statement:\n" ) + ( statement . toString ( ( tab + 1 ) ) ) ; <END_BUG> } public Statement updatedStatement ( ) { } public void updateParseTree ( ) { } public void updateSourceEndIfNecessary ( int sourceEnd ) { } } 
public class MockWebRequest extends WebRequest { private Url url ; private List < Cookie > cookies = new ArrayList < Cookie > ( ) ; private Map < String , List < Object > > headers = new HashMap < String , List < Object > > ( ) ; private MockRequestParameters postRequestParameters = new MockRequestParameters ( ) ; private Locale locale = Locale . getDefault ( ) ; public MockWebRequest ( Url url ) { } MockWebRequest ( Url url , List < Cookie > cookies , Map < String , List < Object > > headers , MockRequestParameters postRequestParameters , Locale locale ) { } @ Override public MockWebRequest requestWithUrl ( Url url ) { } public void setUrl ( Url url ) { } @ Override public Url getUrl ( ) { } @ Override public String toString ( ) { } public void setCookies ( List < Cookie > cookies ) { } public void addCookie ( Cookie cookie ) { } @ Override public List < Cookie > getCookies ( ) { } @ Override public long getDateHeader ( String name ) { List < Object > dates = headers . get ( name ) ; if ( ( dates == null ) || ( dates . isEmpty ( ) ) ) { <START_BUG> throw new WicketRuntimeException ( ( ( "Date<seq2seq4repair_space>header<seq2seq4repair_space>with<seq2seq4repair_space>name<seq2seq4repair_space>'" + name ) + "'<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>exist." ) ) ; <END_BUG> } Object date = dates . get ( 0 ) ; if ( ( date instanceof Long ) == false ) { throw new WicketRuntimeException ( ( ( "Date<seq2seq4repair_space>header<seq2seq4repair_space>with<seq2seq4repair_space>name<seq2seq4repair_space>'" + name ) + "'<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>a<seq2seq4repair_space>valid<seq2seq4repair_space>long." ) ) ; } return ( ( Long ) ( date ) ) ; } private void addHeaderObject ( String name , Object value ) { } public void setDateHeader ( String name , long value ) { } public void addDateHeader ( String name , long value ) { } @ Override public String getHeader ( String name ) { } public void setHeader ( String name , String value ) { } public void addHeader ( String name , String value ) { } public void setLocale ( Locale locale ) { } @ Override public Locale getLocale ( ) { } @ Override public List < String > getHeaders ( String name ) { } public void removeHeader ( String header ) { } @ Override public MockRequestParameters getPostParameters ( ) { } } 
public class CompoundPropertyModel extends AbstractPropertyModel implements ICompoundModel { private static final long serialVersionUID = 1L ; public CompoundPropertyModel ( final Object model ) { } protected String propertyExpression ( final Component component ) { } protected Class propertyType ( final Component component ) { if ( component instanceof FormComponent ) { <START_BUG> return ( ( FormComponent ) ( component ) ) . getValidationType ( ) ; <END_BUG> } return null ; } public String toString ( ) { } } 
public class VelocityContributor extends AbstractBehavior { private static final long serialVersionUID = 1L ; private String encoding = "ISO-8859-1" ; private final IModel < ? extends Map < ? , ? > > model ; private final String templateName ; public VelocityContributor ( String templateName , final IModel < ? extends Map < ? , ? > > model ) { } @ Override public void detach ( Component c ) { if ( ( model ) instanceof IDetachable ) { <START_BUG> ( ( IDetachable ) ( model ) ) . detach ( ) ; <END_BUG> } } public String getEncoding ( ) { } @ Override public void renderHead ( Component component , final IHeaderResponse response ) { } public void setEncoding ( String encoding ) { } protected boolean escapeHtml ( ) { } protected final CharSequence evaluate ( ) { } } 
public class Assignment extends Expression { public Reference lhs ; public Expression expression ; public Assignment ( Expression lhs , Expression expression , int sourceEnd ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } void checkAssignmentEffect ( BlockScope scope ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } Binding getDirectBinding ( Expression someExpression ) { } public TypeBinding resolveType ( BlockScope scope ) { constant = NotAConstant ; this . resolvedType = lhs . resolveType ( scope ) ; TypeBinding rhsType = expression . resolveType ( scope ) ; if ( ( ( this . resolvedType ) == null ) || ( rhsType == null ) ) { return null ; } checkAssignmentEffect ( scope ) ; if ( ( ( expression . isConstantValueOfTypeAssignableToType ( rhsType , this . resolvedType ) ) || ( ( this . resolvedType . isBaseType ( ) ) && ( BaseTypeBinding . isWidening ( this . resolvedType . id , rhsType . id ) ) ) ) || ( rhsType . isCompatibleWith ( this . resolvedType ) ) ) { expression . implicitWidening ( this . resolvedType , rhsType ) ; return this . resolvedType ; } scope . problemReporter ( ) . typeMismatchErrorActualTypeExpectedType ( expression , rhsType , this . resolvedType ) ; <START_BUG> return null ; <END_BUG> } public String toString ( int tab ) { } public String toStringExpression ( ) { } public String toStringExpressionNoParenthesis ( ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } } 
public class TestActionGui extends AbstractSamplerGui { private JComboBox targetBox ; private JRadioButton pauseButton ; private JRadioButton stopButton ; private JTextField durationField ; private int target ; private int action ; private int duration ; private static final String targetLabel = JMeterUtils . getResString ( "test_action_target" ) ; private static final String threadTarget = JMeterUtils . getResString ( "test_action_target_thread" ) ; private static final String testTarget = JMeterUtils . getResString ( "test_action_target_test" ) ; private static final String actionLabel = JMeterUtils . getResString ( "test_action_action" ) ; private static final String pauseAction = JMeterUtils . getResString ( "test_action_pause" ) ; private static final String stopAction = JMeterUtils . getResString ( "test_action_stop" ) ; private static final String durationLabel = JMeterUtils . getResString ( "test_action_duration" ) ; public TestActionGui ( ) { } public String getLabelResource ( ) { } public void configure ( TestElement element ) { } public TestElement createTestElement ( ) { } public void modifyTestElement ( TestElement element ) { } private void init ( ) { setLayout ( new VerticalLayout ( 5 , VerticalLayout . LEFT , VerticalLayout . TOP ) ) ; setBorder ( makeBorder ( ) ) ; add ( makeTitlePanel ( ) ) ; HorizontalPanel targetPanel = new HorizontalPanel ( ) ; targetPanel . add ( new JLabel ( TestActionGui . targetLabel ) ) ; DefaultComboBoxModel targetModel = new DefaultComboBoxModel ( ) ; targetModel . addElement ( TestActionGui . threadTarget ) ; targetModel . addElement ( TestActionGui . testTarget ) ; targetBox = new JComboBox ( targetModel ) ; targetBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( ( ( String ) ( targetBox . getSelectedItem ( ) ) ) . equals ( TestActionGui . threadTarget ) ) { target = TestAction . THREAD ; } else { target = TestAction . TEST ; } } } ) ; targetPanel . add ( targetBox ) ; add ( targetPanel ) ; HorizontalPanel actionPanel = new HorizontalPanel ( ) ; ButtonGroup actionButtons = new ButtonGroup ( ) ; pauseButton = new JRadioButton ( TestActionGui . pauseAction , true ) ; pauseButton . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { if ( pauseButton . isSelected ( ) ) { action = TestAction . PAUSE ; durationField . setEnabled ( true ) ; } } } ) ; stopButton = new JRadioButton ( TestActionGui . stopAction , false ) ; stopButton . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { if ( stopButton . isSelected ( ) ) { action = TestAction . STOP ; durationField . setEnabled ( false ) ; } } } ) ; actionButtons . add ( pauseButton ) ; actionButtons . add ( stopButton ) ; actionPanel . add ( new JLabel ( TestActionGui . actionLabel ) ) ; actionPanel . add ( pauseButton ) ; actionPanel . add ( stopButton ) ; add ( actionPanel ) ; HorizontalPanel durationPanel = new HorizontalPanel ( ) ; durationField = new JTextField ( 5 ) ; durationField . setText ( Integer . toString ( duration ) ) ; durationField . addFocusListener ( new FocusListener ( ) { public void focusLost ( FocusEvent e ) { try { duration = Integer . parseInt ( durationField . getText ( ) ) ; } catch ( NumberFormatException nfe ) { duration = 0 ; } } public void focusGained ( FocusEvent e ) { } } ) ; <START_BUG> durationPanel . add ( new JLabel ( "Duration" ) ) ; <END_BUG> durationPanel . add ( durationField ) ; add ( durationPanel ) ; } } 
public abstract class Border extends WebMarkupContainerWithAssociatedMarkup implements IComponentResolver { private static final long serialVersionUID = 1L ; static final String BODY = "body" ; static final String BORDER = "border" ; static final String BODY_ID = "_body" ; private final Border . BorderBodyContainer body ; private transient MarkupStream originalMarkupStream ; private transient ComponentTag openTag ; private int beginOfBodyIndex ; private transient boolean rendering ; public Border ( final String id ) { } public Border ( final String id , final IModel < ? > model ) { } public final Border . BorderBodyContainer getBodyContainer ( ) { } Border . BorderBodyContainer newBorderBodyContainer ( final String id ) { } @ Override public MarkupContainer add ( final Component ... children ) { } @ Override public Component add ( final IBehavior ... behaviors ) { } public MarkupContainer addToBorder ( final Component ... children ) { } public Component addToBorder ( final IBehavior ... behaviors ) { } public Border addToBorderBody ( final Component ... child ) { } public Component addToBorderBody ( final IBehavior ... behaviors ) { } public final Component getFromBorderBody ( final String path ) { } public boolean resolve ( final MarkupContainer container , final MarkupStream markupStream , final ComponentTag tag ) { if ( ( rendering ) == false ) { if ( tag instanceof WicketTag ) { WicketTag wtag = ( ( WicketTag ) ( tag ) ) ; if ( wtag . isBodyTag ( ) ) { rendering = true ; try { <START_BUG> body . render ( markupStream ) ; <END_BUG> } finally { rendering = false ; } return true ; } } } return false ; } @ Override protected void onComponentTag ( final ComponentTag tag ) { } @ Override protected final void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } @ Override public void renderHead ( HtmlHeaderContainer container ) { } @ Override public IMarkupFragment getMarkup ( final Component child ) { } public class BorderBodyContainer extends WebMarkupContainer { private static final long serialVersionUID = 1L ; private transient boolean wasOpenCloseTag = false ; private boolean transparentResolver ; public BorderBodyContainer ( final String id ) { } @ Override public final boolean isTransparentResolver ( ) { } public final void setTransparentResolver ( final boolean value ) { } @ Override protected void onComponentTag ( final ComponentTag tag ) { } @ Override protected void onComponentTagBody ( final MarkupStream markupStream , final ComponentTag openTag ) { } @ Override public IMarkupFragment getMarkup ( ) { } @ Override public IMarkupFragment getMarkup ( final Component child ) { } } } 
public class BlogAuthorManagerImpl implements BlogAuthorManager { private BlogPersistenceService persistenceService ; public void setPersistenceService ( BlogPersistenceService persistenceService ) { } public void createAuthor ( String email , String dob , String name , String displayName , String bio ) throws ParseException { if ( email == null ) throw new IllegalArgumentException ( "Email<seq2seq4repair_space>must<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>null" ) ; Date dateOfBirth ; <START_BUG> dateOfBirth = ( ( dob == null ) || ( "" . equals ( dob ) ) ) ? null : new SimpleDateFormat ( "dd-mm-yyyy" ) . parse ( dob ) ; <END_BUG> persistenceService . createAuthor ( email , dateOfBirth , name , displayName , bio ) ; } public List < ? extends BlogAuthor > getAllAuthors ( ) { } public BlogAuthor getAuthor ( String emailAddress ) { } public void removeAuthor ( String emailAddress ) { } public void updateAuthor ( String email , String dob , String name , String displayName , String bio ) throws ParseException { } private List < ? extends BlogAuthor > adaptAuthor ( List < ? extends Author > authors ) { } } 
public class PresentSelectorTest extends BaseSelectorTest { private Project project ; public PresentSelectorTest ( String name ) { } public BaseSelector getInstance ( ) { } public void testValidate ( ) { } public void testSelectionBehaviour ( ) { PresentSelector s ; String results ; Mapper m ; Mapper . MapperType identity = new Mapper . MapperType ( ) ; identity . setValue ( "identity" ) ; Mapper . MapperType glob = new Mapper . MapperType ( ) ; glob . setValue ( "glob" ) ; Mapper . MapperType merge = new Mapper . MapperType ( ) ; merge . setValue ( "merge" ) ; Mapper . MapperType flatten = new Mapper . MapperType ( ) ; flatten . setValue ( "flatten" ) ; try { makeBed ( ) ; s = ( ( PresentSelector ) ( getInstance ( ) ) ) ; s . setTargetdir ( beddir ) ; results = selectionString ( s ) ; assertEquals ( "TTTTTTTTTTTT" , results ) ; s = ( ( PresentSelector ) ( getInstance ( ) ) ) ; s . setTargetdir ( beddir ) ; m = s . createMapper ( ) ; m . setType ( identity ) ; results = selectionString ( s ) ; assertEquals ( "TTTTTTTTTTTT" , results ) ; s = ( ( PresentSelector ) ( getInstance ( ) ) ) ; <START_BUG> File subdir = new File ( "src/etc/testcases/taskdefs/expected" ) ; <END_BUG> s . setTargetdir ( subdir ) ; m = s . createMapper ( ) ; m . setType ( flatten ) ; results = selectionString ( s ) ; if ( JavaEnvUtils . isJavaVersion ( JAVA_1_1 ) ) { assertEquals ( "TTTTTFFFFFFF" , results ) ; } else { assertEquals ( "TTTTTTTTTTTF" , results ) ; } s = ( ( PresentSelector ) ( getInstance ( ) ) ) ; s . setTargetdir ( beddir ) ; m = s . createMapper ( ) ; m . setType ( merge ) ; m . setTo ( "asf-logo.gif.gz" ) ; results = selectionString ( s ) ; assertEquals ( "TTTTTTTTTTTT" , results ) ; s = ( ( PresentSelector ) ( getInstance ( ) ) ) ; subdir = new File ( beddir , "tar/bz2" ) ; s . setTargetdir ( subdir ) ; m = s . createMapper ( ) ; m . setType ( glob ) ; m . setFrom ( "*.bz2" ) ; m . setTo ( "*.tar.bz2" ) ; results = selectionString ( s ) ; assertEquals ( "FFTFFFFFFFFF" , results ) ; try { makeMirror ( ) ; s = ( ( PresentSelector ) ( getInstance ( ) ) ) ; subdir = getProject ( ) . resolveFile ( "selectortest2" ) ; s . setTargetdir ( subdir ) ; results = mirrorSelectionString ( s ) ; assertEquals ( "TTTFFTTTTTTT" , results ) ; results = selectionString ( s ) ; assertEquals ( "TTTFFTTTTTTT" , results ) ; } finally { cleanupMirror ( ) ; } } finally { cleanupBed ( ) ; } } } 
public class Table { public static final String SYSTEM_TABLE = "system" ; private static final Logger logger = LoggerFactory . getLogger ( Table . class ) ; private static final String SNAPSHOT_SUBDIR_NAME = "snapshots" ; static final ReentrantReadWriteLock flusherLock = new ReentrantReadWriteLock ( true ) ; private static Timer flushTimer = new Timer ( "FLUSH-TIMER" ) ; private final boolean waitForCommitLog ; private static final Map < String , Table > instances = new org . cliffc . high_scale_lib . NonBlockingHashMap < String , Table > ( ) ; public final String name ; private final Map < Integer , ColumnFamilyStore > columnFamilyStores = new HashMap < Integer , ColumnFamilyStore > ( ) ; private SortedSet < String > applicationColumnFamilies ; private final TimerTask flushTask ; public static Table open ( String table ) { } public static Table clear ( String table ) throws IOException { } public Collection < ColumnFamilyStore > getColumnFamilyStores ( ) { } public ColumnFamilyStore getColumnFamilyStore ( int cfId ) { } @ Deprecated public ColumnFamilyStore getColumnFamilyStore ( String cfName ) { } public void forceCleanup ( ) { } public void snapshot ( String clientSuppliedName ) { } public static String getTimestampedSnapshotName ( String clientSuppliedName ) { } public void clearSnapshot ( ) throws IOException { } public List < SSTableReader > forceAntiCompaction ( Collection < Range > ranges , InetAddress target ) { } public void forceCompaction ( ) { } List < SSTableReader > getAllSSTablesOnDisk ( ) { } private Table ( String table ) { } public void dropCf ( int cfId ) throws IOException { } public void initCf ( int cfId , String cfName ) { } public void renameCf ( int cfId , String newName ) throws IOException { } public Row getRow ( QueryFilter filter ) throws IOException { } public void apply ( RowMutation mutation , Object serializedMutation , boolean writeCommitLog ) throws IOException { HashMap < ColumnFamilyStore , Memtable > memtablesToFlush = new HashMap < ColumnFamilyStore , Memtable > ( 2 ) ; Table . flusherLock . readLock ( ) . lock ( ) ; try { if ( writeCommitLog ) { CommitLog . instance ( ) . add ( mutation , serializedMutation ) ; } DecoratedKey key = StorageService . getPartitioner ( ) . decorateKey ( mutation . key ( ) ) ; for ( ColumnFamily columnFamily : mutation . getColumnFamilies ( ) ) { Memtable memtableToFlush ; ColumnFamilyStore cfs = columnFamilyStores . get ( columnFamily . id ( ) ) ; if ( cfs == null ) { <START_BUG> Table . logger . error ( ( "Attempting<seq2seq4repair_space>to<seq2seq4repair_space>mutate<seq2seq4repair_space>non-existant<seq2seq4repair_space>column<seq2seq4repair_space>family<seq2seq4repair_space>" + ( columnFamily . name ( ) ) ) ) ; <END_BUG> } else { if ( ( memtableToFlush = cfs . apply ( key , columnFamily ) ) != null ) memtablesToFlush . put ( cfs , memtableToFlush ) ; ColumnFamily cachedRow = cfs . getRawCachedRow ( key ) ; if ( cachedRow != null ) cachedRow . addAll ( columnFamily ) ; } } } finally { Table . flusherLock . readLock ( ) . unlock ( ) ; } for ( Map . Entry < ColumnFamilyStore , Memtable > entry : memtablesToFlush . entrySet ( ) ) entry . getKey ( ) . maybeSwitchMemtable ( entry . getValue ( ) , writeCommitLog ) ; } public List < Future < ? > > flush ( ) throws IOException { } void load ( RowMutation rowMutation ) throws IOException { } public String getDataFileLocation ( long expectedCompactedFileSize ) { } public static String getSnapshotPath ( String dataDirPath , String tableName , String snapshotName ) { } public static Iterable < Table > all ( ) { } public void truncate ( String cfname ) throws IOException , InterruptedException , ExecutionException { } } 
public class SizeAssertion extends AbstractScopedAssertion implements Serializable , Assertion { private static final long serialVersionUID = 233L ; public static final int EQUAL = 1 ; public static final int NOTEQUAL = 2 ; public static final int GREATERTHAN = 3 ; public static final int LESSTHAN = 4 ; public static final int GREATERTHANEQUAL = 5 ; public static final int LESSTHANEQUAL = 6 ; private static final String SIZE_KEY = "SizeAssertion.size" ; private static final String OPERATOR_KEY = "SizeAssertion.operator" ; public AssertionResult getResult ( SampleResult response ) { AssertionResult result = new AssertionResult ( getName ( ) ) ; result . setFailure ( false ) ; long resultSize = 0 ; if ( isScopeVariable ( ) ) { String variableName = getVariableName ( ) ; String value = getThreadContext ( ) . getVariables ( ) . get ( variableName ) ; try { resultSize = Integer . parseInt ( value ) ; } catch ( NumberFormatException e ) { result . setFailure ( true ) ; result . setFailureMessage ( ( ( ( "Error<seq2seq4repair_space>parsing<seq2seq4repair_space>variable<seq2seq4repair_space>name:<seq2seq4repair_space>" + variableName ) + "<seq2seq4repair_space>value:<seq2seq4repair_space>" ) + value ) ) ; return result ; } } else { resultSize = response . getBytes ( ) ; } final String msg = compareSize ( resultSize ) ; if ( ( msg . length ( ) ) > 0 ) { result . setFailure ( true ) ; <START_BUG> Object [ ] arguments = new Object [ ] { new Long ( resultSize ) , msg , new Long ( getAllowedSize ( ) ) } ; <END_BUG> String message = MessageFormat . format ( JMeterUtils . getResString ( "size_assertion_failure" ) , arguments ) ; result . setFailureMessage ( message ) ; } return result ; } public long getAllowedSize ( ) { } public void setCompOper ( int operator ) { } public int getCompOper ( ) { } public void setAllowedSize ( long size ) throws IllegalArgumentException { } private String compareSize ( long resultSize ) { } } 
public class BecomeWorkingCopyOperation extends JavaModelOperation { IPath path ; IProblemRequestor problemRequestor ; public BecomeWorkingCopyOperation ( CompilationUnit workingCopy , IPath path , IProblemRequestor problemRequestor ) { } protected void executeOperation ( ) throws JavaModelException { CompilationUnit workingCopy = getWorkingCopy ( ) ; JavaModelManager . getJavaModelManager ( ) . getPerWorkingCopyInfo ( workingCopy , this . path , true , true , this . problemRequestor ) ; workingCopy . openWhenClosed ( workingCopy . createElementInfo ( ) , fMonitor ) ; <START_BUG> if ( ( workingCopy . owner ) != ( DefaultWorkingCopyOwner . PRIMARY ) ) { <END_BUG> JavaElementDelta delta = new JavaElementDelta ( this . getJavaModel ( ) ) ; delta . added ( workingCopy ) ; addDelta ( delta ) ; } else { JavaElementDelta delta = new JavaElementDelta ( this . getJavaModel ( ) ) ; delta . changed ( workingCopy , IJavaElementDelta . F_PRIMARY_WORKING_COPY ) ; addDelta ( delta ) ; } fResultElements = new IJavaElement [ ] { workingCopy } ; } protected CompilationUnit getWorkingCopy ( ) { } public boolean isReadOnly ( ) { } } 
public class Receiver implements Runnable { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private volatile boolean active ; private final Session session ; private final MessageConsumer consumer ; private final Connection conn ; private final boolean useResMsgIdAsCorrelId ; private Receiver ( ConnectionFactory factory , Destination receiveQueue , String principal , String credentials , boolean useResMsgIdAsCorrelId ) throws JMSException { } public static Receiver createReceiver ( ConnectionFactory factory , Destination receiveQueue , String principal , String credentials , boolean useResMsgIdAsCorrelId ) throws JMSException { Receiver receiver = new Receiver ( factory , receiveQueue , principal , credentials , useResMsgIdAsCorrelId ) ; <START_BUG> Thread thread = new Thread ( receiver , "JMS<seq2seq4repair_space>Receiever" ) ; <END_BUG> thread . start ( ) ; return receiver ; } public void run ( ) { } public void deactivate ( ) { } } 
public class TypePatternList extends PatternNode { private TypePattern [ ] typePatterns ; int ellipsisCount = 0 ; public static final TypePatternList EMPTY = new TypePatternList ( new TypePattern [ ] { } ) ; public static final TypePatternList ANY = new TypePatternList ( new TypePattern [ ] { new EllipsisTypePattern ( ) } ) ; public TypePatternList ( ) { } public TypePatternList ( TypePattern [ ] arguments ) { } public TypePatternList ( List l ) { } public int size ( ) { } public TypePattern get ( int index ) { } public String toString ( ) { } public boolean canMatchSignatureWithNParameters ( int numParams ) { } public FuzzyBoolean matches ( ResolvedType [ ] types , TypePattern . MatchKind kind ) { } private static FuzzyBoolean outOfStar ( final TypePattern [ ] pattern , final ResolvedType [ ] target , int pi , int ti , int pLeft , int tLeft , final int starsLeft , TypePattern . MatchKind kind ) { } private static FuzzyBoolean inStar ( final TypePattern [ ] pattern , final ResolvedType [ ] target , int pi , int ti , final int pLeft , int tLeft , int starsLeft , TypePattern . MatchKind kind ) { } public TypePatternList parameterizeWith ( Map typeVariableMap ) { } public TypePatternList resolveBindings ( IScope scope , Bindings bindings , boolean allowBinding , boolean requireExactType ) { } public TypePatternList resolveReferences ( IntMap bindings ) { } public void postRead ( ResolvedType enclosingType ) { } public boolean equals ( Object other ) { } public int hashCode ( ) { } public static TypePatternList read ( VersionedDataInputStream s , ISourceContext context ) throws IOException { } public void write ( DataOutputStream s ) throws IOException { } public TypePattern [ ] getTypePatterns ( ) { } public Collection getExactTypes ( ) { ArrayList ret = new ArrayList ( ) ; for ( int i = 0 ; i < ( typePatterns . length ) ; i ++ ) { UnresolvedType t = typePatterns [ i ] . getExactType ( ) ; <START_BUG> if ( t != ( ResolvedType . MISSING ) ) <END_BUG> ret . add ( t ) ; } return ret ; } public Object accept ( PatternNodeVisitor visitor , Object data ) { } public Object traverse ( PatternNodeVisitor visitor , Object data ) { } public boolean areAllExactWithNoSubtypesAllowed ( ) { } public String [ ] maybeGetCleanNames ( ) { } } 
public class CacheFactoryAdd extends AbstractAddStepHandler { private final AttributeDefinition [ ] attributes ; CacheFactoryAdd ( AttributeDefinition ... attributes ) { } @ Override protected void populateModel ( ModelNode operation , ModelNode model ) throws OperationFailedException { } @ Override protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model , ServiceVerificationHandler verificationHandler , List < ServiceController < ? > > serviceControllers ) throws OperationFailedException { } Collection < ServiceController < ? > > installRuntimeServices ( OperationContext context , ModelNode operation , ModelNode model , ServiceVerificationHandler verificationHandler ) throws OperationFailedException { final String name = PathAddress . pathAddress ( operation . get ( ADDRESS ) ) . getLastElement ( ) . getValue ( ) ; ModelNode passivationStoreModel = PASSIVATION_STORE . resolveModelAttribute ( context , model ) ; String passivationStore = ( passivationStoreModel . isDefined ( ) ) ? passivationStoreModel . asString ( ) : null ; final Collection < String > unwrappedAliasValues = ALIASES . unwrap ( context , model ) ; <START_BUG> final Set < String > aliases = ( unwrappedAliasValues != null ) ? new HashSet < > ( unwrappedAliasValues ) : Collections . < String > emptySet ( ) ; <END_BUG> ServiceTarget target = context . getServiceTarget ( ) ; ServiceBuilder < ? > builder = CacheFactoryAdd . buildCacheFactoryBuilder ( target , name , passivationStore ) ; for ( String alias : aliases ) { builder . addAliases ( CacheFactoryBuilderService . getServiceName ( alias ) ) ; } if ( verificationHandler != null ) { builder . addListener ( verificationHandler ) ; } return Collections . < ServiceController < ? > > singleton ( builder . install ( ) ) ; } private static ServiceBuilder < ? > buildCacheFactoryBuilder ( ServiceTarget target , String name , String passivationStore ) { } } 
public final class QueuelessThreadPoolAdd extends AbstractExecutorAdd { private static final long serialVersionUID = 5597662601486525937L ; private String handoffExecutor ; private boolean blocking ; public QueuelessThreadPoolAdd ( final String name , final ScaledCount maxThreads ) { } protected < P > void applyUpdate ( final UpdateContext updateContext , final UpdateResultHandler < ? super Void , P > handler , final P param ) { <START_BUG> final BatchBuilder builder = updateContext . getBatchBuilder ( ) ; <END_BUG> final ScaledCount maxThreadsCount = getMaxThreads ( ) ; final int maxThreads = maxThreadsCount . getScaledCount ( ) ; final String name = getName ( ) ; final ServiceName serviceName = ThreadsServices . executorName ( name ) ; final QueuelessThreadPoolService service = new QueuelessThreadPoolService ( maxThreads , blocking , getKeepaliveTime ( ) ) ; final ServiceBuilder < ExecutorService > serviceBuilder = builder . addService ( serviceName , service ) ; addThreadFactoryDependency ( serviceName , serviceBuilder , service . getThreadFactoryInjector ( ) , builder ) ; serviceBuilder . install ( ) ; } protected void applyUpdate ( final ThreadsSubsystemElement element ) throws UpdateFailedException { } public String getHandoffExecutor ( ) { } public void setHandoffExecutor ( final String handoffExecutor ) { } public boolean isBlocking ( ) { } public void setBlocking ( final boolean blocking ) { } } 
public class Snippet77 { public static void main ( String [ ] args ) { Display display = new Display ( ) ; Shell shell = new Shell ( display ) ; shell . setLayout ( new FillLayout ( ) ) ; final Composite comp = new Composite ( shell , SWT . NONE ) ; final Table table = new Table ( comp , ( ( SWT . BORDER ) | ( SWT . V_SCROLL ) ) ) ; table . setHeaderVisible ( true ) ; table . setLinesVisible ( true ) ; final TableColumn column1 = new TableColumn ( table , SWT . NONE ) ; column1 . setText ( "Column<seq2seq4repair_space>1" ) ; final TableColumn column2 = new TableColumn ( table , SWT . NONE ) ; column2 . setText ( "Column<seq2seq4repair_space>2" ) ; for ( int i = 0 ; i < 10 ; i ++ ) { TableItem item = new TableItem ( table , SWT . NONE ) ; item . setText ( new String [ ] { "item<seq2seq4repair_space>0" + i , "item<seq2seq4repair_space>1" + i } ) ; } comp . addControlListener ( new ControlAdapter ( ) { public void controlResized ( ControlEvent e ) { Rectangle area = comp . getClientArea ( ) ; Point preferredSize = table . computeSize ( DEFAULT , DEFAULT ) ; int width = ( area . width ) - ( 2 * ( table . getBorderWidth ( ) ) ) ; <START_BUG> if ( ( preferredSize . y ) > ( area . height ) ) { <END_BUG> Point vBarSize = table . getVerticalBar ( ) . getSize ( ) ; width -= vBarSize . x ; } Point oldSize = table . getSize ( ) ; if ( ( oldSize . x ) > ( area . width ) ) { column1 . setWidth ( ( width / 3 ) ) ; column2 . setWidth ( ( width - ( column1 . getWidth ( ) ) ) ) ; table . setSize ( area . width , area . height ) ; } else { table . setSize ( area . width , area . height ) ; column1 . setWidth ( ( width / 3 ) ) ; column2 . setWidth ( ( width - ( column1 . getWidth ( ) ) ) ) ; } } } ) ; shell . open ( ) ; while ( ! ( shell . isDisposed ( ) ) ) { if ( ! ( display . readAndDispatch ( ) ) ) display . sleep ( ) ; } display . dispose ( ) ; } } 
public class TypeSystemImpl extends AbstractTypeSystemImpl implements TypeSystem { private DeclarationsContributor contr = null ; public TypeSystemImpl ( DeclarationsContributor contributor ) { } public Type typeForName ( String name , AbstractTypeReference ... typeArguments ) { DeclaredType dt = contr . typeForName ( name ) ; <START_BUG> if ( dt == null ) { <END_BUG> Type t = FACTORY . createType ( ) ; t . setDeclaredType ( dt ) ; t . getActualTypeArguments ( ) . addAll ( Arrays . asList ( typeArguments ) ) ; return t ; } return null ; } public FunctionType functionForName ( String name , List < AbstractTypeReference > parameterTypes , AbstractTypeReference ... typeArguments ) { } public FunctionType functionForNameAndParameterTypes ( String name , AbstractTypeReference ... parameterTypes ) { } } 
public interface Console { void addCompleter ( CommandLineCompleter completer ) { } boolean isUseHistory ( ) { } void setUseHistory ( boolean useHistory ) { } CommandHistory getHistory ( ) { } void setHistoryFile ( File f ) { } void clearScreen ( ) { } void printColumns ( Collection < String > list ) { } void print ( String line ) { } void printNewLine ( ) { } String readLine ( String prompt ) { } String readLine ( String prompt , Character mask ) { } int getTerminalWidth ( ) { } int getTerminalHeight ( ) { } static final class Factory { public static Console getConsole ( CommandContext ctx ) throws CliInitializationException { } public static Console getConsole ( final CommandContext ctx , InputStream is , OutputStream os ) throws CliInitializationException { org . jboss . aesh . console . Console aeshConsole = null ; try { aeshConsole = new org . jboss . aesh . console . Console ( ) ; } catch ( IOException e ) { <START_BUG> e . printStackTrace ( ) ; <END_BUG> } final org . jboss . aesh . console . Console finalAeshConsole = aeshConsole ; return new Console ( ) { private CommandContext cmdCtx = ctx ; private org . jboss . aesh . console . Console console = finalAeshConsole ; private CommandHistory history = new HistoryImpl ( ) ; @ Override public void addCompleter ( final CommandLineCompleter completer ) { console . addCompletion ( new Completion ( ) { @ Override public void complete ( CompleteOperation co ) { int offset = completer . complete ( cmdCtx , co . getBuffer ( ) , co . getCursor ( ) , co . getCompletionCandidates ( ) ) ; co . setOffset ( offset ) ; if ( ( ( co . getCompletionCandidates ( ) . size ( ) ) == 1 ) && ( co . getCompletionCandidates ( ) . get ( 0 ) . startsWith ( co . getBuffer ( ) ) ) ) co . doAppendSeparator ( true ) ; else co . doAppendSeparator ( false ) ; } } ) ; } @ Override public boolean isUseHistory ( ) { return ! ( Settings . getInstance ( ) . isHistoryDisabled ( ) ) ; } @ Override public void setUseHistory ( boolean useHistory ) { Settings . getInstance ( ) . setHistoryDisabled ( ( ! useHistory ) ) ; } @ Override public CommandHistory getHistory ( ) { return history ; } @ Override public void setHistoryFile ( File f ) { Settings . getInstance ( ) . setHistoryFile ( f ) ; } @ Override public void clearScreen ( ) { try { console . clear ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } @ Override public void printColumns ( Collection < String > list ) { String [ ] newList = new String [ list . size ( ) ] ; list . toArray ( newList ) ; try { console . pushToStdOut ( Parser . formatDisplayList ( newList , console . getTerminalSize ( ) . getHeight ( ) , console . getTerminalSize ( ) . getWidth ( ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } @ Override public void print ( String line ) { try { console . pushToStdOut ( line ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } @ Override public void printNewLine ( ) { try { console . pushToStdOut ( Config . getLineSeparator ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } @ Override public String readLine ( String prompt ) { try { ConsoleOutput output = console . read ( prompt ) ; return output != null ? output . getBuffer ( ) : null ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } } @ Override public String readLine ( String prompt , Character mask ) { try { return console . read ( new Prompt ( prompt ) , mask ) . getBuffer ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return null ; } } @ Override public int getTerminalWidth ( ) { return console . getTerminalSize ( ) . getWidth ( ) ; } @ Override public int getTerminalHeight ( ) { return console . getTerminalSize ( ) . getHeight ( ) ; } class HistoryImpl implements CommandHistory { @ SuppressWarnings ( "unchecked" ) @ Override public List < String > asList ( ) { return console . getHistory ( ) . getAll ( ) ; } @ Override public boolean isUseHistory ( ) { return ! ( Settings . getInstance ( ) . isHistoryDisabled ( ) ) ; } @ Override public void setUseHistory ( boolean useHistory ) { Settings . getInstance ( ) . setHistoryDisabled ( ( ! useHistory ) ) ; } @ Override public void clear ( ) { console . getHistory ( ) . clear ( ) ; } @ Override public void setMaxSize ( int maxSize ) { Settings . getInstance ( ) . setHistorySize ( maxSize ) ; } @ Override public int getMaxSize ( ) { return Settings . getInstance ( ) . getHistorySize ( ) ; } } } ; } } } 
public class Translate extends MatchingTask { private String bundle ; private String bundleLanguage ; private String bundleCountry ; private String bundleVariant ; private File toDir ; private String srcEncoding ; private String destEncoding ; private String bundleEncoding ; private String startToken ; private String endToken ; private boolean forceOverwrite ; private Vector filesets = new Vector ( ) ; private Hashtable resourceMap = new Hashtable ( ) ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private long [ ] bundleLastModified = new long [ 7 ] ; private long srcLastModified ; private long destLastModified ; private boolean loaded = false ; public void setBundle ( String bundle ) { } public void setBundleLanguage ( String bundleLanguage ) { } public void setBundleCountry ( String bundleCountry ) { } public void setBundleVariant ( String bundleVariant ) { } public void setToDir ( File toDir ) { } public void setStartToken ( String startToken ) { } public void setEndToken ( String endToken ) { } public void setSrcEncoding ( String srcEncoding ) { } public void setDestEncoding ( String destEncoding ) { } public void setBundleEncoding ( String bundleEncoding ) { } public void setForceOverwrite ( boolean forceOverwrite ) { } public void addFileset ( FileSet set ) { } public void execute ( ) throws BuildException { } private void loadResourceMaps ( ) throws BuildException { Locale locale = new Locale ( bundleLanguage , bundleCountry , bundleVariant ) ; String language = ( ( locale . getLanguage ( ) . length ( ) ) > 0 ) ? "_" + ( locale . getLanguage ( ) ) : "" ; String country = ( ( locale . getCountry ( ) . length ( ) ) > 0 ) ? "_" + ( locale . getCountry ( ) ) : "" ; String variant = ( ( locale . getVariant ( ) . length ( ) ) > 0 ) ? "_" + ( locale . getVariant ( ) ) : "" ; String bundleFile = ( ( ( bundle ) + language ) + country ) + variant ; processBundle ( bundleFile , 0 , false ) ; bundleFile = ( ( bundle ) + language ) + country ; processBundle ( bundleFile , 1 , false ) ; bundleFile = ( bundle ) + language ; processBundle ( bundleFile , 2 , false ) ; bundleFile = bundle ; processBundle ( bundleFile , 3 , false ) ; locale = Locale . getDefault ( ) ; language = ( ( locale . getLanguage ( ) . length ( ) ) > 0 ) ? "_" + ( locale . getLanguage ( ) ) : "" ; country = ( ( locale . getCountry ( ) . length ( ) ) > 0 ) ? "_" + ( locale . getCountry ( ) ) : "" ; variant = ( ( locale . getVariant ( ) . length ( ) ) > 0 ) ? "_" + ( locale . getVariant ( ) ) : "" ; bundleEncoding = System . getProperty ( "file.encoding" ) ; bundleFile = ( ( ( bundle ) + language ) + country ) + variant ; processBundle ( bundleFile , 4 , false ) ; bundleFile = ( ( bundle ) + language ) + country ; processBundle ( bundleFile , 5 , false ) ; bundleFile = ( bundle ) + language ; <START_BUG> processBundle ( bundleFile , 6 , false ) ; <END_BUG> } private void processBundle ( final String bundleFile , final int i , final boolean checkLoaded ) throws BuildException { } private void loadResourceMap ( FileInputStream ins ) throws BuildException { } private void translate ( ) throws BuildException { } } 
public class Rmic extends MatchingTask { private static final String FAIL_MSG = "Rmic<seq2seq4repair_space>failed,<seq2seq4repair_space>messages<seq2seq4repair_space>should<seq2seq4repair_space>have<seq2seq4repair_space>been<seq2seq4repair_space>provided." ; private boolean verify = false ; private boolean filtering = false ; private boolean iiop = false ; private boolean idl = false ; private boolean debug = false ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private Vector compileList = new Vector ( ) ; private ClassLoader loader = null ; private File baseDir ; private String classname ; private Path compileClasspath ; private Path extdirs ; private String idlopts ; private String iiopopts ; private File sourceBase ; private String stubVersion ; public void setBase ( File base ) { } public void setClassname ( String classname ) { } public void setClasspath ( Path classpath ) throws TaskException { } public void setClasspathRef ( Reference r ) throws TaskException { } public void setDebug ( boolean debug ) { } public void setExtdirs ( Path extdirs ) throws TaskException { } public void setFiltering ( boolean filter ) { } public void setIdl ( boolean idl ) { } public void setIdlopts ( String idlopts ) { } public void setIiop ( boolean iiop ) { } public void setIiopopts ( String iiopopts ) { } public void setIncludeantruntime ( boolean include ) { } public void setIncludejavaruntime ( boolean include ) { } public void setSourceBase ( File sourceBase ) { } public void setStubVersion ( String stubVersion ) { } public void setVerify ( boolean verify ) { } public File getBase ( ) { } public String getClassname ( ) { } public Path getClasspath ( ) { } public Vector getCompileList ( ) { } public boolean getDebug ( ) { } public Path getExtdirs ( ) { } public Vector getFileList ( ) { } public boolean getFiltering ( ) { } public boolean getIdl ( ) { } public String getIdlopts ( ) { } public boolean getIiop ( ) { } public String getIiopopts ( ) { } public boolean getIncludeantruntime ( ) { } public boolean getIncludejavaruntime ( ) { } public ClassLoader getLoader ( ) { } public Class getRemoteInterface ( Class testClass ) { } public File getSourceBase ( ) { } public String getStubVersion ( ) { } public boolean getVerify ( ) { } public boolean isValidRmiRemote ( String classname ) { } public Path createClasspath ( ) throws TaskException { } public Path createExtdirs ( ) throws TaskException { } public void execute ( ) throws TaskException { } protected void scanDir ( File baseDir , String [ ] files , FileNameMapper mapper ) throws TaskException { } private boolean isValidRmiRemote ( Class testClass ) { } private void moveGeneratedFile ( File baseDir , File sourceBaseFile , String classname , RmicAdapter adapter ) throws TaskException { String classFileName = ( classname . replace ( '.' , File . separatorChar ) ) + ".class" ; String [ ] generatedFiles = adapter . getMapper ( ) . mapFileName ( classFileName ) ; for ( int i = 0 ; i < ( generatedFiles . length ) ; i ++ ) { String sourceFileName = ( classFileName . substring ( 0 , ( ( classFileName . length ( ) ) - 6 ) ) ) + ".java" ; File oldFile = new File ( baseDir , sourceFileName ) ; File newFile = new File ( sourceBaseFile , sourceFileName ) ; try { if ( filtering ) { final FilterSetCollection filters = new FilterSetCollection ( project . getGlobalFilterSet ( ) ) ; <START_BUG> FileUtils . newFileUtils ( ) . copyFile ( oldFile , newFile , filters ) ; <END_BUG> } else { FileUtil . copyFile ( oldFile , newFile ) ; } oldFile . delete ( ) ; } catch ( IOException ioe ) { String msg = ( ( ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>copy<seq2seq4repair_space>" + oldFile ) + "<seq2seq4repair_space>to<seq2seq4repair_space>" ) + newFile ) + "<seq2seq4repair_space>due<seq2seq4repair_space>to<seq2seq4repair_space>" ) + ( ioe . getMessage ( ) ) ; throw new TaskException ( msg , ioe ) ; } } } } 
public abstract class CacheAdd extends AbstractAddStepHandler { private static final Logger log = Logger . getLogger ( CacheAdd . class . getPackage ( ) . getName ( ) ) ; private static final String DEFAULTS = "infinispan-defaults.xml" ; private static volatile Map < CacheMode , Configuration > defaults = null ; public static synchronized Configuration getDefaultConfiguration ( CacheMode cacheMode ) { } private static ConfigurationBuilderHolder load ( String resource ) { URL url = CacheAdd . find ( resource , CacheAdd . class . getClassLoader ( ) ) ; CacheAdd . log . debugf ( "Loading<seq2seq4repair_space>Infinispan<seq2seq4repair_space>defaults<seq2seq4repair_space>from<seq2seq4repair_space>%s" , url . toString ( ) ) ; ParserRegistry parser = new ParserRegistry ( ParserRegistry . class . getClassLoader ( ) ) ; try ( InputStream input = url . openStream ( ) ) { return parser . parse ( input ) ; } catch ( IOException e ) { <START_BUG> throw new IllegalStateException ( String . format ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>parse<seq2seq4repair_space>%s" , url ) , e ) ; <END_BUG> } } private static URL find ( String resource , ClassLoader ... loaders ) { } final CacheMode mode ; CacheAdd ( CacheMode mode ) { } @ Override protected void populateModel ( ModelNode operation , ModelNode model ) throws OperationFailedException { } @ Override protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model , ServiceVerificationHandler verificationHandler , List < ServiceController < ? > > newControllers ) throws OperationFailedException { } Collection < ServiceController < ? > > installRuntimeServices ( OperationContext context , ModelNode operation , ModelNode containerModel , ModelNode cacheModel , ServiceVerificationHandler verificationHandler ) throws OperationFailedException { } void removeRuntimeServices ( OperationContext context , ModelNode operation , ModelNode containerModel , ModelNode cacheModel ) throws OperationFailedException { } protected PathAddress getCacheAddressFromOperation ( ModelNode operation ) { } protected PathAddress getCacheContainerAddressFromOperation ( ModelNode operation ) { } ServiceController < ? > installCacheConfigurationService ( ServiceTarget target , String containerName , String cacheName , boolean defaultCache , ModuleIdentifier moduleId , ConfigurationBuilder builder , Configuration config , List < CacheAdd . Dependency < ? > > dependencies , ServiceVerificationHandler verificationHandler ) { } ServiceController < ? > installCacheService ( ServiceTarget target , String containerName , String cacheName , boolean defaultCache , ServiceController . Mode initialMode , Configuration config , ServiceVerificationHandler verificationHandler ) { } @ SuppressWarnings ( "rawtypes" ) ServiceController < ? > installJndiService ( ServiceTarget target , String containerName , String cacheName , boolean defaultCache , String jndiName , ServiceVerificationHandler verificationHandler ) { } private static JndiName createJndiName ( String container , String cache ) { } private static BindInfo createCacheBinding ( JndiName name ) { } private static < T > void addDependency ( ServiceBuilder < ? > builder , CacheAdd . Dependency < T > dependency ) { } void populate ( ModelNode fromModel , ModelNode toModel ) throws OperationFailedException { } void processModelNode ( OperationContext context , String containerName , ModelNode cache , ConfigurationBuilder builder , List < CacheAdd . Dependency < ? > > dependencies ) throws OperationFailedException { } private static String findStoreKey ( ModelNode cache ) { } private static ModelNode getStoreModelNode ( ModelNode cache ) { } private StoreConfigurationBuilder < ? , ? > buildCacheStore ( OperationContext context , PersistenceConfigurationBuilder persistenceBuilder , String containerName , ModelNode store , String storeKey , List < CacheAdd . Dependency < ? > > dependencies ) throws OperationFailedException { } private static AbstractJdbcStoreConfigurationBuilder < ? , ? > buildJdbcStore ( PersistenceConfigurationBuilder persistenceBuilder , OperationContext context , ModelNode store ) throws OperationFailedException { } private static void buildBinaryKeyedTable ( TableManipulationConfigurationBuilder < ? , ? > builder , OperationContext context , ModelNode table ) throws OperationFailedException { } private static void buildStringKeyedTable ( TableManipulationConfigurationBuilder < ? , ? > builder , OperationContext context , ModelNode table ) throws OperationFailedException { } private static void buildTable ( TableManipulationConfigurationBuilder < ? , ? > builder , OperationContext context , ModelNode table , String defaultTableNamePrefix ) throws OperationFailedException { } private static String getColumnProperty ( OperationContext context , ModelNode table , String columnKey , AttributeDefinition columnAttribute , String defaultValue ) throws OperationFailedException { } protected class Dependency < I > { private final ServiceName name ; private final Class < I > type ; private final Injector < I > target ; Dependency ( ServiceName name ) { } Dependency ( ServiceName name , Class < I > type , Injector < I > target ) { } ServiceName getName ( ) { } public Class < I > getType ( ) { } public Injector < I > getInjector ( ) { } } private abstract class SimpleInjector < I > implements Injector < I > { @ Override public void uninject ( ) { } } private static class CacheDependencies implements CacheService . Dependencies { private final Value < EmbeddedCacheManager > container ; private final InjectedValue < XAResourceRecoveryRegistry > recoveryRegistry = new InjectedValue < XAResourceRecoveryRegistry > ( ) ; CacheDependencies ( Value < EmbeddedCacheManager > container ) { } Injector < XAResourceRecoveryRegistry > getRecoveryRegistryInjector ( ) { } @ Override public EmbeddedCacheManager getCacheContainer ( ) { } @ Override public XAResourceRecoveryRegistry getRecoveryRegistry ( ) { } } private static class CacheConfigurationDependencies implements CacheConfigurationService . Dependencies { private final Value < EmbeddedCacheManager > container ; private final InjectedValue < TransactionManager > tm = new InjectedValue < TransactionManager > ( ) ; private final InjectedValue < TransactionSynchronizationRegistry > tsr = new InjectedValue < TransactionSynchronizationRegistry > ( ) ; private final InjectedValue < ModuleLoader > moduleLoader = new InjectedValue < ModuleLoader > ( ) ; CacheConfigurationDependencies ( Value < EmbeddedCacheManager > container ) { } Injector < TransactionManager > getTransactionManagerInjector ( ) { } Injector < TransactionSynchronizationRegistry > getTransactionSynchronizationRegistryInjector ( ) { } Injector < ModuleLoader > getModuleLoaderInjector ( ) { } @ Override public EmbeddedCacheManager getCacheContainer ( ) { } @ Override public TransactionManager getTransactionManager ( ) { } @ Override public TransactionSynchronizationRegistry getTransactionSynchronizationRegistry ( ) { } @ Override public ModuleLoader getModuleLoader ( ) { } } } 
public class ReloadableResourceBundleMessageSource extends AbstractMessageSource implements ResourceLoaderAware { private static final String PROPERTIES_SUFFIX = ".properties" ; private static final String XML_SUFFIX = ".xml" ; private String [ ] basenames = new String [ 0 ] ; private String defaultEncoding ; private Properties fileEncodings ; private boolean fallbackToSystemLocale = true ; private long cacheMillis = - 1 ; private PropertiesPersister propertiesPersister = new DefaultPropertiesPersister ( ) ; private ResourceLoader resourceLoader = new DefaultResourceLoader ( ) ; private final Map cachedFilenames = new HashMap ( ) ; private final Map cachedProperties = new HashMap ( ) ; private final Map cachedMergedProperties = new HashMap ( ) ; public void setBasename ( String basename ) { } public void setBasenames ( String [ ] basenames ) { } public void setDefaultEncoding ( String defaultEncoding ) { } public void setFileEncodings ( Properties fileEncodings ) { } public void setFallbackToSystemLocale ( boolean fallbackToSystemLocale ) { } public void setCacheSeconds ( int cacheSeconds ) { } public void setPropertiesPersister ( PropertiesPersister propertiesPersister ) { } public void setResourceLoader ( ResourceLoader resourceLoader ) { } @ Override protected String resolveCodeWithoutArguments ( String code , Locale locale ) { } @ Override protected MessageFormat resolveCode ( String code , Locale locale ) { } protected ReloadableResourceBundleMessageSource . PropertiesHolder getMergedProperties ( Locale locale ) { } protected List calculateAllFilenames ( String basename , Locale locale ) { } protected List calculateFilenamesForLocale ( String basename , Locale locale ) { List result = new ArrayList ( 3 ) ; String language = locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; String variant = locale . getVariant ( ) ; <START_BUG> StringBuffer temp = new StringBuffer ( basename ) ; <END_BUG> if ( ( language . length ( ) ) > 0 ) { temp . append ( '_' ) . append ( language ) ; result . add ( 0 , temp . toString ( ) ) ; } if ( ( country . length ( ) ) > 0 ) { temp . append ( '_' ) . append ( country ) ; result . add ( 0 , temp . toString ( ) ) ; } if ( ( variant . length ( ) ) > 0 ) { temp . append ( '_' ) . append ( variant ) ; result . add ( 0 , temp . toString ( ) ) ; } return result ; } protected ReloadableResourceBundleMessageSource . PropertiesHolder getProperties ( String filename ) { } protected ReloadableResourceBundleMessageSource . PropertiesHolder refreshProperties ( String filename , ReloadableResourceBundleMessageSource . PropertiesHolder propHolder ) { } protected Properties loadProperties ( Resource resource , String filename ) throws IOException { } public void clearCache ( ) { } public void clearCacheIncludingAncestors ( ) { } @ Override public String toString ( ) { } protected class PropertiesHolder { private Properties properties ; private long fileTimestamp = - 1 ; private long refreshTimestamp = - 1 ; private final Map cachedMessageFormats = new HashMap ( ) ; public PropertiesHolder ( Properties properties , long fileTimestamp ) { } public PropertiesHolder ( ) { } public Properties getProperties ( ) { } public long getFileTimestamp ( ) { } public void setRefreshTimestamp ( long refreshTimestamp ) { } public long getRefreshTimestamp ( ) { } public String getProperty ( String code ) { } public MessageFormat getMessageFormat ( String code , Locale locale ) { } } } 
public abstract class QueryMetricsHandler extends AbstractRuntimeOnlyHandler { private final PersistenceUnitServiceRegistry persistenceUnitRegistry ; private QueryMetricsHandler ( PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } @ Override protected void executeRuntimeStep ( OperationContext context , ModelNode operation ) throws OperationFailedException { handleQueryStatistics ( context , operation ) ; <START_BUG> context . completeStep ( ) ; <END_BUG> } protected abstract void handle ( QueryStatistics statistics , OperationContext context , String attributeName , String originalQueryName ) { } private void handleQueryStatistics ( OperationContext context , ModelNode operation ) { } static final QueryMetricsHandler getExecutionCount ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getCacheHitCount ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getCachePutCount ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getCacheMissCount ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getExecutionRowCount ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getExecutionAvgTime ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getExecutionMaxTime ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } static final QueryMetricsHandler getExecutionMinTime ( final PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } public static OperationStepHandler getOriginalName ( PersistenceUnitServiceRegistry persistenceUnitRegistry ) { } } 
public class WeibullDistribution extends AbstractRealDistribution { public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1.0E-9 ; private static final long serialVersionUID = 8589540077390120676L ; private final double shape ; private final double scale ; private final double solverAbsoluteAccuracy ; private double numericalMean = Double . NaN ; private boolean numericalMeanIsCalculated = false ; private double numericalVariance = Double . NaN ; private boolean numericalVarianceIsCalculated = false ; public WeibullDistribution ( double alpha , double beta ) throws NotStrictlyPositiveException { } public WeibullDistribution ( double alpha , double beta , double inverseCumAccuracy ) { } public WeibullDistribution ( RandomGenerator rng , double alpha , double beta ) throws NotStrictlyPositiveException { } public WeibullDistribution ( RandomGenerator rng , double alpha , double beta , double inverseCumAccuracy ) throws NotStrictlyPositiveException { } public double getShape ( ) { } public double getScale ( ) { } public double density ( double x ) { } @ Override public double logDensity ( double x ) { } public double cumulativeProbability ( double x ) { } @ Override public double inverseCumulativeProbability ( double p ) { double ret ; if ( ( p < 0.0 ) || ( p > 1.0 ) ) { throw new OutOfRangeException ( p , 0.0 , 1.0 ) ; } else if ( p == 0 ) { ret = 0.0 ; } else if ( p == 1 ) { ret = Double . POSITIVE_INFINITY ; } else { <START_BUG> ret = ( scale ) * ( FastMath . pow ( ( - ( FastMath . log ( ( 1.0 - p ) ) ) ) , ( 1.0 / ( shape ) ) ) ) ; <END_BUG> } return ret ; } @ Override protected double getSolverAbsoluteAccuracy ( ) { } public double getNumericalMean ( ) { } protected double calculateNumericalMean ( ) { } public double getNumericalVariance ( ) { } protected double calculateNumericalVariance ( ) { } public double getSupportLowerBound ( ) { } public double getSupportUpperBound ( ) { } public boolean isSupportLowerBoundInclusive ( ) { } public boolean isSupportUpperBoundInclusive ( ) { } public boolean isSupportConnected ( ) { } } 
public class TermsFilterTest extends LuceneTestCase { public void testCachability ( ) throws Exception { } public void testMissingTerms ( ) throws Exception { } public void testMissingField ( ) throws Exception { } public void testFieldNotPresent ( ) throws IOException { } public void testSkipField ( ) throws IOException { } public void testRandom ( ) throws IOException { } private TermsFilter termsFilter ( boolean singleField , Term ... terms ) { } private TermsFilter termsFilter ( boolean singleField , Collection < Term > termList ) { } public void testHashCodeAndEquals ( ) { int num = atLeast ( 100 ) ; final boolean singleField = random ( ) . nextBoolean ( ) ; List < Term > terms = new ArrayList < Term > ( ) ; Set < Term > uniqueTerms = new HashSet < Term > ( ) ; for ( int i = 0 ; i < num ; i ++ ) { String field = "field" + ( singleField ? "1" : random ( ) . nextInt ( 100 ) ) ; String string = _TestUtil . randomRealisticUnicodeString ( random ( ) ) ; terms . add ( new Term ( field , string ) ) ; uniqueTerms . add ( new Term ( field , string ) ) ; TermsFilter left = termsFilter ( ( singleField ? random ( ) . nextBoolean ( ) : false ) , uniqueTerms ) ; Collections . shuffle ( terms , random ( ) ) ; TermsFilter right = termsFilter ( ( singleField ? random ( ) . nextBoolean ( ) : false ) , terms ) ; assertEquals ( right , left ) ; assertEquals ( right . hashCode ( ) , left . hashCode ( ) ) ; <START_BUG> if ( i > 0 ) { <END_BUG> List < Term > asList = new ArrayList < Term > ( uniqueTerms ) ; asList . remove ( 0 ) ; TermsFilter notEqual = termsFilter ( ( singleField ? random ( ) . nextBoolean ( ) : false ) , asList ) ; assertFalse ( left . equals ( notEqual ) ) ; assertFalse ( right . equals ( notEqual ) ) ; } } } public void testNoTerms ( ) { } } 
public class TestDeletionPolicy extends LuceneTestCase { private void verifyCommitOrder ( List commits ) { } class KeepAllDeletionPolicy implements IndexDeletionPolicy { int numOnInit ; int numOnCommit ; public void onInit ( List commits ) { } public void onCommit ( List commits ) { } } class KeepNoneOnInitDeletionPolicy implements IndexDeletionPolicy { int numOnInit ; int numOnCommit ; public void onInit ( List commits ) { } public void onCommit ( List commits ) { } } class KeepLastNDeletionPolicy implements IndexDeletionPolicy { int numOnInit ; int numOnCommit ; int numToKeep ; int numDelete ; Set seen = new HashSet ( ) ; public KeepLastNDeletionPolicy ( int numToKeep ) { } public void onInit ( List commits ) { } public void onCommit ( List commits ) { } private void doDeletes ( List commits , boolean isCommit ) { } } class ExpirationTimeDeletionPolicy implements IndexDeletionPolicy { Directory dir ; double expirationTimeSeconds ; int numDelete ; public ExpirationTimeDeletionPolicy ( Directory dir , double seconds ) { } public void onInit ( List commits ) throws IOException { } public void onCommit ( List commits ) throws IOException { } } public void testExpirationTimeDeletionPolicy ( ) throws IOException , InterruptedException { final double SECONDS = 2.0 ; boolean autoCommit = false ; boolean useCompoundFile = true ; Directory dir = new RAMDirectory ( ) ; TestDeletionPolicy . ExpirationTimeDeletionPolicy policy = new TestDeletionPolicy . ExpirationTimeDeletionPolicy ( dir , SECONDS ) ; IndexWriter writer = new IndexWriter ( dir , autoCommit , new WhitespaceAnalyzer ( ) , true , policy ) ; writer . setUseCompoundFile ( useCompoundFile ) ; writer . close ( ) ; long lastDeleteTime = 0 ; for ( int i = 0 ; i < 7 ; i ++ ) { lastDeleteTime = System . currentTimeMillis ( ) ; writer = new IndexWriter ( dir , autoCommit , new WhitespaceAnalyzer ( ) , false , policy ) ; writer . setUseCompoundFile ( useCompoundFile ) ; for ( int j = 0 ; j < 17 ; j ++ ) { addDoc ( writer ) ; } writer . close ( ) ; Thread . sleep ( ( ( int ) ( 1000.0 * ( SECONDS / 5.0 ) ) ) ) ; } assertTrue ( "no<seq2seq4repair_space>commits<seq2seq4repair_space>were<seq2seq4repair_space>deleted" , ( ( policy . numDelete ) > 0 ) ) ; long gen = SegmentInfos . getCurrentSegmentGeneration ( dir ) ; String fileName = IndexFileNames . fileNameFromGeneration ( SEGMENTS , "" , gen ) ; dir . deleteFile ( SEGMENTS_GEN ) ; while ( gen > 0 ) { try { IndexReader reader = IndexReader . open ( dir ) ; reader . close ( ) ; fileName = IndexFileNames . fileNameFromGeneration ( SEGMENTS , "" , gen ) ; long modTime = dir . fileModified ( fileName ) ; <START_BUG> assertTrue ( ( ( "commit<seq2seq4repair_space>point<seq2seq4repair_space>was<seq2seq4repair_space>older<seq2seq4repair_space>than<seq2seq4repair_space>" + SECONDS ) + "<seq2seq4repair_space>seconds<seq2seq4repair_space>but<seq2seq4repair_space>did<seq2seq4repair_space>not<seq2seq4repair_space>get<seq2seq4repair_space>deleted" ) , ( ( lastDeleteTime - modTime ) < ( SECONDS * 1000 ) ) ) ; <END_BUG> } catch ( IOException e ) { break ; } dir . deleteFile ( IndexFileNames . fileNameFromGeneration ( SEGMENTS , "" , gen ) ) ; gen -- ; } dir . close ( ) ; } public void testKeepAllDeletionPolicy ( ) throws IOException { } public void testKeepNoneOnInitDeletionPolicy ( ) throws IOException { } public void testKeepLastNDeletionPolicy ( ) throws IOException { } public void testKeepLastNDeletionPolicyWithReader ( ) throws IOException { } public void testKeepLastNDeletionPolicyWithCreates ( ) throws IOException { } private void addDoc ( IndexWriter writer ) throws IOException { } } 
public class SolrWriter extends DIHWriterBase implements DIHWriter { private static final Logger log = LoggerFactory . getLogger ( SolrWriter . class ) ; static final String LAST_INDEX_KEY = "last_index_time" ; private final UpdateRequestProcessor processor ; SolrQueryRequest req ; public SolrWriter ( UpdateRequestProcessor processor , SolrQueryRequest req ) { } @ Override public void close ( ) { } @ Override public boolean upload ( SolrInputDocument d ) { } @ Override public void deleteDoc ( Object id ) { try { SolrWriter . log . info ( ( "Deleting<seq2seq4repair_space>document:<seq2seq4repair_space>" + id ) ) ; DeleteUpdateCommand delCmd = new DeleteUpdateCommand ( req ) ; <START_BUG> delCmd . id = id . toString ( ) ; <END_BUG> processor . processDelete ( delCmd ) ; } catch ( IOException e ) { SolrWriter . log . error ( ( "Exception<seq2seq4repair_space>while<seq2seq4repair_space>deleteing:<seq2seq4repair_space>" + id ) , e ) ; } } @ Override public void deleteByQuery ( String query ) { } @ Override public void commit ( boolean optimize ) { } @ Override public void rollback ( ) { } @ Override public void doDeleteAll ( ) { } static String getResourceAsString ( InputStream in ) throws IOException { } static String getDocCount ( ) { } @ Override public void init ( Context context ) { } } 
public abstract class WebApplication extends Application { private Map bufferedResponses = new HashMap ( ) ; private IRequestCycleProcessor requestCycleProcessor ; private String sessionAttributePrefix ; private ISessionFactory sessionFactory = new ISessionFactory ( ) { private static final long serialVersionUID = 1L ; public Session newSession ( ) { } } ; private WicketServlet wicketServlet ; public WebApplication ( ) { } public ApplicationSettings createApplicationSettings ( ) { } public final String getSessionAttributePrefix ( final WebRequest request ) { if ( ( sessionAttributePrefix ) == null ) { String servletPath = request . getServletPath ( ) ; if ( servletPath == null ) { throw new WicketRuntimeException ( "unable<seq2seq4repair_space>to<seq2seq4repair_space>retrieve<seq2seq4repair_space>servlet<seq2seq4repair_space>path" ) ; } <START_BUG> sessionAttributePrefix = ( "wicket-" + servletPath ) + "-" ; <END_BUG> } return sessionAttributePrefix ; } public final WicketServlet getWicketServlet ( ) { } public final void mount ( String path , IRequestTargetEncoderDecoder encoder ) { } public final void mountBookmarkablePage ( String path , Class bookmarkablePageClass ) { } public final void mountBookmarkablePage ( String path , Class bookmarkablePageClass , String pageMapName ) { } public final void mountPackage ( String path , Class classOfPackageToMount ) { } public final void setSessionFactory ( final ISessionFactory sessionFactory ) { } public final void setWicketServlet ( final WicketServlet wicketServlet ) { } public final void unmount ( String path ) { } protected IRequestCycleFactory getDefaultRequestCycleFactory ( ) { } protected IRequestCycleProcessor getDefaultRequestCycleProcessor ( ) { } protected ISessionFactory getSessionFactory ( ) { } protected void init ( ) { } protected void internalDestroy ( ) { } protected void internalInit ( ) { } protected WebRequest newWebRequest ( final HttpServletRequest servletRequest ) { } protected WebResponse newWebResponse ( final HttpServletResponse servletResponse ) { } final void addBufferedResponse ( String sessionId , String bufferId , BufferedResponse renderedResponse ) { } final void clearBufferedResponses ( String sessionId ) { } final WebSession getSession ( final WebRequest request ) { } final BufferedResponse popBufferedResponse ( String sessionId , String bufferId ) { } private void checkMountPath ( String path ) { } } 
public class CCMCheck extends Continuus { private File file = null ; private String comment = null ; private String task = null ; protected Vector filesets = new Vector ( ) ; public CCMCheck ( ) { } public File getFile ( ) { } public void setFile ( File v ) { } public String getComment ( ) { } public void setComment ( String v ) { } public String getTask ( ) { } public void setTask ( String v ) { } public void addFileset ( FileSet set ) { } public void execute ( ) throws BuildException { } private void doit ( ) { Commandline commandLine = new Commandline ( ) ; commandLine . setExecutable ( getCcmCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( getCcmAction ( ) ) ; checkOptions ( commandLine ) ; int result = run ( commandLine ) ; <START_BUG> if ( Execute . isFailure ( 0 ) ) { <END_BUG> String msg = "Failed<seq2seq4repair_space>executing:<seq2seq4repair_space>" + ( commandLine . toString ( ) ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { } public static final String FLAG_COMMENT = "/comment" ; public static final String FLAG_TASK = "/task" ; } 
public class GoModelToElements implements TreeModelPrereqs { public String toString ( ) { <START_BUG> return Localizer . localize ( "Tree" , "Namespace->Owned<seq2seq4repair_space>Element" ) ; <END_BUG> } public Object getRoot ( ) { } public void setRoot ( Object r ) { } public Object getChild ( Object parent , int index ) { } public int getChildCount ( Object parent ) { } public int getIndexOfChild ( Object parent , Object child ) { } public boolean isLeaf ( Object node ) { } public void valueForPathChanged ( TreePath path , Object newValue ) { } public void addTreeModelListener ( TreeModelListener l ) { } public void removeTreeModelListener ( TreeModelListener l ) { } public Vector getPrereqs ( ) { } public Vector getProvidedTypes ( ) { } } 
public class JoranConfigurator extends ConfiguratorBase { Interpreter joranInterpreter ; LoggerRepository repository ; boolean listAppnderAttached = false ; public JoranConfigurator ( ) { } protected interface ParseAction { void parse ( final SAXParser parser , final DefaultHandler handler ) throws IOException , SAXException { } } public final void doConfigure ( final URL url , final LoggerRepository repository ) { } public final void doConfigure ( final String filename , final LoggerRepository repository ) { } public final void doConfigure ( final File file , final LoggerRepository repository ) { } public final void doConfigure ( final InputSource source , final LoggerRepository repository ) { } public final void doConfigure ( final InputStream stream , final LoggerRepository repository ) { } protected void doConfigure ( final JoranConfigurator . ParseAction action , final LoggerRepository repository ) { this . repository = repository ; selfInitialize ( this . repository ) ; ExecutionContext ec = joranInterpreter . getExecutionContext ( ) ; List errorList = ec . getErrorList ( ) ; SAXParser saxParser = null ; try { SAXParserFactory spf = SAXParserFactory . newInstance ( ) ; spf . setValidating ( false ) ; spf . setNamespaceAware ( true ) ; saxParser = spf . newSAXParser ( ) ; } catch ( Exception pce ) { final String errMsg = "Parser<seq2seq4repair_space>configuration<seq2seq4repair_space>error<seq2seq4repair_space>occured" ; getLogger ( repository ) . error ( errMsg , pce ) ; ec . addError ( new ErrorItem ( errMsg , pce ) ) ; return ; } <START_BUG> JoranDocument document = new JoranDocument ( errorList ) ; <END_BUG> try { action . parse ( saxParser , document ) ; } catch ( IOException ie ) { final String errMsg = "I/O<seq2seq4repair_space>error<seq2seq4repair_space>occured<seq2seq4repair_space>while<seq2seq4repair_space>parsing<seq2seq4repair_space>xml<seq2seq4repair_space>file" ; getLogger ( repository ) . error ( errMsg , ie ) ; ec . addError ( new ErrorItem ( errMsg , ie ) ) ; } catch ( Exception ex ) { final String errMsg = "Problem<seq2seq4repair_space>parsing<seq2seq4repair_space>XML<seq2seq4repair_space>document.<seq2seq4repair_space>See<seq2seq4repair_space>previously<seq2seq4repair_space>reported<seq2seq4repair_space>errors.<seq2seq4repair_space>Abandoning<seq2seq4repair_space>all<seq2seq4repair_space>further<seq2seq4repair_space>processing." ; getLogger ( repository ) . error ( errMsg , ex ) ; errorList . add ( new ErrorItem ( errMsg ) ) ; return ; } ec . pushObject ( repository ) ; String errMsg ; try { attachListAppender ( repository ) ; document . replay ( joranInterpreter ) ; getLogger ( repository ) . debug ( "Finished<seq2seq4repair_space>parsing." ) ; } catch ( SAXException e ) { } finally { detachListAppender ( repository ) ; } } public List getErrorList ( ) { } protected void selfInitialize ( LoggerRepository repository ) { } public ExecutionContext getExecutionContext ( ) { } } 
class OSGiSubsystemAdd extends AbstractBoottimeAddStepHandler { static final OSGiSubsystemAdd INSTANCE = new OSGiSubsystemAdd ( ) ; private OSGiRuntimeResource resource ; private OSGiSubsystemAdd ( ) { } @ Override protected Resource createResource ( OperationContext context ) { } @ Override protected void populateModel ( final ModelNode operation , final ModelNode model ) throws OperationFailedException { } @ Override protected void performBoottime ( final OperationContext context , final ModelNode operation , final ModelNode model , final ServiceVerificationHandler verificationHandler , final List < ServiceController < ? > > newControllers ) throws OperationFailedException { OSGiLogger . LOGGER . infoActivatingSubsystem ( ) ; final Activation activation = Activation . valueOf ( ACTIVATION . resolveModelAttribute ( context , model ) . asString ( ) . toUpperCase ( Locale . ENGLISH ) ) ; final ServiceTarget serviceTarget = context . getServiceTarget ( ) ; final InitialDeploymentTracker deploymentTracker = new InitialDeploymentTracker ( context , verificationHandler ) ; final ModuleRegistrationTracker registrationTracker = new ModuleRegistrationTracker ( ) ; final List < SubsystemExtension > extensions = new ArrayList < SubsystemExtension > ( ) ; final Iterator < SubsystemExtension > services = ServiceLoader . load ( SubsystemExtension . class , getClass ( ) . getClassLoader ( ) ) . iterator ( ) ; while ( services . hasNext ( ) ) { extensions . add ( services . next ( ) ) ; } context . addStep ( new OperationStepHandler ( ) { @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { <START_BUG> newControllers . add ( FrameworkBootstrapService . addService ( serviceTarget , resource , extensions , verificationHandler ) ) ; <END_BUG> newControllers . add ( registrationTracker . install ( serviceTarget , verificationHandler ) ) ; context . completeStep ( NOOP_ROLLBACK_HANDLER ) ; } } , RUNTIME ) ; context . addStep ( new AbstractDeploymentChainStep ( ) { @ Override protected void execute ( DeploymentProcessorTarget processorTarget ) { processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , STRUCTURE , STRUCTURE_OSGI_MANIFEST , new OSGiManifestStructureProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , STRUCTURE , STRUCTURE_BUNDLE_SUB_DEPLOYMENT , new BundleSubDeploymentMarkingProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , PARSE , PARSE_OSGI_BUNDLE_INFO , new OSGiBundleInfoParseProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , PARSE , PARSE_OSGI_PROPERTIES , new OSGiXServiceParseProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , PARSE , PARSE_OSGI_DEPLOYMENT , new BundleDeploymentProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , PARSE , PARSE_OSGI_COMPONENTS , new OSGiComponentParseProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , PARSE , PARSE_OSGI_SUBSYSTEM_ACTIVATOR , new org . jboss . as . osgi . deployment . FrameworkActivateProcessor ( deploymentTracker ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , REGISTER , REGISTER_BUNDLE_INSTALL , new org . jboss . as . osgi . deployment . BundleInstallProcessor ( deploymentTracker ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , DEPENDENCIES , DEPENDENCIES_BUNDLE , new BundleDependenciesProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , CONFIGURE_MODULE , CONFIGURE_RESOLVE_BUNDLE , new BundleResolveProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , CONFIGURE_MODULE , CONFIGURE_DEFERRED_PHASE , new DeferredPhaseProcessor ( ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , INSTALL , INSTALL_RESOLVER_MODULE , new org . jboss . as . osgi . deployment . ModuleRegisterProcessor ( registrationTracker ) ) ; processorTarget . addDeploymentProcessor ( SUBSYSTEM_NAME , INSTALL , INSTALL_BUNDLE_ACTIVATE , new BundleActivateProcessor ( ) ) ; } } , RUNTIME ) ; for ( SubsystemExtension extension : extensions ) { extension . performBoottime ( context , operation , model , verificationHandler , newControllers ) ; } newControllers . add ( SubsystemState . addService ( serviceTarget , activation ) ) ; } } 
public class ErfTest { @ Test public void testErf0 ( ) { } @ Test public void testErf1960 ( ) { } @ Test public void testErf2576 ( ) { } @ Test public void testErf2807 ( ) { } @ Test public void testErf3291 ( ) { } @ Test public void testLargeValues ( ) { } @ Test public void testErfGnu ( ) { } @ Test public void testErfcGnu ( ) { } @ Test public void testErfcMaple ( ) { double [ ] [ ] ref = new double [ ] [ ] { new double [ ] { 0.1 , 0.460172162722971 } , new double [ ] { 1.2 , 0.115069670221708 } , new double [ ] { 2.3 , 0.0107241100216758 } , new double [ ] { 3.4 , 3.36929265676881E-4 } , new double [ ] { 4.5 , 3.39767312473006E-6 } , new double [ ] { 5.6 , 1.07175902583109E-8 } , new double [ ] { 6.7 , 1.04209769879652E-11 } , new double [ ] { 7.8 , 3.0953587719587E-15 } , new double [ ] { 8.9 , 2.79233437493966E-19 } , new double [ ] { 10.0 , 7.61985302416053E-24 } , new double [ ] { 11.1 , 6.27219439321703E-29 } , new double [ ] { 12.2 , 1.55411978638959E-34 } , new double [ ] { 13.3 , 1.15734162836904E-40 } , new double [ ] { 14.4 , 2.58717592540226E-47 } , new double [ ] { 15.5 , 1.73446079179387E-54 } , new double [ ] { 16.6 , 3.48454651995041E-62 } } ; for ( int i = 0 ; i < 15 ; i ++ ) { <START_BUG> final double result = 0.5 * ( Erf . erfc ( ( ( ref [ i ] [ 0 ] ) / ( Math . sqrt ( 2 ) ) ) ) ) ; <END_BUG> Assert . assertEquals ( ref [ i ] [ 1 ] , result , 1.0E-15 ) ; TestUtils . assertRelativelyEquals ( ref [ i ] [ 1 ] , result , 1.0E-13 ) ; } } @ Test public void testTwoArgumentErf ( ) { } @ Test public void testErfInvNaN ( ) { } @ Test public void testErfInvInfinite ( ) { } @ Test public void testErfInv ( ) { } @ Test public void testErfcInvNaN ( ) { } @ Test public void testErfcInvInfinite ( ) { } @ Test public void testErfcInv ( ) { } } 
public class Rpm extends AbstractTask { private String m_command = "-bb" ; private boolean m_cleanBuildDir ; private boolean m_removeSpec ; private boolean m_removeSource ; private String m_specFile ; private File m_topDir ; public void setCleanBuildDir ( boolean cleanBuildDir ) { } public void setCommand ( final String command ) { } public void setRemoveSource ( final boolean removeSource ) { } public void setRemoveSpec ( final boolean removeSpec ) { } public void setSpecFile ( final String specFile ) throws TaskException { } public void setTopDir ( final File topDir ) { } public void execute ( ) throws TaskException { final Commandline cmd = createCommand ( ) ; final Execute2 exe = new Execute2 ( ) ; setupLogger ( exe ) ; if ( ( m_topDir ) == null ) { m_topDir = getBaseDirectory ( ) ; } exe . setWorkingDirectory ( m_topDir ) ; <START_BUG> exe . setCommandline ( cmd . getCommandline ( ) ) ; <END_BUG> try { final String message = ( "Building<seq2seq4repair_space>the<seq2seq4repair_space>RPM<seq2seq4repair_space>based<seq2seq4repair_space>on<seq2seq4repair_space>the<seq2seq4repair_space>" + ( m_specFile ) ) + "<seq2seq4repair_space>file" ; getLogger ( ) . info ( message ) ; if ( 0 != ( exe . execute ( ) ) ) { throw new TaskException ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>execute<seq2seq4repair_space>rpm" ) ; } } catch ( IOException e ) { throw new TaskException ( "Error" , e ) ; } } private Commandline createCommand ( ) throws TaskException { } } 
public class DistributableSessionManagerFactoryBuilder implements org . wildfly . extension . undertow . session . DistributableSessionManagerFactoryBuilder { private final SessionManagerFactoryBuilder builder ; public DistributableSessionManagerFactoryBuilder ( ) { } public DistributableSessionManagerFactoryBuilder ( SessionManagerFactoryBuilder builder ) { } @ Override public ServiceBuilder < SessionManagerFactory > build ( ServiceTarget target , ServiceName name , ServiceName deploymentServiceName , Module module , JBossWebMetaData metaData ) { <START_BUG> ServiceName clusteringServiceName = name . append ( "distributable" ) ; <END_BUG> this . builder . buildDeploymentDependency ( target , clusteringServiceName , deploymentServiceName , module , metaData ) . setInitialMode ( ON_DEMAND ) . install ( ) ; return DistributableSessionManagerFactoryService . build ( target , name , clusteringServiceName ) ; } } 
public class ProgressMonitorJobsDialog extends ProgressMonitorDialog { private NewProgressViewer viewer ; private int viewerHeight = - 1 ; Composite viewerComposite ; private Button detailsButton ; private long watchTime = - 1 ; protected boolean alreadyClosed = false ; private IProgressMonitor wrapperedMonitor ; protected boolean enableDetailsButton = false ; public ProgressMonitorJobsDialog ( Shell parent ) { } protected Control createDialogArea ( Composite parent ) { } void handleDetailsButtonSelect ( ) { } protected void createButtonsForButtonBar ( Composite parent ) { } protected void createSpacer ( Composite parent ) { } protected void createDetailsButton ( Composite parent ) { } protected Control createButtonBar ( Composite parent ) { } protected void clearCursors ( ) { } protected void updateForSetBlocked ( IStatus reason ) { } public void run ( boolean fork , boolean cancelable , IRunnableWithProgress runnable ) throws InterruptedException , InvocationTargetException { } protected void enableDetails ( boolean enableState ) { } public void watchTicks ( ) { } public void createWrapperedMonitor ( ) { wrapperedMonitor = new IProgressMonitorWithBlocking ( ) { IProgressMonitor superMonitor = ProgressMonitorJobsDialog . super . getProgressMonitor ( ) ; public void beginTask ( String name , int totalWork ) { superMonitor . beginTask ( name , totalWork ) ; checkTicking ( ) ; } private void checkTicking ( ) { if ( ( watchTime ) < 0 ) return ; if ( ( ( System . currentTimeMillis ( ) ) - ( watchTime ) ) > ( ProgressManager . getInstance ( ) . getLongOperationTime ( ) ) ) { watchTime = - 1 ; openDialog ( ) ; } } private void openDialog ( ) { if ( ! ( PlatformUI . isWorkbenchRunning ( ) ) ) return ; PlatformUI . getWorkbench ( ) . getDisplay ( ) . syncExec ( new Runnable ( ) { public void run ( ) { <START_BUG> if ( ! ( ProgressManagerUtil . safeToOpen ( ProgressMonitorJobsDialog . this ) ) ) { <END_BUG> watchTicks ( ) ; return ; } if ( ! ( alreadyClosed ) ) open ( ) ; } } ) ; } public void done ( ) { superMonitor . done ( ) ; checkTicking ( ) ; } public void internalWorked ( double work ) { superMonitor . internalWorked ( work ) ; checkTicking ( ) ; } public boolean isCanceled ( ) { return superMonitor . isCanceled ( ) ; } public void setCanceled ( boolean value ) { superMonitor . setCanceled ( value ) ; } public void setTaskName ( String name ) { superMonitor . setTaskName ( name ) ; checkTicking ( ) ; } public void subTask ( String name ) { superMonitor . subTask ( name ) ; checkTicking ( ) ; } public void worked ( int work ) { superMonitor . worked ( work ) ; checkTicking ( ) ; } public void clearBlocked ( ) { if ( ( superMonitor ) instanceof IProgressMonitorWithBlocking ) ( ( IProgressMonitorWithBlocking ) ( superMonitor ) ) . clearBlocked ( ) ; } public void setBlocked ( IStatus reason ) { openDialog ( ) ; if ( ( superMonitor ) instanceof IProgressMonitorWithBlocking ) ( ( IProgressMonitorWithBlocking ) ( superMonitor ) ) . setBlocked ( reason ) ; } } ; } public IProgressMonitor getProgressMonitor ( ) { } public boolean close ( ) { } } 
public class Tstamp extends Task { private Vector customFormats = new Vector ( ) ; private String prefix = "" ; public void setPrefix ( String prefix ) { } public void execute ( ) throws BuildException { try { Date d = new Date ( ) ; Enumeration i = customFormats . elements ( ) ; while ( i . hasMoreElements ( ) ) { Tstamp . CustomFormat cts = ( ( Tstamp . CustomFormat ) ( i . nextElement ( ) ) ) ; <START_BUG> cts . execute ( getProject ( ) , d , location ) ; <END_BUG> } SimpleDateFormat dstamp = new SimpleDateFormat ( "yyyyMMdd" ) ; getProject ( ) . setNewProperty ( ( ( prefix ) + "DSTAMP" ) , dstamp . format ( d ) ) ; SimpleDateFormat tstamp = new SimpleDateFormat ( "HHmm" ) ; getProject ( ) . setNewProperty ( ( ( prefix ) + "TSTAMP" ) , tstamp . format ( d ) ) ; SimpleDateFormat today = new SimpleDateFormat ( "MMMM<seq2seq4repair_space>d<seq2seq4repair_space>yyyy" , Locale . US ) ; getProject ( ) . setNewProperty ( ( ( prefix ) + "TODAY" ) , today . format ( d ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public Tstamp . CustomFormat createFormat ( ) { } public class CustomFormat { private TimeZone timeZone ; private String propertyName ; private String pattern ; private String language ; private String country ; private String variant ; private int offset = 0 ; private int field = Calendar . DATE ; private String prefix = "" ; public CustomFormat ( String prefix ) { } public void setProperty ( String propertyName ) { } public void setPattern ( String pattern ) { } public void setLocale ( String locale ) { } public void setTimezone ( String id ) { } public void setOffset ( int offset ) { } public void setUnit ( String unit ) { } public void setUnit ( Tstamp . Unit unit ) { } public void execute ( Project project , Date date , Location location ) { } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String MONTH = "month" ; private static final String YEAR = "year" ; private static final String [ ] units = new String [ ] { Tstamp . Unit . MILLISECOND , Tstamp . Unit . SECOND , Tstamp . Unit . MINUTE , Tstamp . Unit . HOUR , Tstamp . Unit . DAY , Tstamp . Unit . WEEK , Tstamp . Unit . MONTH , Tstamp . Unit . YEAR } ; private Hashtable calendarFields = new Hashtable ( ) ; public Unit ( ) { } public int getCalendarField ( ) { } public String [ ] getValues ( ) { } } } 
public class AttachmentModel { private Folder folder ; private Object uid ; private List displayedMimeParts ; private MimePartTree collection ; public AttachmentModel ( ) { } public synchronized void setFolder ( Folder folder ) { } public synchronized void setUid ( Object uid ) { } public Folder getFolder ( ) { } public Object getUid ( ) { } public MimePartTree getCollection ( ) { } public void setCollection ( MimePartTree collection ) { this . collection = collection ; displayedMimeParts = collection . getAllLeafs ( ) ; MimePart bodyPart = collection . getFirstTextPart ( "plain" ) ; if ( bodyPart != null ) { MimePart bodyParent = ( ( MimePart ) ( bodyPart . getParent ( ) ) ) ; if ( bodyParent != null ) { if ( bodyParent . getHeader ( ) . contentSubtype . equals ( "alternative" ) ) { <START_BUG> Vector bodyParts = bodyParent . getChilds ( ) ; <END_BUG> displayedMimeParts . removeAll ( bodyParts ) ; } else { displayedMimeParts . remove ( bodyPart ) ; } } } } public List getDisplayedMimeParts ( ) { } public void setDisplayedMimeParts ( List displayedMimeParts ) { } } 
public abstract class PagedTableWithAlternatingRowStyle extends Table { public PagedTableWithAlternatingRowStyle ( final String componentName , final List data , int pageSize ) { } protected void populateItem ( final ListItem listItem ) { <START_BUG> listItem . addAttributeModifier ( new ComponentTagAttributeModifier ( "class" , new wicket . Model ( ( listItem . isEvenIndex ( ) ? "even" : "odd" ) ) ) ) ; <END_BUG> } } 
public class FormatterElement { private OutputStream out = new KeepAliveOutputStream ( System . out ) ; private String classname ; private Vector filters = new Vector ( ) ; public void setType ( FormatterElement . TypeAttribute type ) { } public void setClassname ( String classname ) { } public void setFilters ( String filters ) { } public void addFilter ( FilterElement fe ) { } public void setOutput ( OutputAttribute output ) { } protected Formatter createFormatter ( ) throws BuildException { } public static class TypeAttribute extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { "plain" , "xml" , "brief" } ; private static final String [ ] CLASSNAMES = new String [ ] { "xxx" , XMLFormatter . class . getName ( ) , BriefFormatter . class . getName ( ) } ; public String [ ] getValues ( ) { } public String getClassName ( ) { <START_BUG> return FormatterElement . TypeAttribute . CLASSNAMES [ index ] ; <END_BUG> } } } 
public class Decorations extends Canvas { Image image ; Image [ ] images = new Image [ 0 ] ; Menu menuBar ; String text = "" ; boolean minimized ; boolean maximized ; Control savedFocus ; Button defaultButton ; Decorations ( ) { } public Decorations ( Composite parent , int style ) { } static int checkStyle ( int style ) { } void bringToTop ( boolean force ) { } protected void checkSubclass ( ) { } int compare ( ImageData data1 , ImageData data2 ) { } Control computeTabGroup ( ) { } Control computeTabRoot ( ) { } public Button getDefaultButton ( ) { } public Image getImage ( ) { } public Image [ ] getImages ( ) { } public boolean getMaximized ( ) { } public Menu getMenuBar ( ) { } public boolean getMinimized ( ) { } String getNameText ( ) { } public String getText ( ) { } boolean isTabGroup ( ) { } boolean isTabItem ( ) { } Decorations menuShell ( ) { } void releaseChildren ( boolean destroy ) { } void releaseWidget ( ) { } boolean restoreFocus ( ) { } void saveFocus ( ) { int window = OS . GetControlOwner ( handle ) ; <START_BUG> Control control = display . getFocusControl ( window ) ; <END_BUG> if ( ( ( control != null ) && ( control != ( this ) ) ) && ( ( this ) == ( control . menuShell ( ) ) ) ) { setSavedFocus ( control ) ; } } public void setDefaultButton ( Button button ) { } public void setImage ( Image image ) { } public void setImages ( Image [ ] images ) { } public void setMaximized ( boolean maximized ) { } public void setMenuBar ( Menu menu ) { } public void setMinimized ( boolean minimized ) { } void setSavedFocus ( Control control ) { } public void setText ( String string ) { } void sort ( Image [ ] images ) { } boolean traverseItem ( boolean next ) { } boolean traverseReturn ( ) { } } 
public abstract class ConfigurationHandler { private File _loadedFromFile = null ; private URL _loadedFromURL = null ; private boolean _changeable = false ; private boolean _loaded = false ; private boolean _changed = false ; private static PropertyChangeSupport _pcl = null ; public ConfigurationHandler ( ) { } public ConfigurationHandler ( boolean changeable ) { } public abstract String getDefaultPath ( ) { } private void loadIfNecessary ( ) { } public final boolean loadDefault ( ) { } public final boolean saveDefault ( ) { } public final boolean saveDefault ( boolean force ) { } public final boolean isChangeable ( ) { } public final boolean isChanged ( ) { } public final boolean isLoaded ( ) { } public final boolean load ( File file ) { } public final boolean load ( URL url ) { } public final boolean save ( File file ) { } public final boolean save ( URL url ) { } public final String getString ( ConfigurationKey key , String defaultValue ) { } public final int getInteger ( ConfigurationKey key , int defaultValue ) { } public final double getDouble ( ConfigurationKey key , double defaultValue ) { } public final boolean getBoolean ( ConfigurationKey key , boolean defaultValue ) { loadIfNecessary ( ) ; Boolean dflt = new Boolean ( defaultValue ) ; <START_BUG> Boolean b = new Boolean ( getValue ( key . getKey ( ) , dflt . toString ( ) ) ) ; <END_BUG> return b . booleanValue ( ) ; } private final synchronized void workerSetValue ( ConfigurationKey key , String newValue ) { } public final void setString ( ConfigurationKey key , String newValue ) { } public final void setInteger ( ConfigurationKey key , int value ) { } public final void setDouble ( ConfigurationKey key , double value ) { } public final void setBoolean ( ConfigurationKey key , boolean value ) { } public final void addListener ( PropertyChangeListener pcl ) { } public final void removeListener ( PropertyChangeListener pcl ) { } public final void addListener ( ConfigurationKey key , PropertyChangeListener pcl ) { } public final void removeListener ( ConfigurationKey key , PropertyChangeListener pcl ) { } boolean loadUnspecified ( ) { } boolean saveUnspecified ( ) { } abstract boolean loadFile ( File file ) { } abstract boolean loadURL ( URL url ) { } abstract boolean saveFile ( File file ) { } abstract boolean saveURL ( URL url ) { } public boolean hasKey ( ConfigurationKey key ) { } public abstract String getValue ( String key , String defaultValue ) { } abstract void setValue ( String key , String value ) { } } 
public class TransactionalSpoutCoordinator extends BaseRichSpout { public static final Logger LOG = Logger . getLogger ( TransactionalSpoutCoordinator . class ) ; public static final BigInteger INIT_TXID = BigInteger . ONE ; public static final String TRANSACTION_BATCH_STREAM_ID = ( TransactionalSpoutCoordinator . class . getName ( ) ) + "/batch" ; public static final String TRANSACTION_COMMIT_STREAM_ID = ( TransactionalSpoutCoordinator . class . getName ( ) ) + "/commit" ; private static final String CURRENT_TX = "currtx" ; private static final String META_DIR = "meta" ; private ITransactionalSpout _spout ; private Coordinator _coordinator ; private TransactionalState _state ; private RotatingTransactionalState _coordinatorState ; TreeMap < BigInteger , TransactionalSpoutCoordinator . TransactionStatus > _activeTx = new TreeMap < BigInteger , TransactionalSpoutCoordinator . TransactionStatus > ( ) ; private SpoutOutputCollector _collector ; BigInteger _currTransaction ; int _maxTransactionActive ; TransactionalSpoutCoordinator . StateInitializer _initializer ; public TransactionalSpoutCoordinator ( ITransactionalSpout spout ) { } public ITransactionalSpout getSpout ( ) { } @ Override public void open ( Map conf , TopologyContext context , SpoutOutputCollector collector ) { } @ Override public void close ( ) { } @ Override public void nextTuple ( ) { } @ Override public void ack ( Object msgId ) { } @ Override public void fail ( Object msgId ) { } @ Override public void declareOutputFields ( OutputFieldsDeclarer declarer ) { } private void sync ( ) { TransactionalSpoutCoordinator . TransactionStatus maybeCommit = _activeTx . get ( _currTransaction ) ; if ( ( maybeCommit != null ) && ( ( maybeCommit . status ) == ( TransactionalSpoutCoordinator . AttemptStatus . PROCESSED ) ) ) { maybeCommit . status = TransactionalSpoutCoordinator . AttemptStatus . COMMITTING ; _collector . emit ( TransactionalSpoutCoordinator . TRANSACTION_COMMIT_STREAM_ID , new backtype . storm . tuple . Values ( maybeCommit . attempt ) , maybeCommit . attempt ) ; } try { <START_BUG> if ( ( _activeTx . size ( ) ) < ( _maxTransactionActive ) ) { <END_BUG> BigInteger curr = _currTransaction ; for ( int i = 0 ; i < ( _maxTransactionActive ) ; i ++ ) { if ( ! ( _activeTx . containsKey ( curr ) ) ) { TransactionAttempt attempt = new TransactionAttempt ( curr , Utils . randomLong ( ) ) ; Object state = _coordinatorState . getState ( curr , _initializer ) ; _activeTx . put ( curr , new TransactionalSpoutCoordinator . TransactionStatus ( attempt ) ) ; _collector . emit ( TransactionalSpoutCoordinator . TRANSACTION_BATCH_STREAM_ID , new backtype . storm . tuple . Values ( attempt , state , previousTransactionId ( _currTransaction ) ) , attempt ) ; } curr = nextTransactionId ( curr ) ; } } } catch ( FailedException e ) { TransactionalSpoutCoordinator . LOG . warn ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>get<seq2seq4repair_space>metadata<seq2seq4repair_space>for<seq2seq4repair_space>a<seq2seq4repair_space>transaction" , e ) ; } } @ Override public Map < String , Object > getComponentConfiguration ( ) { } private static enum AttemptStatus { PROCESSING , PROCESSED , COMMITTING ; } private static class TransactionStatus { TransactionAttempt attempt ; TransactionalSpoutCoordinator . AttemptStatus status ; public TransactionStatus ( TransactionAttempt attempt ) { } @ Override public String toString ( ) { } } private BigInteger nextTransactionId ( BigInteger id ) { } private BigInteger previousTransactionId ( BigInteger id ) { } private BigInteger getStoredCurrTransaction ( TransactionalState state ) { } private class StateInitializer implements RotatingTransactionalState . StateInitializer { @ Override public Object init ( BigInteger txid , Object lastState ) { } } } 
public class ZipEntry extends java . util . zip . ZipEntry implements Cloneable { public static final int PLATFORM_UNIX = 3 ; public static final int PLATFORM_FAT = 0 ; private static final int SHORT_MASK = 65535 ; private static final int SHORT_SHIFT = 16 ; private int internalAttributes = 0 ; private int platform = ZipEntry . PLATFORM_FAT ; private long externalAttributes = 0 ; private Vector extraFields = null ; private String name = null ; public ZipEntry ( String name ) { } public ZipEntry ( java . util . zip . ZipEntry entry ) throws ZipException { } public ZipEntry ( ZipEntry entry ) throws ZipException { } protected ZipEntry ( ) { } public Object clone ( ) { } public int getInternalAttributes ( ) { } public void setInternalAttributes ( int value ) { } public long getExternalAttributes ( ) { } public void setExternalAttributes ( long value ) { } public void setUnixMode ( int mode ) { } public int getUnixMode ( ) { } public int getPlatform ( ) { } protected void setPlatform ( int platform ) { } public void setExtraFields ( ZipExtraField [ ] fields ) { } public ZipExtraField [ ] getExtraFields ( ) { } public void addExtraField ( ZipExtraField ze ) { } public void removeExtraField ( ZipShort type ) { } public void setExtra ( byte [ ] extra ) throws RuntimeException { try { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } catch ( Exception e ) { <START_BUG> throw new RuntimeException ( e . getMessage ( ) ) ; <END_BUG> } } protected void setExtra ( ) { } public byte [ ] getLocalFileDataExtra ( ) { } public byte [ ] getCentralDirectoryExtra ( ) { } public void setComprSize ( long size ) { } public String getName ( ) { } public boolean isDirectory ( ) { } protected void setName ( String name ) { } public int hashCode ( ) { } public boolean equals ( Object o ) { } } 
public abstract class AbstractLoggingSubsystemTest extends AbstractSubsystemBaseTest { static final String [ ] HANDLER_RESOURCE_KEYS = new String [ ] { CommonAttributes . ASYNC_HANDLER , CommonAttributes . CONSOLE_HANDLER , CommonAttributes . CUSTOM_HANDLER , CommonAttributes . FILE_HANDLER , CommonAttributes . PERIODIC_ROTATING_FILE_HANDLER , CommonAttributes . SIZE_ROTATING_FILE_HANDLER } ; public static final PathElement SUBSYSTEM_PATH = PathElement . pathElement ( SUBSYSTEM , SUBSYSTEM_NAME ) ; static PathAddress SUBSYSTEM_ADDRESS = PathAddress . pathAddress ( AbstractLoggingSubsystemTest . SUBSYSTEM_PATH ) ; public AbstractLoggingSubsystemTest ( ) { } @ BeforeClass public static void setUp ( ) { } @ After public void clearLogContext ( ) { } protected void clearLogContext ( final LogContext logContext ) { } @ Override protected AdditionalInitialization createAdditionalInitialization ( ) { } @ Override protected void compareXml ( String configId , String original , String marshalled ) throws Exception { } static PathAddress createAddress ( final String resourceKey , final String resourceName ) { } static PathAddress createAddress ( final String profileName , final String resourceKey , final String resourceName ) { } static PathAddress createRootLoggerAddress ( ) { } static PathAddress createRootLoggerAddress ( final String profileName ) { } static PathAddress createLoggerAddress ( final String name ) { } static PathAddress createLoggerAddress ( final String profileName , final String name ) { } static PathAddress createConsoleHandlerAddress ( final String name ) { } static PathAddress createConsoleHandlerAddress ( final String profileName , final String name ) { } static PathAddress createFileHandlerAddress ( final String name ) { } static PathAddress createFileHandlerAddress ( final String profileName , final String name ) { } protected KernelServices boot ( ) throws Exception { <START_BUG> final KernelServices kernelServices = createKernelServicesBuilder ( LoggingTestEnvironment . get ( ) ) . setSubsystemXml ( getSubsystemXml ( ) ) . build ( ) ; <END_BUG> final Throwable bootError = kernelServices . getBootError ( ) ; Assert . assertTrue ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>boot:<seq2seq4repair_space>" + ( String . valueOf ( bootError ) ) ) , kernelServices . isSuccessfulBoot ( ) ) ; return kernelServices ; } protected void compare ( final String profileName , final ModelNode node1 , final ModelNode node2 ) { } protected void compare ( final ModelNode currentModel , final ConfigurationPersistence config ) throws OperationFailedException { } protected void compare ( final String profileName , final ModelNode currentModel , final ConfigurationPersistence config ) throws OperationFailedException { } protected void compareLoggers ( final LogContextConfiguration logContextConfiguration , final ModelNode model ) { } protected void compareHandlers ( final LogContextConfiguration logContextConfig , final Collection < String > handlerNames , final ModelNode model ) throws OperationFailedException { } protected ModelNode findHandlerModel ( final ModelNode model , final String name ) { } protected List < String > getHandlerNames ( final ModelNode currentModel ) { } static List < String > modelNodeAsStringList ( final ModelNode node ) { } static ModelNode getSubsystemModel ( final KernelServices kernelServices ) throws OperationFailedException { } static String resolveRelativePath ( final KernelServices kernelServices , final String relativeTo ) throws OperationFailedException { } static class RemoveOperationComparator implements Comparator < PathAddress > { static final AbstractLoggingSubsystemTest . RemoveOperationComparator INSTANCE = new AbstractLoggingSubsystemTest . RemoveOperationComparator ( ) ; static final int GREATER = 1 ; static final int EQUAL = 0 ; static final int LESS = - 1 ; @ Override public int compare ( final PathAddress o1 , final PathAddress o2 ) { } private int compare ( final String key1 , final String key2 ) { } } } 
public class JavaBuilder extends IncrementalProjectBuilder { IProject currentProject ; JavaProject javaProject ; IWorkspaceRoot workspaceRoot ; CompilationParticipant [ ] participants ; NameEnvironment nameEnvironment ; SimpleLookupTable binaryLocationsPerProject ; public State lastState ; BuildNotifier notifier ; char [ ] [ ] extraResourceFileFilters ; String [ ] extraResourceFolderFilters ; public static final String SOURCE_ID = "JDT" ; public static boolean DEBUG = false ; static ArrayList builtProjects = null ; public static IMarker [ ] getProblemsFor ( IResource resource ) { } public static IMarker [ ] getTasksFor ( IResource resource ) { } public static void buildStarting ( ) { } public static void buildFinished ( ) { } public static void removeProblemsFor ( IResource resource ) { } public static void removeTasksFor ( IResource resource ) { } public static void removeProblemsAndTasksFor ( IResource resource ) { } public static State readState ( IProject project , DataInputStream in ) throws IOException { } public static void writeState ( Object state , DataOutputStream out ) throws IOException { } protected IProject [ ] build ( int kind , Map ignored , IProgressMonitor monitor ) throws CoreException { } private void buildAll ( ) { } private void buildDeltas ( SimpleLookupTable deltas ) { } protected void clean ( IProgressMonitor monitor ) throws CoreException { } private void cleanup ( ) { } private void clearLastState ( ) { } boolean filterExtraResource ( IResource resource ) { } private SimpleLookupTable findDeltas ( ) { } public State getLastState ( IProject project ) { } private IProject [ ] getRequiredProjects ( boolean includeBinaryPrerequisites ) { } boolean hasBuildpathErrors ( ) throws CoreException { } private boolean hasClasspathChanged ( ) { } private boolean hasJavaBuilder ( IProject project ) throws CoreException { } private boolean hasStructuralDelta ( ) { } private int initializeBuilder ( int kind , boolean forBuild ) throws CoreException { this . javaProject = ( ( JavaProject ) ( JavaCore . create ( currentProject ) ) ) ; this . workspaceRoot = currentProject . getWorkspace ( ) . getRoot ( ) ; if ( forBuild ) { this . participants = JavaModelManager . getJavaModelManager ( ) . compilationParticipants . getCompilationParticipants ( this . javaProject ) ; if ( ( this . participants ) != null ) for ( int i = 0 , l = this . participants . length ; i < l ; i ++ ) if ( ( this . participants [ i ] . aboutToBuild ( this . javaProject ) ) == ( CompilationParticipant . NEEDS_FULL_BUILD ) ) kind = IncrementalProjectBuilder . FULL_BUILD ; String projectName = currentProject . getName ( ) ; if ( ( ( JavaBuilder . builtProjects ) == null ) || ( JavaBuilder . builtProjects . contains ( projectName ) ) ) { org . eclipse . jdt . internal . core . JavaModel . flushExternalFileCache ( ) ; JavaBuilder . builtProjects = new ArrayList ( ) ; } JavaBuilder . builtProjects . add ( projectName ) ; } this . binaryLocationsPerProject = new SimpleLookupTable ( 3 ) ; <START_BUG> this . nameEnvironment = new NameEnvironment ( workspaceRoot , javaProject , binaryLocationsPerProject ) ; <END_BUG> if ( forBuild ) { String filterSequence = javaProject . getOption ( JavaCore . CORE_JAVA_BUILD_RESOURCE_COPY_FILTER , true ) ; char [ ] [ ] filters = ( ( filterSequence != null ) && ( ( filterSequence . length ( ) ) > 0 ) ) ? CharOperation . splitAndTrimOn ( ',' , filterSequence . toCharArray ( ) ) : null ; if ( filters == null ) { this . extraResourceFileFilters = null ; this . extraResourceFolderFilters = null ; } else { int fileCount = 0 ; int folderCount = 0 ; for ( int i = 0 , l = filters . length ; i < l ; i ++ ) { char [ ] f = filters [ i ] ; if ( ( f . length ) == 0 ) continue ; if ( ( f [ ( ( f . length ) - 1 ) ] ) == '/' ) folderCount ++ ; else fileCount ++ ; } this . extraResourceFileFilters = new char [ fileCount ] [ ] ; this . extraResourceFolderFilters = new String [ folderCount ] ; for ( int i = 0 , l = filters . length ; i < l ; i ++ ) { char [ ] f = filters [ i ] ; if ( ( f . length ) == 0 ) continue ; if ( ( f [ ( ( f . length ) - 1 ) ] ) == '/' ) extraResourceFolderFilters [ ( -- folderCount ) ] = new String ( f , 0 , ( ( f . length ) - 1 ) ) ; else extraResourceFileFilters [ ( -- fileCount ) ] = f ; } } } return kind ; } private boolean isClasspathBroken ( IClasspathEntry [ ] classpath , IProject p ) throws CoreException { } private boolean isWorthBuilding ( ) throws CoreException { } void mustPropagateStructuralChanges ( ) { } private void printLocations ( ClasspathLocation [ ] newLocations , ClasspathLocation [ ] oldLocations ) { } private void recordNewState ( State state ) { } public String toString ( ) { } } 
public class MemoryLeakFixesTest extends BaseJDBCTestCase { public MemoryLeakFixesTest ( String name ) { } private static long HALFMB = 500 * 1024 ; private static int numRows = 100 ; private static int numPreparedStmts = 2000 ; public void testPrepStmtD210 ( ) throws Exception { } public void testReExecuteD557 ( ) throws Exception { } public void testResultSetgcD3316 ( ) throws Exception { } public void testRepeatedDatabaseCreationWithAutoStats ( ) throws SQLException { final String DB_NAME = "derby-memory-test" ; final File DB_DIR = new File ( "system" , DB_NAME ) ; DataSource ds = JDBCDataSource . getDataSource ( DB_NAME ) ; int iter = 0 ; while ( iter < 50 ) { <START_BUG> traceit ( ( "--<seq2seq4repair_space>" + ( iter ++ ) ) ) ; <END_BUG> if ( PrivilegedFileOpsForTests . exists ( DB_DIR ) ) { assertDirectoryDeleted ( DB_DIR ) ; } JDBCDataSource . setBeanProperty ( ds , "createDatabase" , "create" ) ; Connection conn = ds . getConnection ( ) ; JDBCDataSource . clearStringBeanProperty ( ds , "createDatabase" ) ; Statement s = conn . createStatement ( ) ; s . executeUpdate ( "CREATE<seq2seq4repair_space>TABLE<seq2seq4repair_space>TEST<seq2seq4repair_space>(CINT<seq2seq4repair_space>INT)" ) ; s . executeUpdate ( "CREATE<seq2seq4repair_space>INDEX<seq2seq4repair_space>NDX<seq2seq4repair_space>ON<seq2seq4repair_space>TEST<seq2seq4repair_space>(CINT)" ) ; for ( int i = 0 ; i < 500 ; i ++ ) { s . executeUpdate ( ( ( "INSERT<seq2seq4repair_space>INTO<seq2seq4repair_space>TEST<seq2seq4repair_space>VALUES(" + i ) + ")" ) ) ; s . executeQuery ( ( "SELECT<seq2seq4repair_space>*<seq2seq4repair_space>FROM<seq2seq4repair_space>TEST<seq2seq4repair_space>WHERE<seq2seq4repair_space>CINT=" + i ) ) . close ( ) ; } s . close ( ) ; conn . close ( ) ; JDBCDataSource . setBeanProperty ( ds , "shutdownDatabase" , "shutdown" ) ; try { ds . getConnection ( ) ; fail ( "Expected<seq2seq4repair_space>shutdown<seq2seq4repair_space>exception" ) ; } catch ( SQLException e ) { assertSQLState ( "08006" , e ) ; } finally { JDBCDataSource . clearStringBeanProperty ( ds , "shutdownDatabase" ) ; } if ( isPhoneME ( ) ) { Runtime . getRuntime ( ) . gc ( ) ; } } assertTrue ( PrivilegedFileOpsForTests . exists ( DB_DIR ) ) ; } private static void runFinalizerIfNeeded ( ) { } public static Test suite ( ) { } } 
class Client implements IConnection { private static final Logger LOG = LoggerFactory . getLogger ( Client . class ) ; private final int max_retries ; private final int base_sleep_ms ; private final int max_sleep_ms ; private LinkedBlockingQueue < Object > message_queue ; private AtomicReference < Channel > channelRef ; private final ClientBootstrap bootstrap ; private InetSocketAddress remote_addr ; private AtomicInteger retries ; private final Random random = new Random ( ) ; private final ChannelFactory factory ; private AtomicBoolean ready_to_release_resource ; private final int buffer_size ; private final AtomicBoolean being_closed ; @ SuppressWarnings ( "rawtypes" ) Client ( Map storm_conf , String host , int port ) { } void reconnect ( ) { } private int getSleepTimeMs ( ) { } public void send ( int task , byte [ ] message ) { } ArrayList < Object > takeMessages ( ) throws InterruptedException { int size = 0 ; ArrayList < Object > requests = new ArrayList < Object > ( ) ; requests . add ( message_queue . take ( ) ) ; for ( Object msg = message_queue . poll ( ) ; msg != null ; msg = message_queue . poll ( ) ) { requests . add ( msg ) ; <START_BUG> if ( msg . equals ( ControlMessage . closeMessage ( ) ) ) <END_BUG> break ; TaskMessage taskMsg = ( ( TaskMessage ) ( msg ) ) ; size += ( ( taskMsg . message ( ) ) != null ? taskMsg . message ( ) . length : 0 ) + 6 ; if ( size > ( buffer_size ) ) break ; } return requests ; } public void close ( ) { } void close_n_release ( ) { } public TaskMessage recv ( int flags ) { } void setChannel ( Channel channel ) { } } 
public class TestFrenchAnalyzer extends BaseTokenStreamTestCase { public void testAnalyzer ( ) throws Exception { } public void testReusableTokenStream ( ) throws Exception { } public void testExclusionTableViaCtor ( ) throws Exception { } public void testElision ( ) throws Exception { } public void testStopwordsCasing ( ) throws IOException { } public void testRandomStrings ( ) throws Exception { <START_BUG> checkRandomData ( random ( ) , new FrenchAnalyzer ( TEST_VERSION_CURRENT ) , ( 10000 * ( RANDOM_MULTIPLIER ) ) ) ; <END_BUG> } public void testAccentInsensitive ( ) throws Exception { } } 
public class ToolBar extends Composite { ToolItem lastFocus ; ImageList imageList ; public ToolBar ( Composite parent , int style ) { } static int checkStyle ( int style ) { } protected void checkSubclass ( ) { } void createHandle ( int index ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } int eventHandle ( ) { } void fixChildren ( Shell newShell , Shell oldShell , Decorations newDecorations , Decorations oldDecorations , Menu [ ] menus ) { } boolean forceFocus ( int focusHandle ) { } public ToolItem getItem ( int index ) { } public ToolItem getItem ( Point point ) { } public int getItemCount ( ) { } public ToolItem [ ] getItems ( ) { } public int getRowCount ( ) { } int gtk_key_press_event ( int widget , int eventPtr ) { } boolean hasFocus ( ) { } public int indexOf ( ToolItem item ) { } boolean mnemonicHit ( char key ) { } boolean mnemonicMatch ( char key ) { } void relayout ( ) { } void releaseChildren ( boolean destroy ) { ToolItem [ ] items = getItems ( ) ; for ( int i = 0 ; i < ( items . length ) ; i ++ ) { ToolItem item = items [ i ] ; if ( ( item != null ) && ( ! ( item . isDisposed ( ) ) ) ) { <START_BUG> item . releaseChildren ( false ) ; <END_BUG> } } super . releaseChildren ( destroy ) ; } void releaseWidget ( ) { } void removeControl ( Control control ) { } int setBounds ( int x , int y , int width , int height , boolean move , boolean resize ) { } void setFontDescription ( int font ) { } void setForegroundColor ( GdkColor color ) { } public void setToolTipText ( String string ) { } } 
public class Snippet6 { public static void main ( String [ ] args ) { Display display = new Display ( ) ; final Shell shell = new Shell ( display ) ; shell . setLayout ( new GridLayout ( ) ) ; final Composite c = new Composite ( shell , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 3 ; c . setLayout ( layout ) ; for ( int i = 0 ; i < 10 ; i ++ ) { Button b = new Button ( c , SWT . PUSH ) ; b . setText ( ( "Button<seq2seq4repair_space>" + i ) ) ; } Button b = new Button ( shell , SWT . PUSH ) ; b . setText ( "add<seq2seq4repair_space>a<seq2seq4repair_space>new<seq2seq4repair_space>button<seq2seq4repair_space>at<seq2seq4repair_space>row<seq2seq4repair_space>2<seq2seq4repair_space>column<seq2seq4repair_space>1" ) ; final int [ ] index = new int [ 1 ] ; b . addListener ( Selection , new Listener ( ) { public void handleEvent ( Event e ) { Button b = new Button ( c , SWT . PUSH ) ; b . setText ( ( "Special<seq2seq4repair_space>" + ( index [ 0 ] ) ) ) ; ( index [ 0 ] ) ++ ; Control [ ] children = c . getChildren ( ) ; b . moveAbove ( children [ 3 ] ) ; <START_BUG> shell . layout ( true ) ; <END_BUG> } } ) ; shell . open ( ) ; while ( ! ( shell . isDisposed ( ) ) ) { if ( ! ( display . readAndDispatch ( ) ) ) display . sleep ( ) ; } display . dispose ( ) ; } } 
class CoolBarTab extends Tab { CoolBar coolBar ; CoolItem pushItem ; CoolItem dropDownItem ; CoolItem radioItem ; CoolItem checkItem ; CoolItem textItem ; Group coolBarGroup ; Button horizontalButton ; Button verticalButton ; Button dropDownButton ; Button flatButton ; Button lockedButton ; Point [ ] sizes ; int [ ] wrapIndices ; int [ ] order ; CoolBarTab ( ControlExample instance ) { } void createOtherGroup ( ) { } void createExampleGroup ( ) { super . createExampleGroup ( ) ; coolBarGroup = new Group ( exampleGroup , SWT . NONE ) ; coolBarGroup . setLayout ( new GridLayout ( ) ) ; <START_BUG> coolBarGroup . setLayoutData ( new GridData ( ( ( ( GridData . GRAB_HORIZONTAL ) | ( GridData . HORIZONTAL_ALIGN_FILL ) ) | ( GridData . VERTICAL_ALIGN_FILL ) ) ) ) ; <END_BUG> coolBarGroup . setText ( "CoolBar" ) ; } void createExampleWidgets ( ) { } void createStyleGroup ( ) { } void disposeExampleWidgets ( ) { } Item [ ] getExampleWidgetItems ( ) { } Control [ ] getExampleWidgets ( ) { } String [ ] getMethodNames ( ) { } String getTabText ( ) { } void setExampleWidgetState ( ) { } void setWidgetLocked ( ) { } class DropDownSelectionListener extends SelectionAdapter { private Menu menu = null ; private boolean visible = false ; public void widgetSelected ( SelectionEvent event ) { } private void setMenuVisible ( boolean visible ) { } } class CoolItemSelectionListener extends SelectionAdapter { private Menu menu = null ; public void widgetSelected ( SelectionEvent event ) { } } } 
public class NewEditorAction extends ActiveEditorAction { public NewEditorAction ( IWorkbenchWindow window ) { } public void run ( ) { WorkbenchPage page = ( ( WorkbenchPage ) ( getActivePage ( ) ) ) ; IEditorPart editor = getActiveEditor ( ) ; if ( ( page == null ) || ( editor == null ) ) { return ; } String editorId = editor . getSite ( ) . getId ( ) ; if ( editorId == null ) { return ; } try { <START_BUG> page . openEditor ( editor . getEditorInput ( ) , editorId , true , false ) ; <END_BUG> } catch ( PartInitException e ) { DialogUtil . openError ( page . getWorkbenchWindow ( ) . getShell ( ) , Error , e . getMessage ( ) , e ) ; } } } 
public class ChatRoomBot implements IIMMessageListener { protected IChatRoomBotEntry bot ; protected IContainer container ; protected ID targetID ; protected IChatRoomContainer roomContainer ; protected ID roomID ; public ChatRoomBot ( IChatRoomBotEntry bot ) { } protected void fireInitBot ( ) { } protected void firePreConnect ( ) { } protected void firePreRoomConnect ( ) { } public synchronized void connect ( ) throws ECFException { fireInitBot ( ) ; try { Namespace namespace = null ; if ( ( container ) == null ) { container = ContainerFactory . getDefault ( ) . createContainer ( bot . getContainerFactoryName ( ) ) ; namespace = container . getConnectNamespace ( ) ; } else throw new org . eclipse . ecf . core . ContainerConnectException ( Messages . DefaultChatRoomBot_EXCEPTION_ALREADY_CONNECTED ) ; targetID = IDFactory . getDefault ( ) . createID ( namespace , bot . getConnectID ( ) ) ; IChatRoomManager manager = ( ( IChatRoomManager ) ( container . getAdapter ( IChatRoomManager . class ) ) ) ; if ( manager == null ) throw new ECFException ( Messages . DefaultChatRoomBot_EXCEPTION_NO_CHAT_ROOM ) ; firePreConnect ( ) ; String password = bot . getPassword ( ) ; IConnectContext context = ( password == null ) ? null : ConnectContextFactory . createPasswordConnectContext ( password ) ; container . connect ( targetID , context ) ; IChatRoomInfo room = manager . getChatRoomInfo ( bot . getChatRoom ( ) ) ; <START_BUG> IChatRoomContainer roomContainer = room . createChatRoomContainer ( ) ; <END_BUG> roomID = room . getRoomID ( ) ; firePreRoomConnect ( ) ; roomContainer . addMessageListener ( this ) ; String roomPassword = bot . getChatRoomPassword ( ) ; IConnectContext roomContext = ( roomPassword == null ) ? null : ConnectContextFactory . createPasswordConnectContext ( roomPassword ) ; roomContainer . connect ( roomID , roomContext ) ; } catch ( ECFException e ) { if ( ( container ) != null ) { if ( ( container . getConnectedID ( ) ) != null ) { container . disconnect ( ) ; } container . dispose ( ) ; } container = null ; throw e ; } } public void handleMessageEvent ( IIMMessageEvent event ) { } } 
final class JVMOptionAddHandler implements OperationStepHandler , DescriptionProvider { static final String OPERATION_NAME = "add-jvm-option" ; static final JVMOptionAddHandler INSTANCE = new JVMOptionAddHandler ( ) ; private final ParameterValidator validator = new StringLengthValidator ( 1 ) ; @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { validator . validateParameter ( JVM_OPTION , operation . get ( JVM_OPTION ) ) ; final Resource resource = context . readResourceForUpdate ( EMPTY_ADDRESS ) ; final ModelNode model = resource . getModel ( ) ; final ModelNode option = operation . require ( JVM_OPTION ) ; ModelNode jvmOptions = model . get ( JVM_OPTIONS ) ; if ( jvmOptions . isDefined ( ) ) { for ( ModelNode optionNode : jvmOptions . asList ( ) ) { if ( optionNode . equals ( option ) ) { throw HostControllerMessages . MESSAGES . jvmOptionAlreadyExists ( option . asString ( ) ) ; } } } model . get ( JVM_OPTIONS ) . add ( option ) ; <START_BUG> context . completeStep ( ) ; <END_BUG> } @ Override public ModelNode getModelDescription ( Locale locale ) { } } 
public class TreeColumn extends Item { Tree parent ; boolean resizable ; boolean moveable ; public TreeColumn ( Tree parent , int style ) { } public TreeColumn ( Tree parent , int style , int index ) { } public void addControlListener ( ControlListener listener ) { } public void addSelectionListener ( SelectionListener listener ) { } static int checkStyle ( int style ) { } protected void checkSubclass ( ) { } public int getAlignment ( ) { } public boolean getMoveable ( ) { } String getNameText ( ) { } public Tree getParent ( ) { } public boolean getResizable ( ) { } public int getWidth ( ) { } public void pack ( ) { } void releaseChild ( ) { } void releaseWidget ( ) { super . releaseWidget ( ) ; <START_BUG> if ( ( ( parent ) != null ) && ( ( parent . sortColumn ) == ( this ) ) ) { <END_BUG> parent . sortColumn = null ; } parent = null ; } public void removeControlListener ( ControlListener listener ) { } public void removeSelectionListener ( SelectionListener listener ) { } public void setAlignment ( int alignment ) { } public void setImage ( Image image ) { } void setImage ( Image image , boolean sort , boolean right ) { } public void setMoveable ( boolean moveable ) { } public void setResizable ( boolean resizable ) { } void setSortDirection ( int direction ) { } public void setText ( String string ) { } public void setWidth ( int width ) { } } 
private static Logger logger = LoggerFactory . getLogger ( CassandraServer . class ) ; private static final List < ColumnOrSuperColumn > EMPTY_COLUMNS = Collections . emptyList ( ) ; private static final List < Column > EMPTY_SUBCOLUMNS = Collections . emptyList ( ) ; private ThreadLocal < AccessLevel > loginDone = new ThreadLocal < AccessLevel > ( ) { @ Override protected AccessLevel initialValue ( ) { } } ; private final StorageService storageService ; public CassandraServer ( ) { } protected Map < byte [ ] , ColumnFamily > readColumnFamily ( List < ReadCommand > commands , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } public List < Column > thriftifySubColumns ( Collection < IColumn > columns ) { } public List < ColumnOrSuperColumn > thriftifyColumns ( Collection < IColumn > columns , boolean reverseOrder ) { } private List < ColumnOrSuperColumn > thriftifySuperColumns ( Collection < IColumn > columns , boolean reverseOrder ) { } private Map < byte [ ] , List < ColumnOrSuperColumn > > getSlice ( List < ReadCommand > commands , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } private List < ColumnOrSuperColumn > thriftifyColumnFamily ( ColumnFamily cf , boolean subcolumnsOnly , boolean reverseOrder ) { } public List < ColumnOrSuperColumn > get_slice ( String keyspace , byte [ ] key , ColumnParent column_parent , SlicePredicate predicate , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } public Map < byte [ ] , List < ColumnOrSuperColumn > > multiget_slice ( String keyspace , List < byte [ ] > keys , ColumnParent column_parent , SlicePredicate predicate , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } private Map < byte [ ] , List < ColumnOrSuperColumn > > multigetSliceInternal ( String keyspace , List < byte [ ] > keys , ColumnParent column_parent , SlicePredicate predicate , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } public ColumnOrSuperColumn get ( String table , byte [ ] key , ColumnPath column_path , ConsistencyLevel consistency_level ) throws InvalidRequestException , NotFoundException , TimedOutException , UnavailableException { } public Map < byte [ ] , ColumnOrSuperColumn > multiget ( String table , List < byte [ ] > keys , ColumnPath column_path , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } private Map < byte [ ] , ColumnOrSuperColumn > multigetInternal ( String table , List < byte [ ] > keys , ColumnPath column_path , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } public int get_count ( String table , byte [ ] key , ColumnParent column_parent , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } public void insert ( String table , byte [ ] key , ColumnParent column_parent , Column column , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } public void batch_insert ( String keyspace , byte [ ] key , Map < String , List < ColumnOrSuperColumn > > cfmap , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } public void batch_mutate ( String keyspace , Map < byte [ ] , Map < String , List < Mutation > > > mutation_map , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } public void remove ( String table , byte [ ] key , ColumnPath column_path , long timestamp , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } private void doInsert ( ConsistencyLevel consistency_level , RowMutation rm ) throws TimedOutException , UnavailableException { } public Map < String , Map < String , String > > describe_keyspace ( String table ) throws NotFoundException { } public List < KeySlice > get_range_slice ( String keyspace , ColumnParent column_parent , SlicePredicate predicate , byte [ ] start_key , byte [ ] finish_key , int maxRows , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException , TException { } public List < KeySlice > get_range_slices ( String keyspace , ColumnParent column_parent , SlicePredicate predicate , KeyRange range , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException , TException { } private List < KeySlice > getRangeSlicesInternal ( String keyspace , ColumnParent column_parent , SlicePredicate predicate , KeyRange range , ConsistencyLevel consistency_level ) throws InvalidRequestException , TimedOutException , UnavailableException { } public Set < String > describe_keyspaces ( ) throws TException { } public String describe_cluster_name ( ) throws TException { } public String describe_version ( ) throws TException { } public List < TokenRange > describe_ring ( String keyspace ) { List < TokenRange > ranges = new ArrayList < TokenRange > ( ) ; <START_BUG> for ( Map . Entry < Range , List < String > > entry : instance . getRangeToEndPointMap ( keyspace ) . entrySet ( ) ) { <END_BUG> Range range = entry . getKey ( ) ; List < String > endpoints = entry . getValue ( ) ; ranges . add ( new TokenRange ( range . left . toString ( ) , range . right . toString ( ) , endpoints ) ) ; } return ranges ; } public List < String > describe_splits ( String start_token , String end_token , int keys_per_split ) throws TException { } public AccessLevel login ( String keyspace , AuthenticationRequest auth_request ) throws AuthenticationException , AuthorizationException , TException { } protected void checkLoginAuthorized ( AccessLevel level ) throws InvalidRequestException { } public void system_add_column_family ( CfDef cf_def ) throws InvalidRequestException , TException { } public void system_drop_column_family ( String keyspace , String column_family ) throws InvalidRequestException , TException { } public void system_rename_column_family ( String keyspace , String old_name , String new_name ) throws InvalidRequestException , TException { } public void system_add_keyspace ( KsDef ks_def ) throws InvalidRequestException , TException { } public void system_drop_keyspace ( String keyspace ) throws InvalidRequestException , TException { } public void system_rename_keyspace ( String old_name , String new_name ) throws InvalidRequestException , TException { } } 
public class SaveService { private static XStream saver = new XStream ( ) ; private static Logger log = LoggingManager . getLoggerForClass ( ) ; static String version = "1.0" ; static String propertiesVersion = "" ; private static final String PROPVERSION = "1.3" ; private static void makeAlias ( String alias , String clazz ) { } private static void initProps ( ) { } public static void saveTree ( HashTree tree , Writer writer ) throws Exception { } static boolean versionsOK = true ; private static final String REVPFX = "$Revision:<seq2seq4repair_space>" ; private static final String REVSFX = "<seq2seq4repair_space>$" ; private static String extractVersion ( String rev ) { } private static void checkVersion ( Class clazz , String expected ) { } private static void checkVersions ( ) { SaveService . versionsOK = true ; SaveService . checkVersion ( BooleanPropertyConverter . class , "1.4" ) ; SaveService . checkVersion ( HashTreeConverter . class , "1.2" ) ; SaveService . checkVersion ( IntegerPropertyConverter . class , "1.3" ) ; SaveService . checkVersion ( LongPropertyConverter . class , "1.3" ) ; SaveService . checkVersion ( MultiPropertyConverter . class , "1.3" ) ; SaveService . checkVersion ( SampleResultConverter . class , "1.2" ) ; <START_BUG> SaveService . checkVersion ( StringPropertyConverter . class , "1.5" ) ; <END_BUG> SaveService . checkVersion ( TestElementConverter . class , "1.2" ) ; SaveService . checkVersion ( TestElementPropertyConverter . class , "1.3" ) ; SaveService . checkVersion ( ScriptWrapperConverter . class , "1.2" ) ; if ( ! ( SaveService . PROPVERSION . equalsIgnoreCase ( SaveService . propertiesVersion ) ) ) { SaveService . log . warn ( ( ( ( "Property<seq2seq4repair_space>file<seq2seq4repair_space>-<seq2seq4repair_space>expected<seq2seq4repair_space>" + ( SaveService . PROPVERSION ) ) + ",<seq2seq4repair_space>found<seq2seq4repair_space>" ) + ( SaveService . propertiesVersion ) ) ) ; } if ( SaveService . versionsOK ) { SaveService . log . info ( "All<seq2seq4repair_space>converter<seq2seq4repair_space>versions<seq2seq4repair_space>present<seq2seq4repair_space>and<seq2seq4repair_space>correct" ) ; } } public static HashTree loadTree ( InputStream reader ) throws Exception { } public static class Test extends JMeterTestCase { public Test ( ) { } public Test ( String name ) { } public void testVersions ( ) throws Exception { } } } 
public final class Logging { private static final Logger LOG = Logger . getLogger ( "org.columba" ) ; private static ConsoleHandler consoleHandler ; public static boolean DEBUG = false ; private Logging ( ) { } private static boolean userHasDefinedLogging ( ) { } public static void createDefaultHandler ( ) { if ( ! ( Logging . userHasDefinedLogging ( ) ) ) { Logging . LOG . setUseParentHandlers ( false ) ; Logging . consoleHandler = new ConsoleHandler ( ) ; Logging . consoleHandler . setFormatter ( new OneLineFormatter ( ) ) ; <START_BUG> Logging . consoleHandler . setLevel ( Level . ALL ) ; <END_BUG> Logging . LOG . addHandler ( Logging . consoleHandler ) ; } } public static void setDebugging ( boolean debug ) { } public static void createDefaultFileHandler ( File configDirectory ) { } } 
public class PersistenceExceptions extends Exceptions { public static final RuntimeExceptionTranslator TRANSLATOR = new RuntimeExceptionTranslator ( ) { public RuntimeException translate ( RuntimeException re ) { } } ; public static RuntimeExceptionTranslator getRollbackTranslator ( final OpenJPAEntityManager em ) { } public static RuntimeException toPersistenceException ( Throwable t ) { } private static Throwable translateException ( Throwable t , boolean checked ) { } private static Throwable translateStoreException ( OpenJPAException ke ) { Exception e ; Throwable cause = ( ( ( ke . getNestedThrowables ( ) ) != null ) && ( ( ke . getNestedThrowables ( ) . length ) == 1 ) ) ? ke . getNestedThrowables ( ) [ 0 ] : null ; if ( ( ( ke . getSubtype ( ) ) == ( StoreException . OBJECT_NOT_FOUND ) ) || ( cause instanceof ObjectNotFoundException ) ) { e = new org . apache . openjpa . persistence . EntityNotFoundException ( ke . getMessage ( ) , PersistenceExceptions . getNestedThrowables ( ke ) , PersistenceExceptions . getFailedObject ( ke ) , ke . isFatal ( ) ) ; } else if ( ( ( ke . getSubtype ( ) ) == ( StoreException . OPTIMISTIC ) ) || ( cause instanceof OptimisticException ) ) { e = new org . apache . openjpa . persistence . OptimisticLockException ( ke . getMessage ( ) , PersistenceExceptions . getNestedThrowables ( ke ) , PersistenceExceptions . getFailedObject ( ke ) , ke . isFatal ( ) ) ; } else if ( ( ( ke . getSubtype ( ) ) == ( StoreException . LOCK ) ) || ( cause instanceof LockException ) ) { LockException lockEx = ( ( LockException ) ( ( ke instanceof LockException ) ? ke : cause ) ) ; if ( ( lockEx != null ) && ( ( lockEx . getLockLevel ( ) ) >= ( JPA2LockLevels . LOCK_PESSIMISTIC_READ ) ) ) { <START_BUG> if ( lockEx . isRecoverable ( ) ) { <END_BUG> e = new org . apache . openjpa . persistence . LockTimeoutException ( ke . getMessage ( ) , PersistenceExceptions . getNestedThrowables ( ke ) , PersistenceExceptions . getFailedObject ( ke ) , ke . isFatal ( ) ) ; } else { e = new org . apache . openjpa . persistence . PessimisticLockException ( ke . getMessage ( ) , PersistenceExceptions . getNestedThrowables ( ke ) , PersistenceExceptions . getFailedObject ( ke ) , ke . isFatal ( ) ) ; } } else { e = new org . apache . openjpa . persistence . OptimisticLockException ( ke . getMessage ( ) , PersistenceExceptions . getNestedThrowables ( ke ) , PersistenceExceptions . getFailedObject ( ke ) , ke . isFatal ( ) ) ; } } else if ( ( ( ke . getSubtype ( ) ) == ( StoreException . OBJECT_EXISTS ) ) || ( cause instanceof ObjectExistsException ) ) { e = new org . apache . openjpa . persistence . EntityExistsException ( ke . getMessage ( ) , PersistenceExceptions . getNestedThrowables ( ke ) , PersistenceExceptions . getFailedObject ( ke ) , ke . isFatal ( ) ) ; } else { e = new org . apache . openjpa . persistence . PersistenceException ( ke . getMessage ( ) , PersistenceExceptions . getNestedThrowables ( ke ) , PersistenceExceptions . getFailedObject ( ke ) , ke . isFatal ( ) ) ; } e . setStackTrace ( ke . getStackTrace ( ) ) ; return e ; } private static Exception translateUserException ( OpenJPAException ke ) { } private static Exception translateCause ( OpenJPAException ke ) { } private static Throwable translateGeneralException ( OpenJPAException ke ) { } private static boolean isPersistenceException ( Throwable t ) { } private static Throwable [ ] getNestedThrowables ( OpenJPAException ke ) { } private static Object getFailedObject ( OpenJPAException ke ) { } static Throwable getCause ( Throwable [ ] nested ) { } } 
abstract class RFC1522Codec { protected static final char SEP = '?' ; protected static final String POSTFIX = "?=" ; protected static final String PREFIX = "=?" ; protected String encodeText ( final String text , final Charset charset ) throws EncoderException { if ( text == null ) { return null ; } <START_BUG> StringBuffer buffer = new StringBuffer ( ) ; <END_BUG> buffer . append ( RFC1522Codec . PREFIX ) ; buffer . append ( charset ) ; buffer . append ( RFC1522Codec . SEP ) ; buffer . append ( this . getEncoding ( ) ) ; buffer . append ( RFC1522Codec . SEP ) ; byte [ ] rawData = this . doEncoding ( text . getBytes ( charset ) ) ; buffer . append ( StringUtils . newStringUsAscii ( rawData ) ) ; buffer . append ( RFC1522Codec . POSTFIX ) ; return buffer . toString ( ) ; } protected String encodeText ( final String text , final String charsetName ) throws UnsupportedEncodingException , EncoderException { } protected String decodeText ( final String text ) throws UnsupportedEncodingException , DecoderException { } protected abstract String getEncoding ( ) { } protected abstract byte [ ] doEncoding ( byte [ ] bytes ) throws EncoderException { } protected abstract byte [ ] doDecoding ( byte [ ] bytes ) throws DecoderException { } } 
public abstract class Expression extends Statement { public static final boolean isConstantValueRepresentable ( Constant constant , int constantTypeID , int targetTypeID ) { } public Constant constant ; public int implicitConversion ; public TypeBinding resolvedType ; public Expression ( ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , boolean valueRequired ) { } public final boolean checkCastTypesCompatibility ( Scope scope , TypeBinding castType , TypeBinding expressionType , Expression expression ) { } public FlowInfo checkNullStatus ( BlockScope scope , FlowContext flowContext , FlowInfo flowInfo , int nullStatus ) { } private MethodBinding [ ] getAllInheritedMethods ( ReferenceBinding binding ) { } private void getAllInheritedMethods0 ( ReferenceBinding binding , ArrayList collector ) { } public void checkNullComparison ( BlockScope scope , FlowContext flowContext , FlowInfo flowInfo , FlowInfo initsWhenTrue , FlowInfo initsWhenFalse ) { } public boolean checkUnsafeCast ( Scope scope , TypeBinding castType , TypeBinding expressionType , TypeBinding match , boolean isNarrowing ) { } public void computeConversion ( Scope scope , TypeBinding runtimeType , TypeBinding compileTimeType ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { <START_BUG> if ( ( ( bits ) & ( IsReachableMASK ) ) == 0 ) { <END_BUG> return ; } generateCode ( currentScope , codeStream , false ) ; } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateOptimizedBoolean ( BlockScope currentScope , CodeStream codeStream , Label trueLabel , Label falseLabel , boolean valueRequired ) { } public void generateOptimizedStringConcatenation ( BlockScope blockScope , CodeStream codeStream , int typeID ) { } public void generateOptimizedStringConcatenationCreation ( BlockScope blockScope , CodeStream codeStream , int typeID ) { } public boolean isCompactableOperation ( ) { } public boolean isConstantValueOfTypeAssignableToType ( TypeBinding constantType , TypeBinding targetType ) { } public boolean isTypeReference ( ) { } public int nullStatus ( FlowInfo flowInfo ) { } public Constant optimizedBooleanConstant ( ) { } public StringBuffer print ( int indent , StringBuffer output ) { } public abstract StringBuffer printExpression ( int indent , StringBuffer output ) { } public StringBuffer printStatement ( int indent , StringBuffer output ) { } public void resolve ( BlockScope scope ) { } public TypeBinding resolveType ( BlockScope scope ) { } public TypeBinding resolveType ( ClassScope scope ) { } public TypeBinding resolveTypeExpecting ( BlockScope scope , TypeBinding expectedType ) { } public void setExpectedType ( TypeBinding expectedType ) { } public void tagAsUnnecessaryCast ( Scope scope , TypeBinding castType ) { } public void tagAsNeedCheckCast ( ) { } public Expression toTypeReference ( ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } public void traverse ( ASTVisitor visitor , ClassScope scope ) { } public void traverse ( ASTVisitor visitor , CompilationUnitScope scope ) { } public LocalVariableBinding localVariableBinding ( ) { } } 
public class JobsExecutor extends AbstractExecutor { protected int fJobCounter = 1 ; protected String fExecutorName ; protected boolean fSystem ; protected ISchedulingRule fSchedulingRule ; protected long delay ; public JobsExecutor ( String executorName ) { } public JobsExecutor ( String executorName , boolean system ) { } public JobsExecutor ( String executorName , boolean system , ISchedulingRule schedulingRule ) { } public JobsExecutor ( String executorName , boolean system , ISchedulingRule schedulingRule , long delay ) { } protected void setChildProgressMonitor ( IProgressMonitor parent , IProgressMonitor child ) { } protected void safeRun ( ISafeProgressRunner runner , IProgressRunnable progressRunnable ) { <START_BUG> runner . safeRun ( progressRunnable ) ; <END_BUG> } protected String createJobName ( String executorName , int jobCounter , IProgressRunnable runnable ) { } protected AbstractFuture createFuture ( IProgressMonitor progressMonitor ) { } public IFuture execute ( final IProgressRunnable runnable , final IProgressMonitor clientProgressMonitor ) { } protected void configureJobForExecution ( Job job ) { } } 
public class InspectorDebugPanel extends StandardDebugPanel { private static final long serialVersionUID = 1L ; public static final IDebugBarContributor DEBUG_BAR_CONTRIB = new IDebugBarContributor ( ) { private static final long serialVersionUID = 1L ; public Component createComponent ( String id , DebugBar debugBar ) { } } ; public InspectorDebugPanel ( String id ) { } @ Override protected Class < ? extends Page > getLinkPageClass ( ) { } @ Override protected ResourceReference getImageResourceReference ( ) { } @ Override protected IModel < String > getDataModel ( ) { } @ Override protected PageParameters getLinkPageParameters ( ) { PageParameters params = new PageParameters ( ) ; <START_BUG> params . addNamedParameter ( "pageId" , getPage ( ) . getId ( ) ) ; <END_BUG> return params ; } } 
public - 1929279013 , 136589919 , - 4620627 , 227358015 , 1246654146 , 1982086071 , - 624967954 , - 846982953 , - 1559291965 , 727305967 , - 634914880 , 2031976763 , - 1068406975 , - 1285298945 , 836616119 , 1239094672 , - 666676932 , - 1926137227 , - 1304197153 , 1677541478 , - 1594039144 , 2067979927 , 820894732 , 119198242 , 982537412 , 1558401688 , 928769611 , 279917256 , - 1449546271 , - 90223311 , - 69055958 , 1284665675 , - 857537174 , - 1474469526 , 1001689619 , 1929194254 , 457625982 , - 1844077625 , 1952637298 , 1339833861 , - 217464733 , - 1858907348 , - 433220799 , 1746552945 , - 1319533275 , 1233953672 , - 1767380351 , 2031913605 , 708026850 , 510311559 , - 1306900360 , 1710933307 , 1494624993 , 579177008 , 1089791337 , - 439680989 , 1651298976 , - 26374200 , - 1149315133 , - 1705675885 , - 788570528 , 706801051 , 1319828314 , - 1097587267 , 1667370209 , 837428461 , 137249386 , 2146654835 , - 1501578583 , - 756824647 , 445704554 , 1911656836 , - 1204373365 , - 450911865 , 1113023544 , 1490192246 , 1203606179 , 159475810 , 693188847 , 598420401 , - 674921248 , 395511343 , - 867702702 , - 1024747773 , - 427741805 , - 1532342994 , 2137217913 , - 1488946391 , - 1759199097 , 1080953038 , 1811011767 , - 1628063723 , - 221843308 , - 2044289886 , 402500175 , - 1687921823 , 1880865771 , - 1914192713 , - 731371926 , 1222591662 , 1460340938 , 2052826171 , - 57511150 , 878814173 , 268327235 , - 2029649035 , - 1920270633 , - 2083388537 , 2011872081 , - 127073189 , 1906603319 , - 1538761048 , - 47486269 , - 1262870577 , 836562562 , - 1958621706 , - 355605461 , 48127931 , - 1238295896 , 362212957 , 895271837 , - 1105557567 , 31579911 , - 29278906 , 1583223723 , 807616470 , - 1723559278 , 882204108 , 523752340 , - 734643779 , 1707708142 , 1740133779 , 375435937 , - 41490016 , 867921498 , - 581397765 , - 1501355887 , - 797453802 , 893124250 , - 1264515290 , - 904244370 , - 309659967 , 1104242641 , 1599424833 , - 1812724950 , - 2082981147 , - 930715131 , - 1016259041 , - 1784642875 , - 664900435 , 808174468 , 1107003159 , 1629625544 , - 828750643 , 679799841 , - 1760422611 , 1100892473 , 842431303 , 596567090 , - 763425906 , - 1544884956 , 519033001 , - 209050624 , 1925239986 , - 1948524863 , 1446652761 , 223352699 , - 1340770577 , 2111435582 , 2030420256 , 1175917270 , 2015780499 , 1420369675 , - 1198605888 , - 1651927121 , - 887287146 , - 99992969 , 1538420185 , - 153454369 , 1404626956 , - 983770378 , - 2028324495 , 198759202 , - 90305892 , - 1785422322 , - 380694821 , 367029029 , - 1958857524 , - 1744674391 , 982508608 , - 953995094 , - 1074411338 , 1214908646 , 1799292520 , 1405683553 , 499267403 , - 1167967306 , 1913495551 , - 2074805542 , 703632739 , 1695691534 , - 2076770238 , - 631914165 , - 432440537 , - 620512057 , - 689800826 , 1211815154 , - 522009702 , 1168009106 , 62988524 , 333412423 , - 1007781919 , - 1125221164 , - 617138964 , 236579762 , 352407930 , - 2125360905 , - 365905364 , - 312978884 , - 1647948792 , 1490580799 , 531067333 , 1998715657 , - 968024224 , - 200811496 , 1876631091 , - 1985229640 , 799770389 , - 655477458 , 1103079268 , - 637376530 , 1702445184 , - 485925531 , 149034123 , 389088181 , 1432828280 , - 1921601005 , 1859399243 , - 1101491307 , - 817082998 , - 751717833 , 183694539 , 539748346 , 780647463 , 336238047 , - 1596854402 , 271702576 , 1661943462 , 238750097 , - 1166277534 , - 896919252 , 1719932898 , 745443013 , 1059996530 , 822683625 , - 1468309682 , 568586885 , 1722463422 , - 1769975949 , 159135291 , 1984190481 , - 1349321865 , 1711280311 , 1073064891 , - 626719280 , 400307336 , 1171965546 , - 1472932117 , - 1393531873 , 89612660 , 683612248 , 142778002 , - 742009552 , 1791819954 , - 211024315 , 1132841703 , - 1817108600 , 1040063911 , 761133528 , - 719500913 , 487730052 , 749167007 , 1729083962 , - 1516294119 , - 765796863 , 1139748744 , 97479412 , 1875097056 , 811217054 , - 1212357253 , 1237669523 , - 711207216 , - 552392884 , - 1520170729 , - 1192721120 , - 132138907 , 609839055 , 1682047250 , - 1754132528 , 251204600 , - 1613818636 , - 1717015968 , 353034357 , 457958686 , 318665576 , 595075051 , 911716547 , - 1862774894 , 137323117 , - 262680847 , - 263208255 , - 2023230703 , 604682296 , 369452224 , - 1762376179 , 746478723 , - 1269928543 , 1140353761 , - 475013373 , 873935970 , 427655216 , - 1339200793 , 216794988 , 263835742 , 531058073 , 66675566 , 61842509 , 2043589740 , - 1952566952 , - 1383606202 , - 1351006702 , - 587157967 , - 561159202 , 580673126 , 770993684 , 1018901969 , - 1741511333 , - 1342980068 , - 1353923906 , 84499499 , - 294919089 , 2073809784 , 161870111 , - 35900406 , 17670394 , 1619480163 , - 1627151477 , - 570549243 , - 1917989866 , 1845063956 , - 529032484 , - 1914164857 , - 2083740004 , 951164540 , - 339538681 , - 1284553012 , - 296938413 , 1965212432 , 977523574 , - 1421865195 , 1340996249 , 48706110 , 1280833152 , - 468120859 , 1784396361 , - 742251560 , 461876118 , - 1359709857 , - 195572435 , 732857993 , - 1574321009 , 1102929524 , 634076584 , - 45620016 , 170139644 , 381737895 , 1863608829 , - 2129914150 , 1722266428 , - 422977535 , - 1664156186 , - 766543140 , 466389376 , 923288146 , - 1216752179 , 1390696144 , 825992414 , - 5203645 , 245190175 , 1513902508 , 1862622980 , - 1297311194 , - 1208302001 , 667683981 , 875281091 } ; @ Test public void testReference ( ) { } private int [ ] getActualSequence ( ISAACRandom isaacRandom ) { } } 
public class XmlTag extends MarkupElement { public static final XmlTag . Type CLOSE = new XmlTag . Type ( "CLOSE" ) ; public static final XmlTag . Type OPEN = new XmlTag . Type ( "OPEN" ) ; public static final XmlTag . Type OPEN_CLOSE = new XmlTag . Type ( "OPEN_CLOSE" ) ; private LowerCaseKeyValueMap attributes = new LowerCaseKeyValueMap ( ) ; int columnNumber ; int length ; int lineNumber ; String name ; String namespace ; int pos ; String text ; XmlTag . Type type ; private XmlTag closes ; private XmlTag copyOf = this ; private boolean isMutable = true ; private boolean nameChanged = false ; public static final class Type extends EnumeratedType { Type ( final String name ) { } } public XmlTag ( ) { } public final boolean closes ( final XmlTag open ) { } public LowerCaseKeyValueMap getAttributes ( ) { } public int getColumnNumber ( ) { } public int getLength ( ) { } public int getLineNumber ( ) { } public String getName ( ) { } public boolean getNameChanged ( ) { } public String getNamespace ( ) { } public final XmlTag getOpenTag ( ) { } public int getPos ( ) { } public String getString ( final String key ) { } public XmlTag . Type getType ( ) { } public boolean isClose ( ) { } public final boolean isMutable ( ) { } public boolean isOpen ( ) { } public boolean isOpenClose ( ) { } public void makeImmutable ( ) { } public XmlTag mutable ( ) { } public Object put ( final String key , final boolean value ) { } public Object put ( final String key , final int value ) { } public Object put ( final String key , final String value ) { } public Object put ( final String key , final StringValue value ) { } public void putAll ( final Map map ) { } public void remove ( final String key ) { } public void setName ( final String name ) { } public void setOpenTag ( final XmlTag tag ) { } public void setType ( final XmlTag . Type type ) { } public String toDebugString ( ) { } public String toString ( ) { <START_BUG> if ( ! ( isMutable ) ) { <END_BUG> return text ; } return toXmlString ( null ) ; } public String toUserDebugString ( ) { } public String toXmlString ( final String attributeToBeIgnored ) { } } 
public class CollatingIterator < E > implements Iterator < E > { private Comparator < ? super E > comparator = null ; private ArrayList < Iterator < ? extends E > > iterators = null ; private ArrayList < E > values = null ; private BitSet valueSet = null ; private int lastReturned = - 1 ; public CollatingIterator ( ) { } public CollatingIterator ( final Comparator < ? super E > comp ) { } public CollatingIterator ( final Comparator < ? super E > comp , final int initIterCapacity ) { } public CollatingIterator ( final Comparator < ? super E > comp , final Iterator < ? extends E > a , final Iterator < ? extends E > b ) { } public CollatingIterator ( final Comparator < ? super E > comp , final Iterator < ? extends E > [ ] iterators ) { } public CollatingIterator ( final Comparator < ? super E > comp , final Collection < Iterator < ? extends E > > iterators ) { } public void addIterator ( final Iterator < ? extends E > iterator ) { } public void setIterator ( final int index , final Iterator < ? extends E > iterator ) { } public List < Iterator < ? extends E > > getIterators ( ) { <START_BUG> return UnmodifiableList . decorate ( iterators ) ; <END_BUG> } public Comparator < ? super E > getComparator ( ) { } public void setComparator ( final Comparator < ? super E > comp ) { } public boolean hasNext ( ) { } public E next ( ) throws NoSuchElementException { } public void remove ( ) { } public int getIteratorIndex ( ) { } private void start ( ) { } private boolean set ( int i ) { } private void clear ( int i ) { } private void checkNotStarted ( ) throws IllegalStateException { } private int least ( ) { } private boolean anyValueSet ( BitSet set ) { } private boolean anyHasNext ( ArrayList < Iterator < ? extends E > > iters ) { } } 
@ RunWith ( Arquillian . class ) public class AS1601TestCase { @ Inject public BundleContext context ; @ Inject public Bundle bundle ; @ Deployment @ StartLevelAware ( startLevel = 4 ) public static WebArchive createdeployment ( ) { final WebArchive archive = ShrinkWrap . create ( WebArchive . class , "as1601.war" ) ; <START_BUG> archive . addClasses ( OSGiTestSupport . class , EndpointServlet . class ) ; <END_BUG> archive . addAsWebInfResource ( "osgi/webapp/webA.xml" , "web.xml" ) ; archive . add ( new Asset ( ) { public InputStream openStream ( ) { OSGiManifestBuilder builder = OSGiManifestBuilder . newInstance ( ) ; builder . addBundleSymbolicName ( archive . getName ( ) ) ; builder . addBundleManifestVersion ( 2 ) ; builder . addManifestHeader ( Constants . BUNDLE_CLASSPATH , ".,WEB-INF/classes" ) ; builder . addManifestHeader ( "Web-ContextPath" , "as1601" ) ; builder . addImportPackages ( StartLevel . class , HttpServlet . class , Servlet . class ) ; return builder . openStream ( ) ; } } , JarFile . MANIFEST_NAME ) ; return archive ; } @ Test public void testServletAccess ( ) throws Exception { } private String getHttpResponse ( String reqPath , int timeout ) throws IOException { } } 
public class Jar extends Zip { private static final String INDEX_NAME = "META-INF/INDEX.LIST" ; private static final String MANIFEST_NAME = "META-INF/MANIFEST.MF" ; private List serviceList = new ArrayList ( ) ; private Manifest configuredManifest ; private Manifest savedConfiguredManifest ; private Manifest filesetManifest ; private Manifest originalManifest ; private Jar . FilesetManifestConfig filesetManifestConfig ; private boolean mergeManifestsMain = true ; private Manifest manifest ; private String manifestEncoding ; private File manifestFile ; private boolean index = false ; private boolean createEmpty = false ; private Vector rootEntries ; private Path indexJars ; private ZipExtraField [ ] JAR_MARKER = new ZipExtraField [ ] { JarMarker . getInstance ( ) } ; protected String emptyBehavior = "create" ; public Jar ( ) { } public void setWhenempty ( WhenEmpty we ) { } public void setWhenmanifestonly ( WhenEmpty we ) { } public void setJarfile ( File jarFile ) { } public void setIndex ( boolean flag ) { } public void setManifestEncoding ( String manifestEncoding ) { } public void addConfiguredManifest ( Manifest newManifest ) throws ManifestException { } public void setManifest ( File manifestFile ) { } private Manifest getManifest ( File manifestFile ) { } private Manifest getManifestFromJar ( File jarFile ) throws IOException { } private Manifest getManifest ( Reader r ) { } public void setFilesetmanifest ( Jar . FilesetManifestConfig config ) { } public void addMetainf ( ZipFileSet fs ) { } public void addConfiguredIndexJars ( Path p ) { } public void addConfiguredService ( Service service ) { } private void writeServices ( ZipOutputStream zOut ) throws IOException { } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } private Manifest createManifest ( ) throws BuildException { } private void writeManifest ( ZipOutputStream zOut , Manifest manifest ) throws IOException { } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } private void createIndexList ( ZipOutputStream zOut ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( baos , "UTF8" ) ) ; writer . println ( "JarIndex-Version:<seq2seq4repair_space>1.0" ) ; writer . println ( ) ; writer . println ( zipFile . getName ( ) ) ; writeIndexLikeList ( new ArrayList ( addedDirs . keySet ( ) ) , rootEntries , writer ) ; writer . println ( ) ; if ( ( indexJars ) != null ) { Manifest mf = createManifest ( ) ; Manifest . Attribute classpath = mf . getMainSection ( ) . getAttribute ( ATTRIBUTE_CLASSPATH ) ; String [ ] cpEntries = null ; <START_BUG> if ( classpath != null ) { <END_BUG> StringTokenizer tok = new StringTokenizer ( classpath . getValue ( ) , "<seq2seq4repair_space>" ) ; cpEntries = new String [ tok . countTokens ( ) ] ; int c = 0 ; while ( tok . hasMoreTokens ( ) ) { cpEntries [ ( c ++ ) ] = tok . nextToken ( ) ; } } String [ ] indexJarEntries = indexJars . list ( ) ; for ( int i = 0 ; i < ( indexJarEntries . length ) ; i ++ ) { String name = Jar . findJarName ( indexJarEntries [ i ] , cpEntries ) ; if ( name != null ) { ArrayList dirs = new ArrayList ( ) ; ArrayList files = new ArrayList ( ) ; Jar . grabFilesAndDirs ( indexJarEntries [ i ] , dirs , files ) ; if ( ( ( dirs . size ( ) ) + ( files . size ( ) ) ) > 0 ) { writer . println ( name ) ; writeIndexLikeList ( dirs , files , writer ) ; writer . println ( ) ; } } } } writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , Jar . INDEX_NAME , System . currentTimeMillis ( ) , null , DEFAULT_FILE_MODE ) ; } protected void zipFile ( InputStream is , ZipOutputStream zOut , String vPath , long lastModified , File fromArchive , int mode ) throws IOException { } private void filesetManifest ( File file , InputStream is ) throws IOException { } protected ArchiveState getResourcesToAdd ( ResourceCollection [ ] rcs , File zipFile , boolean needsUpdate ) throws BuildException { } protected boolean createEmptyZip ( File zipFile ) throws BuildException { } protected void cleanUp ( ) { } public void reset ( ) { } public static class FilesetManifestConfig extends EnumeratedAttribute { public String [ ] getValues ( ) { } } protected final void writeIndexLikeList ( List dirs , List files , PrintWriter writer ) throws IOException { } protected static final String findJarName ( String fileName , String [ ] classpath ) { } protected static final void grabFilesAndDirs ( String file , List dirs , List files ) throws IOException { } } 
public class TestCzechAnalyzer extends BaseTokenStreamTestCase { @ Deprecated public void testStopWordLegacy ( ) throws Exception { } public void testStopWord ( ) throws Exception { } @ Deprecated public void testReusableTokenStreamLegacy ( ) throws Exception { } public void testReusableTokenStream ( ) throws Exception { } public void testWithStemExclusionSet ( ) throws IOException { } public void testRandomStrings ( ) throws Exception { <START_BUG> checkRandomData ( random ( ) , new CzechAnalyzer ( TEST_VERSION_CURRENT ) , ( 10000 * ( RANDOM_MULTIPLIER ) ) ) ; <END_BUG> } } 
final class CollectionToStringConverter implements GenericConverter { private static final String DELIMITER = "," ; private final ConversionService conversionService ; public CollectionToStringConverter ( ConversionService conversionService ) { } public Set < ConvertiblePair > getConvertibleTypes ( ) { } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( source == null ) { return null ; } Collection < ? > sourceCollection = ( ( Collection < ? > ) ( source ) ) ; if ( ( sourceCollection . size ( ) ) == 0 ) { return "" ; } StringBuilder sb = new StringBuilder ( ) ; int i = 0 ; for ( Object sourceElement : sourceCollection ) { if ( i > 0 ) { sb . append ( CollectionToStringConverter . DELIMITER ) ; } <START_BUG> Object targetElement = this . conversionService . convert ( sourceElement , sourceType . elementType ( sourceElement ) , targetType ) ; <END_BUG> sb . append ( targetElement ) ; i ++ ; } return sb . toString ( ) ; } } 
public class WeldExtension implements Extension { public static final String SUBSYSTEM_NAME = "weld" ; public static final String NAMESPACE = "urn:jboss:domain:weld:1.0" ; private static final WeldExtension . WeldSubsystemParser parser = new WeldExtension . WeldSubsystemParser ( ) ; private static final PathElement PATH_SUBSYSTEM = PathElement . pathElement ( SUBSYSTEM , WeldExtension . SUBSYSTEM_NAME ) ; private static final String RESOURCE_NAME = ( WeldExtension . class . getPackage ( ) . getName ( ) ) + ".LocalDescriptions" ; private static final int MANAGEMENT_API_MAJOR_VERSION = 1 ; private static final int MANAGEMENT_API_MINOR_VERSION = 0 ; private static final int MANAGEMENT_API_MICRO_VERSION = 0 ; static StandardResourceDescriptionResolver getResourceDescriptionResolver ( final String ... keyPrefix ) { } private static final ResourceDefinition WELD_SUBSYSTEM_RESOURCE = new org . jboss . as . controller . SimpleResourceDefinition ( WeldExtension . PATH_SUBSYSTEM , WeldExtension . getResourceDescriptionResolver ( ) , WeldSubsystemAdd . INSTANCE , ReloadRequiredRemoveStepHandler . INSTANCE ) ; @ Override public void initialize ( final ExtensionContext context ) { ROOT_LOGGER . debug ( "Activating<seq2seq4repair_space>Weld<seq2seq4repair_space>Extension" ) ; final SubsystemRegistration subsystem = context . registerSubsystem ( WeldExtension . SUBSYSTEM_NAME , WeldExtension . MANAGEMENT_API_MAJOR_VERSION , WeldExtension . MANAGEMENT_API_MINOR_VERSION , WeldExtension . MANAGEMENT_API_MICRO_VERSION ) ; final ManagementResourceRegistration registration = subsystem . registerSubsystemModel ( WeldExtension . WELD_SUBSYSTEM_RESOURCE ) ; <START_BUG> registration . registerOperationHandler ( DESCRIBE , INSTANCE , INSTANCE , false , PRIVATE ) ; <END_BUG> subsystem . registerXMLElementWriter ( WeldExtension . parser ) ; } @ Override public void initializeParsers ( final ExtensionParsingContext context ) { } static class WeldSubsystemParser implements XMLStreamConstants , XMLElementReader < List < ModelNode > > , XMLElementWriter < SubsystemMarshallingContext > { @ Override public void readElement ( final XMLExtendedStreamReader reader , final List < ModelNode > list ) throws XMLStreamException { } @ Override public void writeContent ( final XMLExtendedStreamWriter streamWriter , final SubsystemMarshallingContext context ) throws XMLStreamException { } } } 
public abstract class Expression extends Statement { public static final boolean isConstantValueRepresentable ( Constant constant , int constantTypeID , int targetTypeID ) { } public Constant constant ; public int implicitConversion ; public TypeBinding resolvedType ; public Expression ( ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , boolean valueRequired ) { } public final boolean checkCastTypesCompatibility ( Scope scope , TypeBinding castType , TypeBinding expressionType , Expression expression ) { } public FlowInfo checkNullStatus ( BlockScope scope , FlowContext flowContext , FlowInfo flowInfo , int nullStatus ) { } private MethodBinding [ ] getAllInheritedMethods ( ReferenceBinding binding ) { } private void getAllInheritedMethods0 ( ReferenceBinding binding , ArrayList collector ) { } public void checkNullComparison ( BlockScope scope , FlowContext flowContext , FlowInfo flowInfo , FlowInfo initsWhenTrue , FlowInfo initsWhenFalse ) { } public boolean checkUnsafeCast ( Scope scope , TypeBinding castType , TypeBinding expressionType , TypeBinding match , boolean isNarrowing ) { } public void computeConversion ( Scope scope , TypeBinding runtimeTimeType , TypeBinding compileTimeType ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateOptimizedBoolean ( BlockScope currentScope , CodeStream codeStream , Label trueLabel , Label falseLabel , boolean valueRequired ) { if ( ( ( constant ) != ( Constant . NotAConstant ) ) && ( ( constant . typeID ( ) ) == ( TypeIds . T_boolean ) ) ) { int pc = codeStream . position ; if ( ( constant . booleanValue ( ) ) == true ) { if ( valueRequired ) { if ( falseLabel == null ) { if ( trueLabel != null ) { codeStream . goto_ ( trueLabel ) ; } } } } else { if ( valueRequired ) { if ( falseLabel != null ) { if ( trueLabel == null ) { codeStream . goto_ ( falseLabel ) ; } } } } codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; return ; } generateCode ( currentScope , codeStream , valueRequired ) ; int position = codeStream . position ; if ( valueRequired ) { if ( falseLabel == null ) { if ( trueLabel != null ) { codeStream . ifne ( trueLabel ) ; } } else { if ( trueLabel == null ) { codeStream . ifeq ( falseLabel ) ; } else { } } } <START_BUG> codeStream . updateLastRecordedEndPC ( position ) ; <END_BUG> } public void generateOptimizedStringConcatenation ( BlockScope blockScope , CodeStream codeStream , int typeID ) { } public void generateOptimizedStringConcatenationCreation ( BlockScope blockScope , CodeStream codeStream , int typeID ) { } public boolean isCompactableOperation ( ) { } public boolean isConstantValueOfTypeAssignableToType ( TypeBinding constantType , TypeBinding targetType ) { } public boolean isTypeReference ( ) { } public int nullStatus ( FlowInfo flowInfo ) { } public Constant optimizedBooleanConstant ( ) { } public StringBuffer print ( int indent , StringBuffer output ) { } public abstract StringBuffer printExpression ( int indent , StringBuffer output ) { } public StringBuffer printStatement ( int indent , StringBuffer output ) { } public void resolve ( BlockScope scope ) { } public TypeBinding resolveType ( BlockScope scope ) { } public TypeBinding resolveType ( ClassScope classScope ) { } public TypeBinding resolveTypeExpecting ( BlockScope scope , TypeBinding expectedType ) { } public void setExpectedType ( TypeBinding expectedType ) { } public void tagAsUnnecessaryCast ( Scope scope , TypeBinding castType ) { } public void tagAsNeedCheckCast ( ) { } public Expression toTypeReference ( ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } public void traverse ( ASTVisitor visitor , ClassScope scope ) { } public void traverse ( ASTVisitor visitor , CompilationUnitScope scope ) { } public LocalVariableBinding localVariableBinding ( ) { } } 
public class LongLiteral extends NumberLiteral { long value ; static final Constant FORMAT_ERROR = new DoubleConstant ( ( 1.0 / 0.0 ) ) ; public LongLiteral ( char [ ] token , int s , int e ) { } public LongLiteral ( char [ ] token , int s , int e , long value ) { } public void computeConstant ( ) { int length = ( source . length ) - 1 ; long computedValue ; if ( ( source [ 0 ] ) == '0' ) { if ( length == 1 ) { constant = Constant . fromValue ( 0L ) ; return ; } final int shift ; final int radix ; int j ; <START_BUG> if ( ( ( source [ 1 ] ) == 'x' ) | ( ( source [ 1 ] ) == 'X' ) ) { <END_BUG> shift = 4 ; j = 2 ; radix = 16 ; } else { shift = 3 ; j = 1 ; radix = 8 ; } int nbDigit = 0 ; while ( ( source [ j ] ) == '0' ) { j ++ ; if ( j == length ) { constant = Constant . fromValue ( ( value = 0L ) ) ; return ; } } int digitValue ; if ( ( digitValue = Character . digit ( source [ ( j ++ ) ] , radix ) ) < 0 ) { constant = LongLiteral . FORMAT_ERROR ; return ; } if ( digitValue >= 8 ) nbDigit = 4 ; else if ( digitValue >= 4 ) nbDigit = 3 ; else if ( digitValue >= 2 ) nbDigit = 2 ; else nbDigit = 1 ; computedValue = digitValue ; while ( j < length ) { if ( ( digitValue = Character . digit ( source [ ( j ++ ) ] , radix ) ) < 0 ) { constant = LongLiteral . FORMAT_ERROR ; return ; } if ( ( nbDigit += shift ) > 64 ) return ; computedValue = ( computedValue << shift ) | digitValue ; } } else { long previous = computedValue = 0 ; for ( int i = 0 ; i < length ; i ++ ) { int digitValue ; if ( ( digitValue = Character . digit ( source [ i ] , 10 ) ) < 0 ) return ; previous = computedValue ; computedValue = ( 10 * computedValue ) + digitValue ; if ( previous > computedValue ) return ; } } constant = Constant . fromValue ( ( value = computedValue ) ) ; } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public TypeBinding literalType ( BlockScope scope ) { } public final boolean mayRepresentMIN_VALUE ( ) { } public TypeBinding resolveType ( BlockScope scope ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } } 
public class CSVPrinterTest extends TestCase { String lineSeparator = "\n" ; public void testPrinter1 ( ) throws IOException { } public void testPrinter2 ( ) throws IOException { } public void testPrinter3 ( ) throws IOException { } public void testPrinter4 ( ) throws IOException { } public void testPrinter5 ( ) throws IOException { } public void testPrinter6 ( ) throws IOException { } public void testPrinter7 ( ) throws IOException { } public void testExcelPrinter1 ( ) throws IOException { } public void testExcelPrinter2 ( ) throws IOException { } public void testRandom ( ) throws Exception { int iter = 10000 ; format = CSVFormat . DEFAULT ; doRandom ( iter ) ; format = CSVFormat . EXCEL ; doRandom ( iter ) ; <START_BUG> format = new CSVFormat ( '\t' , CSVFormat . ENCAPSULATOR_DISABLED , CSVFormat . COMMENTS_DISABLED , '\\' , false , false , false , false ) ; <END_BUG> doRandom ( iter ) ; } Random r = new Random ( ) ; CSVFormat format ; public void doRandom ( int iter ) throws Exception { } public void doOneRandom ( ) throws Exception { } public static boolean equals ( String [ ] [ ] a , String [ ] [ ] b ) { } public static String printable ( String s ) { } public String randStr ( ) { } } 
public class XmlLogger implements BuildListener { private static final DocumentBuilder builder = XmlLogger . getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private Document doc ; private Hashtable tasks = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private Hashtable threadStacks = new Hashtable ( ) ; private XmlLogger . TimedElement buildElement = null ; private static class TimedElement { long startTime ; Element element ; } public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { long totalTime = ( System . currentTimeMillis ( ) ) - ( buildElement . startTime ) ; buildElement . element . setAttribute ( XmlLogger . TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( ( event . getException ( ) ) != null ) { buildElement . element . setAttribute ( XmlLogger . ERROR_ATTR , event . getException ( ) . toString ( ) ) ; } try { String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } Writer out = new OutputStreamWriter ( new FileOutputStream ( outFilename ) , "UTF8" ) ; <START_BUG> out . write ( "<?xml<seq2seq4repair_space>version=\"1.0\"?>\n" ) ; <END_BUG> out . write ( "<?xml:stylesheet<seq2seq4repair_space>type=\"text/xsl\"<seq2seq4repair_space>href=\"log.xsl\"?>\n\n" ) ; new DOMElementWriter ( ) . write ( buildElement . element , out , 0 , "\t" ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable<seq2seq4repair_space>to<seq2seq4repair_space>close<seq2seq4repair_space>log<seq2seq4repair_space>file" , exc ) ; } buildElement = null ; } private Stack getStack ( ) { } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } } 
public class LabeledStatement extends Statement { public Statement statement ; public char [ ] label ; public Label targetLabel ; int mergedInitStateIndex = - 1 ; public LabeledStatement ( char [ ] label , Statement statement , int sourceStart , int sourceEnd ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public ASTNode concreteStatement ( ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { int pc = codeStream . position ; if ( ( targetLabel ) != null ) { <START_BUG> targetLabel . codeStream = codeStream ; <END_BUG> if ( ( statement ) != null ) { statement . generateCode ( currentScope , codeStream ) ; } targetLabel . place ( ) ; } if ( ( mergedInitStateIndex ) != ( - 1 ) ) { codeStream . removeNotDefinitelyAssignedVariables ( currentScope , mergedInitStateIndex ) ; } codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; } public StringBuffer printStatement ( int tab , StringBuffer output ) { } public void resolve ( BlockScope scope ) { } public void traverse ( ASTVisitor visitor , BlockScope blockScope ) { } public void resetStateForCodeGeneration ( ) { } } 
public class StatefulComponentDescription extends SessionBeanComponentDescription { private Method afterBegin ; private Method afterCompletion ; private Method beforeCompletion ; private final Map < MethodIdentifier , StatefulComponentDescription . StatefulRemoveMethod > removeMethods = new HashMap < MethodIdentifier , StatefulComponentDescription . StatefulRemoveMethod > ( ) ; private StatefulTimeoutInfo statefulTimeout ; private CacheInfo cache ; private Map < Method , String > initMethods = new HashMap < Method , String > ( 0 ) ; public class StatefulRemoveMethod { private final MethodIdentifier methodIdentifier ; private final boolean retainIfException ; StatefulRemoveMethod ( final MethodIdentifier method , final boolean retainIfException ) { } public MethodIdentifier getMethodIdentifier ( ) { } public boolean isRetainIfException ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } } public StatefulComponentDescription ( final String componentName , final String componentClassName , final EjbJarDescription ejbJarDescription , final ServiceName deploymentUnitServiceName , final SessionBeanMetaData descriptorData ) { } private void addInitMethodInvokingInterceptor ( ) { } private void addStatefulSessionSynchronizationInterceptor ( ) { } @ Override public ComponentConfiguration createConfiguration ( final ClassIndex classIndex , final ClassLoader moduleClassLoder ) { } @ Override public boolean allowsConcurrentAccess ( ) { } public Method getAfterBegin ( ) { } public Method getAfterCompletion ( ) { } public Method getBeforeCompletion ( ) { } @ Override public SessionBeanType getSessionBeanType ( ) { } public void setAfterBegin ( final Method afterBegin ) { } public void setAfterCompletion ( final Method afterCompletion ) { } public void setBeforeCompletion ( final Method afterCompletion ) { } @ Override protected void setupViewInterceptors ( EJBViewDescription view ) { } @ Override protected ViewConfigurator getSessionBeanObjectViewConfigurator ( ) { } private void addViewSerializationInterceptor ( final ViewDescription view ) { view . setSerializable ( true ) ; view . setUseWriteReplace ( true ) ; view . getConfigurators ( ) . add ( new ViewConfigurator ( ) { @ Override public void configure ( final DeploymentPhaseContext context , final ComponentConfiguration componentConfiguration , final ViewDescription description , final ViewConfiguration configuration ) throws DeploymentUnitProcessingException { final DeploymentReflectionIndex index = context . getDeploymentUnit ( ) . getAttachment ( REFLECTION_INDEX ) ; ClassReflectionIndex < WriteReplaceInterface > classIndex = index . getClassIndex ( WriteReplaceInterface . class ) ; for ( Method method : classIndex . getMethods ( ) ) { <START_BUG> configuration . addClientInterceptor ( method , new WriteReplaceInterceptor . Factory ( configuration . getViewServiceName ( ) . getCanonicalName ( ) ) , WRITE_REPLACE ) ; <END_BUG> } } } ) ; } public void addRemoveMethod ( final MethodIdentifier removeMethod , final boolean retainIfException ) { } public Collection < StatefulComponentDescription . StatefulRemoveMethod > getRemoveMethods ( ) { } public StatefulTimeoutInfo getStatefulTimeout ( ) { } public void setStatefulTimeout ( final StatefulTimeoutInfo statefulTimeout ) { } private void addStatefulInstanceAssociatingInterceptor ( final EJBViewDescription view ) { } private void addRemoveMethodInterceptor ( final ViewDescription view ) { } public void addInitMethod ( final Method method , final String createMethod ) { } public Map < Method , String > getInitMethods ( ) { } public CacheInfo getCache ( ) { } public void setCache ( CacheInfo cache ) { } @ Override public boolean isPassivationApplicable ( ) { } } 
@ RunWith ( Arquillian . class ) public class StatefulBeanTestCase { private static final Logger log = Logger . getLogger ( StatefulBeanTestCase . class . getName ( ) ) ; @ Deployment public static JavaArchive createDeployment ( ) { } @ EJB ( mappedName = "java:global/ejb3-sfsb-example/SimpleStatefulSessionBean!org.jboss.as.demos.ejb3.archive.SimpleStatefulSessionLocal" ) private SimpleStatefulSessionLocal localSfsb ; @ Test public void testSFSB ( ) throws Exception { String state = "not<seq2seq4repair_space>in<seq2seq4repair_space>a<seq2seq4repair_space>good<seq2seq4repair_space>mood!" ; localSfsb . setState ( state ) ; String storedState = localSfsb . getState ( ) ; <START_BUG> Assert . assertEquals ( "Unexpected<seq2seq4repair_space>state<seq2seq4repair_space>returned<seq2seq4repair_space>from<seq2seq4repair_space>stateful<seq2seq4repair_space>session<seq2seq4repair_space>bean" , ( ( ( SimpleInterceptor . class . getSimpleName ( ) ) + "#" ) + state ) , storedState ) ; <END_BUG> } } 
final class EmbedClob extends ConnectionChild implements Clob , EngineLOB { private InternalClob clob ; private boolean isValid = true ; private int locator ; EmbedClob ( EmbedConnection con ) throws SQLException { } protected EmbedClob ( EmbedConnection con , DataValueDescriptor dvd ) throws StandardException { } public long length ( ) throws SQLException { } public String getSubString ( long pos , int length ) throws SQLException { } public Reader getCharacterStream ( ) throws SQLException { } public InputStream getAsciiStream ( ) throws SQLException { } public long position ( String searchStr , long start ) throws SQLException { } public long position ( Clob searchClob , long start ) throws SQLException { } public int setString ( long pos , String str ) throws SQLException { } public int setString ( long pos , String str , int offset , int len ) throws SQLException { } public OutputStream setAsciiStream ( long pos ) throws SQLException { } public Writer setCharacterStream ( long pos ) throws SQLException { } public void truncate ( long len ) throws SQLException { } public void free ( ) throws SQLException { } public Reader getCharacterStream ( long pos , long length ) throws SQLException { checkValidity ( ) ; if ( pos <= 0 ) { throw Util . generateCsSQLException ( BLOB_BAD_POSITION , new Long ( pos ) ) ; } if ( length < 0 ) { throw Util . generateCsSQLException ( BLOB_NONPOSITIVE_LENGTH , new Long ( length ) ) ; } <START_BUG> if ( length > ( ( this . length ( ) ) - pos ) ) { <END_BUG> throw Util . generateCsSQLException ( POS_AND_LENGTH_GREATER_THAN_LOB , new Long ( pos ) , new Long ( length ) ) ; } try { return new ClobUpdatableReader ( this , ( pos - 1 ) , length ) ; } catch ( IOException ioe ) { throw Util . setStreamFailure ( ioe ) ; } } private void checkValidity ( ) throws SQLException { } private void makeWritableClobClone ( ) throws IOException , SQLException { } private void makeWritableClobClone ( long len ) throws IOException , SQLException { } InternalClob getInternalClob ( ) { } public int getLocator ( ) { } } 
public class KindedPointcut extends Pointcut { Kind kind ; private SignaturePattern signature ; private Set matchKinds ; private ShadowMunger munger = null ; public KindedPointcut ( Shadow . Kind kind , SignaturePattern signature ) { } public KindedPointcut ( Shadow . Kind kind , SignaturePattern signature , ShadowMunger munger ) { } public SignaturePattern getSignature ( ) { } public Set couldMatchKinds ( ) { } public boolean couldEverMatchSameJoinPointsAs ( KindedPointcut other ) { } public FuzzyBoolean fastMatch ( FastMatchInfo info ) { } public FuzzyBoolean fastMatch ( Class targetType ) { } protected FuzzyBoolean matchInternal ( Shadow shadow ) { } private void warnOnBridgeMethod ( Shadow shadow ) { } public FuzzyBoolean match ( JoinPoint . StaticPart jpsp ) { } public boolean matchesDynamically ( Object thisObject , Object targetObject , Object [ ] args ) { } public FuzzyBoolean matchesStatically ( String joinpointKind , Member member , Class thisClass , Class targetClass , Member withinCode ) { } private void warnOnConfusingSig ( Shadow shadow ) { } public boolean equals ( Object other ) { } public int hashCode ( ) { } public String toString ( ) { } public void postRead ( ResolvedType enclosingType ) { } public void write ( DataOutputStream s ) throws IOException { } public static Pointcut read ( VersionedDataInputStream s , ISourceContext context ) throws IOException { } public void resolveBindings ( IScope scope , Bindings bindings ) { if ( ( kind ) == ( Shadow . Initialization ) ) { } signature = signature . resolveBindings ( scope , bindings ) ; if ( ( kind ) == ( Shadow . ConstructorExecution ) ) { if ( ( signature . getDeclaringType ( ) ) != null ) { World world = scope . getWorld ( ) ; UnresolvedType exactType = signature . getDeclaringType ( ) . getExactType ( ) ; if ( ( ( ( ( signature . getKind ( ) ) == ( org . aspectj . weaver . Member . CONSTRUCTOR ) ) && ( ! ( exactType . equals ( MISSING ) ) ) ) && ( exactType . resolve ( world ) . isInterface ( ) ) ) && ( ! ( signature . getDeclaringType ( ) . isIncludeSubtypes ( ) ) ) ) { world . getLint ( ) . noInterfaceCtorJoinpoint . signal ( exactType . toString ( ) , getSourceLocation ( ) ) ; } } } if ( ( kind ) == ( Shadow . StaticInitialization ) ) { UnresolvedType exactType = signature . getDeclaringType ( ) . getExactType ( ) ; <START_BUG> if ( ( exactType . isParameterizedType ( ) ) && ( ! ( signature . getDeclaringType ( ) . isIncludeSubtypes ( ) ) ) ) { <END_BUG> scope . message ( MessageUtil . error ( WeaverMessages . format ( NO_STATIC_INIT_JPS_FOR_PARAMETERIZED_TYPES ) , getSourceLocation ( ) ) ) ; } } } public void resolveBindingsFromRTTI ( ) { } protected Test findResidueInternal ( Shadow shadow , ExposedState state ) { } public Pointcut concretize1 ( ResolvedType inAspect , IntMap bindings ) { } public Kind getKind ( ) { } public Object accept ( PatternNodeVisitor visitor , Object data ) { } } 
@ RunWith ( Arquillian . class ) @ Category ( CommonCriteria . class ) public class EJBSecurityTestCase { private static Context ctx ; @ AfterClass public static void afterClass ( ) throws NamingException { } @ BeforeClass public static void beforeClass ( ) throws NamingException { } @ Deployment public static JavaArchive createDeployment ( ) { final JavaArchive jar = ShrinkWrap . create ( JavaArchive . class , "ejb-security-test.jar" ) ; jar . addPackage ( AnnotatedSLSB . class . getPackage ( ) ) ; <START_BUG> jar . addAsManifestResource ( "ejb/security/ejb-jar.xml" , "ejb-jar.xml" ) ; <END_BUG> jar . addAsManifestResource ( EJBSecurityTestCase . class . getPackage ( ) , "jboss-ejb3.xml" , "jboss-ejb3.xml" ) ; jar . addPackage ( CommonCriteria . class . getPackage ( ) ) ; return jar ; } private static < T > T lookup ( final Class < ? > beanClass , final Class < T > viewClass ) throws NamingException { } @ Test public void testDenyAllAnnotation ( ) throws Exception { } @ Test public void testEJB2 ( ) throws Exception { } @ Test public void testExcludeList ( ) throws Exception { } @ Test public void testSecurityOnBeanInAbsenceOfExplicitSecurityDomain ( ) throws Exception { } @ Test public void testEmptyRolesAllowedAnnotationValue ( ) throws Exception { } } 
public class HttpMirrorServer extends Thread implements Stoppable { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final int ACCEPT_TIMEOUT = 1000 ; private final int daemonPort ; private volatile boolean running ; private volatile Exception except ; public HttpMirrorServer ( int port ) { } @ Override public void run ( ) { } public void stopServer ( ) { } public Exception getException ( ) { } public static void main ( String [ ] args ) { <START_BUG> int port = 8081 ; <END_BUG> if ( ( args . length ) > 0 ) { port = Integer . parseInt ( args [ 0 ] ) ; } LoggingManager . setPriority ( "INFO" ) ; LoggingManager . setLoggingLevels ( System . getProperties ( ) ) ; HttpMirrorServer serv = new HttpMirrorServer ( port ) ; serv . start ( ) ; } } 
public class TreeColumn extends Item { Tree parent ; boolean resizable ; boolean moveable ; public TreeColumn ( Tree parent , int style ) { } public TreeColumn ( Tree parent , int style , int index ) { } public void addControlListener ( ControlListener listener ) { } public void addSelectionListener ( SelectionListener listener ) { } static int checkStyle ( int style ) { } protected void checkSubclass ( ) { } void destroyWidget ( ) { } public int getAlignment ( ) { } public boolean getMoveable ( ) { } String getNameText ( ) { } public Tree getParent ( ) { } public boolean getResizable ( ) { } public int getWidth ( ) { } public void pack ( ) { checkWidget ( ) ; int index = parent . indexOf ( this ) ; if ( index == ( - 1 ) ) return ; int columnWidth = 0 ; int hwnd = parent . handle ; int hDC = OS . GetDC ( hwnd ) ; int oldFont = 0 ; int newFont = OS . SendMessage ( hwnd , WM_GETFONT , 0 , 0 ) ; if ( newFont != 0 ) oldFont = OS . SelectObject ( hDC , newFont ) ; int cp = parent . getCodePage ( ) ; RECT rect = new RECT ( ) ; int flags = ( OS . DT_CALCRECT ) | ( OS . DT_NOPREFIX ) ; TVITEM tvItem = new TVITEM ( ) ; tvItem . mask = OS . TVIF_PARAM ; int hItem = OS . SendMessage ( hwnd , TVM_GETNEXTITEM , TVGN_ROOT , 0 ) ; while ( hItem != 0 ) { hItem = OS . SendMessage ( hwnd , TVM_GETNEXTITEM , TVGN_NEXTVISIBLE , hItem ) ; tvItem . hItem = hItem ; OS . SendMessage ( hwnd , TVM_GETITEM , 0 , tvItem ) ; TreeItem item = parent . items [ tvItem . lParam ] ; if ( index == 0 ) { rect . left = item . handle ; if ( ( OS . SendMessage ( hwnd , TVM_GETITEMRECT , 1 , rect ) ) != 0 ) { columnWidth = Math . max ( columnWidth , rect . right ) ; } } else { int imageWidth = 0 ; int textWidth = 0 ; Image image = ( ( item . images ) != null ) ? item . images [ index ] : null ; if ( image != null ) { Rectangle bounds = image . getBounds ( ) ; imageWidth = bounds . width ; } String string = ( ( item . strings ) != null ) ? item . strings [ index ] : null ; if ( string != null ) { TCHAR buffer = new TCHAR ( cp , string , false ) ; OS . DrawText ( hDC , buffer , buffer . length ( ) , rect , flags ) ; textWidth = ( rect . right ) - ( rect . left ) ; } columnWidth = Math . max ( columnWidth , ( ( imageWidth + textWidth ) + ( ( Tree . INSET ) * 3 ) ) ) ; } } <START_BUG> TCHAR buffer = new TCHAR ( cp , text , true ) ; <END_BUG> OS . DrawText ( hDC , buffer , buffer . length ( ) , rect , flags ) ; int headerWidth = ( ( rect . right ) - ( rect . left ) ) + ( Tree . HEADER_MARGIN ) ; if ( ( ( image ) != null ) || ( ( parent . sortColumn ) == ( this ) ) ) { Image headerImage = null ; if ( ( ( parent . sortColumn ) == ( this ) ) && ( ( parent . sortDirection ) != ( SWT . NULL ) ) ) { if ( ( OS . COMCTL32_MAJOR ) < 6 ) { headerImage = display . getSortImage ( parent . sortDirection ) ; } else { headerWidth += Tree . SORT_WIDTH ; } } else { headerImage = image ; } if ( headerImage != null ) { Rectangle bounds = headerImage . getBounds ( ) ; headerWidth += bounds . width ; } int margin = 0 ; int hwndHeader = parent . hwndHeader ; if ( ( hwndHeader != 0 ) && ( ( OS . COMCTL32_VERSION ) >= ( OS . VERSION ( 5 , 80 ) ) ) ) { margin = OS . SendMessage ( hwndHeader , HDM_GETBITMAPMARGIN , 0 , 0 ) ; } else { margin = ( OS . GetSystemMetrics ( SM_CXEDGE ) ) * 3 ; } headerWidth += margin * 2 ; } if ( newFont != 0 ) OS . SelectObject ( hDC , oldFont ) ; OS . ReleaseDC ( hwnd , hDC ) ; setWidth ( Math . max ( headerWidth , columnWidth ) ) ; } void releaseHandle ( ) { } void releaseParent ( ) { } public void removeControlListener ( ControlListener listener ) { } public void removeSelectionListener ( SelectionListener listener ) { } public void setAlignment ( int alignment ) { } public void setImage ( Image image ) { } void setImage ( Image image , boolean sort , boolean right ) { } public void setMoveable ( boolean moveable ) { } public void setResizable ( boolean resizable ) { } void setSortDirection ( int direction ) { } public void setText ( String string ) { } public void setWidth ( int width ) { } } 
public class DrawApplication extends JFrame implements DrawingEditor , PaletteListener , VersionRequester { private Tool fTool ; private Iconkit fIconkit ; private JTextField fStatusLine ; private DrawingView fView ; private ToolButton fDefaultToolButton ; private ToolButton fSelectedToolButton ; private String fApplicationName ; private StorageFormatManager fStorageFormatManager ; private UndoManager myUndoManager ; protected static String fgUntitled = "untitled" ; private final EventListenerList listenerList = new EventListenerList ( ) ; private DesktopListener fDesktopListener ; private Desktop fDesktop ; private static final String fgDrawPath = "/CH/ifa/draw/" ; public static final String IMAGES = ( DrawApplication . fgDrawPath ) + "images/" ; protected static int winCount = 0 ; public static final int FILE_MENU = 0 ; public static final int EDIT_MENU = 1 ; public static final int ALIGNMENT_MENU = 2 ; public static final int ATTRIBUTES_MENU = 3 ; public DrawApplication ( ) { } public DrawApplication ( String title ) { } protected DrawApplication createApplication ( ) { } public void newView ( ) { } public void newWindow ( Drawing initialDrawing ) { } public void open ( ) { } protected synchronized void open ( DrawingView newDrawingView ) { } protected void addListeners ( ) { } protected void createMenus ( JMenuBar mb ) { } protected void addMenuIfPossible ( JMenuBar mb , JMenu newMenu ) { } protected JMenu createFileMenu ( ) { } protected JMenu createEditMenu ( ) { } protected JMenu createAlignmentMenu ( ) { } protected JMenu createDebugMenu ( ) { CommandMenu menu = new CommandMenu ( "Debug" ) ; Command cmd = new AbstractCommand ( "Simple<seq2seq4repair_space>Update" , this ) { <START_BUG> public void executable ( ) { <END_BUG> this . view ( ) . setDisplayUpdate ( new SimpleUpdateStrategy ( ) ) ; } } ; menu . add ( cmd ) ; cmd = new AbstractCommand ( "Buffered<seq2seq4repair_space>Update" , this ) { public void executable ( ) { this . view ( ) . setDisplayUpdate ( new BufferedUpdateStrategy ( ) ) ; } } ; menu . add ( cmd ) ; return menu ; } protected JMenu createAttributesMenu ( ) { } protected JMenu createColorMenu ( String title , FigureAttributeConstant attribute ) { } protected JMenu createArrowMenu ( ) { } protected JMenu createFontMenu ( ) { } protected JMenu createFontStyleMenu ( ) { } protected JMenu createFontSizeMenu ( ) { } public JMenu createLookAndFeelMenu ( ) { } protected JToolBar createToolPalette ( ) { } protected void createTools ( JToolBar palette ) { } protected Tool createSelectionTool ( ) { } protected Tool createDefaultTool ( ) { } protected void setDefaultTool ( Tool newDefaultTool ) { } public Tool getDefaultTool ( ) { } protected ToolButton createToolButton ( String iconName , String toolName , Tool tool ) { } protected DrawingView createDrawingView ( ) { } protected DrawingView createDrawingView ( Drawing newDrawing ) { } protected DrawingView createInitialDrawingView ( ) { } protected Dimension getDrawingViewSize ( ) { } protected Drawing createDrawing ( ) { } protected Desktop createDesktop ( ) { } protected void setDesktop ( Desktop newDesktop ) { } public Desktop getDesktop ( ) { } public StorageFormatManager createStorageFormatManager ( ) { } protected final void setStorageFormatManager ( StorageFormatManager newStorageFormatManager ) { } public StorageFormatManager getStorageFormatManager ( ) { } protected Dimension defaultSize ( ) { } protected JTextField createStatusLine ( ) { } private void setStatusLine ( JTextField newStatusLine ) { } protected JTextField getStatusLine ( ) { } public void paletteUserSelected ( PaletteButton paletteButton ) { } public void paletteUserOver ( PaletteButton paletteButton , boolean inside ) { } public Tool tool ( ) { } public DrawingView view ( ) { } protected void setView ( DrawingView newView ) { } public DrawingView [ ] views ( ) { } public void toolDone ( ) { } public void figureSelectionChanged ( DrawingView view ) { } protected void checkCommandMenu ( CommandMenu cm ) { } public void addViewChangeListener ( ViewChangeListener vsl ) { } public void removeViewChangeListener ( ViewChangeListener vsl ) { } protected void fireViewSelectionChangedEvent ( DrawingView oldView , DrawingView newView ) { } protected void fireViewCreatedEvent ( DrawingView view ) { } protected void fireViewDestroyingEvent ( DrawingView view ) { } public void showStatus ( String string ) { } public void setTool ( Tool t , String name ) { } private void setSelected ( ToolButton button ) { } public void exit ( ) { } protected void destroy ( ) { } public void promptNew ( ) { } public void promptOpen ( ) { } public void promptSaveAs ( ) { } protected JFileChooser createOpenFileChooser ( ) { } protected JFileChooser createSaveFileChooser ( ) { } public void print ( ) { } protected void saveDrawing ( StorageFormat storeFormat , String file ) { } protected void loadDrawing ( StorageFormat restoreFormat , String file ) { } private void newLookAndFeel ( String landf ) { } protected void setDrawingTitle ( String drawingTitle ) { } protected String getDrawingTitle ( ) { } public void setApplicationName ( String applicationName ) { } public String getApplicationName ( ) { } protected void setUndoManager ( UndoManager newUndoManager ) { } public UndoManager getUndoManager ( ) { } protected VersionControlStrategy getVersionControlStrategy ( ) { } public String [ ] getRequiredVersions ( ) { } public String getDefaultDrawingTitle ( ) { } protected DesktopListener getDesktopListener ( ) { } protected void setDesktopListener ( DesktopListener desktopPaneListener ) { } protected DesktopListener createDesktopListener ( ) { } protected Iconkit createIconkit ( ) { } protected void setIconkit ( Iconkit newIconkit ) { } protected Iconkit getIconkit ( ) { } } 
public class MethodVerifier implements TagBits , TypeConstants { SourceTypeBinding type ; HashtableOfObject inheritedMethods ; HashtableOfObject currentMethods ; ReferenceBinding runtimeException ; ReferenceBinding errorException ; LookupEnvironment environment ; MethodVerifier ( LookupEnvironment environment ) { } boolean areMethodsEqual ( MethodBinding one , MethodBinding two ) { } boolean areParametersEqual ( MethodBinding one , MethodBinding two ) { } boolean areReturnTypesEqual ( MethodBinding one , MethodBinding two ) { } boolean areTypesEqual ( TypeBinding one , TypeBinding two ) { } boolean canSkipInheritedMethods ( ) { } boolean canSkipInheritedMethods ( MethodBinding one , MethodBinding two ) { } void checkAbstractMethod ( MethodBinding abstractMethod ) { } void checkAgainstInheritedMethods ( MethodBinding currentMethod , MethodBinding [ ] methods , int length , MethodBinding [ ] otherInheritedMethods ) { } void checkConcreteInheritedMethod ( MethodBinding concreteMethod , MethodBinding [ ] abstractMethods ) { } void checkExceptions ( MethodBinding newMethod , MethodBinding inheritedMethod ) { } void checkForBridgeMethod ( MethodBinding currentMethod , MethodBinding inheritedMethod , MethodBinding [ ] otherInheritedMethods ) { } void checkForInheritedNameClash ( MethodBinding inheritedMethod , MethodBinding otherInheritedMethod ) { } void checkForNameClash ( MethodBinding currentMethod , MethodBinding inheritedMethod ) { } void checkInheritedMethods ( MethodBinding [ ] methods , int length ) { MethodBinding first = methods [ 0 ] ; int index = length ; while ( ( ( -- index ) > 0 ) && ( areReturnTypesEqual ( first , methods [ index ] ) ) ) { } if ( index > 0 ) { problemReporter ( ) . inheritedMethodsHaveIncompatibleReturnTypes ( this . type , methods , length ) ; return ; } MethodBinding concreteMethod = null ; if ( ! ( type . isInterface ( ) ) ) { for ( int i = length ; ( -- i ) >= 0 ; ) { if ( ! ( methods [ i ] . isAbstract ( ) ) ) { concreteMethod = methods [ i ] ; break ; } } } if ( concreteMethod == null ) { <START_BUG> if ( ( this . type . isClass ( ) ) && ( ! ( this . type . isAbstract ( ) ) ) ) { <END_BUG> for ( int i = length ; ( -- i ) >= 0 ; ) { if ( mustImplementAbstractMethod ( methods [ i ] . declaringClass ) ) { TypeDeclaration typeDeclaration = this . type . scope . referenceContext ; if ( typeDeclaration != null ) { MethodDeclaration missingAbstractMethod = typeDeclaration . addMissingAbstractMethodFor ( methods [ 0 ] ) ; missingAbstractMethod . scope . problemReporter ( ) . abstractMethodMustBeImplemented ( this . type , methods [ 0 ] ) ; } else { problemReporter ( ) . abstractMethodMustBeImplemented ( this . type , methods [ 0 ] ) ; } return ; } } } return ; } MethodBinding [ ] abstractMethods = new MethodBinding [ length - 1 ] ; index = 0 ; for ( int i = length ; ( -- i ) >= 0 ; ) if ( ( methods [ i ] ) != concreteMethod ) abstractMethods [ ( index ++ ) ] = methods [ i ] ; checkConcreteInheritedMethod ( concreteMethod , abstractMethods ) ; } void checkMethods ( ) { } void checkPackagePrivateAbstractMethod ( MethodBinding abstractMethod ) { } void computeInheritedMethods ( ) { } void computeInheritedMethods ( ReferenceBinding superclass , ReferenceBinding [ ] superInterfaces ) { } void computeMethods ( ) { } MethodBinding computeSubstituteMethod ( MethodBinding inheritedMethod , MethodBinding currentMethod ) { } public boolean doesMethodOverride ( MethodBinding method , MethodBinding inheritedMethod ) { } public boolean doReturnTypesCollide ( MethodBinding method , MethodBinding inheritedMethod ) { } ReferenceBinding errorException ( ) { } boolean isAsVisible ( MethodBinding newMethod , MethodBinding inheritedMethod ) { } boolean isInterfaceMethodImplemented ( MethodBinding inheritedMethod , MethodBinding existingMethod , ReferenceBinding superType ) { } boolean isSameClassOrSubclassOf ( ReferenceBinding testClass , ReferenceBinding superclass ) { } boolean mustImplementAbstractMethod ( ReferenceBinding declaringClass ) { } boolean mustImplementAbstractMethods ( ) { } ProblemReporter problemReporter ( ) { } ProblemReporter problemReporter ( MethodBinding currentMethod ) { } ReferenceBinding [ ] resolvedExceptionTypesFor ( MethodBinding method ) { } ReferenceBinding runtimeException ( ) { } void verify ( SourceTypeBinding someType ) { } public String toString ( ) { } } 
public class ExpressionLanguageScenarioTests extends ExpressionTestCase { public void testScenario_UsingStandardInfrastructure ( ) { } public void testScenario_DefiningVariablesThatWillBeAccessibleInExpressions ( ) throws Exception { SpelAntlrExpressionParser parser = new SpelAntlrExpressionParser ( ) ; StandardEvaluationContext ctx = new StandardEvaluationContext ( ) ; ctx . setVariable ( "favouriteColour" , "blue" ) ; List < Integer > primes = new ArrayList < Integer > ( ) ; primes . addAll ( Arrays . asList ( 2 , 3 , 5 , 7 , 11 , 13 , 17 ) ) ; ctx . setVariable ( "primes" , primes ) ; Expression expr = parser . parseExpression ( "#favouriteColour" ) ; Object value = expr . getValue ( ctx ) ; assertEquals ( "blue" , value ) ; expr = parser . parseExpression ( "#primes.get(1)" ) ; value = expr . getValue ( ctx ) ; assertEquals ( 3 , value ) ; <START_BUG> expr = parser . parseExpression ( "#primes.?{#this>10}" ) ; <END_BUG> value = expr . getValue ( ctx ) ; assertEquals ( "[11,<seq2seq4repair_space>13,<seq2seq4repair_space>17]" , value . toString ( ) ) ; } static class TestClass { public String str ; private int property ; public int getProperty ( ) { } public void setProperty ( int i ) { } } public void testScenario_UsingADifferentRootContextObject ( ) throws Exception { } public static String repeat ( String s ) { } public void testScenario_RegisteringJavaMethodsAsFunctionsAndCallingThem ( ) throws NoSuchMethodException , SecurityException { } public void testScenario_AddingYourOwnPropertyResolvers_1 ( ) throws Exception { } public void testScenario_AddingYourOwnPropertyResolvers_2 ( ) throws Exception { } private static class FruitColourAccessor implements PropertyAccessor { private static Map < String , Color > propertyMap = new HashMap < String , Color > ( ) ; private static TypeDescriptor mapElementTypeDescriptor = TypeDescriptor . valueOf ( Color . class ) ; public Class < ? > [ ] getSpecificTargetClasses ( ) { } public boolean canRead ( EvaluationContext context , Object target , String name ) throws AccessException { } public TypedValue read ( EvaluationContext context , Object target , String name ) throws AccessException { } public boolean canWrite ( EvaluationContext context , Object target , String name ) throws AccessException { } public void write ( EvaluationContext context , Object target , String name , Object newValue ) throws AccessException { } } private static class VegetableColourAccessor implements PropertyAccessor { private static Map < String , Color > propertyMap = new HashMap < String , Color > ( ) ; public Class < ? > [ ] getSpecificTargetClasses ( ) { } public boolean canRead ( EvaluationContext context , Object target , String name ) throws AccessException { } public TypedValue read ( EvaluationContext context , Object target , String name ) throws AccessException { } public boolean canWrite ( EvaluationContext context , Object target , String name ) throws AccessException { } public void write ( EvaluationContext context , Object target , String name , Object newValue ) throws AccessException { } } } 
public class LayoutAction extends Action { static final Logger logger = Logger . getLogger ( LayoutAction . class ) ; Layout layout ; public void begin ( ExecutionContext ec , String name , Attributes attributes ) { inError = false ; String className = attributes . getValue ( CLASS_ATTRIBUTE ) ; try { LayoutAction . logger . debug ( ( ( "About<seq2seq4repair_space>to<seq2seq4repair_space>instantiate<seq2seq4repair_space>layout<seq2seq4repair_space>of<seq2seq4repair_space>type<seq2seq4repair_space>[" + className ) + "]" ) ) ; Object instance = OptionConverter . instantiateByClassName ( className , Layout . class , null ) ; layout = ( ( Layout ) ( instance ) ) ; LayoutAction . logger . debug ( "Pushing<seq2seq4repair_space>layout<seq2seq4repair_space>on<seq2seq4repair_space>top<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>object<seq2seq4repair_space>stack." ) ; ec . pushObject ( layout ) ; } catch ( Exception oops ) { inError = true ; LayoutAction . logger . error ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>create<seq2seq4repair_space>an<seq2seq4repair_space>Layout.<seq2seq4repair_space>Reported<seq2seq4repair_space>error<seq2seq4repair_space>follows." , oops ) ; <START_BUG> ec . addError ( new org . apache . joran . ErrorItem ( ( ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>create<seq2seq4repair_space>layout<seq2seq4repair_space>of<seq2seq4repair_space>type<seq2seq4repair_space>" + className ) + "]." ) , ec . getLocator ( ) ) ) ; <END_BUG> } } public void end ( ExecutionContext ec , String e ) { } public void finish ( ExecutionContext ec ) { } } 
public class ConversionHelp { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final String CHAR_SET = "UTF-8" ; public static final String ATT_CLASS = "class" ; public static final String ATT_NAME = "name" ; public static final String ATT_ELEMENT_TYPE = "elementType" ; private static final String ATT_TE_ENABLED = "enabled" ; private static final String ATT_TE_TESTCLASS = "testclass" ; private static final String ATT_TE_GUICLASS = "guiclass" ; private static final String ATT_TE_NAME = "testname" ; private static String inVersion ; private static String outVersion = "1.1" ; public static void setInVersion ( String v ) { } public static void setOutVersion ( String v ) { } public static String encode ( String p ) { } public static String decode ( String p ) { } public static String cdata ( byte [ ] chars , String encoding ) throws UnsupportedEncodingException { <START_BUG> StringBuffer buf = new StringBuffer ( "<![CDATA[" ) ; <END_BUG> buf . append ( new String ( chars , encoding ) ) ; buf . append ( "]]>" ) ; return buf . toString ( ) ; } private static final Map < String , String > propertyToAttribute = new HashMap < String , String > ( ) ; private static void mapentry ( String prop , String att ) { } private static void saveClass ( TestElement el , HierarchicalStreamWriter writer , String prop ) { } private static void restoreClass ( TestElement el , HierarchicalStreamReader reader , String prop ) { } private static void saveItem ( TestElement el , HierarchicalStreamWriter writer , String prop , boolean encode ) { } private static void restoreItem ( TestElement el , HierarchicalStreamReader reader , String prop , boolean decode ) { } public static boolean isSpecialProperty ( String name ) { } public static void saveSpecialProperties ( TestElement el , HierarchicalStreamWriter writer ) { } public static void restoreSpecialProperties ( TestElement el , HierarchicalStreamReader reader ) { } } 
public class CounterConfig extends AbstractTestElement implements Serializable , LoopIterationListener , NoThreadClone { private static Logger log = LoggingManager . getLoggerFor ( ELEMENTS ) ; private static final String START = "CounterConfig.start" ; private static final String END = "CounterConfig.end" ; private static final String INCREMENT = "CounterConfig.incr" ; private static final String PER_USER = "CounterConfig.per_user" ; private static final String VAR_NAME = "CounterConfig.name" ; private boolean perUser = false ; private int globalCounter = - 1 ; private int currentIterationCount = - 1 ; public synchronized void iterationStart ( LoopIterationEvent event ) { JMeterVariables variables = JMeterContextService . getContext ( ) . getVariables ( ) ; int start = getStart ( ) ; int end = getEnd ( ) ; int increment = getIncrement ( ) ; if ( ! ( isPerUser ( ) ) ) { if ( ( ( globalCounter ) == ( - 1 ) ) || ( ( globalCounter ) > end ) ) { globalCounter = start ; } variables . put ( getVarName ( ) , Integer . toString ( globalCounter ) ) ; globalCounter += increment ; } else { String value = variables . get ( getVarName ( ) ) ; <START_BUG> if ( ( value == null ) || ( value . equals ( "" ) ) ) { <END_BUG> variables . put ( getVarName ( ) , Integer . toString ( start ) ) ; value = variables . get ( getVarName ( ) ) ; } else { try { int current = Integer . parseInt ( value ) ; current += increment ; if ( current > end ) { current = start ; } variables . put ( getVarName ( ) , Integer . toString ( current ) ) ; } catch ( NumberFormatException e ) { CounterConfig . log . info ( "Bad<seq2seq4repair_space>number<seq2seq4repair_space>in<seq2seq4repair_space>Counter<seq2seq4repair_space>config" , e ) ; } } } } public void setStart ( int start ) { } public void setStart ( String start ) { } public int getStart ( ) { } public void setEnd ( int end ) { } public void setEnd ( String end ) { } public int getEnd ( ) { } public void setIncrement ( int inc ) { } public void setIncrement ( String incr ) { } public int getIncrement ( ) { } public void setIsPerUser ( boolean isPer ) { } public boolean isPerUser ( ) { } public void setVarName ( String name ) { } public String getVarName ( ) { } } 
class DefaultCategoryFactory implements LoggerFactory { DefaultCategoryFactory ( ) { } public Logger makeNewLoggerInstance ( String name ) { <START_BUG> return new Category ( name ) ; <END_BUG> } } 
public class BaseHrefScanner extends TagScanner { private LinkProcessor processor ; public BaseHrefScanner ( ) { } public BaseHrefScanner ( String filter , LinkProcessor processor ) { } public String [ ] getID ( ) { } protected Tag createTag ( TagData tagData , Tag tag , String url ) throws ParserException { String baseUrl = ( ( String ) ( tag . getAttribute ( "HREF" ) ) ) ; String absoluteBaseUrl = "" ; if ( ( baseUrl != null ) && ( ( baseUrl . length ( ) ) > 0 ) ) { <START_BUG> absoluteBaseUrl = baseUrl . trim ( ) ; <END_BUG> processor . setBaseUrl ( absoluteBaseUrl ) ; } return new org . htmlparser . tags . BaseHrefTag ( tagData , absoluteBaseUrl ) ; } } 
@ RunWith ( Arquillian . class ) public class InflowTestCase extends ContainerResourceMgmtTestBase { @ Deployment public static ResourceAdapterArchive createDeployment ( ) throws Exception { } @ ArquillianResource ServiceContainer serviceContainer ; @ Test public void testRegistryConfiguration ( ) throws Throwable { ServiceController < ? > controller = serviceContainer . getService ( RA_REPOSITORY_SERVICE ) ; assertNotNull ( controller ) ; ResourceAdapterRepository repository = ( ( ResourceAdapterRepository ) ( controller . getValue ( ) ) ) ; assertNotNull ( repository ) ; Set < String > ids = repository . getResourceAdapters ( MessageListener . class ) ; assertNotNull ( ids ) ; <START_BUG> assertEquals ( 2 , ids . size ( ) ) ; <END_BUG> String piId = ids . iterator ( ) . next ( ) ; assertNotNull ( piId ) ; Endpoint endpoint = repository . getEndpoint ( piId ) ; assertNotNull ( endpoint ) ; List < MessageListener > listeners = repository . getMessageListeners ( piId ) ; assertNotNull ( listeners ) ; assertEquals ( 1 , listeners . size ( ) ) ; MessageListener listener = listeners . get ( 0 ) ; ActivationSpec as = listener . getActivation ( ) . createInstance ( ) ; assertNotNull ( as ) ; assertNotNull ( as . getResourceAdapter ( ) ) ; } @ Test public void testMetadataConfiguration ( ) throws Throwable { } } 
public class ServletResourceManager implements ResourceManager { private final FileResourceManager deploymentResourceManager ; private final Collection < VirtualFile > overlays ; public ServletResourceManager ( final VirtualFile resourcesRoot , final Collection < VirtualFile > overlays ) throws IOException { } @ Override public Resource getResource ( final String path ) throws IOException { Resource res = deploymentResourceManager . getResource ( path ) ; if ( res != null ) { return res ; } String p = path ; if ( p . startsWith ( "/" ) ) { p = p . substring ( 1 ) ; } if ( ( overlays ) != null ) { for ( VirtualFile overlay : overlays ) { VirtualFile child = overlay . getChild ( p ) ; if ( child . exists ( ) ) { URL url = child . toURL ( ) ; <START_BUG> return new URLResource ( url , url . openConnection ( ) ) ; <END_BUG> } } } return null ; } } 
final class RemoteServiceImpl implements InvocationHandler , IRemoteService { static final Object [ ] EMPTY_PARAMETERS = new Object [ 0 ] ; RemoteServiceReferenceImpl refImpl ; Object service ; private long nextID ; public RemoteServiceImpl ( final RemoteServiceReferenceImpl refImpl , final Object service ) { } public void callAsync ( final IRemoteCall call , final IRemoteCallListener listener ) { } public IFuture callAsync ( final IRemoteCall call ) { } public Object callSync ( final IRemoteCall call ) throws ECFException { } public void fireAsync ( final IRemoteCall call ) throws ECFException { } public Object getProxy ( ) throws ECFException { } synchronized long getNextID ( ) { } public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { } Method getMethod ( final Class aClass , String aMethodName , final Class [ ] someParameterTypes ) throws NoSuchMethodException { if ( ( someParameterTypes == null ) || ( ( someParameterTypes . length ) == 0 ) ) { return aClass . getMethod ( aMethodName , null ) ; } final Method [ ] methods = aClass . getMethods ( ) ; final int parameterCount = someParameterTypes . length ; aMethodName = aMethodName . intern ( ) ; OUTER : for ( int i = 0 ; i < ( methods . length ) ; i ++ ) { Method candidate = methods [ i ] ; String candidateMethodName = candidate . getName ( ) . intern ( ) ; Class [ ] candidateParameterTypes = candidate . getParameterTypes ( ) ; int candidateParameterCount = candidateParameterTypes . length ; if ( ( candidateParameterCount == parameterCount ) && ( aMethodName == candidateMethodName ) ) { for ( int j = 0 ; j < candidateParameterCount ; j ++ ) { Class clazzA = candidateParameterTypes [ j ] ; Class clazzB = someParameterTypes [ j ] ; if ( ! ( clazzA . isAssignableFrom ( clazzB ) ) ) { continue OUTER ; } } return candidate ; } } <START_BUG> throw new NoSuchMethodException ( ( ( ( ( "No<seq2seq4repair_space>such<seq2seq4repair_space>method:<seq2seq4repair_space>" + aMethodName ) + "(" ) + ( Arrays . toString ( someParameterTypes ) ) ) + ")" ) ) ; <END_BUG> } private class AsyncResult extends Thread { Object result ; Throwable exception ; IRemoteCall call ; private IRemoteCallListener listener ; AsyncResult ( final IRemoteCall call , final IRemoteCallListener listener ) { } public void run ( ) { } } } 
public class DeclareSoft extends Declare { private TypePattern exception ; private Pointcut pointcut ; public DeclareSoft ( TypePattern exception , Pointcut pointcut ) { } public String toString ( ) { } public boolean equals ( Object other ) { } public int hashCode ( ) { } public void write ( DataOutputStream s ) throws IOException { } public static Declare read ( DataInputStream s , ISourceContext context ) throws IOException { } public Pointcut getPointcut ( ) { } public TypePattern getException ( ) { } public void resolve ( IScope scope ) { <START_BUG> exception = exception . resolveBindings ( scope , null , false ) ; <END_BUG> pointcut = pointcut . resolve ( scope ) ; } public boolean isAdviceLike ( ) { } } 
public class FilterModel { private EventTypeEntryContainer eventContainer = new EventTypeEntryContainer ( ) ; private EventListenerList eventListenerList = new EventListenerList ( ) ; public void processNewLoggingEvent ( String eventType , LoggingEvent event ) { EventTypeEntryContainer container = getContainer ( eventType ) ; container . addLevel ( event . getLevel ( ) ) ; container . addLogger ( event . getLoggerName ( ) ) ; container . addThread ( event . getThreadName ( ) ) ; container . addNDC ( event . getNDC ( ) ) ; container . addMDCKeys ( event . getMDCKeySet ( ) ) ; <START_BUG> if ( ( event . getLocationInformation ( ) ) != null ) { <END_BUG> LocationInfo info = event . getLocationInformation ( ) ; container . addClass ( info . getClassName ( ) ) ; container . addMethod ( info . getMethodName ( ) ) ; container . addFileName ( info . getFileName ( ) ) ; } } public EventTypeEntryContainer getContainer ( ) { } EventTypeEntryContainer getContainer ( String eventType ) { } } 
public class TaskItem extends Item { TaskBar parent ; Shell shell ; NSImage defaultImage ; int progress ; int iProgress ; int progressState = SWT . DEFAULT ; Image overlayImage ; String overlayText = "" ; Menu menu ; static final int PROGRESS_MAX = 100 ; static final int PROGRESS_TIMER = 350 ; static final int PROGRESS_BARS = 7 ; TaskItem ( TaskBar parent , int style ) { } protected void checkSubclass ( ) { } void createWidget ( ) { } void destroyWidget ( ) { } public Menu getMenu ( ) { } public Image getOverlayImage ( ) { } public String getOverlayText ( ) { } public TaskBar getParent ( ) { } public int getProgress ( ) { } public int getProgressState ( ) { } void releaseHandle ( ) { } void releaseWidget ( ) { } public void setMenu ( Menu menu ) { } public void setOverlayImage ( Image image ) { } public void setOverlayText ( String string ) { } public void setProgress ( int progress ) { } public void setProgressState ( int progressState ) { } void setShell ( Shell shell ) { } void updateImage ( ) { boolean drawProgress = ( ( progress ) != 0 ) && ( ( progressState ) != ( SWT . DEFAULT ) ) ; boolean drawIntermidiate = ( progressState ) == ( SWT . INDETERMINATE ) ; NSApplication app = NSApplication . sharedApplication ( ) ; NSDockTile dock = app . dockTile ( ) ; boolean drawImage = ( ( overlayImage ) != null ) && ( ( dock . badgeLabel ( ) ) == null ) ; if ( ( ( ! drawImage ) && ( ! drawProgress ) ) && ( ! drawIntermidiate ) ) { <START_BUG> app . setApplicationIconImage ( null ) ; <END_BUG> return ; } NSSize size = defaultImage . size ( ) ; NSImage newImage = ( ( NSImage ) ( new NSImage ( ) . alloc ( ) ) ) ; newImage = newImage . initWithSize ( size ) ; NSBitmapImageRep rep = ( ( NSBitmapImageRep ) ( new NSBitmapImageRep ( ) . alloc ( ) ) ) ; rep = rep . initWithBitmapDataPlanes ( 0 , ( ( int ) ( size . width ) ) , ( ( int ) ( size . height ) ) , 8 , 4 , true , false , NSDeviceRGBColorSpace , ( ( OS . NSAlphaFirstBitmapFormat ) | ( OS . NSAlphaNonpremultipliedBitmapFormat ) ) , ( ( ( int ) ( size . width ) ) * 4 ) , 32 ) ; newImage . addRepresentation ( rep ) ; rep . release ( ) ; NSRect rect = new NSRect ( ) ; rect . height = size . height ; rect . width = size . width ; newImage . lockFocus ( ) ; defaultImage . drawInRect ( rect , rect , NSCompositeSourceOver , 1 ) ; if ( drawImage ) { NSImage badgetImage = overlayImage . handle ; NSSize badgeSize = badgetImage . size ( ) ; NSRect srcRect = new NSRect ( ) ; srcRect . height = badgeSize . height ; srcRect . width = badgeSize . width ; NSRect dstRect = new NSRect ( ) ; dstRect . x = ( size . width ) / 2 ; dstRect . height = ( size . height ) / 2 ; dstRect . width = ( size . width ) / 2 ; badgetImage . drawInRect ( dstRect , srcRect , NSCompositeSourceOver , 1 ) ; } if ( drawIntermidiate || drawProgress ) { switch ( progressState ) { case SWT . ERROR : NSColor . colorWithDeviceRed ( 1 , 0 , 0 , 0.6F ) . setFill ( ) ; break ; case SWT . PAUSED : NSColor . colorWithDeviceRed ( 1 , 1 , 0 , 0.6F ) . setFill ( ) ; break ; default : NSColor . colorWithDeviceRed ( 1 , 1 , 1 , 0.6F ) . setFill ( ) ; } rect . width = ( size . width ) / ( ( ( TaskItem . PROGRESS_BARS ) * 2 ) - 1 ) ; rect . height = ( size . height ) / 3 ; int count ; if ( drawIntermidiate ) { count = iProgress ; iProgress = ( ( iProgress ) + 1 ) % ( ( TaskItem . PROGRESS_BARS ) + 1 ) ; getDisplay ( ) . timerExec ( TaskItem . PROGRESS_TIMER , new Runnable ( ) { public void run ( ) { updateImage ( ) ; } } ) ; } else { count = ( ( progress ) * ( TaskItem . PROGRESS_BARS ) ) / ( TaskItem . PROGRESS_MAX ) ; } for ( int i = 0 ; i <= count ; i ++ ) { rect . x = ( i * 2 ) * ( rect . width ) ; NSBezierPath . fillRect ( rect ) ; } } newImage . unlockFocus ( ) ; app . setApplicationIconImage ( newImage ) ; newImage . release ( ) ; } void updateOverlayText ( String string ) { } } 
private EditorHistory editorHistory ; private PerspectiveHistory perspHistory ; private boolean runEventLoop ; private boolean isStarting = true ; private boolean isClosing = false ; private Object returnCode ; private WorkbenchConfigurationInfo configurationInfo ; private ListenerList windowListeners = new ListenerList ( ) ; private String [ ] commandLineArgs ; private static final String [ ] VERSION_STRING = new String [ ] { "0.046" , "2.0" } ; private static final String DEFAULT_WORKBENCH_STATE_FILENAME = "workbench.xml" ; private static final int RESTORE_CODE_OK = 0 ; private static final int RESTORE_CODE_RESET = 1 ; private static final int RESTORE_CODE_EXIT = 2 ; protected static final String WELCOME_EDITOR_ID = "org.eclipse.ui.internal.dialogs.WelcomeEditor" ; public Workbench ( ) { } private static final String TASK_LIST_ID = ( WorkbenchPlugin . PI_WORKBENCH ) + ".views.TaskList" ; private IResourceChangeListener getShowTasksChangeListener ( ) { } private IMarker findProblemToShow ( IResourceChangeEvent event ) { } public void addWindowListener ( IWindowListener l ) { } public void removeWindowListener ( IWindowListener l ) { } protected void fireWindowOpened ( IWorkbenchWindow window ) { } protected void fireWindowClosed ( IWorkbenchWindow window ) { } protected void fireWindowActivated ( IWorkbenchWindow window ) { } protected void fireWindowDeactivated ( IWorkbenchWindow window ) { } private void addAdapters ( ) { } private boolean busyClose ( final boolean force ) { } public boolean saveAllEditors ( boolean confirm ) { } private IWorkbenchWindow busyOpenWorkbenchWindow ( String perspID , IAdaptable input ) throws WorkbenchException { } private void checkUpdates ( String [ ] commandLineArgs ) { } public boolean close ( ) { } public boolean close ( Object returnCode ) { } public boolean close ( Object returnCode , final boolean force ) { } protected WorkbenchActionBuilder createActionBuilder ( IWorkbenchWindow window ) { } private void connectToWorkspace ( ) { } private void disconnectFromWorkspace ( ) { } public IWorkbenchWindow getActiveWorkbenchWindow ( ) { } public String [ ] getCommandLineArgs ( ) { } public EditorHistory getEditorHistory ( ) { } public PerspectiveHistory getPerspectiveHistory ( ) { } public IEditorRegistry getEditorRegistry ( ) { } protected int getNewWindowNumber ( ) { } public IPerspectiveRegistry getPerspectiveRegistry ( ) { } public PreferenceManager getPreferenceManager ( ) { } public IPreferenceStore getPreferenceStore ( ) { } public ISharedImages getSharedImages ( ) { } public IMarkerHelpRegistry getMarkerHelpRegistry ( ) { } protected WindowManager getWindowManager ( ) { } public WorkbenchConfigurationInfo getConfigurationInfo ( ) { } private File getWorkbenchStateFile ( ) { } public int getWorkbenchWindowCount ( ) { } public IWorkbenchWindow [ ] getWorkbenchWindows ( ) { } public IWorkingSetManager getWorkingSetManager ( ) { } public void updateKeys ( ) { } private boolean init ( String [ ] commandLineArgs ) { Manager . getInstance ( ) ; this . commandLineArgs = commandLineArgs ; if ( WorkbenchPlugin . getDefault ( ) . isDebugging ( ) ) { WorkbenchPlugin . DEBUG = true ; ModalContext . setDebugMode ( true ) ; } initializeProductImage ( ) ; connectToWorkspace ( ) ; addAdapters ( ) ; windowManager = new WindowManager ( ) ; WorkbenchColors . startup ( ) ; boolean useColorIcons = getPreferenceStore ( ) . getBoolean ( COLOR_ICONS ) ; ActionContributionItem . setUseColorIconsInToolbars ( useColorIcons ) ; initializeFonts ( ) ; updateKeys ( ) ; initializeSingleClickOption ( ) ; boolean avoidDeadlock = true ; for ( int i = 0 ; i < ( commandLineArgs . length ) ; i ++ ) { if ( commandLineArgs [ i ] . equalsIgnoreCase ( "-allowDeadlock" ) ) avoidDeadlock = false ; } if ( avoidDeadlock ) { try { Display display = Display . getCurrent ( ) ; UIWorkspaceLock uiLock = new UIWorkspaceLock ( WorkbenchPlugin . getPluginWorkspace ( ) , display ) ; WorkbenchPlugin . getPluginWorkspace ( ) . setWorkspaceLock ( uiLock ) ; display . setSynchronizer ( new UISynchronizer ( display , uiLock ) ) ; } catch ( CoreException e ) { e . printStackTrace ( System . out ) ; } } try { UIStats . start ( RESTORE_WORKBENCH , "Workbench" ) ; int restoreCode = openPreviousWorkbenchState ( ) ; if ( restoreCode == ( Workbench . RESTORE_CODE_EXIT ) ) return false ; if ( restoreCode == ( Workbench . RESTORE_CODE_RESET ) ) openFirstTimeWindow ( ) ; } finally { UIStats . end ( RESTORE_WORKBENCH , "Workbench" ) ; } forceOpenPerspective ( commandLineArgs ) ; <START_BUG> getConfigurationInfo ( ) . openWelcomeEditors ( ) ; <END_BUG> refreshFromLocal ( commandLineArgs ) ; isStarting = false ; return true ; } private void refreshFromLocal ( String [ ] commandLineArgs ) { } private void forceOpenPerspective ( String [ ] commandLineArgs ) { } private void initializeSingleClickOption ( ) { } private void initializeFonts ( ) { } private void initializeFont ( String fontKey , FontRegistry registry , IPreferenceStore store ) { } private void initializeProductImage ( ) { } public boolean isClosing ( ) { } public boolean isStarting ( ) { } protected WorkbenchWindow newWorkbenchWindow ( ) { } private void openFirstTimeWindow ( ) { } private int openPreviousWorkbenchState ( ) { } public IWorkbenchWindow openWorkbenchWindow ( IAdaptable input ) throws WorkbenchException { } public IWorkbenchWindow openWorkbenchWindow ( final String perspID , final IAdaptable input ) throws WorkbenchException { } private XMLMemento recordWorkbenchState ( ) { } public boolean restart ( ) { } private IStatus restoreState ( IMemento memento ) { } public IPluginDescriptor [ ] getEarlyActivatedPlugins ( ) { } protected void startPlugins ( ) { } public Object run ( Object arg ) { } protected void runEventLoop ( Window . IExceptionHandler handler ) { } private IStatus saveState ( IMemento memento ) { } private boolean saveWorkbenchState ( XMLMemento memento ) { } public void setInitializationData ( IConfigurationElement configElement , String propertyName , Object data ) { } public IWorkbenchPage showPerspective ( String perspectiveId , IWorkbenchWindow window ) throws WorkbenchException { } public IWorkbenchPage showPerspective ( String perspectiveId , IWorkbenchWindow window , IAdaptable input ) throws WorkbenchException { } private void shutdown ( ) { } public void refreshPluginActions ( String pluginId ) { } public IDecoratorManager getDecoratorManager ( ) { } } 
public class WeaveMessage extends Message { public static WeaveMessage . WeaveMessageKind WEAVEMESSAGE_DECLAREPARENTSIMPLEMENTS = new WeaveMessage . WeaveMessageKind ( 1 , "Extending<seq2seq4repair_space>interface<seq2seq4repair_space>set<seq2seq4repair_space>for<seq2seq4repair_space>type<seq2seq4repair_space>'%1'<seq2seq4repair_space>(%2)<seq2seq4repair_space>to<seq2seq4repair_space>include<seq2seq4repair_space>'%3'<seq2seq4repair_space>(%4)" ) ; public static WeaveMessage . WeaveMessageKind WEAVEMESSAGE_ITD = new WeaveMessage . WeaveMessageKind ( 2 , "Type<seq2seq4repair_space>'%1'<seq2seq4repair_space>(%2)<seq2seq4repair_space>has<seq2seq4repair_space>intertyped<seq2seq4repair_space>%3<seq2seq4repair_space>from<seq2seq4repair_space>'%4'<seq2seq4repair_space>(%5)" ) ; public static WeaveMessage . WeaveMessageKind WEAVEMESSAGE_ADVISES = new WeaveMessage . WeaveMessageKind ( 3 , "Type<seq2seq4repair_space>'%1'<seq2seq4repair_space>(%2)<seq2seq4repair_space>advised<seq2seq4repair_space>by<seq2seq4repair_space>%3<seq2seq4repair_space>advice<seq2seq4repair_space>from<seq2seq4repair_space>'%4'<seq2seq4repair_space>(%5)%6" ) ; public static WeaveMessage . WeaveMessageKind WEAVEMESSAGE_DECLAREPARENTSEXTENDS = new WeaveMessage . WeaveMessageKind ( 4 , "Setting<seq2seq4repair_space>superclass<seq2seq4repair_space>of<seq2seq4repair_space>type<seq2seq4repair_space>'%1'<seq2seq4repair_space>(%2)<seq2seq4repair_space>to<seq2seq4repair_space>'%3'<seq2seq4repair_space>(%4)" ) ; public static WeaveMessage . WeaveMessageKind WEAVEMESSAGE_SOFTENS = new WeaveMessage . WeaveMessageKind ( 5 , "Softening<seq2seq4repair_space>exceptions<seq2seq4repair_space>in<seq2seq4repair_space>type<seq2seq4repair_space>'%1'<seq2seq4repair_space>(%2)<seq2seq4repair_space>as<seq2seq4repair_space>defined<seq2seq4repair_space>by<seq2seq4repair_space>aspect<seq2seq4repair_space>'%3'<seq2seq4repair_space>(%4)" ) ; private WeaveMessage ( String message ) { } public static WeaveMessage constructWeavingMessage ( WeaveMessage . WeaveMessageKind kind , String [ ] inserts ) { StringBuffer str = new StringBuffer ( kind . getMessage ( ) ) ; int pos = - 1 ; <START_BUG> while ( ( pos = str . indexOf ( "%" ) ) != ( - 1 ) ) { <END_BUG> int n = Character . getNumericValue ( str . charAt ( ( pos + 1 ) ) ) ; str . replace ( pos , ( pos + 2 ) , inserts [ ( n - 1 ) ] ) ; } return new WeaveMessage ( str . toString ( ) ) ; } public static class WeaveMessageKind { private int id ; private String message ; public WeaveMessageKind ( int id , String message ) { } public String getMessage ( ) { } } } 
public class SequenceFilesFromLuceneStorageMRJobTest extends AbstractLuceneStorageTest { private SequenceFilesFromLuceneStorageMRJob lucene2seq ; private LuceneStorageConfiguration lucene2SeqConf ; @ Before public void before ( ) throws IOException { lucene2seq = new SequenceFilesFromLuceneStorageMRJob ( ) ; <START_BUG> Configuration configuration = new Configuration ( ) ; <END_BUG> Path seqOutputPath = new Path ( getTestTempDirPath ( ) , "seqOutputPath" ) ; lucene2SeqConf = new LuceneStorageConfiguration ( configuration , Arrays . asList ( getIndexPath1 ( ) , getIndexPath2 ( ) ) , seqOutputPath , SingleFieldDocument . ID_FIELD , Arrays . asList ( FIELD ) ) ; } @ After public void after ( ) throws IOException { } @ Test public void testRun ( ) throws IOException { } } 
public class MultiplexAppenderTest extends TestCase { private Logger root ; private Logger logger = Logger . getLogger ( MultiplexAppenderTest . class ) ; public void setUp ( ) { } public void testIllegalStates ( ) { MultiplexAppender appender = null ; appender = new MultiplexAppender ( ) ; try { <START_BUG> appender . activate ( ) ; <END_BUG> fail ( "Should<seq2seq4repair_space>have<seq2seq4repair_space>thrown<seq2seq4repair_space>an<seq2seq4repair_space>IllegalStateException<seq2seq4repair_space>because<seq2seq4repair_space>it<seq2seq4repair_space>should<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>configured<seq2seq4repair_space>correctly" ) ; } catch ( Exception e ) { } appender = null ; } protected void tearDown ( ) throws Exception { } public void testMDCSelector ( ) throws Exception { } public void testcreateMDCAndDailyRollingAppenderFactory ( ) { } } 
public class TimerServiceDeploymentProcessor implements DeploymentUnitProcessor { public static final ServiceName TIMER_SERVICE_NAME = JBOSS . append ( "ejb3" , "timer" ) ; private final ServiceName timerServiceThreadPool ; private final String defaultTimerDataStore ; public TimerServiceDeploymentProcessor ( final ServiceName timerServiceThreadPool , final String defaultTimerDataStore ) { } @ Override public void deploy ( final DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final EEModuleDescription moduleDescription = deploymentUnit . getAttachment ( EE_MODULE_DESCRIPTION ) ; final Module module = deploymentUnit . getAttachment ( MODULE ) ; final EjbJarMetaData ejbJarMetaData = deploymentUnit . getAttachment ( EJB_JAR_METADATA ) ; ServiceName defaultTimerPersistenceService = SERVICE_NAME . append ( defaultTimerDataStore ) ; final Map < String , ServiceName > timerPersistenceServices = new HashMap < String , ServiceName > ( ) ; final TimerServiceRegistry timerServiceRegistry = ( EjbDeploymentMarker . isEjbDeployment ( deploymentUnit ) ) ? new TimerServiceRegistry ( ) : null ; if ( ( ejbJarMetaData != null ) && ( ( ejbJarMetaData . getAssemblyDescriptor ( ) ) != null ) ) { List < TimerServiceMetaData > timerService = ejbJarMetaData . getAssemblyDescriptor ( ) . getAny ( TimerServiceMetaData . class ) ; if ( timerService != null ) { for ( TimerServiceMetaData data : timerService ) { if ( data . getEjbName ( ) . equals ( "*" ) ) { defaultTimerPersistenceService = SERVICE_NAME . append ( data . getDataStoreName ( ) ) ; } else { timerPersistenceServices . put ( data . getEjbName ( ) , SERVICE_NAME . append ( data . getDataStoreName ( ) ) ) ; } } } } final ServiceName finalDefaultTimerPersistenceService = defaultTimerPersistenceService ; for ( final ComponentDescription componentDescription : moduleDescription . getComponentDescriptions ( ) ) { if ( componentDescription . isTimerServiceApplicable ( ) ) { if ( componentDescription . isTimerServiceRequired ( ) ) { final String deploymentName ; if ( ( ( moduleDescription . getDistinctName ( ) ) == null ) || ( ( moduleDescription . getDistinctName ( ) . length ( ) ) == 0 ) ) { deploymentName = ( ( moduleDescription . getApplicationName ( ) ) + "." ) + ( moduleDescription . getModuleName ( ) ) ; } else { deploymentName = ( ( ( ( moduleDescription . getApplicationName ( ) ) + "." ) + ( moduleDescription . getModuleName ( ) ) ) + "." ) + ( moduleDescription . getDistinctName ( ) ) ; } <START_BUG> ROOT_LOGGER . debugf ( "Installing<seq2seq4repair_space>timer<seq2seq4repair_space>service<seq2seq4repair_space>for<seq2seq4repair_space>component<seq2seq4repair_space>%s" , componentDescription . getComponentName ( ) ) ; <END_BUG> componentDescription . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { @ Override public void configure ( final DeploymentPhaseContext context , final ComponentDescription description , final ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { final EJBComponentDescription ejbComponentDescription = ( ( EJBComponentDescription ) ( description ) ) ; final ServiceName invokerServiceName = ejbComponentDescription . getServiceName ( ) . append ( TimedObjectInvokerImpl . SERVICE_NAME ) ; final TimedObjectInvokerImpl invoker = new TimedObjectInvokerImpl ( deploymentName , module ) ; context . getServiceTarget ( ) . addService ( invokerServiceName , invoker ) . addDependency ( componentDescription . getCreateServiceName ( ) , EJBComponent . class , invoker . getEjbComponent ( ) ) . install ( ) ; final ServiceName serviceName = componentDescription . getServiceName ( ) . append ( TimerServiceImpl . SERVICE_NAME ) ; final TimerServiceImpl service = new TimerServiceImpl ( ejbComponentDescription . getScheduleMethods ( ) , serviceName , timerServiceRegistry ) ; final ServiceBuilder < TimerService > createBuilder = context . getServiceTarget ( ) . addService ( serviceName , service ) ; createBuilder . addDependency ( TimerServiceDeploymentProcessor . TIMER_SERVICE_NAME , Timer . class , service . getTimerInjectedValue ( ) ) ; createBuilder . addDependency ( componentDescription . getCreateServiceName ( ) , EJBComponent . class , service . getEjbComponentInjectedValue ( ) ) ; createBuilder . addDependency ( timerServiceThreadPool , ExecutorService . class , service . getExecutorServiceInjectedValue ( ) ) ; if ( timerPersistenceServices . containsKey ( ejbComponentDescription . getEJBName ( ) ) ) { createBuilder . addDependency ( timerPersistenceServices . get ( ejbComponentDescription . getEJBName ( ) ) , TimerPersistence . class , service . getTimerPersistence ( ) ) ; } else { createBuilder . addDependency ( finalDefaultTimerPersistenceService , TimerPersistence . class , service . getTimerPersistence ( ) ) ; } createBuilder . addDependency ( invokerServiceName , TimedObjectInvoker . class , service . getTimedObjectInvoker ( ) ) ; createBuilder . install ( ) ; ejbComponentDescription . setTimerService ( service ) ; configuration . getStartDependencies ( ) . add ( new org . jboss . as . ee . component . DependencyConfigurator < ComponentStartService > ( ) { @ Override public void configureDependency ( final ServiceBuilder < ? > serviceBuilder , final ComponentStartService service ) throws DeploymentUnitProcessingException { serviceBuilder . addDependency ( serviceName ) ; } } ) ; } } ) ; } else { componentDescription . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { @ Override public void configure ( final DeploymentPhaseContext context , final ComponentDescription description , final ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { final EJBComponentDescription ejbComponentDescription = ( ( EJBComponentDescription ) ( description ) ) ; final ServiceName nonFunctionalTimerServiceName = NonFunctionalTimerService . serviceNameFor ( ejbComponentDescription ) ; final NonFunctionalTimerService nonFunctionalTimerService ; if ( ejbComponentDescription instanceof StatefulComponentDescription ) { nonFunctionalTimerService = new NonFunctionalTimerService ( EjbLogger . ROOT_LOGGER . timerServiceMethodNotAllowedForSFSB ( ejbComponentDescription . getComponentName ( ) ) , timerServiceRegistry ) ; } else { nonFunctionalTimerService = new NonFunctionalTimerService ( EjbLogger . ROOT_LOGGER . ejbHasNoTimerMethods ( ) , timerServiceRegistry ) ; } context . getServiceTarget ( ) . addService ( nonFunctionalTimerServiceName , nonFunctionalTimerService ) . install ( ) ; ejbComponentDescription . setTimerService ( nonFunctionalTimerService ) ; configuration . getStartDependencies ( ) . add ( new org . jboss . as . ee . component . DependencyConfigurator < ComponentStartService > ( ) { @ Override public void configureDependency ( ServiceBuilder < ? > serviceBuilder , ComponentStartService service ) throws DeploymentUnitProcessingException { serviceBuilder . addDependency ( nonFunctionalTimerServiceName ) ; } } ) ; } } ) ; } } } } @ Override public void undeploy ( final DeploymentUnit context ) { } } 
public class PopupMenuExtender implements IRegistryChangeListener , IMenuListener2 { private static final int STATIC_ACTION_READ = 1 ; private static final int INCLUDE_EDITOR_INPUT = 1 << 1 ; private final MenuManager menu ; private SubMenuManager menuWrapper ; private final ISelectionProvider selProvider ; private final IWorkbenchPart part ; private Map staticActionBuilders = null ; private int bitSet = 0 ; private ArrayList contributionCache = new ArrayList ( ) ; public PopupMenuExtender ( String id , MenuManager menu , ISelectionProvider prov , IWorkbenchPart part ) { } public PopupMenuExtender ( final String id , final MenuManager menu , final ISelectionProvider prov , final IWorkbenchPart part , final boolean includeEditorInput ) { } public Set getMenuIds ( ) { } public final void addMenuId ( final String menuId ) { } public final boolean matches ( final MenuManager menuManager , final ISelectionProvider selectionProvider , final IWorkbenchPart part ) { } private void addEditorActions ( IMenuManager mgr ) { } private void addObjectActions ( IMenuManager mgr ) { } private final void clearStaticActions ( ) { } private void addStaticActions ( IMenuManager mgr ) { } public void menuAboutToShow ( IMenuManager mgr ) { } private boolean contributionsPopulated = false ; private void addMenuContributions ( IMenuManager mgr ) { } public final void menuAboutToHide ( final IMenuManager mgr ) { } private void sweepContributions ( IMenuManager mgr ) { if ( mgr == null ) return ; final IMenuService menuService = ( ( IMenuService ) ( part . getSite ( ) . getService ( IMenuService . class ) ) ) ; InternalMenuService realService = ( ( InternalMenuService ) ( menuService ) ) ; IContributionItem [ ] items = mgr . getItems ( ) ; for ( int i = 0 ; i < ( items . length ) ; i ++ ) { <START_BUG> if ( ( items [ i ] ) instanceof IMenuManager ) { <END_BUG> sweepContributions ( ( ( IMenuManager ) ( items [ i ] ) ) ) ; realService . releaseContributions ( ( ( ContributionManager ) ( items [ i ] ) ) ) ; ( ( ContributionManager ) ( items [ i ] ) ) . removeAll ( ) ; } } } private void gatherContributions ( final IMenuManager mgr ) { } private void cleanUpContributionCache ( ) { } private final void readStaticActions ( ) { } private void readStaticActionsFor ( final String menuId ) { } public void dispose ( ) { } public void registryChanged ( final IRegistryChangeEvent event ) { } public MenuManager getManager ( ) { } } 
public class KittenCaptchaPanel extends Panel { private static final long serialVersionUID = 2711167040323855070L ; private static BufferedImage grass = KittenCaptchaPanel . load ( "images/grass.png" ) ; private static final List < KittenCaptchaPanel . Animal > kittens = new ArrayList < KittenCaptchaPanel . Animal > ( ) ; private static final List < KittenCaptchaPanel . Animal > nonKittens = new ArrayList < KittenCaptchaPanel . Animal > ( ) ; private static Random random = new Random ( ( - 1 ) ) ; private static BufferedImage load ( final String filename ) { } private final KittenCaptchaPanel . PlacedAnimalList animals ; private final Label animalSelectionLabel ; private final Image image ; private final KittenCaptchaPanel . CaptchaImageResource imageResource ; private final Dimension imageSize ; public KittenCaptchaPanel ( final String id , final Dimension imageSize ) { } public boolean allKittensSelected ( ) { } public void reset ( ) { } private KittenCaptchaPanel . PlacedAnimal placeAnimal ( final List < KittenCaptchaPanel . PlacedAnimal > animals , final KittenCaptchaPanel . Animal newAnimal ) { } private int random ( final int max ) { } private KittenCaptchaPanel . Animal randomKitten ( ) { } private KittenCaptchaPanel . Animal randomNonKitten ( ) { } private static class Animal { private final BufferedImage highlightedImage ; private final BufferedImage image ; private final boolean isKitten ; private final OpaqueRegion visibleRegion ; private Animal ( final String filename , final boolean isKitten ) { } private BufferedImage load ( final String filename ) { } } private class CaptchaImageResource extends DynamicImageResource { private static final long serialVersionUID = - 1560784998742404278L ; private final KittenCaptchaPanel . PlacedAnimalList animals ; private transient SoftReference < byte [ ] > data = null ; @ Override protected void configureResponse ( ResourceResponse response , Attributes attributes ) { super . configureResponse ( response , attributes ) ; <START_BUG> response . setCacheDuration ( 0 ) ; <END_BUG> } private CaptchaImageResource ( final KittenCaptchaPanel . PlacedAnimalList animals ) { } @ Override protected byte [ ] getImageData ( Attributes attributes ) { } protected void invalidate ( ) { } private boolean allKittensSelected ( ) { } private void clearData ( ) { } private void reset ( ) { } private String selectString ( ) { } } private class PlacedAnimal implements Serializable { private static final long serialVersionUID = - 6703909440564862486L ; private transient KittenCaptchaPanel . Animal animal ; private final int index ; private boolean isHighlighted ; private final boolean isKitten ; private final Point location ; private final float [ ] scales = new float [ ] { 1.0F , 1.0F , 1.0F , 1.0F } ; public PlacedAnimal ( final KittenCaptchaPanel . Animal animal , final Point location ) { } @ Override public String toString ( ) { } private boolean contains ( final Point point ) { } private void draw ( final Graphics2D graphics ) { } private KittenCaptchaPanel . Animal getAnimal ( ) { } private float random ( float min , float max ) { } } private class PlacedAnimalList implements Serializable { private static final long serialVersionUID = 6335852594326213439L ; private final List < KittenCaptchaPanel . PlacedAnimal > animals = new ArrayList < KittenCaptchaPanel . PlacedAnimal > ( ) ; private PlacedAnimalList ( ) { } private boolean allKittensSelected ( ) { } private KittenCaptchaPanel . PlacedAnimal atLocation ( final Point location ) { } private BufferedImage createImage ( ) { } private void reset ( ) { } private String selectString ( ) { } private OpaqueRegion visibleRegion ( final KittenCaptchaPanel . PlacedAnimal animal ) { } } } 
public class UMLLinkedList extends UMLList2 implements MouseListener { public UMLLinkedList ( UMLModelElementListModel2 dataModel , boolean showIcon ) { } public UMLLinkedList ( UMLModelElementListModel2 dataModel ) { } protected void doIt ( ListSelectionEvent e ) { } public void mouseClicked ( MouseEvent e ) { if ( ( e . getSource ( ) ) == ( this ) ) { if ( ( ( e . getClickCount ( ) ) >= 2 ) && ( SwingUtilities . isLeftMouseButton ( e ) ) ) { Object o = getSelectedValue ( ) ; if ( o instanceof MModelElement ) { <START_BUG> TheInstance . setTarget ( o ) ; <END_BUG> } } e . consume ( ) ; } } public void mouseEntered ( MouseEvent e ) { } public void mouseExited ( MouseEvent e ) { } public void mousePressed ( MouseEvent e ) { } public void mouseReleased ( MouseEvent e ) { } } 
public class NewLoggingExtension implements NewExtension { public static final String SUBSYSTEM_NAME = "logging" ; private static final PathElement loggersPath = PathElement . pathElement ( LOGGER ) ; private static final PathElement handlersPath = PathElement . pathElement ( HANDLER ) ; public void initialize ( NewExtensionContext context ) { final SubsystemRegistration subsystem = context . registerSubsystem ( NewLoggingExtension . SUBSYSTEM_NAME ) ; final ModelNodeRegistration registration = subsystem . registerSubsystemModel ( SUBSYSTEM ) ; registration . registerOperationHandler ( ADD , NewLoggingExtension . ADD_INSTANCE , SUBSYSTEM_ADD , false ) ; registration . registerOperationHandler ( "set-root-logger" , INSTANCE , SET_ROOT_LOGGER , false ) ; registration . registerOperationHandler ( "remove-root-logger" , NewRootLoggerRemove . INSTANCE , SET_ROOT_LOGGER , false ) ; final ModelNodeRegistration loggers = registration . registerSubModel ( NewLoggingExtension . loggersPath , NewLoggingSubsystemProviders . LOGGER ) ; loggers . registerOperationHandler ( ADD , NewLoggerAdd . INSTANCE , LOGGER_ADD , false ) ; loggers . registerOperationHandler ( REMOVE , NewLoggerRemove . INSTANCE , LOGGER_REMOVE , false ) ; final ModelNodeRegistration handlers = registration . registerSubModel ( NewLoggingExtension . handlersPath , HANDLERS ) ; handlers . registerOperationHandler ( ADD , NewLoggerHandlerAdd . INSTANCE , HANDLER_ADD , false ) ; handlers . registerOperationHandler ( REMOVE , NewLoggerHandlerRemove . INSTANCE , HANDLER_REMOVE , false ) ; <START_BUG> handlers . registerOperationHandler ( "add-async-handler" , NewAsyncHandlerAdd . INSTANCE , ASYNC_HANDLER_ADD , false ) ; <END_BUG> handlers . registerOperationHandler ( "add-console-handler" , NewConsoleHandlerAdd . INSTANCE , CONSOLE_HANDLER_ADD , false ) ; handlers . registerOperationHandler ( "add-file-handler" , NewFileHandlerAdd . INSTANCE , FILE_HANDLER_ADD , false ) ; handlers . registerOperationHandler ( "add-periodic-handler" , NewPeriodicFileHandlerAdd . INSTANCE , PERIODIC_HANDLER_ADD , false ) ; handlers . registerOperationHandler ( "add-size-periodic-handler" , NewSizePeriodicFileHandlerAdd . INSTANCE , SIZE_PERIODIC_HANDLER_ADD , false ) ; } public void initializeParsers ( ExtensionParsingContext context ) { } private static final NewLoggingExtension . NewLoggingSubsystemAdd ADD_INSTANCE = new NewLoggingExtension . NewLoggingSubsystemAdd ( ) ; static class NewLoggingSubsystemAdd implements ModelAddOperationHandler { public Cancellable execute ( final NewOperationContext context , final ModelNode operation , final ResultHandler resultHandler ) { } } } 
public class TestTimeLimitingCollector extends LuceneTestCase { private static final int SLOW_DOWN = 3 ; private static final long TIME_ALLOWED = 17 * ( TestTimeLimitingCollector . SLOW_DOWN ) ; private static final double MULTI_THREAD_SLACK = 7 ; private static final int N_DOCS = 3000 ; private static final int N_THREADS = 50 ; private Searcher searcher ; private final String FIELD_NAME = "body" ; private Query query ; public TestTimeLimitingCollector ( String name ) { } @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; final String [ ] docText = new String [ ] { "docThatNeverMatchesSoWeCanRequireLastDocCollectedToBeGreaterThanZero" , "one<seq2seq4repair_space>blah<seq2seq4repair_space>three" , "one<seq2seq4repair_space>foo<seq2seq4repair_space>three<seq2seq4repair_space>multiOne" , "one<seq2seq4repair_space>foobar<seq2seq4repair_space>three<seq2seq4repair_space>multiThree" , "blueberry<seq2seq4repair_space>pancakes" , "blueberry<seq2seq4repair_space>pie" , "blueberry<seq2seq4repair_space>strudel" , "blueberry<seq2seq4repair_space>pizza" } ; Directory directory = new RAMDirectory ( ) ; IndexWriter iw = new IndexWriter ( directory , new WhitespaceAnalyzer ( ) , true , MaxFieldLength . UNLIMITED ) ; for ( int i = 0 ; i < ( TestTimeLimitingCollector . N_DOCS ) ; i ++ ) { add ( docText [ ( i % ( docText . length ) ) ] , iw ) ; } iw . close ( ) ; searcher = new IndexSearcher ( directory , true ) ; String qtxt = "one" ; for ( int i = 1 ; i < ( docText . length ) ; i ++ ) { qtxt += '<seq2seq4repair_space>' + ( docText [ i ] ) ; } <START_BUG> QueryParser queryParser = new QueryParser ( Version . LUCENE_CURRENT , FIELD_NAME , new WhitespaceAnalyzer ( ) ) ; <END_BUG> query = queryParser . parse ( qtxt ) ; searcher . search ( query , null , 1000 ) ; } @ Override public void tearDown ( ) throws Exception { } private void add ( String value , IndexWriter iw ) throws IOException { } private void search ( Collector collector ) throws Exception { } public void testSearch ( ) { } private void doTestSearch ( ) { } private Collector createTimedCollector ( TestTimeLimitingCollector . MyHitCollector hc , long timeAllowed , boolean greedy ) { } public void testTimeoutGreedy ( ) { } public void testTimeoutNotGreedy ( ) { } private void doTestTimeout ( boolean multiThreaded , boolean greedy ) { } private long maxTime ( boolean multiThreaded ) { } private String maxTimeStr ( boolean multiThreaded ) { } public void testModifyResolution ( ) { } public void testSearchMultiThreaded ( ) throws Exception { } public void testTimeoutMultiThreaded ( ) throws Exception { } private void doTestMultiThreads ( final boolean withTimeout ) throws Exception { } private class MyHitCollector extends Collector { private final BitSet bits = new BitSet ( ) ; private int slowdown = 0 ; private int lastDocCollected = - 1 ; private int docBase = 0 ; public void setSlowDown ( int milliseconds ) { } public int hitCount ( ) { } public int getLastDocCollected ( ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void collect ( final int doc ) throws IOException { } @ Override public void setNextReader ( IndexReader reader , int base ) { } @ Override public boolean acceptsDocsOutOfOrder ( ) { } } } 
public class TCPConfigGui extends AbstractConfigGui { private static final String SERVER = "server" ; private static final String PORT = "port" ; private static final String FILENAME = "filename" ; private static final String TIMEOUT = "timeout" ; private static final String NODELAY = "nodelay" ; private JTextField server ; private JTextField port ; private JTextField filename ; private JTextField timeout ; private JTextField nodelay ; private boolean displayName = true ; public TCPConfigGui ( ) { } public TCPConfigGui ( boolean displayName ) { } public String getStaticLabel ( ) { <START_BUG> return JMeterUtils . getResString ( "tcp_sample_title" ) ; <END_BUG> } public void configure ( TestElement element ) { } public TestElement createTestElement ( ) { } public void modifyTestElement ( TestElement element ) { } private JPanel createTimeoutPanel ( ) { } private JPanel createNoDelayPanel ( ) { } private JPanel createServerPanel ( ) { } private JPanel createPortPanel ( ) { } private JPanel createFilenamePanel ( ) { } private void init ( ) { } } 
public class GoLinkStimuli implements TreeModelPrereqs { public String toString ( ) { <START_BUG> return Localizer . localize ( "Tree" , "Link->Stimuli" ) ; <END_BUG> } public Object getRoot ( ) { } public void setRoot ( Object r ) { } public Object getChild ( Object parent , int index ) { } public int getChildCount ( Object parent ) { } public int getIndexOfChild ( Object parent , Object child ) { } public Vector getChildren ( Object parent ) { } public boolean isLeaf ( Object node ) { } public void valueForPathChanged ( TreePath path , Object newValue ) { } public void addTreeModelListener ( TreeModelListener l ) { } public void removeTreeModelListener ( TreeModelListener l ) { } public Vector getPrereqs ( ) { } public Vector getProvidedTypes ( ) { } } 
public class ConditionalExpression extends OperatorExpression { public Expression condition ; public Expression valueIfTrue ; public Expression valueIfFalse ; public Constant optimizedBooleanConstant ; public Constant optimizedIfTrueConstant ; public Constant optimizedIfFalseConstant ; int trueInitStateIndex = - 1 ; int falseInitStateIndex = - 1 ; int mergedInitStateIndex = - 1 ; public ConditionalExpression ( Expression condition , Expression valueIfTrue , Expression valueIfFalse ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { int pc = codeStream . position ; BranchLabel endifLabel ; BranchLabel falseLabel ; if ( ( constant ) != ( Constant . NotAConstant ) ) { if ( valueRequired ) codeStream . generateConstant ( constant , implicitConversion ) ; codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; return ; } Constant cst = condition . constant ; Constant condCst = condition . optimizedBooleanConstant ( ) ; boolean needTruePart = ! ( ( ( cst != ( Constant . NotAConstant ) ) && ( ( cst . booleanValue ( ) ) == false ) ) || ( ( condCst != ( Constant . NotAConstant ) ) && ( ( condCst . booleanValue ( ) ) == false ) ) ) ; boolean needFalsePart = ! ( ( ( cst != ( Constant . NotAConstant ) ) && ( ( cst . booleanValue ( ) ) == true ) ) || ( ( condCst != ( Constant . NotAConstant ) ) && ( ( condCst . booleanValue ( ) ) == true ) ) ) ; endifLabel = new BranchLabel ( codeStream ) ; boolean needConditionValue = ( cst == ( Constant . NotAConstant ) ) && ( condCst == ( Constant . NotAConstant ) ) ; falseLabel = new BranchLabel ( codeStream ) ; falseLabel . tagBits |= BranchLabel . USED ; condition . generateOptimizedBoolean ( currentScope , codeStream , null , falseLabel , needConditionValue ) ; if ( ( trueInitStateIndex ) != ( - 1 ) ) { codeStream . removeNotDefinitelyAssignedVariables ( currentScope , trueInitStateIndex ) ; codeStream . addDefinitelyAssignedVariables ( currentScope , trueInitStateIndex ) ; } if ( needTruePart ) { valueIfTrue . generateCode ( currentScope , codeStream , valueRequired ) ; if ( needFalsePart ) { int position = codeStream . position ; codeStream . goto_ ( endifLabel ) ; codeStream . updateLastRecordedEndPC ( currentScope , position ) ; if ( valueRequired ) { codeStream . decrStackSize ( ( ( ( this . resolvedType ) == ( TypeBinding . LONG ) ) || ( ( this . resolvedType ) == ( TypeBinding . DOUBLE ) ) ? 2 : 1 ) ) ; } } } if ( needFalsePart ) { if ( ( falseInitStateIndex ) != ( - 1 ) ) { codeStream . removeNotDefinitelyAssignedVariables ( currentScope , falseInitStateIndex ) ; codeStream . addDefinitelyAssignedVariables ( currentScope , falseInitStateIndex ) ; } <START_BUG> if ( falseLabel . hasForwardReferences ( ) ) { <END_BUG> falseLabel . place ( ) ; } valueIfFalse . generateCode ( currentScope , codeStream , valueRequired ) ; if ( valueRequired ) { codeStream . recordExpressionType ( this . resolvedType ) ; } if ( needTruePart ) { endifLabel . place ( ) ; } } if ( ( mergedInitStateIndex ) != ( - 1 ) ) { codeStream . removeNotDefinitelyAssignedVariables ( currentScope , mergedInitStateIndex ) ; } if ( valueRequired ) codeStream . generateImplicitConversion ( implicitConversion ) ; codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; } public void generateOptimizedBoolean ( BlockScope currentScope , CodeStream codeStream , BranchLabel trueLabel , BranchLabel falseLabel , boolean valueRequired ) { } public int nullStatus ( FlowInfo flowInfo ) { } public Constant optimizedBooleanConstant ( ) { } public StringBuffer printExpressionNoParenthesis ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } } 
public class ResourceStreamResource extends AbstractResource { private static final long serialVersionUID = 1L ; private static final Logger logger = LoggerFactory . getLogger ( ResourceStreamResource . class ) ; private final IResourceStream stream ; private String fileName ; private ContentDisposition contentDisposition = ContentDisposition . INLINE ; private String textEncoding ; private String mimeType ; public ResourceStreamResource ( IResourceStream stream ) { } public ResourceStreamResource setFileName ( String fileName ) { } public ResourceStreamResource setContentDisposition ( ContentDisposition contentDisposition ) { } public ResourceStreamResource setTextEncoding ( String textEncoding ) { } @ Override protected ResourceResponse newResourceResponse ( Attributes attributes ) { ResourceResponse data = new ResourceResponse ( ) ; Time lastModifiedTime = stream . lastModifiedTime ( ) ; if ( lastModifiedTime != null ) { <START_BUG> data . setLastModified ( lastModifiedTime . toDate ( ) ) ; <END_BUG> } if ( data . dataNeedsToBeWritten ( attributes ) ) { InputStream inputStream = null ; if ( ( ( stream ) instanceof IResourceStreamWriter ) == false ) { try { inputStream = stream . getInputStream ( ) ; } catch ( ResourceStreamNotFoundException e ) { data . setError ( SC_NOT_FOUND ) ; close ( ) ; } } data . setContentDisposition ( contentDisposition ) ; Bytes length = stream . length ( ) ; if ( length != null ) { data . setContentLength ( length . bytes ( ) ) ; } data . setFileName ( fileName ) ; data . setContentType ( stream . getContentType ( ) ) ; data . setTextEncoding ( textEncoding ) ; if ( ( stream ) instanceof IResourceStreamWriter ) { data . setWriteCallback ( new WriteCallback ( ) { @ Override public void writeData ( Attributes attributes ) { ( ( IResourceStreamWriter ) ( stream ) ) . write ( attributes . getResponse ( ) ) ; close ( ) ; } } ) ; } else { final InputStream s = inputStream ; data . setWriteCallback ( new WriteCallback ( ) { @ Override public void writeData ( Attributes attributes ) { try { writeStream ( attributes , s ) ; } finally { close ( ) ; } } } ) ; } } return data ; } private void close ( ) { } } 
public class BeansXmlProcessor implements DeploymentUnitProcessor { private static final String WEB_INF_BEANS_XML = "WEB-INF/beans.xml" ; private static final String META_INF_BEANS_XML = "META-INF/beans.xml" ; @ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; BeansXmlParser parser = new BeansXmlParser ( ) ; Set < BeanArchiveMetadata > beanArchiveMetadata = new HashSet < BeanArchiveMetadata > ( ) ; ResourceRoot deploymentRoot = deploymentUnit . getAttachment ( DEPLOYMENT_ROOT ) ; if ( deploymentRoot == null ) { return ; } ResourceRoot classesRoot = null ; List < ResourceRoot > structure = deploymentUnit . getAttachmentList ( RESOURCE_ROOTS ) ; for ( ResourceRoot resourceRoot : structure ) { if ( ( ModuleRootMarker . isModuleRoot ( resourceRoot ) ) && ( ! ( SubDeploymentMarker . isSubDeployment ( resourceRoot ) ) ) ) { if ( resourceRoot . getRootName ( ) . equals ( "classes" ) ) { classesRoot = resourceRoot ; } else { VirtualFile beansXml = resourceRoot . getRoot ( ) . getChild ( BeansXmlProcessor . META_INF_BEANS_XML ) ; if ( ( beansXml . exists ( ) ) && ( beansXml . isFile ( ) ) ) { DEPLOYMENT_LOGGER . debugf ( "Found<seq2seq4repair_space>beans.xml:<seq2seq4repair_space>%s" , beansXml . toString ( ) ) ; beanArchiveMetadata . add ( new BeanArchiveMetadata ( beansXml , resourceRoot , parseBeansXml ( beansXml , parser , deploymentUnit ) , false ) ) ; } } } } if ( DeploymentTypeMarker . isType ( WAR , deploymentUnit ) ) { final VirtualFile rootBeansXml = deploymentRoot . getRoot ( ) . getChild ( BeansXmlProcessor . WEB_INF_BEANS_XML ) ; <START_BUG> if ( ( rootBeansXml . exists ( ) ) && ( rootBeansXml . isFile ( ) ) ) { <END_BUG> DEPLOYMENT_LOGGER . debugf ( "Found<seq2seq4repair_space>beans.xml:<seq2seq4repair_space>%s" , rootBeansXml ) ; beanArchiveMetadata . add ( new BeanArchiveMetadata ( rootBeansXml , classesRoot , parseBeansXml ( rootBeansXml , parser , deploymentUnit ) , true ) ) ; } else if ( classesRoot != null ) { VirtualFile beansXml = classesRoot . getRoot ( ) . getChild ( BeansXmlProcessor . META_INF_BEANS_XML ) ; if ( ( beansXml . exists ( ) ) && ( beansXml . isFile ( ) ) ) { DEPLOYMENT_LOGGER . beansXmlInNonStandardLocation ( beansXml . toString ( ) ) ; beanArchiveMetadata . add ( new BeanArchiveMetadata ( beansXml , classesRoot , parseBeansXml ( beansXml , parser , deploymentUnit ) , true ) ) ; } } } else if ( ! ( DeploymentTypeMarker . isType ( EAR , deploymentUnit ) ) ) { final VirtualFile rootBeansXml = deploymentRoot . getRoot ( ) . getChild ( BeansXmlProcessor . META_INF_BEANS_XML ) ; if ( ( rootBeansXml . exists ( ) ) && ( rootBeansXml . isFile ( ) ) ) { DEPLOYMENT_LOGGER . debugf ( "Found<seq2seq4repair_space>beans.xml:<seq2seq4repair_space>%s" , rootBeansXml . toString ( ) ) ; beanArchiveMetadata . add ( new BeanArchiveMetadata ( rootBeansXml , deploymentRoot , parseBeansXml ( rootBeansXml , parser , deploymentUnit ) , true ) ) ; } } if ( ! ( beanArchiveMetadata . isEmpty ( ) ) ) { WeldDeploymentMetadata deploymentMetadata = new WeldDeploymentMetadata ( beanArchiveMetadata ) ; deploymentUnit . putAttachment ( ATTACHMENT_KEY , deploymentMetadata ) ; WeldDeploymentMarker . mark ( deploymentUnit ) ; if ( ( deploymentUnit . getParent ( ) ) != null ) { WeldDeploymentMarker . mark ( deploymentUnit . getParent ( ) ) ; } } } @ Override public void undeploy ( DeploymentUnit context ) { } private BeansXml parseBeansXml ( VirtualFile beansXmlFile , BeansXmlParser parser , final DeploymentUnit deploymentUnit ) throws DeploymentUnitProcessingException { } } 
public class GrantNode extends MiscellaneousStatementNode { private PrivilegeNode privileges ; private List grantees ; public String toString ( ) { } public String statementToString ( ) { } public void init ( Object privileges , Object grantees ) { } public QueryTreeNode bind ( ) throws StandardException { <START_BUG> privileges = ( ( PrivilegeNode ) ( privileges . bind ( new HashMap ( ) , grantees ) ) ) ; <END_BUG> return this ; } public ConstantAction makeConstantAction ( ) throws StandardException { } } 
public abstract class WorkingCopyOwner { public static void setPrimaryBufferProvider ( WorkingCopyOwner primaryBufferProvider ) { } public IBuffer createBuffer ( ICompilationUnit workingCopy ) { <START_BUG> return BufferManager . getDefaultBufferManager ( ) . createBuffer ( workingCopy ) ; <END_BUG> } public final ICompilationUnit newWorkingCopy ( String name , IClasspathEntry [ ] classpath , IProblemRequestor problemRequestor , IProgressMonitor monitor ) throws JavaModelException { } } 
public class ConcreteAspectCodeGen { private static final String [ ] EMPTY_STRINGS = new String [ 0 ] ; private static final Type [ ] EMPTY_TYPES = new Type [ 0 ] ; private final ConcreteAspect m_concreteAspect ; private final World m_world ; private boolean m_isValid = false ; private ResolvedType m_parent ; private PerClause m_perClause ; ConcreteAspectCodeGen ( Definition . ConcreteAspect concreteAspect , World world ) { } public boolean validate ( ) { } private String stringify ( ) { } public byte [ ] getBytes ( ) { if ( ! ( m_isValid ) ) { throw new RuntimeException ( "Must<seq2seq4repair_space>validate<seq2seq4repair_space>first" ) ; } LazyClassGen cg = new LazyClassGen ( m_concreteAspect . name . replace ( '.' , '/' ) , m_parent . getName ( ) , null , ( ( Modifier . PUBLIC ) + ( Constants . ACC_SUPER ) ) , ConcreteAspectCodeGen . EMPTY_STRINGS , m_world ) ; AnnotationGen ag = new AnnotationGen ( new ObjectType ( "org/aspectj/lang/annotation/Aspect" ) , Collections . EMPTY_LIST , true , cg . getConstantPoolGen ( ) ) ; cg . addAnnotation ( ag . getAnnotation ( ) ) ; if ( ( m_concreteAspect . precedence ) != null ) { SimpleElementValueGen svg = new SimpleElementValueGen ( ElementValueGen . STRING , cg . getConstantPoolGen ( ) , m_concreteAspect . precedence ) ; List elems = new ArrayList ( ) ; elems . add ( new org . aspectj . apache . bcel . generic . annotation . ElementNameValuePairGen ( "value" , svg , cg . getConstantPoolGen ( ) ) ) ; AnnotationGen agprec = new AnnotationGen ( new ObjectType ( "org/aspectj/lang/annotation/DeclarePrecedence" ) , elems , true , cg . getConstantPoolGen ( ) ) ; cg . addAnnotation ( agprec . getAnnotation ( ) ) ; } LazyMethodGen init = new LazyMethodGen ( Modifier . PUBLIC , Type . VOID , "<init>" , ConcreteAspectCodeGen . EMPTY_TYPES , ConcreteAspectCodeGen . EMPTY_STRINGS , cg ) ; InstructionList cbody = init . getBody ( ) ; cbody . append ( ALOAD_0 ) ; cbody . append ( cg . getFactory ( ) . createInvoke ( m_parent . getName ( ) . replace ( '.' , '/' ) , "<init>" , VOID , ConcreteAspectCodeGen . EMPTY_TYPES , INVOKESPECIAL ) ) ; cbody . append ( RETURN ) ; cg . addMethodGen ( init ) ; for ( Iterator it = m_concreteAspect . pointcuts . iterator ( ) ; it . hasNext ( ) ; ) { Definition . Pointcut abstractPc = ( ( Definition . Pointcut ) ( it . next ( ) ) ) ; LazyMethodGen mg = new LazyMethodGen ( Modifier . PUBLIC , Type . VOID , abstractPc . name , ConcreteAspectCodeGen . EMPTY_TYPES , ConcreteAspectCodeGen . EMPTY_STRINGS , cg ) ; SimpleElementValueGen svg = new SimpleElementValueGen ( ElementValueGen . STRING , cg . getConstantPoolGen ( ) , abstractPc . expression ) ; List elems = new ArrayList ( ) ; elems . add ( new org . aspectj . apache . bcel . generic . annotation . ElementNameValuePairGen ( "value" , svg , cg . getConstantPoolGen ( ) ) ) ; AnnotationGen mag = new AnnotationGen ( new ObjectType ( "org/aspectj/lang/annotation/Pointcut" ) , elems , true , cg . getConstantPoolGen ( ) ) ; AnnotationX max = new AnnotationX ( mag . getAnnotation ( ) , m_world ) ; mg . addAnnotation ( max ) ; InstructionList body = mg . getBody ( ) ; body . append ( RETURN ) ; cg . addMethodGen ( mg ) ; } BcelPerClauseAspectAdder perClauseMunger = new BcelPerClauseAspectAdder ( ResolvedType . forName ( m_concreteAspect . name ) . resolve ( m_world ) , m_perClause . getKind ( ) ) ; <START_BUG> perClauseMunger . forceMunge ( cg ) ; <END_BUG> JavaClass jc = cg . getJavaClass ( ( ( BcelWorld ) ( m_world ) ) ) ; ( ( BcelWorld ) ( m_world ) ) . addSourceObjectType ( jc ) ; return jc . getBytes ( ) ; } private void reportError ( String message ) { } } 
public class UnionNode extends SetOperatorNode { private boolean addNewNodesCalled ; boolean tableConstructor ; boolean topTableConstructor ; public void init ( Object leftResult , Object rightResult , Object all , Object tableConstructor , Object tableProperties ) throws StandardException { } public void markTopTableConstructor ( ) { } boolean tableConstructor ( ) { } public void rejectParameters ( ) throws StandardException { } void setTableConstructorTypes ( ResultColumnList typeColumns ) throws StandardException { } public CostEstimate optimizeIt ( Optimizer optimizer , OptimizablePredicateList predList , CostEstimate outerCost , RowOrdering rowOrdering ) throws StandardException { if ( ( predList != null ) && ( ! ( getCurrentAccessPath ( ) . getJoinStrategy ( ) . isHashJoin ( ) ) ) ) { for ( int i = ( predList . size ( ) ) - 1 ; i >= 0 ; i -- ) { if ( pushOptPredicate ( predList . getOptPredicate ( i ) ) ) predList . removeOptPredicate ( i ) ; } } <START_BUG> addOrLoadBestPlanMapping ( true , this ) ; <END_BUG> leftResultSet = optimizeSource ( optimizer , leftResultSet , getLeftOptPredicateList ( ) , outerCost ) ; rightResultSet = optimizeSource ( optimizer , rightResultSet , getRightOptPredicateList ( ) , outerCost ) ; CostEstimate costEstimate = getCostEstimate ( optimizer ) ; costEstimate . setCost ( leftResultSet . getCostEstimate ( ) . getEstimatedCost ( ) , leftResultSet . getCostEstimate ( ) . rowCount ( ) , ( ( leftResultSet . getCostEstimate ( ) . singleScanRowCount ( ) ) + ( rightResultSet . getCostEstimate ( ) . singleScanRowCount ( ) ) ) ) ; costEstimate . add ( costEstimate , costEstimate ) ; getCurrentAccessPath ( ) . getJoinStrategy ( ) . estimateCost ( this , predList , ( ( ConglomerateDescriptor ) ( null ) ) , outerCost , optimizer , costEstimate ) ; optimizer . considerCost ( this , predList , costEstimate , outerCost ) ; return costEstimate ; } public void pushExpressions ( PredicateList predicateList ) throws StandardException { } public Optimizable modifyAccessPath ( JBitSet outerTables ) throws StandardException { } public ResultSetNode modifyAccessPaths ( ) throws StandardException { } private ResultSetNode addNewNodes ( ) throws StandardException { } public String toString ( ) { } public void bindExpressions ( FromList fromListParam ) throws StandardException { } public void generate ( ActivationClassBuilder acb , MethodBuilder mb ) throws StandardException { } public CostEstimate getFinalCostEstimate ( ) throws StandardException { } String getOperatorName ( ) { } } 
public class CassandraBulkLoader { public static class Map extends MapReduceBase implements Mapper < Text , Text , Text , Text > { public void map ( Text key , Text value , OutputCollector < Text , Text > output , Reporter reporter ) throws IOException { } } public static class Reduce extends MapReduceBase implements Reducer < Text , Text , Text , Text > { private Path [ ] localFiles ; private JobConf jobconf ; public void configure ( JobConf job ) { } public void close ( ) { } public void reduce ( Text key , Iterator < Text > values , OutputCollector < Text , Text > output , Reporter reporter ) throws IOException { } } public static void runJob ( String [ ] args ) { } public static Message createMessage ( String keyspace , byte [ ] key , String columnFamily , List < ColumnFamily > columnFamilies ) { ColumnFamily baseColumnFamily ; DataOutputBuffer bufOut = new DataOutputBuffer ( ) ; RowMutation rm ; Message message ; Column column ; baseColumnFamily = new ColumnFamily ( ColumnFamilyType . Standard , DatabaseDescriptor . getComparator ( keyspace , columnFamily ) , DatabaseDescriptor . getSubComparator ( keyspace , columnFamily ) , CFMetaData . getId ( keyspace , columnFamily ) ) ; for ( ColumnFamily cf : columnFamilies ) { bufOut . reset ( ) ; ColumnFamily . serializer ( ) . serializeWithIndexes ( cf , bufOut ) ; byte [ ] data = new byte [ bufOut . getLength ( ) ] ; System . arraycopy ( bufOut . getData ( ) , 0 , data , 0 , bufOut . getLength ( ) ) ; column = new Column ( FBUtilities . toByteBuffer ( cf . id ( ) ) , ByteBuffer . wrap ( data ) , 0 ) ; baseColumnFamily . addColumn ( column ) ; } rm = new RowMutation ( keyspace , ByteBuffer . wrap ( key ) ) ; rm . add ( baseColumnFamily ) ; try { <START_BUG> message = rm . makeRowMutationMessage ( BINARY ) ; <END_BUG> } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return message ; } public static void main ( String [ ] args ) throws Exception { } } 
public class War extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public War ( ) { } public void setWarfile ( File warFile ) { } public void setWebxml ( File descr ) { } public void addLib ( ZipFileSet fs ) { } public void addClasses ( ZipFileSet fs ) { } public void addWebinf ( ZipFileSet fs ) { } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( ( ( deploymentDescriptor ) == null ) && ( ! ( isInUpdateMode ( ) ) ) ) { <START_BUG> throw new BuildException ( "webxml<seq2seq4repair_space>attribute<seq2seq4repair_space>is<seq2seq4repair_space>required" , location ) ; <END_BUG> } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { } protected void cleanUp ( ) { } } 
public class MethodRef extends ASTNode implements IDocElement { public static final ChildPropertyDescriptor QUALIFIER_PROPERTY = new ChildPropertyDescriptor ( MethodRef . class , "qualifier" , Name . class , ASTNode . OPTIONAL , ASTNode . NO_CYCLE_RISK ) ; public static final ChildPropertyDescriptor NAME_PROPERTY = new ChildPropertyDescriptor ( MethodRef . class , "name" , SimpleName . class , ASTNode . MANDATORY , ASTNode . NO_CYCLE_RISK ) ; public static final ChildListPropertyDescriptor PARAMETERS_PROPERTY = new ChildListPropertyDescriptor ( MethodRef . class , "parameters" , MethodRefParameter . class , ASTNode . NO_CYCLE_RISK ) ; private static final List PROPERTY_DESCRIPTORS ; public static List propertyDescriptors ( int apiLevel ) { } private Name optionalQualifier = null ; private SimpleName methodName = null ; private ASTNode . NodeList parameters = new ASTNode . NodeList ( MethodRef . PARAMETERS_PROPERTY ) ; MethodRef ( AST ast ) { } final List internalStructuralPropertiesForType ( int apiLevel ) { } final ASTNode internalGetSetChildProperty ( ChildPropertyDescriptor property , boolean get , ASTNode child ) { } final List internalGetChildListProperty ( ChildListPropertyDescriptor property ) { } final int getNodeType0 ( ) { } ASTNode clone0 ( AST target ) { MethodRef result = new MethodRef ( target ) ; <START_BUG> result . setSourceRange ( this . getStartPosition ( ) , this . getLength ( ) ) ; <END_BUG> result . setQualifier ( ( ( Name ) ( ASTNode . copySubtree ( target , getQualifier ( ) ) ) ) ) ; result . setName ( ( ( SimpleName ) ( ASTNode . copySubtree ( target , getName ( ) ) ) ) ) ; result . parameters ( ) . addAll ( ASTNode . copySubtrees ( target , parameters ( ) ) ) ; return result ; } final boolean subtreeMatch0 ( ASTMatcher matcher , Object other ) { } void accept0 ( ASTVisitor visitor ) { } public Name getQualifier ( ) { } public void setQualifier ( Name name ) { } public SimpleName getName ( ) { } public void setName ( SimpleName name ) { } public List parameters ( ) { } public final IBinding resolveBinding ( ) { } int memSize ( ) { } int treeSize ( ) { } } 
public class PluginLoader { public PluginLoader ( ) { } public static Object loadExternalPlugin ( String className , String type , File file , Object [ ] args ) throws Exception { log . debug ( "loading.." ) ; if ( ( type . equals ( "java" ) ) || ( type . equals ( "jar" ) ) ) { String path = file . getPath ( ) ; URL [ ] url = new URL [ 1 ] ; URL newURL = new File ( path ) . toURL ( ) ; url [ 0 ] = newURL ; log . debug ( ( "url=" + newURL ) ) ; return new ExternalClassLoader ( url ) . instanciate ( className , args ) ; } InterpreterHandler handler = ( ( InterpreterHandler ) ( pluginManager . getHandler ( "interpreter" ) ) ) ; <START_BUG> Object instance = handler . getPlugin ( type , "org.columba.core.scripting.PythonInterpreterPlugin" , null ) ; <END_BUG> if ( instance != null ) { AbstractInterpreter ip = ( ( AbstractInterpreter ) ( instance ) ) ; String pythonFile = ( ( file . toString ( ) ) + "/" ) + ( className . toString ( ) ) ; String pythonClass = className . toString ( ) . substring ( 0 , ( ( className . toString ( ) . length ( ) ) - 3 ) ) ; Object i = ip . instanciate ( pythonFile , pythonClass , args , "test" ) ; return i ; } return null ; } } 
public class PromptPasswordState implements State { private final ConsoleWrapper theConsole ; private final StateValues stateValues ; private final boolean rePrompt ; public PromptPasswordState ( ConsoleWrapper theConsole , StateValues stateValues , boolean rePrompt ) { } @ Override public State execute ( ) { if ( ( stateValues . isSilentOrNonInteractive ( ) ) == false ) { if ( ( rePrompt ) == false ) { RestrictionLevel level = stateValues . getOptions ( ) . getCheckUtil ( ) . getRestrictionLevel ( ) ; if ( ! ( RELAX . equals ( level ) ) ) { final List < PasswordRestriction > passwordRestrictions = stateValues . getOptions ( ) . getCheckUtil ( ) . getPasswordRestrictions ( ) ; if ( ( passwordRestrictions . size ( ) ) > 0 ) { if ( level == ( RestrictionLevel . REJECT ) ) { theConsole . printf ( ROOT_LOGGER . passwordRequirements ( ) ) ; } else { theConsole . printf ( ROOT_LOGGER . passwordRecommendations ( ) ) ; } theConsole . printf ( AddUser . NEW_LINE ) ; for ( PasswordRestriction passwordRestriction : passwordRestrictions ) { final String message = passwordRestriction . getRequirementMessage ( ) ; if ( ( message != null ) && ( ! ( message . isEmpty ( ) ) ) ) { theConsole . printf ( "<seq2seq4repair_space>-<seq2seq4repair_space>" ) ; theConsole . printf ( message ) ; theConsole . printf ( AddUser . NEW_LINE ) ; } } } } theConsole . printf ( ROOT_LOGGER . passwordPrompt ( ) ) ; char [ ] tempChar = theConsole . readPassword ( "<seq2seq4repair_space>:<seq2seq4repair_space>" ) ; if ( ( tempChar == null ) || ( ( tempChar . length ) == 0 ) ) { <START_BUG> return new ErrorState ( theConsole , ROOT_LOGGER . noPasswordExiting ( ) ) ; <END_BUG> } stateValues . setPassword ( new String ( tempChar ) ) ; return new ValidatePasswordState ( theConsole , stateValues ) ; } else { theConsole . printf ( ROOT_LOGGER . passwordConfirmationPrompt ( ) ) ; char [ ] secondTempChar = theConsole . readPassword ( "<seq2seq4repair_space>:<seq2seq4repair_space>" ) ; if ( secondTempChar == null ) { secondTempChar = new char [ 0 ] ; } if ( ( Arrays . equals ( stateValues . getPassword ( ) . toCharArray ( ) , secondTempChar ) ) == false ) { return new ErrorState ( theConsole , ROOT_LOGGER . passwordMisMatch ( ) , new PromptPasswordState ( theConsole , stateValues , false ) ) ; } return stateValues . groupPropertiesFound ( ) ? new PromptGroupsState ( theConsole , stateValues ) : new PreModificationState ( theConsole , stateValues ) ; } } return new ValidatePasswordState ( theConsole , stateValues ) ; } } 
public class Touch extends Task { private interface DateFormatFactory { DateFormat getPrimaryFormat ( ) { } DateFormat getFallbackFormat ( ) { } } private static final Touch . DateFormatFactory DEFAULT_DF_FACTORY = new Touch . DateFormatFactory ( ) { public DateFormat getPrimaryFormat ( ) { } public DateFormat getFallbackFormat ( ) { } } ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File file ; private long millis = - 1 ; private String dateTime ; private Vector filesets = new Vector ( ) ; private Union resources = new Union ( ) ; private boolean dateTimeConfigured ; private boolean mkdirs ; private boolean verbose = true ; private FileNameMapper fileNameMapper = null ; private Touch . DateFormatFactory dfFactory = Touch . DEFAULT_DF_FACTORY ; public Touch ( ) { } public void setFile ( File file ) { } public void setMillis ( long millis ) { } public void setDatetime ( String dateTime ) { } public void setMkdirs ( boolean mkdirs ) { } public void setVerbose ( boolean verbose ) { } public void setPattern ( final String pattern ) { } public void addConfiguredMapper ( Mapper mapper ) { } public void add ( FileNameMapper fileNameMapper ) throws BuildException { } public void addFileset ( FileSet set ) { } public void addFilelist ( FileList list ) { } public void add ( ResourceCollection rc ) { } protected synchronized void checkConfiguration ( ) throws BuildException { } public void execute ( ) throws BuildException { } protected void touch ( ) throws BuildException { } protected void touch ( File file ) { } private long getTimestamp ( ) { } private void touch ( Resource r , long defaultTimestamp ) { if ( ( fileNameMapper ) == null ) { if ( r instanceof FileResource ) { touch ( ( ( FileResource ) ( r ) ) . getFile ( ) , defaultTimestamp ) ; } else { ( ( org . apache . tools . ant . types . resources . Touchable ) ( r ) ) . touch ( defaultTimestamp ) ; } } else { String [ ] mapped = fileNameMapper . mapFileName ( r . getName ( ) ) ; if ( ( mapped != null ) && ( ( mapped . length ) > 0 ) ) { long modTime = ( r . isExists ( ) ) ? r . getLastModified ( ) : defaultTimestamp ; for ( int i = 0 ; i < ( mapped . length ) ; i ++ ) { <START_BUG> touch ( getProject ( ) . resolveFile ( mapped [ i ] ) , modTime ) ; <END_BUG> } } } } private void touch ( File file , long modTime ) { } } 
public final class Server { private final ServerCommunicationHandler communicationHandler ; public Server ( ServerCommunicationHandler communicationHandler ) { } public void start ( Standalone serverConf ) throws IOException { } public void stop ( ) throws IOException { } private void sendCommand ( ServerManagerProtocolCommand command ) throws IOException { } private void sendCommand ( ServerManagerProtocolCommand command , Object o ) throws IOException { byte [ ] cmd = ServerManagerProtocolUtils . createCommandBytes ( command , o ) ; <START_BUG> communicationHandler . sendMessage ( cmd , StreamUtils . calculateChecksum ( cmd ) ) ; <END_BUG> } } 
public class BeanShell extends AbstractFunction implements Serializable { private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final long serialVersionUID = 1L ; private static final List desc = new LinkedList ( ) ; private static final String KEY = "__BeanShell" ; public static final String INIT_FILE = "beanshell.function.init" ; private transient Object [ ] values ; private transient BeanShellInterpreter bshInterpreter = null ; public BeanShell ( ) { } public Object clone ( ) throws CloneNotSupportedException { } public synchronized String execute ( SampleResult previousResult , Sampler currentSampler ) throws InvalidVariableException { } public void log_info ( String s ) { } public synchronized void setParameters ( Collection parameters ) throws InvalidVariableException { values = parameters . toArray ( ) ; if ( ( ( values . length ) < 1 ) || ( ( values . length ) > 2 ) ) { throw new InvalidVariableException ( ( "Expecting<seq2seq4repair_space>1<seq2seq4repair_space>or<seq2seq4repair_space>2<seq2seq4repair_space>parameters,<seq2seq4repair_space>but<seq2seq4repair_space>found<seq2seq4repair_space>" + ( values . length ) ) ) ; } try { <START_BUG> bshInterpreter = new BeanShellInterpreter ( BeanShell . INIT_FILE , BeanShell . log ) ; <END_BUG> } catch ( ClassNotFoundException e ) { throw new InvalidVariableException ( "BeanShell<seq2seq4repair_space>not<seq2seq4repair_space>found" ) ; } } public String getReferenceKey ( ) { } public List getArgumentDesc ( ) { } } 
public class TestPolishAnalyzer extends BaseTokenStreamTestCase { public void testResourcesAvailable ( ) { } public void testBasics ( ) throws IOException { } public void testExclude ( ) throws IOException { } public void testRandomStrings ( ) throws Exception { <START_BUG> checkRandomData ( random ( ) , new PolishAnalyzer ( TEST_VERSION_CURRENT ) , ( 10000 * ( RANDOM_MULTIPLIER ) ) ) ; <END_BUG> } } 
public class SimpleName extends Name { private static final String MISSING_IDENTIFIER = "MISSING" ; private String identifier = SimpleName . MISSING_IDENTIFIER ; SimpleName ( AST ast ) { } ASTNode clone ( AST target ) { } boolean equalSubtrees ( Object other ) { } void accept0 ( ASTVisitor visitor ) { } public String getIdentifier ( ) { } public void setIdentifier ( String identifier ) { if ( identifier == null ) { throw new IllegalArgumentException ( ) ; } <START_BUG> Scanner scanner = this . getAST ( ) . scanner ; <END_BUG> char [ ] source = identifier . toCharArray ( ) ; scanner . setSourceBuffer ( source ) ; scanner . resetTo ( 0 , source . length ) ; try { int tokenType = scanner . getNextToken ( ) ; switch ( tokenType ) { case Scanner . TokenNameIdentifier : break ; default : throw new IllegalArgumentException ( ) ; } } catch ( InvalidInputException e ) { throw new IllegalArgumentException ( ) ; } modifying ( ) ; this . identifier = identifier ; } int memSize ( ) { } int treeSize ( ) { } } 
public class TableItem extends Item { Table parent ; String [ ] strings ; Image [ ] images ; boolean checked ; boolean grayed ; boolean cached ; Color foreground ; Color background ; Color [ ] cellForeground ; Color [ ] cellBackground ; Font font ; Font [ ] cellFont ; int width = - 1 ; public TableItem ( Table parent , int style ) { } public TableItem ( Table parent , int style , int index ) { } TableItem ( Table parent , int style , int index , boolean create ) { } static Table checkNull ( Table control ) { } int calculateWidth ( int index , GC gc ) { } protected void checkSubclass ( ) { } void clear ( ) { } void destroyWidget ( ) { } public Color getBackground ( ) { } public Color getBackground ( int index ) { } public Rectangle getBounds ( ) { } public Rectangle getBounds ( int index ) { } public boolean getChecked ( ) { } public Font getFont ( ) { } public Font getFont ( int index ) { } public Color getForeground ( ) { } public Color getForeground ( int index ) { } public boolean getGrayed ( ) { } public Image getImage ( ) { } public Image getImage ( int index ) { } public Rectangle getImageBounds ( int index ) { } public int getImageIndent ( ) { } String getNameText ( ) { } public Table getParent ( ) { } public String getText ( ) { } public String getText ( int index ) { } public Rectangle getTextBounds ( int index ) { } void redraw ( int propertyID ) { if ( ( parent . currentItem ) == ( this ) ) return ; <START_BUG> if ( ( ( parent . drawCount ) != 0 ) && ( propertyID != ( Table . CHECK_COLUMN_ID ) ) ) <END_BUG> return ; int itemIndex = parent . indexOf ( this ) ; if ( itemIndex == ( - 1 ) ) return ; int [ ] id = new int [ ] { parent . getId ( itemIndex ) } ; OS . UpdateDataBrowserItems ( parent . handle , kDataBrowserNoItem , id . length , id , kDataBrowserItemNoProperty , propertyID ) ; if ( propertyID == ( Table . CHECK_COLUMN_ID ) ) { Rect rect = new Rect ( ) ; if ( ( OS . GetDataBrowserItemPartBounds ( parent . handle , parent . getId ( itemIndex ) , propertyID , kDataBrowserPropertyEnclosingPart , rect ) ) == ( OS . noErr ) ) { int x = rect . left ; int y = ( rect . top ) - 1 ; int width = ( rect . right ) - ( rect . left ) ; int height = 1 ; redrawWidget ( parent . handle , x , y , width , height , false ) ; } } } void releaseHandle ( ) { } void releaseParent ( ) { } void releaseWidget ( ) { } public void setBackground ( Color color ) { } public void setBackground ( int index , Color color ) { } public void setChecked ( boolean checked ) { } void setChecked ( boolean checked , boolean notify ) { } public void setFont ( Font font ) { } public void setFont ( int index , Font font ) { } public void setForeground ( Color color ) { } public void setForeground ( int index , Color color ) { } public void setGrayed ( boolean grayed ) { } public void setImage ( Image [ ] images ) { } public void setImage ( int index , Image image ) { } public void setImage ( Image image ) { } public void setImageIndent ( int indent ) { } public void setText ( String [ ] strings ) { } public void setText ( int index , String string ) { } public void setText ( String string ) { } } 
public class DomainRolloutStepHandler implements OperationStepHandler { private final DomainOperationContext domainOperationContext ; private final Map < String , ProxyController > hostProxies ; private final Map < String , ProxyController > serverProxies ; private final ExecutorService executorService ; private final ModelNode providedRolloutPlan ; private final boolean trace = DomainControllerLogger . HOST_CONTROLLER_LOGGER . isTraceEnabled ( ) ; public DomainRolloutStepHandler ( final Map < String , ProxyController > hostProxies , final Map < String , ProxyController > serverProxies , final DomainOperationContext domainOperationContext , final ModelNode rolloutPlan , final ExecutorService executorService ) { } @ Override public void execute ( final OperationContext context , final ModelNode operation ) throws OperationFailedException { if ( context . hasFailureDescription ( ) ) { context . setRollbackOnly ( ) ; <START_BUG> context . completeStep ( ) ; <END_BUG> return ; } boolean pushToServers = ! ( domainOperationContext . hasHostLevelFailures ( ) ) ; if ( pushToServers ) { ModelNode ourResult = domainOperationContext . getCoordinatorResult ( ) ; if ( ourResult . has ( FAILURE_DESCRIPTION ) ) { if ( trace ) { DomainControllerLogger . HOST_CONTROLLER_LOGGER . tracef ( "coordinator<seq2seq4repair_space>failed:<seq2seq4repair_space>%s" , ourResult ) ; } pushToServers = false ; domainOperationContext . setCompleteRollback ( true ) ; } else { if ( trace ) { DomainControllerLogger . HOST_CONTROLLER_LOGGER . tracef ( "coordinator<seq2seq4repair_space>succeeded:<seq2seq4repair_space>%s" , ourResult ) ; } for ( ModelNode hostResult : domainOperationContext . getHostControllerResults ( ) . values ( ) ) { if ( hostResult . has ( FAILURE_DESCRIPTION ) ) { if ( trace ) { DomainControllerLogger . HOST_CONTROLLER_LOGGER . tracef ( "host<seq2seq4repair_space>failed:<seq2seq4repair_space>%s" , hostResult ) ; } pushToServers = false ; domainOperationContext . setCompleteRollback ( true ) ; break ; } } } } if ( pushToServers ) { domainOperationContext . setCompleteRollback ( false ) ; final Map < ServerIdentity , ServerTaskExecutor . ExecutedServerRequest > submittedTasks = new HashMap < ServerIdentity , ServerTaskExecutor . ExecutedServerRequest > ( ) ; final List < ServerTaskExecutor . ServerPreparedResponse > preparedResults = new ArrayList < ServerTaskExecutor . ServerPreparedResponse > ( ) ; try { pushToServers ( context , submittedTasks , preparedResults ) ; context . completeStep ( ) ; } finally { boolean completeRollback = domainOperationContext . isCompleteRollback ( ) ; final String localHostName = domainOperationContext . getLocalHostInfo ( ) . getLocalHostName ( ) ; for ( final ServerTaskExecutor . ServerPreparedResponse preparedResult : preparedResults ) { boolean rollback = completeRollback || ( domainOperationContext . isServerGroupRollback ( preparedResult . getServerGroupName ( ) ) ) ; if ( ! ( preparedResult . finalizeTransaction ( ( ! rollback ) ) ) ) { final ServerIdentity identity = preparedResult . getServerIdentity ( ) ; try { final ModelNode result = preparedResult . getPreparedOperation ( ) . getPreparedResult ( ) ; ProxyController proxy = hostProxies . get ( identity . getHostName ( ) ) ; if ( proxy == null ) { if ( localHostName . equals ( identity . getHostName ( ) ) ) { proxy = serverProxies . get ( identity . getServerName ( ) ) ; if ( proxy == null ) { if ( trace ) { DomainControllerLogger . HOST_CONTROLLER_LOGGER . tracef ( "No<seq2seq4repair_space>proxy<seq2seq4repair_space>for<seq2seq4repair_space>%s" , identity ) ; } continue ; } } } final Future < ModelNode > future = executorService . submit ( new ServerRequireRestartTask ( identity , proxy , result ) ) ; submittedTasks . put ( identity , new ServerTaskExecutor . ExecutedServerRequest ( identity , future ) ) ; } catch ( Exception ignore ) { } } } boolean interrupted = false ; try { for ( Map . Entry < ServerIdentity , ServerTaskExecutor . ExecutedServerRequest > entry : submittedTasks . entrySet ( ) ) { final ServerTaskExecutor . ExecutedServerRequest request = entry . getValue ( ) ; final Future < ModelNode > future = request . getFinalResult ( ) ; try { final ModelNode finalResult = ( future . isCancelled ( ) ) ? getCancelledResult ( ) : future . get ( ) ; final ModelNode transformedResult = request . transformResult ( finalResult ) ; domainOperationContext . addServerResult ( entry . getKey ( ) , transformedResult ) ; } catch ( InterruptedException e ) { interrupted = true ; DomainControllerLogger . HOST_CONTROLLER_LOGGER . interruptedAwaitingFinalResponse ( entry . getKey ( ) . getServerName ( ) , entry . getKey ( ) . getHostName ( ) ) ; } catch ( ExecutionException e ) { DomainControllerLogger . HOST_CONTROLLER_LOGGER . caughtExceptionAwaitingFinalResponse ( e . getCause ( ) , entry . getKey ( ) . getServerName ( ) , entry . getKey ( ) . getHostName ( ) ) ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } } else { reportHostFailures ( context , operation ) ; context . completeStep ( ) ; } } private ModelNode getCancelledResult ( ) { } private void pushToServers ( final OperationContext context , final Map < ServerIdentity , ServerTaskExecutor . ExecutedServerRequest > submittedTasks , final List < ServerTaskExecutor . ServerPreparedResponse > preparedResults ) throws OperationFailedException { } private Map < String , Map < ServerIdentity , ModelNode > > getOpsByGroup ( Map < String , ModelNode > hostResults ) { } private ModelNode translateDomainMappedOperation ( final ModelNode domainMappedOperation ) { } private ModelNode getRolloutPlan ( ModelNode rolloutPlan , Map < String , Map < ServerIdentity , ModelNode > > opsByGroup ) throws OperationFailedException { } private void validateServerGroupPlan ( Set < String > found , Property prop ) throws OperationFailedException { } private ModelNode getDefaultRolloutPlan ( Map < String , Map < ServerIdentity , ModelNode > > opsByGroup ) { } private void reportHostFailures ( final OperationContext context , final ModelNode operation ) { } private boolean collectDomainFailure ( OperationContext context , final boolean isDomain ) { } private boolean collectHostFailures ( final OperationContext context , final boolean isDomain ) { } private boolean isDomainOperation ( final ModelNode operation ) { } } 
public class EditorStack extends PartStack { private EditorSashContainer editorArea ; private WorkbenchPage page ; private SystemMenuSize sizeItem = new SystemMenuSize ( null ) ; private SystemMenuPinEditor pinEditorItem = new SystemMenuPinEditor ( null ) ; public EditorStack ( EditorSashContainer editorArea , WorkbenchPage page ) { } public void addSystemActions ( IMenuManager menuManager ) { } public boolean isMoveable ( IPresentablePart part ) { } public boolean isCloseable ( IPresentablePart part ) { } public boolean supportsState ( int state ) { } public static EditorStack newEditorWorkbook ( EditorSashContainer editorArea , WorkbenchPage page ) { } protected void add ( LayoutPart newChild , IPresentablePart position ) { } public void add ( LayoutPart child ) { } public void createControl ( Composite parent ) { } protected void updateActions ( ) { } private void updateContainerVisibleTab ( ) { } public Control [ ] getTabList ( ) { } public void removeAll ( ) { } public boolean isActiveWorkbook ( ) { } public void becomeActiveWorkbook ( boolean hasFocus ) { } public void tabFocusHide ( ) { } public void tabFocusShow ( boolean hasFocus ) { } public EditorPane [ ] getEditors ( ) { } public EditorSashContainer getEditorArea ( ) { } public EditorPane getVisibleEditor ( ) { } public void setVisibleEditor ( EditorPane editorPane ) { } public void showVisibleEditor ( ) { } protected boolean canMoveFolder ( ) { } protected void derefPart ( LayoutPart toDeref ) { <START_BUG> EditorPresentation . derefPart ( toDeref ) ; <END_BUG> } protected boolean allowsDrop ( PartPane part ) { } public void setActive ( boolean activeState ) { } public void setFocus ( ) { } protected void close ( IPresentablePart [ ] parts ) { } } 
public class LZMACompressorInputStream extends CompressorInputStream { private final InputStream in ; public LZMACompressorInputStream ( InputStream inputStream ) throws IOException { } @ Override public int read ( ) throws IOException { int ret = in . read ( ) ; <START_BUG> count ( ( ret == ( - 1 ) ? - 1 : 1 ) ) ; <END_BUG> return ret ; } @ Override public int read ( byte [ ] buf , int off , int len ) throws IOException { } @ Override public long skip ( long n ) throws IOException { } @ Override public int available ( ) throws IOException { } @ Override public void close ( ) throws IOException { } } 
class ButtonTab extends AlignableTab { Button button1 ; Button button2 ; Button button3 ; Button button4 ; Button button5 ; Button button6 ; Group textButtonGroup ; Group imageButtonGroup ; Button upButton ; Button downButton ; Button pushButton ; Button checkButton ; Button radioButton ; Button toggleButton ; Button arrowButton ; Button flatButton ; ButtonTab ( ControlExample instance ) { } void createControlGroup ( ) { } void createExampleGroup ( ) { } void createExampleWidgets ( ) { } void createStyleGroup ( ) { } Control [ ] getExampleWidgets ( ) { } String [ ] getMethodNames ( ) { <START_BUG> return new String [ ] { "Selection" , "Text" } ; <END_BUG> } String getTabText ( ) { } void setExampleWidgetAlignment ( ) { } void setExampleWidgetState ( ) { } } 
public class CommandLineTest { private ByteArrayOutputStream results ; private PrintStream oldOut ; private static boolean testWasRun ; @ Before public void before ( ) { } @ After public void after ( ) { } public static class Example { @ Test public void test ( ) { } } @ Test public void runATest ( ) { CommandLineTest . testWasRun = false ; <START_BUG> new JUnitCore ( ) . runMain ( new String [ ] { "org.junit.tests.CommandLineTest$Example" } ) ; <END_BUG> Assert . assertTrue ( CommandLineTest . testWasRun ) ; } @ Test public void runAClass ( ) { } private static int fCount ; public static class Count { @ Test public void increment ( ) { } } @ Test public void runTwoClassesAsArray ( ) { } @ Test public void runTwoClasses ( ) { } } 
public class JPAAnnotationParseProcessor implements DeploymentUnitProcessor { private static final DotName PERSISTENCE_CONTEXT_ANNOTATION_NAME = DotName . createSimple ( PersistenceContext . class . getName ( ) ) ; private static final DotName PERSISTENCE_UNIT_ANNOTATION_NAME = DotName . createSimple ( PersistenceUnit . class . getName ( ) ) ; private static final String ENTITY_MANAGER_CLASS = "javax.persistence.EntityManager" ; private static final String ENTITY_MANAGERFACTORY_CLASS = "javax.persistence.EntityManagerFactory" ; @ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { } @ Override public void undeploy ( DeploymentUnit context ) { } private void processPersistenceAnnotations ( final DeploymentUnit deploymentUnit , final EEModuleDescription eeModuleDescription , List < AnnotationInstance > persistenceContexts ) throws DeploymentUnitProcessingException { } private void processField ( final DeploymentUnit deploymentUnit , final AnnotationInstance annotation , final FieldInfo fieldInfo , final EEModuleClassDescription eeModuleClassDescription ) throws DeploymentUnitProcessingException { } private void processMethod ( final DeploymentUnit deploymentUnit , final AnnotationInstance annotation , final MethodInfo methodInfo , final EEModuleClassDescription eeModuleClassDescription ) throws DeploymentUnitProcessingException { } private void processClass ( final DeploymentUnit deploymentUnit , final AnnotationInstance annotation , final ClassInfo classInfo , final EEModuleClassDescription eeModuleClassDescription ) throws DeploymentUnitProcessingException { } private InjectionSource getBindingSource ( final DeploymentUnit deploymentUnit , final AnnotationInstance annotation , String injectionTypeName ) throws DeploymentUnitProcessingException { String scopedPuName = getScopedPuName ( deploymentUnit , annotation ) ; ServiceName puServiceName = getPuServiceName ( scopedPuName ) ; if ( isPersistenceContext ( annotation ) ) { AnnotationValue pcType = annotation . value ( "type" ) ; PersistenceContextType type = ( ( pcType == null ) || ( TRANSACTION . name ( ) . equals ( pcType . asString ( ) ) ) ) ? PersistenceContextType . TRANSACTION : PersistenceContextType . EXTENDED ; Map properties ; AnnotationValue value = annotation . value ( "properties" ) ; AnnotationInstance [ ] props = ( value != null ) ? value . asNestedArray ( ) : null ; if ( props != null ) { properties = new HashMap ( ) ; for ( int source = 0 ; source < ( props . length ) ; source ++ ) { properties . put ( props [ source ] . value ( "name" ) , props [ source ] . value ( "value" ) ) ; } } else { properties = null ; } return new org . jboss . as . jpa . injectors . PersistenceContextInjectionSource ( type , properties , puServiceName , deploymentUnit , scopedPuName , injectionTypeName ) ; } else { <START_BUG> return new org . jboss . as . jpa . injectors . PersistenceUnitInjectionSource ( puServiceName , deploymentUnit , scopedPuName , injectionTypeName ) ; <END_BUG> } } private boolean isExtendedPersistenceContext ( final AnnotationInstance annotation ) { } private boolean isPersistenceContext ( final AnnotationInstance annotation ) { } private String getClassLevelInjectionType ( final AnnotationInstance annotation ) { } private String getScopedPuName ( final DeploymentUnit deploymentUnit , final AnnotationInstance annotation ) throws DeploymentUnitProcessingException { } private ServiceName getPuServiceName ( String scopedPuName ) throws DeploymentUnitProcessingException { } private void registerInterceptorsForExtendedPersistenceContext ( SessionBeanComponentDescription componentDescription , AnnotationInstance annotation ) { } } 
public class ArrayCreation extends Expression { public static final ChildPropertyDescriptor TYPE_PROPERTY = new ChildPropertyDescriptor ( ArrayCreation . class , "type" , ArrayType . class , ASTNode . MANDATORY , ASTNode . NO_CYCLE_RISK ) ; public static final ChildListPropertyDescriptor DIMENSIONS_PROPERTY = new ChildListPropertyDescriptor ( ArrayCreation . class , "dimensions" , Expression . class , ASTNode . CYCLE_RISK ) ; public static final ChildPropertyDescriptor INITIALIZER_PROPERTY = new ChildPropertyDescriptor ( ArrayCreation . class , "initializer" , ArrayInitializer . class , ASTNode . OPTIONAL , ASTNode . CYCLE_RISK ) ; private static final List PROPERTY_DESCRIPTORS ; public static List propertyDescriptors ( int apiLevel ) { } private ArrayType arrayType = null ; private ASTNode . NodeList dimensions = new ASTNode . NodeList ( ArrayCreation . DIMENSIONS_PROPERTY ) ; private ArrayInitializer optionalInitializer = null ; ArrayCreation ( AST ast ) { } final List internalStructuralPropertiesForType ( int apiLevel ) { } final ASTNode internalGetSetChildProperty ( ChildPropertyDescriptor property , boolean get , ASTNode child ) { } final List internalGetChildListProperty ( ChildListPropertyDescriptor property ) { } final int getNodeType0 ( ) { } ASTNode clone0 ( AST target ) { } final boolean subtreeMatch0 ( ASTMatcher matcher , Object other ) { } void accept0 ( ASTVisitor visitor ) { } public ArrayType getType ( ) { if ( ( this . arrayType ) == null ) { <START_BUG> synchronized ( this . ast ) { <END_BUG> if ( ( this . arrayType ) == null ) { preLazyInit ( ) ; this . arrayType = this . ast . newArrayType ( this . ast . newPrimitiveType ( PrimitiveType . INT ) ) ; postLazyInit ( this . arrayType , ArrayCreation . TYPE_PROPERTY ) ; } } } return this . arrayType ; } public void setType ( ArrayType type ) { } public List dimensions ( ) { } public ArrayInitializer getInitializer ( ) { } public void setInitializer ( ArrayInitializer initializer ) { } int memSize ( ) { } int treeSize ( ) { } } 
public abstract class AbstractMethodDeclaration extends ASTNode implements ReferenceContext , ProblemSeverities { public MethodScope scope ; public char [ ] selector ; public int declarationSourceStart ; public int declarationSourceEnd ; public int modifiers ; public int modifiersSourceStart ; public Annotation [ ] annotations ; public Argument [ ] arguments ; public TypeReference [ ] thrownExceptions ; public Statement [ ] statements ; public int explicitDeclarations ; public MethodBinding binding ; public boolean ignoreFurtherInvestigation = false ; public boolean needFreeReturn = false ; public Javadoc javadoc ; public int bodyStart ; public int bodyEnd = - 1 ; public CompilationResult compilationResult ; public boolean errorInSignature = false ; AbstractMethodDeclaration ( CompilationResult compilationResult ) { } public void abort ( int abortLevel , IProblem problem ) { } public abstract void analyseCode ( ClassScope classScope , InitializationFlowContext initializationContext , FlowInfo info ) { } public void bindArguments ( ) { } public void bindThrownExceptions ( ) { } public CompilationResult compilationResult ( ) { } public void generateCode ( ClassScope classScope , ClassFile classFile ) { } public void generateCode ( ClassFile classFile ) { } private void checkArgumentsSize ( ) { TypeBinding [ ] parameters = this . binding . parameters ; int size = 1 ; for ( int i = 0 , max = parameters . length ; i < max ; i ++ ) { TypeBinding parameter = parameters [ i ] ; <START_BUG> if ( ( parameter == ( LongBinding ) ) || ( parameter == ( DoubleBinding ) ) ) { <END_BUG> size += 2 ; } else { size ++ ; } if ( size > 255 ) { this . scope . problemReporter ( ) . noMoreAvailableSpaceForArgument ( this . scope . locals [ i ] , this . scope . locals [ i ] . declaration ) ; } } } public boolean hasErrors ( ) { } public boolean isAbstract ( ) { } public boolean isAnnotationMethod ( ) { } public boolean isClinit ( ) { } public boolean isConstructor ( ) { } public boolean isDefaultConstructor ( ) { } public boolean isInitializationMethod ( ) { } public boolean isMethod ( ) { } public boolean isNative ( ) { } public boolean isStatic ( ) { } public abstract void parseStatements ( Parser parser , CompilationUnitDeclaration unit ) { } public StringBuffer print ( int tab , StringBuffer output ) { } public StringBuffer printBody ( int indent , StringBuffer output ) { } public StringBuffer printReturnType ( int indent , StringBuffer output ) { } public void resolve ( ClassScope upperScope ) { } public void resolveJavadoc ( ) { } public void resolveStatements ( ) { } public void tagAsHavingErrors ( ) { } public void traverse ( ASTVisitor visitor , ClassScope classScope ) { } public TypeParameter [ ] typeParameters ( ) { } } 
abstract class Const implements Val , Constant { private ClassMetaData _meta = null ; private Column [ ] _cols = null ; public ClassMetaData getMetaData ( ) { } public void setMetaData ( ClassMetaData meta ) { } public boolean isVariable ( ) { } public Column getColumn ( int index ) { } public abstract Object getValue ( ) { } public Object getValue ( Object [ ] parameters ) { } public Object getSQLValue ( ) { } public boolean isSQLValueNull ( ) { } public void initialize ( Select sel , JDBCStore store , boolean nullTest ) { } public Joins getJoins ( ) { } public void calculateValue ( Select sel , JDBCStore store , Object [ ] params , Val other , JDBCFetchConfiguration fetch ) { } public Object toDataStoreValue ( Object val , JDBCStore store ) { } public void select ( Select sel , JDBCStore store , Object [ ] params , boolean pks , JDBCFetchConfiguration fetch ) { } private SQLBuffer newSQLBuffer ( Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { } public void selectColumns ( Select sel , JDBCStore store , Object [ ] params , boolean pks , JDBCFetchConfiguration fetch ) { } public void groupBy ( Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { <START_BUG> sel . groupBy ( newSQLBuffer ( sel , store , params , fetch ) , false ) ; <END_BUG> } public void orderBy ( Select sel , JDBCStore store , Object [ ] params , boolean asc , JDBCFetchConfiguration fetch ) { } public Object load ( Result res , JDBCStore store , JDBCFetchConfiguration fetch ) throws SQLException { } public boolean hasVariable ( Variable var ) { } public int length ( ) { } public void appendIsEmpty ( SQLBuffer sql , Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { } public void appendIsNotEmpty ( SQLBuffer sql , Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { } public void appendSize ( SQLBuffer sql , Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { } public void appendIsNull ( SQLBuffer sql , Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { } public void appendIsNotNull ( SQLBuffer sql , Select sel , JDBCStore store , Object [ ] params , JDBCFetchConfiguration fetch ) { } } 
public class SendAllMessagesCommand extends FolderCommand { protected SendListManager sendListManager = new SendListManager ( ) ; protected OutboxFolder outboxFolder ; public SendAllMessagesCommand ( AbstractFrameController frameController , DefaultCommandReference [ ] references ) { } public void execute ( Worker worker ) throws Exception { FolderCommandReference [ ] r = ( ( FolderCommandReference [ ] ) ( getReferences ( ) ) ) ; worker . setDisplayText ( MailResourceLoader . getString ( "statusbar" , "message" , "send_message" ) ) ; outboxFolder = ( ( OutboxFolder ) ( r [ 0 ] . getFolder ( ) ) ) ; Object [ ] uids = outboxFolder . getUids ( ) ; for ( int i = 0 ; i < ( uids . length ) ; i ++ ) { if ( ( outboxFolder . exists ( uids [ i ] ) ) == true ) { SendableMessage message = ( ( SendableMessage ) ( outboxFolder . getMessage ( uids [ i ] ) ) ) ; sendListManager . add ( message ) ; } } int actAccountUid = - 1 ; List sentList = new Vector ( ) ; boolean open = false ; SMTPServer smtpServer = null ; Folder sentFolder = null ; while ( sendListManager . hasMoreMessages ( ) ) { SendableMessage message = sendListManager . getNextMessage ( ) ; if ( ( message . getAccountUid ( ) ) != actAccountUid ) { actAccountUid = message . getAccountUid ( ) ; AccountItem accountItem = MailConfig . getAccountList ( ) . uidGet ( actAccountUid ) ; sentFolder = ( ( Folder ) ( treeModel . getFolder ( Integer . parseInt ( accountItem . getSpecialFoldersItem ( ) . get ( "sent" ) ) ) ) ) ; smtpServer = new SMTPServer ( accountItem ) ; open = smtpServer . openConnection ( ) ; ( ( StatusObservableImpl ) ( smtpServer . getObservable ( ) ) ) . setWorker ( worker ) ; } if ( open ) { try { smtpServer . sendMessage ( message , worker ) ; <START_BUG> sentList . add ( message . getHeaderInterface ( ) . get ( "columba.uid" ) ) ; <END_BUG> } catch ( SMTPException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "Error<seq2seq4repair_space>while<seq2seq4repair_space>sending" , JOptionPane . ERROR_MESSAGE ) ; } } } worker . clearDisplayTextWithDelay ( ) ; if ( ( sentList . size ( ) ) > 0 ) { moveToSentFolder ( sentList , sentFolder ) ; sentList . clear ( ) ; } } protected void moveToSentFolder ( List v , Folder sentFolder ) { } } 
@ SuppressWarnings ( "deprecation" ) public class LegacyGlobalConfigurationAdapter { public static GlobalConfiguration adapt ( GlobalConfiguration config ) { } @ SuppressWarnings ( "unchecked" ) public static GlobalConfiguration adapt ( org . infinispan . config . GlobalConfiguration legacy ) { if ( legacy == null ) return null ; GlobalConfigurationBuilder builder = new GlobalConfigurationBuilder ( ) ; if ( ( legacy . getTransportClass ( ) ) != null ) { builder . transport ( ) . clusterName ( legacy . getClusterName ( ) ) . machineId ( legacy . getMachineId ( ) ) . rackId ( legacy . getRackId ( ) ) . siteId ( legacy . getSiteId ( ) ) . strictPeerToPeer ( legacy . isStrictPeerToPeer ( ) ) . distributedSyncTimeout ( legacy . getDistributedSyncTimeout ( ) ) . transport ( Util . < Transport > getInstance ( legacy . getTransportClass ( ) , legacy . getClassLoader ( ) ) ) . nodeName ( legacy . getTransportNodeName ( ) ) . withProperties ( legacy . getTransportProperties ( ) ) ; } builder . globalJmxStatistics ( ) . enabled ( legacy . isExposeGlobalJmxStatistics ( ) ) . jmxDomain ( legacy . getJmxDomain ( ) ) . mBeanServerLookup ( legacy . getMBeanServerLookupInstance ( ) ) . allowDuplicateDomains ( legacy . isAllowDuplicateDomains ( ) ) . cacheManagerName ( legacy . getCacheManagerName ( ) ) . withProperties ( legacy . getMBeanServerProperties ( ) ) ; builder . serialization ( ) . marshallerClass ( Util . < Marshaller > loadClass ( legacy . getMarshallerClass ( ) , legacy . getClassLoader ( ) ) ) . version ( legacy . getMarshallVersion ( ) ) ; for ( AdvancedExternalizerConfig externalizerConfig : legacy . getExternalizers ( ) ) { <START_BUG> builder . serialization ( ) . addAdvancedExternalizer ( externalizerConfig . getAdvancedExternalizer ( ) ) ; <END_BUG> } builder . asyncTransportExecutor ( ) . factory ( Util . < ExecutorFactory > getInstance ( legacy . getAsyncTransportExecutorFactoryClass ( ) , legacy . getClassLoader ( ) ) ) . withProperties ( legacy . getAsyncTransportExecutorProperties ( ) ) ; builder . asyncListenerExecutor ( ) . factory ( Util . < ExecutorFactory > getInstance ( legacy . getAsyncListenerExecutorFactoryClass ( ) , legacy . getClassLoader ( ) ) ) . withProperties ( legacy . getAsyncListenerExecutorProperties ( ) ) ; builder . evictionScheduledExecutor ( ) . factory ( Util . < ScheduledExecutorFactory > getInstance ( legacy . getEvictionScheduledExecutorFactoryClass ( ) , legacy . getClassLoader ( ) ) ) . withProperties ( legacy . getAsyncListenerExecutorProperties ( ) ) ; builder . replicationQueueScheduledExecutor ( ) . factory ( Util . < ScheduledExecutorFactory > getInstance ( legacy . getReplicationQueueScheduledExecutorFactoryClass ( ) , legacy . getClassLoader ( ) ) ) . withProperties ( legacy . getReplicationQueueScheduledExecutorProperties ( ) ) ; builder . shutdown ( ) . hookBehavior ( ShutdownHookBehavior . valueOf ( legacy . getShutdownHookBehavior ( ) . name ( ) ) ) ; return builder . build ( ) ; } } 
public class CachingConnectionFactory extends SingleConnectionFactory { private int sessionCacheSize = 1 ; private boolean cacheProducers = true ; private boolean cacheConsumers = true ; private volatile boolean active = true ; private final Map < Integer , LinkedList < Session > > cachedSessions = new HashMap < Integer , LinkedList < Session > > ( ) ; public CachingConnectionFactory ( ) { } public CachingConnectionFactory ( ConnectionFactory targetConnectionFactory ) { } public void setSessionCacheSize ( int sessionCacheSize ) { } public int getSessionCacheSize ( ) { } public void setCacheProducers ( boolean cacheProducers ) { } public boolean isCacheProducers ( ) { } public void setCacheConsumers ( boolean cacheConsumers ) { } public boolean isCacheConsumers ( ) { } public void resetConnection ( ) { } protected Session getSession ( Connection con , Integer mode ) throws JMSException { } protected Session getCachedSessionProxy ( Session target , LinkedList < Session > sessionList ) { } private class CachedSessionInvocationHandler implements InvocationHandler { private final Session target ; private final LinkedList < Session > sessionList ; private final Map < Destination , MessageProducer > cachedProducers = new HashMap < Destination , MessageProducer > ( ) ; private final Map < CachingConnectionFactory . ConsumerCacheKey , MessageConsumer > cachedConsumers = new HashMap < CachingConnectionFactory . ConsumerCacheKey , MessageConsumer > ( ) ; private boolean transactionOpen = false ; public CachedSessionInvocationHandler ( Session target , LinkedList < Session > sessionList ) { } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { String methodName = method . getName ( ) ; if ( methodName . equals ( "equals" ) ) { <START_BUG> return proxy == ( args [ 0 ] ) ? Boolean . TRUE : Boolean . FALSE ; <END_BUG> } else if ( methodName . equals ( "hashCode" ) ) { return System . identityHashCode ( proxy ) ; } else if ( methodName . equals ( "toString" ) ) { return "Cached<seq2seq4repair_space>JMS<seq2seq4repair_space>Session:<seq2seq4repair_space>" + ( this . target ) ; } else if ( methodName . equals ( "close" ) ) { if ( active ) { synchronized ( this . sessionList ) { if ( ( this . sessionList . size ( ) ) < ( getSessionCacheSize ( ) ) ) { logicalClose ( ( ( Session ) ( proxy ) ) ) ; return null ; } } } physicalClose ( ) ; return null ; } else if ( methodName . equals ( "getTargetSession" ) ) { return this . target ; } else if ( ( methodName . equals ( "commit" ) ) || ( methodName . equals ( "rollback" ) ) ) { this . transactionOpen = false ; } else { this . transactionOpen = true ; if ( ( ( ( methodName . equals ( "createProducer" ) ) || ( methodName . equals ( "createSender" ) ) ) || ( methodName . equals ( "createPublisher" ) ) ) && ( isCacheProducers ( ) ) ) { return getCachedProducer ( ( ( Destination ) ( args [ 0 ] ) ) ) ; } else if ( ( ( ( methodName . equals ( "createConsumer" ) ) || ( methodName . equals ( "createReceiver" ) ) ) || ( methodName . equals ( "createSubscriber" ) ) ) && ( isCacheConsumers ( ) ) ) { return getCachedConsumer ( ( ( Destination ) ( args [ 0 ] ) ) , ( ( args . length ) > 1 ? ( ( String ) ( args [ 1 ] ) ) : null ) , ( ( ( args . length ) > 2 ) && ( ( Boolean ) ( args [ 2 ] ) ) ) , null ) ; } else if ( ( methodName . equals ( "createDurableSubscriber" ) ) && ( isCacheConsumers ( ) ) ) { return getCachedConsumer ( ( ( Destination ) ( args [ 0 ] ) ) , ( ( args . length ) > 2 ? ( ( String ) ( args [ 2 ] ) ) : null ) , ( ( ( args . length ) > 3 ) && ( ( Boolean ) ( args [ 3 ] ) ) ) , ( ( String ) ( args [ 1 ] ) ) ) ; } } try { return method . invoke ( this . target , args ) ; } catch ( InvocationTargetException ex ) { throw ex . getTargetException ( ) ; } } private MessageProducer getCachedProducer ( Destination dest ) throws JMSException { } private MessageConsumer getCachedConsumer ( Destination dest , String selector , boolean noLocal , String subscription ) throws JMSException { } private void logicalClose ( Session proxy ) throws JMSException { } private void physicalClose ( ) throws JMSException { } } private static class ConsumerCacheKey { private final Destination destination ; private final String selector ; private final boolean noLocal ; private final String subscription ; private ConsumerCacheKey ( Destination destination , String selector , boolean noLocal , String subscription ) { } public boolean equals ( Object other ) { } public int hashCode ( ) { } } } 
public class EditorManager implements IExtensionChangeHandler { EditorAreaHelper editorPresentation ; WorkbenchWindow window ; WorkbenchPage page ; private Map actionCache = new HashMap ( ) ; private static final String PIN_EDITOR_KEY = "PIN_EDITOR" ; private static final String PIN_EDITOR = "ovr16/pinned_ovr.gif" ; private IPropertyChangeListener editorPropChangeListnener = null ; private IHandlerActivation pinEditorHandlerActivation = null ; static final String RESOURCES_TO_SAVE_MESSAGE = WorkbenchMessages . EditorManager_saveResourcesMessage ; static final String SAVE_RESOURCES_TITLE = WorkbenchMessages . EditorManager_saveResourcesTitle ; public EditorManager ( WorkbenchWindow window , WorkbenchPage workbenchPage , EditorAreaHelper pres ) { } void checkDeleteEditorResources ( ) { } void checkCreateEditorPropListener ( ) { } void checkCreatePinEditorShortcutKeyHandler ( ) { } ImageDescriptor getEditorPinImageDesc ( ) { } private List collectDirtyEditors ( ) { } public boolean containsEditor ( IEditorReference ref ) { } private EditorActionBars createEditorActionBars ( EditorDescriptor desc , final IEditorSite site ) { } private EditorActionBars createEmptyEditorActionBars ( final IEditorSite site ) { } void disposeEditorActionBars ( EditorActionBars actionBars ) { } public IEditorPart findEditor ( IEditorInput input ) { } public IEditorPart findEditor ( String editorId , IEditorInput input , int matchFlags ) { } public IEditorReference [ ] findEditors ( IEditorInput input , String editorId , int matchFlags ) { } private void findEditors ( List editorList , IEditorInput input , String editorId , int matchFlags , List result ) { } private Display getDisplay ( ) { } public int getEditorCount ( ) { } private IEditorRegistry getEditorRegistry ( ) { } public IEditorPart [ ] getDirtyEditors ( ) { } public IEditorReference [ ] getEditors ( ) { } public IEditorPart getVisibleEditor ( ) { } public boolean isSaveAllNeeded ( ) { } private IEditorReference findReusableEditor ( EditorDescriptor desc ) { } public IEditorReference openEditor ( String editorId , IEditorInput input , boolean setVisible , IMemento editorState ) throws PartInitException { } public IEditorReference openEditorFromDescriptor ( EditorDescriptor desc , IEditorInput input , IMemento editorState ) throws PartInitException { } private IEditorReference openExternalEditor ( final EditorDescriptor desc , IEditorInput input ) throws PartInitException { } IEditorReference [ ] openMultiEditor ( final IEditorReference ref , final AbstractMultiEditor part , final MultiEditorInput input ) throws PartInitException { } private void createEditorTab ( final EditorReference ref , final String workbookId ) throws PartInitException { <START_BUG> editorPresentation . addEditor ( ref , workbookId ) ; <END_BUG> } EditorSite createSite ( final IEditorReference ref , final IEditorPart part , final EditorDescriptor desc , final IEditorInput input ) throws PartInitException { } private IEditorReference reuseInternalEditor ( EditorDescriptor desc , IEditorInput input ) throws PartInitException { } IEditorPart createPart ( final EditorDescriptor desc ) throws PartInitException { } private IEditorReference openSystemExternalEditor ( final IPath location ) throws PartInitException { } ImageDescriptor findImage ( EditorDescriptor desc , IPath path ) { } public IStatus restoreState ( IMemento memento ) { } public boolean saveAll ( boolean confirm , boolean closing , boolean addNonPartSources ) { } public static boolean saveAll ( List dirtyParts , boolean confirm , boolean closing , boolean addNonPartSources , final IWorkbenchWindow window ) { } public static boolean saveAll ( List dirtyParts , final boolean confirm , final boolean closing , boolean addNonPartSources , final IRunnableContext runnableContext , final IShellProvider shellProvider ) { } private static List convertToSaveables ( List parts , boolean closing , boolean addNonPartSources ) { } private static Saveable [ ] getSaveables ( IWorkbenchPart part ) { } private static boolean closingLastPartShowingModel ( Saveable model , List closingParts , IWorkbenchPage page ) { } public boolean savePart ( final ISaveablePart saveable , IWorkbenchPart part , boolean confirm ) { } public IStatus saveState ( final IMemento memento ) { } public boolean setVisibleEditor ( IEditorReference newEd , boolean setFocus ) { } private IPathEditorInput getPathEditorInput ( IEditorInput input ) { } private class InnerEditor extends EditorReference { private IEditorReference outerEditor ; private AbstractMultiEditor outerEditorPart ; public InnerEditor ( IEditorReference outerEditor , AbstractMultiEditor outerEditorPart , IEditorInput input , EditorDescriptor desc ) { } protected void doDisposePart ( ) { } protected PartPane createPane ( ) { } protected Composite getPaneControlContainer ( ) { } } public void restoreEditorState ( IMemento editorMem , ArrayList visibleEditors , IEditorReference [ ] activeEditor , MultiStatus result ) { } protected void saveEditorState ( IMemento mem , IEditorReference ed , MultiStatus res ) { } public IMemento getMemento ( IEditorReference e ) { } public void removeExtension ( IExtension source , Object [ ] objects ) { } public void addExtension ( IExtensionTracker tracker , IExtension extension ) { } IEditorReference openEmptyTab ( ) { } public static boolean useIPersistableEditor ( ) { } } 
public class OSGiSubsystemSupport { private static final Logger log = Logger . getLogger ( OSGiSubsystemSupport . class ) ; public static final byte [ ] BLANK_SHA1 = new byte [ 20 ] ; private static final AtomicInteger archiveCount = new AtomicInteger ( ) ; private final ServiceContainer serviceContainer ; private OSGiSubsystemState subsystemState ; private DeploymentChain deploymentChain ; private Selector selector ; public OSGiSubsystemSupport ( ) throws Exception { } public OSGiSubsystemSupport ( final OSGiSubsystemState subsystemState ) throws Exception { } public ServiceContainer getServiceContainer ( ) { } public ModuleLoader getClassifyingModuleLoader ( ) { } public OSGiSubsystemSupport . TestModuleLoader getTestModuleLoader ( ) { } public DeploymentChain getDeploymentChain ( ) { } public String getUniqueName ( String prefix ) { } public void assertServiceUp ( ServiceName serviceName ) { } public void assertServiceDown ( ServiceName serviceName ) { } public void shutdown ( ) { } public void removeDeploymentChain ( ) { } public void setupServices ( final BatchBuilder batchBuilder ) throws Exception { } public void setupEnvironmentServices ( final BatchBuilder batchBuilder ) { } public void setupModuleLoaderServices ( final BatchBuilder batchBuilder ) { } public void setupDeploymentServices ( final BatchBuilder batchBuilder ) { } public void setupFrameworkServices ( final BatchBuilder batchBuilder ) { batchBuilder . addService ( SERVICE_NAME , new MBeanServerService ( ) ) ; OSGiSubsystemSupport . TestBundleManagerService . addService ( batchBuilder ) ; <START_BUG> FrameworkService . addService ( batchBuilder , null ) ; <END_BUG> PackageAdminService . addService ( batchBuilder ) ; } private Selector getDeploymentChainSelector ( ) { } public BundleManager getBundleManager ( ) { } public BundleContext getSystemContext ( ) { } public Configuration getSubsystemConfig ( ) { } public void assertLoadClass ( ModuleIdentifier identifier , String className ) throws Exception { } public void assertLoadClass ( ModuleIdentifier identifier , String className , ModuleIdentifier exporterId ) throws Exception { } public void assertLoadClassFails ( ModuleIdentifier identifier , String className ) throws Exception { } public Class < ? > loadClass ( ModuleIdentifier identifier , String className ) throws Exception { } public Module loadModule ( ModuleIdentifier identifier ) throws ModuleLoadException { } public Bundle executeDeploy ( final JavaArchive archive ) throws Exception { } public void executeUndeploy ( final JavaArchive archive ) throws Exception { } List < ServiceName > runWithLatchedBatch ( final OSGiSubsystemSupport . BatchedWork work ) throws Exception { } public interface BatchedWork { void execute ( final BatchBuilder batchBuilder ) throws Exception { } } private static class TestServiceListener extends AbstractServiceListener < Object > { final List < ServiceName > registeredServices = new ArrayList < ServiceName > ( ) ; final List < ServiceName > startedServices = new ArrayList < ServiceName > ( ) ; final List < ServiceName > failedServices = new ArrayList < ServiceName > ( ) ; final Map < Mode , List < ServiceName > > initialModes ; private final AtomicInteger count = new AtomicInteger ( 1 ) ; private final Runnable finishTask ; public TestServiceListener ( Runnable finishTask , Map < Mode , List < ServiceName > > initialModes ) { } public void listenerAdded ( final ServiceController < ? extends Object > controller ) { } public void serviceStarted ( final ServiceController < ? extends Object > controller ) { } public void serviceFailed ( ServiceController < ? extends Object > controller , StartException reason ) { } @ Override public void serviceRemoved ( ServiceController < ? extends Object > controller ) { } public void finishBatch ( ) { } private void batchComplete ( ) { } } public static class TestModuleLoader extends ModuleLoader implements Service < OSGiSubsystemSupport . TestModuleLoader > { public static final ServiceName SERVICE_NAME = JBOSS . append ( "module" , "loader" , "support" ) ; private String prefix ; private Map < ModuleIdentifier , ModuleSpec > modules = new HashMap < ModuleIdentifier , ModuleSpec > ( ) ; private Injector < ClassifyingModuleLoaderService > injector ; TestModuleLoader ( String prefix ) { } public void addModuleSpec ( ModuleSpec moduleSpec ) { } @ Override protected ModuleSpec findModule ( ModuleIdentifier identifier ) throws ModuleLoadException { } public static OSGiSubsystemSupport . TestModuleLoader getServiceValue ( ServiceContainer container ) { } public synchronized void start ( StartContext context ) throws StartException { } public synchronized void stop ( StopContext context ) { } public synchronized OSGiSubsystemSupport . TestModuleLoader getValue ( ) throws IllegalStateException { } @ Override public String toString ( ) { } } static class TestBundleManagerService implements Service < BundleManager > { public static final ServiceName SERVICE_NAME = BundleManagerService . SERVICE_NAME ; private static final Logger log = Logger . getLogger ( "org.jboss.as.osgi" ) ; private InjectedValue < Configuration > injectedConfig = new InjectedValue < Configuration > ( ) ; private InjectedValue < ClassifyingModuleLoaderService > injectedModuleLoader = new InjectedValue < ClassifyingModuleLoaderService > ( ) ; private Injector < ClassifyingModuleLoaderService > moduleLoaderInjector ; private BundleManager bundleManager ; public static void addService ( final BatchBuilder batchBuilder ) { } public static BundleManager getServiceValue ( ServiceContainer container ) { } public synchronized void start ( StartContext context ) throws StartException { } public synchronized void stop ( StopContext context ) { } @ Override public BundleManager getValue ( ) throws IllegalStateException { } } static class TestServerDeploymentRepository implements ServerDeploymentRepository , Service < ServerDeploymentRepository > { private Map < String , JavaArchive > repository = new HashMap < String , JavaArchive > ( ) ; public static OSGiSubsystemSupport . TestServerDeploymentRepository getServiceValue ( ServiceContainer container ) { } public void registerDeploymentArchive ( String name , JavaArchive archive ) { } @ Override public void start ( StartContext context ) throws StartException { } @ Override public void stop ( StopContext context ) { } @ Override public ServerDeploymentRepository getValue ( ) throws IllegalStateException { } @ Override public byte [ ] addDeploymentContent ( String name , String runtimeName , InputStream stream ) throws IOException { } @ Override public Closeable mountDeploymentContent ( String name , String runtimeName , byte [ ] deploymentHash , VirtualFile mountPoint ) throws IOException { } } } 
public class Version { private Version ( ) { } public static String id ( ) { <START_BUG> return "4.5" ; <END_BUG> } public static void main ( String [ ] args ) { } } 
public class ClassicalRungeKuttaIntegratorTest { @ Test public void testMissedEndEvent ( ) { } @ Test public void testSanityChecks ( ) { } @ Test public void testDecreasingSteps ( ) { TestProblemAbstract [ ] problems = TestProblemFactory . getProblems ( ) ; for ( int k = 0 ; k < ( problems . length ) ; ++ k ) { double previousValueError = Double . NaN ; double previousTimeError = Double . NaN ; for ( int i = 4 ; i < 10 ; ++ i ) { TestProblemAbstract pb = problems [ k ] . copy ( ) ; double step = ( ( pb . getFinalTime ( ) ) - ( pb . getInitialTime ( ) ) ) * ( FastMath . pow ( 2.0 , ( - i ) ) ) ; FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator ( step ) ; TestProblemHandler handler = new TestProblemHandler ( pb , integ ) ; integ . addStepHandler ( handler ) ; EventHandler [ ] functions = pb . getEventsHandlers ( ) ; for ( int l = 0 ; l < ( functions . length ) ; ++ l ) { integ . addEventHandler ( functions [ l ] , Double . POSITIVE_INFINITY , ( 1.0E-6 * step ) , 1000 ) ; } Assert . assertEquals ( functions . length , integ . getEventHandlers ( ) . size ( ) ) ; double stopTime = integ . integrate ( pb , pb . getInitialTime ( ) , pb . getInitialState ( ) , pb . getFinalTime ( ) , new double [ pb . getDimension ( ) ] ) ; if ( ( functions . length ) == 0 ) { Assert . assertEquals ( pb . getFinalTime ( ) , stopTime , 1.0E-10 ) ; } double error = handler . getMaximalValueError ( ) ; if ( i > 4 ) { <START_BUG> Assert . assertTrue ( ( error < ( FastMath . abs ( previousValueError ) ) ) ) ; <END_BUG> } previousValueError = error ; double timeError = handler . getMaximalTimeError ( ) ; if ( i > 4 ) { Assert . assertTrue ( ( timeError <= ( FastMath . abs ( previousTimeError ) ) ) ) ; } previousTimeError = timeError ; integ . clearEventHandlers ( ) ; Assert . assertEquals ( 0 , integ . getEventHandlers ( ) . size ( ) ) ; } } } @ Test public void testSmallStep ( ) { } @ Test public void testBigStep ( ) { } @ Test public void testBackward ( ) { } @ Test public void testKepler ( ) { } private static class KeplerHandler implements StepHandler { public KeplerHandler ( TestProblem3 pb ) { } public void reset ( ) { } public void handleStep ( StepInterpolator interpolator , boolean isLast ) { } private double maxError = 0 ; private TestProblem3 pb ; } @ Test public void testStepSize ( ) { } } 
public class ReferencesSearchGroup extends ActionGroup { private final IWorkbenchSite site ; private IActionBars actionBars ; private final String groupId ; private SelectionDispatchAction findReferencesAction ; public ReferencesSearchGroup ( final IWorkbenchSite site ) { } protected ReferencesSearchGroup ( final AbstractXtendXpandEditor editor ) { } private void registerAction ( final SelectionDispatchAction action , final ISelectionProvider provider , final ISelection selection ) { } private void addAction ( final IAction action , final IMenuManager manager ) { } @ Override public void fillActionBars ( final IActionBars actionBars ) { } @ Override public void fillContextMenu ( final IMenuManager manager ) { <START_BUG> final IMenuManager menuManager = new org . eclipse . jface . action . MenuManager ( "Re&ferences" , IContextMenuConstants . GROUP_SEARCH ) ; <END_BUG> addAction ( findReferencesAction , menuManager ) ; menuManager . add ( new Separator ( ) ) ; if ( ! ( menuManager . isEmpty ( ) ) ) { manager . appendToGroup ( groupId , menuManager ) ; } } @ Override public void dispose ( ) { } private void updateGlobalActionHandlers ( ) { } private void disposeAction ( final ISelectionChangedListener action , final ISelectionProvider provider ) { } } 
class StyledTextTab extends ScrollableTab { StyledText styledText ; Group styledTextGroup ; Group styledTextStyleGroup ; Button wrapButton ; Button readOnlyButton ; Button fullSelectionButton ; Button boldButton ; Button italicButton ; Button redButton ; Button yellowButton ; Button underlineButton ; Button strikeoutButton ; Image boldImage ; Image italicImage ; Image redImage ; Image yellowImage ; Image underlineImage ; Image strikeoutImage ; String text ; StyleRange [ ] styleRanges ; StyledTextTab ( ControlExample instance ) { } Image createBitmapImage ( Display display , String name ) { } void createControlWidgets ( ) { } void createExampleGroup ( ) { } void createExampleWidgets ( ) { } void createStyleGroup ( ) { } void createStyledTextStyleGroup ( ) { } Composite createTabFolderPage ( TabFolder tabFolder ) { } void disposeExampleWidgets ( ) { } String [ ] getCustomEventNames ( ) { } Widget [ ] getExampleWidgets ( ) { } String [ ] getMethodNames ( ) { <START_BUG> return new String [ ] { "CaretOffset" , "DoubleClickEnabled" , "Editable" , "HorizontalIndex" , "HorizontalPixel" , "Orientation" , "Selection" , "Tabs" , "Text" , "TextLimit" , "ToolTipText" , "TopIndex" , "TopPixel" , "WordWrap" } ; <END_BUG> } String getTabText ( ) { } void hookCustomListener ( final String eventName ) { } void setExampleWidgetState ( ) { } } 
public abstract class CreateTypeMemberOperation extends CreateElementInCUOperation { protected String source = null ; protected String alteredName ; protected ASTNode createdNode ; public CreateTypeMemberOperation ( IJavaElement parentElement , String source , boolean force ) { } protected StructuralPropertyDescriptor getChildPropertyDescriptor ( ASTNode parent ) { } protected ASTNode generateElementAST ( ASTRewrite rewriter , ICompilationUnit cu ) throws JavaModelException { } private String removeIndentAndNewLines ( String code , ICompilationUnit cu ) throws JavaModelException { } protected abstract SimpleName rename ( ASTNode node , SimpleName newName ) { } protected String generateSyntaxIncorrectAST ( ) { } protected IType getType ( ) { } protected void setAlteredName ( String newName ) { } public IJavaModelStatus verify ( ) { IJavaModelStatus status = super . verify ( ) ; if ( ! ( status . isOK ( ) ) ) { return status ; } if ( ( this . source ) == null ) { return new JavaModelStatus ( IJavaModelStatusConstants . INVALID_CONTENTS ) ; } <START_BUG> if ( ! ( force ) ) { <END_BUG> try { ICompilationUnit cu = getCompilationUnit ( ) ; generateElementAST ( null , cu ) ; } catch ( JavaModelException jme ) { return jme . getJavaModelStatus ( ) ; } return verifyNameCollision ( ) ; } return JavaModelStatus . VERIFIED_OK ; } protected IJavaModelStatus verifyNameCollision ( ) { } } 
public class AndAnnotationTypePattern extends AnnotationTypePattern { private AnnotationTypePattern left ; private AnnotationTypePattern right ; public AndAnnotationTypePattern ( AnnotationTypePattern left , AnnotationTypePattern right ) { } public FuzzyBoolean matches ( AnnotatedElement annotated ) { } public AnnotationTypePattern resolveBindings ( IScope scope , Bindings bindings , boolean allowBinding ) { } public static AnnotationTypePattern read ( DataInputStream s , ISourceContext context ) throws IOException { } public void write ( DataOutputStream s ) throws IOException { } public boolean equals ( Object obj ) { } public int hashCode ( ) { } public String toString ( ) { <START_BUG> return ( ( ( "(" + ( left . toString ( ) ) ) + "<seq2seq4repair_space>&&<seq2seq4repair_space>" ) + ( right . toString ( ) ) ) + ")" ; <END_BUG> } public AnnotationTypePattern getLeft ( ) { } public AnnotationTypePattern getRight ( ) { } } 
final class EmbedBlob extends ConnectionChild implements Blob , EngineLOB { private boolean materialized ; private PositionedStoreStream myStream ; private int locator = 0 ; private long streamLength = - 1 ; private final int streamPositionOffset ; private boolean isValid = true ; private LOBStreamControl control ; EmbedBlob ( byte [ ] blobBytes , EmbedConnection con ) throws SQLException { } protected EmbedBlob ( DataValueDescriptor dvd , EmbedConnection con ) throws StandardException { } private int handleStreamValue ( InputStream dvdStream , EmbedConnection con ) throws StandardException { } private long setBlobPosition ( long logicalPos ) throws IOException , StandardException { } private int read ( long pos ) throws IOException , StandardException { } public long length ( ) throws SQLException { } public byte [ ] getBytes ( long startPos , int length ) throws SQLException { } public InputStream getBinaryStream ( ) throws SQLException { } public long position ( byte [ ] pattern , long start ) throws SQLException { } private boolean checkMatch ( byte [ ] pattern , long pos ) throws IOException , StandardException { } public long position ( Blob pattern , long start ) throws SQLException { } private boolean checkMatch ( Blob pattern , long pos ) throws IOException , StandardException { } private SQLException handleMyExceptions ( Throwable t ) throws SQLException { } protected void finalize ( ) { } public int setBytes ( long pos , byte [ ] bytes ) throws SQLException { } public int setBytes ( long pos , byte [ ] bytes , int offset , int len ) throws SQLException { checkValidity ( ) ; if ( ( pos - 1 ) > ( length ( ) ) ) throw Util . generateCsSQLException ( BLOB_POSITION_TOO_LARGE , new Long ( pos ) ) ; if ( pos < 1 ) throw Util . generateCsSQLException ( BLOB_BAD_POSITION , new Long ( pos ) ) ; if ( ( offset < 0 ) || ( offset > ( bytes . length ) ) ) { throw Util . generateCsSQLException ( BLOB_INVALID_OFFSET , new Long ( offset ) ) ; } if ( len < 0 ) { throw Util . generateCsSQLException ( BLOB_NONPOSITIVE_LENGTH , new Long ( len ) ) ; } if ( len == 0 ) { return 0 ; } <START_BUG> if ( ( len + offset ) > ( bytes . length ) ) { <END_BUG> throw Util . generateCsSQLException ( BLOB_LENGTH_TOO_LONG , new Long ( len ) ) ; } try { if ( materialized ) { control . write ( bytes , offset , len , ( pos - 1 ) ) ; } else { control = new LOBStreamControl ( getEmbedConnection ( ) ) ; control . copyData ( myStream , length ( ) ) ; control . write ( bytes , offset , len , ( pos - 1 ) ) ; myStream . close ( ) ; streamLength = - 1 ; materialized = true ; } return len ; } catch ( IOException e ) { throw Util . setStreamFailure ( e ) ; } catch ( StandardException se ) { throw Util . generateCsSQLException ( se ) ; } } public OutputStream setBinaryStream ( long pos ) throws SQLException { } public void truncate ( long len ) throws SQLException { } public void free ( ) throws SQLException { } public InputStream getBinaryStream ( long pos , long length ) throws SQLException { } private void checkValidity ( ) throws SQLException { } boolean isMaterialized ( ) { } public int getLocator ( ) { } } 
public class DistributableSingleSignOnManagerFactoryBuilder implements org . wildfly . extension . undertow . security . sso . DistributableSingleSignOnManagerFactoryBuilder { private static SSOManagerFactoryBuilder load ( ) { } private final SSOManagerFactoryBuilder builder ; public DistributableSingleSignOnManagerFactoryBuilder ( ) { } private DistributableSingleSignOnManagerFactoryBuilder ( SSOManagerFactoryBuilder builder ) { } @ Override public ServiceBuilder < SingleSignOnManagerFactory > build ( ServiceTarget target , ServiceName name , final ServiceName hostServiceName ) { <START_BUG> ServiceName managerServiceName = name . append ( "clustering" ) ; <END_BUG> this . builder . build ( target , managerServiceName , hostServiceName . getSimpleName ( ) ) . setInitialMode ( ON_DEMAND ) . install ( ) ; SessionManagerRegistryService . build ( target , hostServiceName ) . setInitialMode ( ON_DEMAND ) . install ( ) ; return DistributableSingleSignOnManagerFactoryService . build ( target , name , hostServiceName , managerServiceName ) ; } } 
public class SimpleSortedSetFacetsExample { private final Directory indexDir = new RAMDirectory ( ) ; private final FacetsConfig config = new FacetsConfig ( ) ; public SimpleSortedSetFacetsExample ( ) { } private void index ( ) throws IOException { IndexWriter indexWriter = new IndexWriter ( indexDir , new org . apache . lucene . index . IndexWriterConfig ( FacetExamples . EXAMPLES_VER , new org . apache . lucene . analysis . core . WhitespaceAnalyzer ( FacetExamples . EXAMPLES_VER ) ) ) ; Document doc = new Document ( ) ; doc . add ( new SortedSetDocValuesFacetField ( "Author" , "Bob" ) ) ; doc . add ( new SortedSetDocValuesFacetField ( "Publish<seq2seq4repair_space>Year" , "2010" ) ) ; indexWriter . addDocument ( config . build ( doc ) ) ; doc = new Document ( ) ; doc . add ( new SortedSetDocValuesFacetField ( "Author" , "Lisa" ) ) ; doc . add ( new SortedSetDocValuesFacetField ( "Publish<seq2seq4repair_space>Year" , "2010" ) ) ; indexWriter . addDocument ( config . build ( doc ) ) ; doc = new Document ( ) ; doc . add ( new SortedSetDocValuesFacetField ( "Author" , "Lisa" ) ) ; doc . add ( new SortedSetDocValuesFacetField ( "Publish<seq2seq4repair_space>Year" , "2012" ) ) ; indexWriter . addDocument ( config . build ( doc ) ) ; doc = new Document ( ) ; doc . add ( new SortedSetDocValuesFacetField ( "Author" , "Susan" ) ) ; doc . add ( new SortedSetDocValuesFacetField ( "Publish<seq2seq4repair_space>Year" , "2012" ) ) ; indexWriter . addDocument ( config . build ( doc ) ) ; doc = new Document ( ) ; doc . add ( new SortedSetDocValuesFacetField ( "Author" , "Frank" ) ) ; doc . add ( new SortedSetDocValuesFacetField ( "Publish<seq2seq4repair_space>Year" , "1999" ) ) ; indexWriter . addDocument ( config . build ( doc ) ) ; <START_BUG> indexWriter . close ( ) ; <END_BUG> } private List < FacetResult > search ( ) throws IOException { } private FacetResult drillDown ( ) throws IOException { } public List < FacetResult > runSearch ( ) throws IOException { } public FacetResult runDrillDown ( ) throws IOException { } public static void main ( String [ ] args ) throws Exception { } } 
public class ResolvedPointcutDefinition extends ResolvedMember { private Pointcut pointcut ; public ResolvedPointcutDefinition ( TypeX declaringType , int modifiers , String name , TypeX [ ] parameterTypes , Pointcut pointcut ) { } public void write ( DataOutputStream s ) throws IOException { } public static ResolvedPointcutDefinition read ( DataInputStream s , ISourceContext context ) throws IOException { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; <START_BUG> buf . append ( "poincut<seq2seq4repair_space>" ) ; <END_BUG> buf . append ( getDeclaringType ( ) . getName ( ) ) ; buf . append ( "." ) ; buf . append ( getName ( ) ) ; buf . append ( "(" ) ; for ( int i = 0 ; i < ( getParameterTypes ( ) . length ) ; i ++ ) { if ( i > 0 ) buf . append ( ",<seq2seq4repair_space>" ) ; buf . append ( getParameterTypes ( ) [ i ] . toString ( ) ) ; } buf . append ( ")" ) ; return buf . toString ( ) ; } public Pointcut getPointcut ( ) { } public boolean isAjSynthetic ( ) { } public static final ResolvedPointcutDefinition DUMMY = new ResolvedPointcutDefinition ( TypeX . OBJECT , 0 , "missing" , TypeX . NONE , Pointcut . makeMatchesNothing ( RESOLVED ) ) ; } 
public class PackageFragment extends Openable implements IPackageFragment , SuffixConstants { protected static final IClassFile [ ] NO_CLASSFILES = new IClassFile [ ] { } ; protected static final ICompilationUnit [ ] NO_COMPILATION_UNITS = new ICompilationUnit [ ] { } ; protected PackageFragment ( PackageFragmentRoot root , String name ) { } protected boolean buildStructure ( OpenableElementInfo info , IProgressMonitor pm , Map newElements , IResource underlyingResource ) throws JavaModelException { } public boolean containsJavaResources ( ) throws JavaModelException { } public void copy ( IJavaElement container , IJavaElement sibling , String rename , boolean force , IProgressMonitor monitor ) throws JavaModelException { } public ICompilationUnit createCompilationUnit ( String cuName , String contents , boolean force , IProgressMonitor monitor ) throws JavaModelException { CreateCompilationUnitOperation op = new CreateCompilationUnitOperation ( this , cuName , contents , force ) ; <START_BUG> runOperation ( op , monitor ) ; <END_BUG> return new CompilationUnit ( this , cuName , DefaultWorkingCopyOwner . PRIMARY ) ; } protected Object createElementInfo ( ) { } public void delete ( boolean force , IProgressMonitor monitor ) throws JavaModelException { } public boolean equals ( Object o ) { } public IClassFile getClassFile ( String classFileName ) { } public IClassFile [ ] getClassFiles ( ) throws JavaModelException { } public ICompilationUnit getCompilationUnit ( String cuName ) { } public ICompilationUnit [ ] getCompilationUnits ( ) throws JavaModelException { } public ICompilationUnit [ ] getCompilationUnits ( WorkingCopyOwner owner ) { } public int getElementType ( ) { } public IJavaElement getHandleFromMemento ( String token , StringTokenizer memento , WorkingCopyOwner owner ) { } protected char getHandleMementoDelimiter ( ) { } public int getKind ( ) throws JavaModelException { } public Object [ ] getNonJavaResources ( ) throws JavaModelException { } public IPath getPath ( ) { } public IResource getResource ( ) { } public IResource getUnderlyingResource ( ) throws JavaModelException { } public boolean hasSubpackages ( ) throws JavaModelException { } public boolean isDefaultPackage ( ) { } public void move ( IJavaElement container , IJavaElement sibling , String rename , boolean force , IProgressMonitor monitor ) throws JavaModelException { } public void rename ( String newName , boolean force , IProgressMonitor monitor ) throws JavaModelException { } protected void toStringChildren ( int tab , StringBuffer buffer , Object info ) { } protected void toStringInfo ( int tab , StringBuffer buffer , Object info ) { } } 
class XSDHandler { static final int ATTRIBUTE_TYPE = 1 ; static final int ATTRIBUTEGROUP_TYPE = 2 ; static final int ELEMENT_TYPE = 3 ; static final int GROUP_TYPE = 4 ; static final int IDENTITYCONSTRAINT_TYPE = 5 ; static final int NOTATION_TYPE = 6 ; static final int TYPEDECL_TYPE = 7 ; public static final String REDEF_IDENTIFIER = "_fn3dktizrknc9pi" ; public String EMPTY_STRING ; protected Hashtable fNotationRegistry = new Hashtable ( ) ; private Hashtable fUnparsedAttributeRegistry = new Hashtable ( ) ; private Hashtable fUnparsedAttributeGroupRegistry = new Hashtable ( ) ; private Hashtable fUnparsedElementRegistry = new Hashtable ( ) ; private Hashtable fUnparsedGroupRegistry = new Hashtable ( ) ; private Hashtable fUnparsedIdentityConstraintRegistry = new Hashtable ( ) ; private Hashtable fUnparsedNotationRegistry = new Hashtable ( ) ; private Hashtable fUnparsedTypeRegistry = new Hashtable ( ) ; private Hashtable fXSDocumentInfoRegistry = new Hashtable ( ) ; private Hashtable fDependencyMap = new Hashtable ( ) ; private Vector fTraversed = new Vector ( ) ; private XSDocumentInfo fRoot = null ; private Hashtable fDoc2XSDocumentMap = new Hashtable ( ) ; private Hashtable fRedefine2XSDMap = new Hashtable ( ) ; private Hashtable fRedefinedRestrictedAttributeGroupRegistry = new Hashtable ( ) ; private Hashtable fRedefinedRestrictedGroupRegistry = new Hashtable ( ) ; private XMLErrorReporter fErrorReporter ; private XSAttributeChecker fAttributeChecker ; private SubstitutionGroupHandler fSubGroupHandler ; private XMLEntityResolver fEntityResolver ; private SymbolTable fSymbolTable ; private XSGrammarResolver fGrammarResolver ; XSDAttributeGroupTraverser fAttributeGroupTraverser ; XSDAttributeTraverser fAttributeTraverser ; XSDComplexTypeTraverser fComplexTypeTraverser ; XSDElementTraverser fElementTraverser ; XSDGroupTraverser fGroupTraverser ; XSDKeyrefTraverser fKeyrefTraverser ; XSDNotationTraverser fNotationTraverser ; XSDSimpleTypeTraverser fSimpleTypeTraverser ; XSDUniqueOrKeyTraverser fUniqueOrKeyTraverser ; XSDWildcardTraverser fWildCardTraverser ; DOMParser fSchemaParser ; private static final int INIT_STACK_SIZE = 30 ; private static final int INC_STACK_SIZE = 10 ; private int fLocalElemStackPos ; private XSParticleDecl [ ] fParticle ; private Element [ ] fLocalElementDecl ; private int [ ] fAllContext ; private String [ ] [ ] fLocalElemNamespaceContext ; XSDHandler ( XSGrammarResolver gResolver ) { } SchemaGrammar parseSchema ( String schemaNamespace , String schemaHint ) { } protected XSDocumentInfo constructTrees ( Document schemaRoot ) { if ( schemaRoot == null ) return null ; XSDocumentInfo currSchemaInfo = new XSDocumentInfo ( schemaRoot , fAttributeChecker , fSymbolTable ) ; SchemaGrammar sg = null ; if ( ( sg = fGrammarResolver . getGrammar ( currSchemaInfo . fTargetNamespace ) ) == null ) { sg = new SchemaGrammar ( fSymbolTable , currSchemaInfo . fTargetNamespace ) ; fGrammarResolver . putGrammar ( sg ) ; } Vector dependencies = new Vector ( ) ; <START_BUG> dependencies . add ( currSchemaInfo ) ; <END_BUG> Element rootNode = DOMUtil . getRoot ( schemaRoot ) ; String schemaNamespace = EMPTY_STRING ; String schemaHint = EMPTY_STRING ; Document newSchemaRoot = null ; for ( Element child = DOMUtil . getFirstChildElement ( rootNode ) ; child != null ; child = DOMUtil . getNextSiblingElement ( child ) ) { String localName = DOMUtil . getLocalName ( child ) ; if ( localName . equals ( ELT_ANNOTATION ) ) continue ; else if ( localName . equals ( ELT_IMPORT ) ) { Object [ ] includeAttrs = fAttributeChecker . checkAttributes ( child , true , currSchemaInfo ) ; schemaHint = ( ( String ) ( includeAttrs [ XSAttributeChecker . ATTIDX_SCHEMALOCATION ] ) ) ; schemaNamespace = ( ( String ) ( includeAttrs [ XSAttributeChecker . ATTIDX_NAMESPACE ] ) ) ; fAttributeChecker . returnAttrArray ( includeAttrs , currSchemaInfo ) ; newSchemaRoot = getSchema ( schemaNamespace , schemaHint ) ; } else if ( ( localName . equals ( ELT_INCLUDE ) ) || ( localName . equals ( ELT_REDEFINE ) ) ) { Object [ ] includeAttrs = fAttributeChecker . checkAttributes ( child , true , currSchemaInfo ) ; schemaHint = ( ( String ) ( includeAttrs [ XSAttributeChecker . ATTIDX_SCHEMALOCATION ] ) ) ; fAttributeChecker . returnAttrArray ( includeAttrs , currSchemaInfo ) ; newSchemaRoot = getSchema ( EMPTY_STRING , schemaHint ) ; } else { break ; } XSDocumentInfo newSchemaInfo = constructTrees ( newSchemaRoot ) ; if ( localName . equals ( ELT_REDEFINE ) ) { fRedefine2XSDMap . put ( child , newSchemaInfo ) ; } dependencies . addElement ( newSchemaInfo ) ; fDoc2XSDocumentMap . put ( newSchemaRoot , newSchemaInfo ) ; newSchemaRoot = null ; } fDependencyMap . put ( currSchemaInfo , dependencies ) ; return currSchemaInfo ; } protected void buildGlobalNameRegistries ( ) { } protected void traverseSchemas ( ) { } protected Object getGlobalDecl ( XSDocumentInfo currSchema , int declType , QName declToTraverse ) { } protected void resolveKeyRefs ( ) { } private Document getSchema ( String schemaNamespace , String schemaHint ) { } private void createTraversers ( ) { } protected void reset ( XMLErrorReporter errorReporter , XMLEntityResolver entityResolver , SymbolTable symbolTable ) { } void traverseLocalElements ( ) { } void fillInLocalElemInfo ( Element elmDecl , XSDocumentInfo schemaDoc , int allContextFlags , XSParticleDecl particle ) { } private void checkForDuplicateNames ( String qName , Hashtable registry , Element currComp , XSDocumentInfo currSchema ) { } protected String resolvePrefixToURI ( String prefix ) { } private void renameRedefiningComponents ( XSDocumentInfo currSchema , Element child , String componentType , String oldName , String newName ) { } private String findQName ( String name , SchemaNamespaceSupport currNSMap ) { } private int changeRedefineGroup ( String originalQName , String elementSought , String newName , Element curr , SchemaNamespaceSupport currNSMap ) { } private XSDocumentInfo findXSDocumentForDecl ( XSDocumentInfo currSchema , Element decl ) { } private void setSchemasVisible ( XSDocumentInfo startSchema ) { } public static void main ( String [ ] args ) throws Exception { } public static class DummyResolver implements EntityResolver { public InputSource resolveEntity ( String pubId , String sysId ) throws IOException , SAXException { } } } 
public class Util { static ThreadLocal < ClassLoader > storedClassLoaders = new ThreadLocal < ClassLoader > ( ) ; public static void storeContextClassloader ( ) { } public static void restoreContextClassloader ( ) { } public static void fixContextClassloader ( String cls , String method , Class < ? > clsArg , ClassLoader bundleLoader ) { } private static ClassLoader findContextClassloader ( Bundle consumerBundle , String className , String methodName , Class < ? > clsArg ) { Activator activator = Activator . activator ; String requestedClass ; if ( ( ServiceLoader . class . getName ( ) . equals ( className ) ) && ( "load" . equals ( methodName ) ) ) { requestedClass = clsArg . getName ( ) ; } else { requestedClass = className ; } Collection < Bundle > bundles = new ArrayList < Bundle > ( activator . findProviderBundles ( requestedClass ) ) ; activator . log ( LogService . LOG_DEBUG , ( ( ( "Found<seq2seq4repair_space>bundles<seq2seq4repair_space>providing<seq2seq4repair_space>" + requestedClass ) + ":<seq2seq4repair_space>" ) + bundles ) ) ; Map < Pair < Integer , String > , String > args = new HashMap < Pair < Integer , String > , String > ( ) ; <START_BUG> args . put ( new Pair < Integer , String > ( 1 , Class . class . getName ( ) ) , clsArg . getName ( ) ) ; <END_BUG> Collection < Bundle > allowedBundles = activator . findConsumerRestrictions ( consumerBundle , className , methodName , args ) ; if ( allowedBundles != null ) { for ( Iterator < Bundle > it = bundles . iterator ( ) ; it . hasNext ( ) ; ) { if ( ! ( allowedBundles . contains ( it . next ( ) ) ) ) { it . remove ( ) ; } } } switch ( bundles . size ( ) ) { case 0 : return null ; case 1 : Bundle bundle = bundles . iterator ( ) . next ( ) ; BundleWiring wiring = bundle . adapt ( BundleWiring . class ) ; return wiring . getClassLoader ( ) ; default : List < ClassLoader > loaders = new ArrayList < ClassLoader > ( ) ; for ( Bundle b : bundles ) { BundleWiring bw = b . adapt ( BundleWiring . class ) ; loaders . add ( bw . getClassLoader ( ) ) ; } return new MultiDelegationClassloader ( loaders . toArray ( new ClassLoader [ loaders . size ( ) ] ) ) ; } } } 
public class CopyCommand extends FigureTransferCommand { public CopyCommand ( String name , DrawingView view ) { } public void execute ( ) { } public boolean isExecutable ( ) { <START_BUG> return ( fView . selectionCount ( ) ) > 0 ; <END_BUG> } } 
public class FastViewManager { private Perspective perspective ; private WorkbenchPage page ; private WorkbenchWindow wbw ; private TrimLayout tbm ; private Map idToFastViewsMap = new HashMap ( ) ; private boolean deferringUpdates = false ; private AnimationEngine batchAnimation = null ; private AnimationEngine oneShotAnimation = null ; private IPerspectiveListener2 perspListener = new IPerspectiveListener2 ( ) { public void perspectiveActivated ( IWorkbenchPage page , IPerspectiveDescriptor perspective ) { } public void perspectiveChanged ( IWorkbenchPage changedPage , IPerspectiveDescriptor perspective , IWorkbenchPartReference partRef , String changeId ) { } public void perspectiveChanged ( IWorkbenchPage changedPage , IPerspectiveDescriptor perspective , String changeId ) { } } ; public FastViewManager ( Perspective perspective , WorkbenchPage page ) { } protected void handlePerspectiveActivation ( IWorkbenchPage activatingPage , IPerspectiveDescriptor activatingPerspective ) { } protected void handlePerspectiveChange ( IWorkbenchPage changedPage , IPerspectiveDescriptor changedPerspective , IWorkbenchPartReference partRef , String changeId ) { if ( ( changedPage != ( page ) ) && ( ( perspective . getDesc ( ) ) != changedPerspective ) ) return ; if ( changeId . equals ( CHANGE_VIEW_HIDE ) ) { <START_BUG> if ( partRef instanceof IViewReference ) { <END_BUG> ViewReference ref = ( ( ViewReference ) ( partRef ) ) ; if ( ( ref . getPane ( ) . getContainer ( ) ) instanceof ViewStack ) { int viewCount = 0 ; LayoutPart [ ] children = ref . getPane ( ) . getContainer ( ) . getChildren ( ) ; for ( int i = 0 ; i < ( children . length ) ; i ++ ) { if ( ( ( children [ i ] ) instanceof ViewPane ) && ( ( children [ i ] ) != ( ref . getPane ( ) ) ) ) viewCount ++ ; } if ( viewCount == 0 ) ref . getPane ( ) . getStack ( ) . setState ( STATE_RESTORED ) ; } } } if ( changeId . equals ( CHANGE_FAST_VIEW_REMOVE ) ) { removeViewReference ( ( ( IViewReference ) ( partRef ) ) , false , true ) ; } } protected void handlePerspectiveChange ( IWorkbenchPage changedPage , IPerspectiveDescriptor changedPerspective , String changeId ) { } public List getFastViews ( String forId ) { } public void addViewReference ( String id , int index , IViewReference ref , boolean update ) { } private ViewStackTrimToolBar getTrimForViewStack ( String id , int suggestedSide , int paneOrientation ) { } public void updateTrim ( String id ) { } public void removeViewReference ( IViewReference ref , boolean makeUnfast , boolean update ) { } private void makeFast ( IViewReference ref , boolean makeFast , boolean activate ) { } boolean isFastView ( IViewReference ref ) { } public String getIdForRef ( IViewReference ref ) { } public int getViewSide ( IViewReference ref ) { } private IWindowTrim getTrimForRef ( IViewReference ref ) { } private List getTrueViewOrder ( ViewStack stack ) { } public void moveToTrim ( ViewStack vs , boolean restoreOnUnzoom ) { } public void restoreToPresentation ( String id ) { } public void restoreZoomedViewStacks ( ) { } public void setFastViewIconSelection ( IViewReference ref , boolean selected ) { } public void activate ( ) { } public void deActivate ( ) { } public boolean restoreAllTrimStacks ( ) { } private void setTrimStackVisibility ( boolean visible ) { } public void saveState ( IMemento memento ) { } public void restoreState ( IMemento memento , MultiStatus result ) { } public ViewStackTrimToolBar getViewStackTrimToolbar ( String id ) { } public void printFVModel ( ) { } public void deferUpdates ( boolean defer ) { } private void deferAnimations ( boolean defer ) { } private AnimationEngine getDeferrableAnimation ( ) { } private void scheduleDeferrableAnimation ( ) { } public ViewStackTrimToolBar getBottomRightTrimStack ( ) { } } 
public abstract class AttributeDefinition { private final String name ; private final String xmlName ; private final ModelType type ; private final boolean allowNull ; private final boolean allowExpression ; private final ModelNode defaultValue ; private final MeasurementUnit measurementUnit ; private final String [ ] alternatives ; private final String [ ] requires ; private final ParameterCorrector valueCorrector ; private final ParameterValidator validator ; private final EnumSet < AttributeAccess . Flag > flags ; protected final AttributeMarshaller attributeMarshaller ; private final boolean resourceOnly ; private final DeprecationData deprecationData ; protected AttributeDefinition ( String name , String xmlName , final ModelNode defaultValue , final ModelType type , final boolean allowNull , final boolean allowExpression , final MeasurementUnit measurementUnit , final ParameterValidator validator , final String [ ] alternatives , final String [ ] requires , final AttributeAccess ... flags ) { } protected AttributeDefinition ( String name , String xmlName , final ModelNode defaultValue , final ModelType type , final boolean allowNull , final boolean allowExpression , final MeasurementUnit measurementUnit , final ParameterCorrector valueCorrector , final ParameterValidator validator , boolean validateNull , final String [ ] alternatives , final String [ ] requires , AttributeMarshaller attributeMarshaller , boolean resourceOnly , DeprecationData deprecationData , final AttributeAccess ... flags ) { } public String getName ( ) { } public String getXmlName ( ) { } public ModelType getType ( ) { } public boolean isAllowNull ( ) { } public boolean isAllowExpression ( ) { } public ModelNode getDefaultValue ( ) { } public MeasurementUnit getMeasurementUnit ( ) { } public ParameterValidator getValidator ( ) { } public String [ ] getAlternatives ( ) { } public String [ ] getRequires ( ) { } public EnumSet < AttributeAccess . Flag > getFlags ( ) { } public boolean isMarshallable ( final ModelNode resourceModel ) { } public boolean isMarshallable ( final ModelNode resourceModel , final boolean marshallDefault ) { } public ModelNode validateOperation ( final ModelNode operationObject ) throws OperationFailedException { } public final void validateAndSet ( ModelNode operationObject , final ModelNode model ) throws OperationFailedException { <START_BUG> if ( isDeprecated ( ) ) { <END_BUG> DEPRECATED_LOGGER . attributeDeprecated ( getName ( ) ) ; } final ModelNode newValue = correctValue ( operationObject . get ( name ) , model . get ( name ) ) ; if ( ! ( newValue . equals ( operationObject . get ( name ) ) ) ) { operationObject . get ( name ) . set ( newValue ) ; } ModelNode node = validateOperation ( operationObject , false ) ; model . get ( name ) . set ( node ) ; } @ Deprecated public ModelNode validateResolvedOperation ( final ModelNode operationObject ) throws OperationFailedException { } public ModelNode resolveModelAttribute ( final OperationContext context , final ModelNode model ) throws OperationFailedException { } public ModelNode resolveModelAttribute ( final ExpressionResolver resolver , final ModelNode model ) throws OperationFailedException { } public boolean isAllowed ( final ModelNode operationObject ) { } public boolean isRequired ( final ModelNode operationObject ) { } public boolean hasAlternative ( final ModelNode operationObject ) { } public void marshallAsElement ( final ModelNode resourceModel , final XMLStreamWriter writer ) throws XMLStreamException { } public void marshallAsElement ( final ModelNode resourceModel , final boolean marshallDefault , final XMLStreamWriter writer ) throws XMLStreamException { } public ModelNode addResourceAttributeDescription ( final ResourceBundle bundle , final String prefix , final ModelNode resourceDescription ) { } public ModelNode addResourceAttributeDescription ( final ModelNode resourceDescription , final ResourceDescriptionResolver resolver , final Locale locale , final ResourceBundle bundle ) { } public ModelNode addOperationParameterDescription ( final ResourceBundle bundle , final String prefix , final ModelNode operationDescription ) { } public ModelNode addOperationParameterDescription ( final ModelNode resourceDescription , final String operationName , final ResourceDescriptionResolver resolver , final Locale locale , final ResourceBundle bundle ) { } public String getAttributeTextDescription ( final ResourceBundle bundle , final String prefix ) { } public String getAttributeDeprecatedDescription ( final ResourceBundle bundle , final String prefix ) { } public ModelNode addDeprecatedInfo ( final ModelNode model ) { } public ModelNode getNoTextDescription ( boolean forOperation ) { } protected final ModelNode correctValue ( final ModelNode newValue , final ModelNode oldValue ) { } private ModelNode validateOperation ( final ModelNode operationObject , final boolean correctValue ) throws OperationFailedException { } public AttributeMarshaller getAttributeMarshaller ( ) { } public boolean isResourceOnly ( ) { } public boolean isDeprecated ( ) { } public DeprecationData getDeprecationData ( ) { } private static final ExpressionResolver NO_OPERATION_CONTEXT_FOR_RESOLVING_MODEL_PARAMETERS = new ExpressionResolver ( ) { @ Override public ModelNode resolveExpressions ( ModelNode node ) throws OperationFailedException { } } ; } 
public class TestCJKWidthFilter extends BaseTokenStreamTestCase { private Analyzer analyzer = new Analyzer ( ) { @ Override protected TokenStreamComponents createComponents ( String fieldName , Reader reader ) { } } ; public void testFullWidthASCII ( ) throws IOException { } public void testHalfWidthKana ( ) throws IOException { } public void testRandomData ( ) throws IOException { <START_BUG> checkRandomData ( random ( ) , analyzer , ( 10000 * ( RANDOM_MULTIPLIER ) ) ) ; <END_BUG> } public void testEmptyTerm ( ) throws IOException { } } 
public class PageAndComponentProvider extends DefaultPageProvider { private IRequestableComponent component ; private String componentPath ; public PageAndComponentProvider ( IRequestablePage page , String componentPath ) { } public PageAndComponentProvider ( IRequestablePage page , IRequestableComponent component ) { } public PageAndComponentProvider ( Class < ? extends IRequestablePage > pageClass , PageParameters pageParameters , String componentPath ) { } public PageAndComponentProvider ( Class < ? extends IRequestablePage > pageClass , String componentPath ) { } public PageAndComponentProvider ( int pageId , Class < ? extends IRequestablePage > pageClass , Integer renderCount , String componentPath ) { } public PageAndComponentProvider ( int pageId , Class < ? extends IRequestablePage > pageClass , PageParameters pageParameters , Integer renderCount , String componentPath ) { } public PageAndComponentProvider ( int pageId , Integer renderCount , String componentPath ) { } @ Override protected boolean prepareForRenderNewPage ( ) { } public IRequestableComponent getComponent ( ) { } public String getComponentPath ( ) { if ( ( componentPath ) != null ) { return componentPath ; } else { <START_BUG> return component . getPath ( ) ; <END_BUG> } } private void setComponentPath ( String componentPath ) { } } 
public class DateTimeDV extends AbstractDateTimeDV { public Object getActualValue ( String content , ValidationContext context ) throws InvalidDatatypeValueException { try { return parse ( content , null ) ; } catch ( Exception ex ) { <START_BUG> throw new InvalidDatatypeValueException ( "not<seq2seq4repair_space>a<seq2seq4repair_space>valid<seq2seq4repair_space>dataTime" ) ; <END_BUG> } } protected int [ ] parse ( String str , int [ ] date ) throws SchemaDateTimeException { } } 
class ConsoleHandlerAdd extends FlushingHandlerAddProperties < ConsoleHandlerService > { static final ConsoleHandlerAdd INSTANCE = new ConsoleHandlerAdd ( ) ; private ConsoleHandlerAdd ( ) { } @ Override protected ConsoleHandlerService createHandlerService ( OperationContext context , final ModelNode model ) throws OperationFailedException { } @ Override protected void updateRuntime ( final OperationContext context , final ServiceBuilder < Handler > serviceBuilder , final String name , final ConsoleHandlerService service , final ModelNode model ) throws OperationFailedException { super . updateRuntime ( context , serviceBuilder , name , service , model ) ; final ModelNode target = CommonAttributes . TARGET . resolveModelAttribute ( context , model ) ; if ( target . isDefined ( ) ) { <START_BUG> service . setTarget ( Target . fromString ( target . asString ( ) ) ) ; <END_BUG> } } } 
public class CharSetUtilsTest { @ Test public void testConstructor ( ) { assertNotNull ( new CharSetUtils ( ) ) ; <START_BUG> Constructor < ? > [ ] cons = CharSetUtils . class . getDeclaredConstructors ( ) ; <END_BUG> assertEquals ( 1 , cons . length ) ; assertTrue ( Modifier . isPublic ( cons [ 0 ] . getModifiers ( ) ) ) ; assertTrue ( Modifier . isPublic ( CharSetUtils . class . getModifiers ( ) ) ) ; assertFalse ( Modifier . isFinal ( CharSetUtils . class . getModifiers ( ) ) ) ; } @ Test public void testSqueeze_StringString ( ) { } @ Test public void testSqueeze_StringStringarray ( ) { } @ Test public void testCount_StringString ( ) { } @ Test public void testCount_StringStringarray ( ) { } @ Test public void testKeep_StringString ( ) { } @ Test public void testKeep_StringStringarray ( ) { } @ Test public void testDelete_StringString ( ) { } @ Test public void testDelete_StringStringarray ( ) { } } 
public class ContainsSelector extends BaseExtendSelector implements ResourceSelector { private String contains = null ; private boolean casesensitive = true ; private boolean ignorewhitespace = false ; public static final String EXPRESSION_KEY = "expression" ; public static final String CONTAINS_KEY = "text" ; public static final String CASE_KEY = "casesensitive" ; public static final String WHITESPACE_KEY = "ignorewhitespace" ; public ContainsSelector ( ) { } public String toString ( ) { } public void setText ( String contains ) { } public void setCasesensitive ( boolean casesensitive ) { } public void setIgnorewhitespace ( boolean ignorewhitespace ) { } public void setParameters ( Parameter [ ] parameters ) { } public void verifySettings ( ) { } public boolean isSelected ( File basedir , String filename , File file ) { } public boolean isSelected ( Resource r ) { validate ( ) ; <START_BUG> if ( r . isDirectory ( ) ) { <END_BUG> return true ; } String userstr = contains ; if ( ! ( casesensitive ) ) { userstr = contains . toLowerCase ( ) ; } if ( ignorewhitespace ) { userstr = SelectorUtils . removeWhitespace ( userstr ) ; } BufferedReader in = null ; try { in = new BufferedReader ( new InputStreamReader ( r . getInputStream ( ) ) ) ; } catch ( Exception e ) { throw new org . apache . tools . ant . BuildException ( ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>get<seq2seq4repair_space>InputStream<seq2seq4repair_space>from<seq2seq4repair_space>" + ( r . toLongString ( ) ) ) , e ) ; } try { String teststr = in . readLine ( ) ; while ( teststr != null ) { if ( ! ( casesensitive ) ) { teststr = teststr . toLowerCase ( ) ; } if ( ignorewhitespace ) { teststr = SelectorUtils . removeWhitespace ( teststr ) ; } if ( ( teststr . indexOf ( userstr ) ) > ( - 1 ) ) { return true ; } teststr = in . readLine ( ) ; } return false ; } catch ( IOException ioe ) { throw new org . apache . tools . ant . BuildException ( ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>read<seq2seq4repair_space>" + ( r . toLongString ( ) ) ) ) ; } finally { FileUtils . close ( in ) ; } } } 
public class ParameterizedTypeBinding extends ReferenceBinding implements Substitution { public ReferenceBinding type ; public TypeBinding [ ] arguments ; public LookupEnvironment environment ; public char [ ] genericTypeSignature ; public ReferenceBinding superclass ; public ReferenceBinding [ ] superInterfaces ; public FieldBinding [ ] fields ; public ReferenceBinding [ ] memberTypes ; public MethodBinding [ ] methods ; public ReferenceBinding enclosingType ; public ParameterizedTypeBinding ( ReferenceBinding type , TypeBinding [ ] arguments , ReferenceBinding enclosingType , LookupEnvironment environment ) { } public void collectSubstitutes ( TypeBinding otherType , Map substitutes ) { } public void computeId ( ) { } public char [ ] constantPoolName ( ) { } public String debugName ( ) { } public ReferenceBinding enclosingType ( ) { } public TypeBinding erasure ( ) { } public int fieldCount ( ) { } public FieldBinding [ ] fields ( ) { } public char [ ] genericTypeSignature ( ) { } public MethodBinding getExactConstructor ( TypeBinding [ ] argumentTypes ) { } public MethodBinding getExactMethod ( char [ ] selector , TypeBinding [ ] argumentTypes ) { } public FieldBinding getField ( char [ ] fieldName , boolean needResolve ) { } public ReferenceBinding getMemberType ( char [ ] typeName ) { } public MethodBinding [ ] getMethods ( char [ ] selector ) { } public boolean implementsMethod ( MethodBinding method ) { } void initialize ( ReferenceBinding someType , TypeBinding [ ] someArguments ) { this . type = someType ; this . sourceName = someType . sourceName ; this . compoundName = someType . compoundName ; this . fPackage = someType . fPackage ; this . fileName = someType . fileName ; this . modifiers = ( ( someType . modifiers ) | ( AccGenericSignature ) ) | ( AccUnresolved ) ; if ( someArguments != null ) { this . arguments = someArguments ; for ( int i = 0 , length = someArguments . length ; i < length ; i ++ ) { TypeBinding someArgument = someArguments [ i ] ; <START_BUG> if ( ( ! ( someArgument . isWildcard ( ) ) ) || ( ! ( ( ( WildcardBinding ) ( someArgument ) ) . isEquivalentToUnboundWildcard ( ) ) ) ) { <END_BUG> this . tagBits |= IsBoundParameterizedType ; } this . tagBits |= ( someArgument . tagBits ) & ( ( HasTypeVariable ) | ( HasWildcard ) ) ; } } this . tagBits |= ( someType . tagBits ) & ( ( ( IsLocalType ) | ( IsMemberType ) ) | ( IsNestedType ) ) ; } protected void initializeArguments ( ) { } public boolean isEquivalentTo ( TypeBinding otherType ) { } public boolean isParameterizedType ( ) { } public ReferenceBinding [ ] memberTypes ( ) { } public MethodBinding [ ] methods ( ) { } public char [ ] qualifiedSourceName ( ) { } public char [ ] readableName ( ) { } ReferenceBinding resolve ( ) { } public char [ ] shortReadableName ( ) { } public char [ ] signature ( ) { } public char [ ] sourceName ( ) { } public TypeBinding substitute ( TypeBinding originalType ) { } public ReferenceBinding superclass ( ) { } public ReferenceBinding [ ] superInterfaces ( ) { } public void swapUnresolved ( UnresolvedReferenceBinding unresolvedType , ReferenceBinding resolvedType , LookupEnvironment env ) { } public ReferenceBinding [ ] syntheticEnclosingInstanceTypes ( ) { } public SyntheticArgumentBinding [ ] syntheticOuterLocalVariables ( ) { } public TypeBinding leafComponentType ( ) { } public char [ ] qualifiedPackageName ( ) { } public String toString ( ) { } } 
public class XMLFormatter extends BaseStreamFormatter { public static final String TESTSUITES = "testsuites" ; public static final String TESTSUITE = "testsuite" ; public static final String TESTCASE = "testcase" ; public static final String ERROR = "error" ; public static final String FAILURE = "failure" ; public static final String SYSTEM_ERR = "system-err" ; public static final String SYSTEM_OUT = "system-out" ; public static final String ATTR_PACKAGE = "package" ; public static final String ATTR_NAME = "name" ; public static final String ATTR_TIME = "time" ; public static final String ATTR_ERRORS = "errors" ; public static final String ATTR_FAILURES = "failures" ; public static final String ATTR_TESTS = "tests" ; public static final String ATTR_TYPE = "type" ; public static final String ATTR_MESSAGE = "message" ; public static final String PROPERTIES = "properties" ; public static final String PROPERTY = "property" ; public static final String ATTR_VALUE = "value" ; private Document doc = XMLFormatter . getDocumentBuilder ( ) . newDocument ( ) ; private Element rootElement = doc . createElement ( XMLFormatter . TESTSUITE ) ; private Hashtable testElements = new Hashtable ( ) ; private Hashtable testStarts = new Hashtable ( ) ; public void onTestStarted ( TestRunEvent evt ) { } public void onTestEnded ( TestRunEvent evt ) { } public void onTestFailure ( TestRunEvent evt ) { <START_BUG> String type = ( ( evt == ( evt . getType ( ) ) ) == ( TestRunEvent . TEST_FAILURE ) ) ? XMLFormatter . FAILURE : XMLFormatter . ERROR ; <END_BUG> Element nested = doc . createElement ( type ) ; Element currentTest = ( ( Element ) ( testElements . get ( evt . getName ( ) ) ) ) ; currentTest . appendChild ( nested ) ; String [ ] args = XMLFormatter . parseFirstLine ( evt . getStackTrace ( ) ) ; if ( ( ( args [ 1 ] ) != null ) && ( ( args [ 1 ] . length ( ) ) > 0 ) ) { nested . setAttribute ( XMLFormatter . ATTR_MESSAGE , args [ 1 ] ) ; } nested . setAttribute ( XMLFormatter . ATTR_TYPE , args [ 0 ] ) ; Text text = doc . createTextNode ( evt . getStackTrace ( ) ) ; nested . appendChild ( text ) ; super . onTestFailure ( evt ) ; removeEvent ( evt ) ; } protected void removeEvent ( TestRunEvent evt ) { } public void onRunStarted ( TestRunEvent evt ) { } public void onRunEnded ( TestRunEvent evt ) { } public void onRunStopped ( TestRunEvent evt ) { } protected void close ( ) { } private static DocumentBuilder getDocumentBuilder ( ) { } protected static String [ ] parseFirstLine ( String trace ) { } } 
public abstract class PortletApplication extends Application implements ISessionFactory { private String applicationKey ; private IRequestCycleProcessor requestCycleProcessor ; private IRequestCycleProcessor actionRequestCycleProcessor ; private String sessionAttributePrefix ; private ISessionFactory sessionFactory = this ; private RequestLogger requestLogger ; WicketPortlet portlet ; public void setWicketPortlet ( WicketPortlet portlet ) { } public WicketPortletSession getSession ( final WicketPortletRequest request ) { ISessionStore sessionStore = getSessionStore ( ) ; Session session = sessionStore . lookup ( request ) ; if ( session == null ) { <START_BUG> session = getSessionFactory ( ) . newSession ( request ) ; <END_BUG> session . setLocale ( request . getLocale ( ) ) ; sessionStore . bind ( request , session ) ; } WicketPortletSession webSession ; if ( session instanceof WicketPortletSession ) { webSession = ( ( WicketPortletSession ) ( session ) ) ; } else { throw new WicketRuntimeException ( ( "Session<seq2seq4repair_space>created<seq2seq4repair_space>by<seq2seq4repair_space>a<seq2seq4repair_space>PortletApplication<seq2seq4repair_space>session<seq2seq4repair_space>factory<seq2seq4repair_space>" + "must<seq2seq4repair_space>be<seq2seq4repair_space>a<seq2seq4repair_space>subclass<seq2seq4repair_space>of<seq2seq4repair_space>PortletSession" ) ) ; } session . setApplication ( this ) ; webSession . initForRequest ( ) ; return webSession ; } public WicketPortletResponse newPortletResponse ( final PortletResponse res ) { } public WicketPortletRequest newPortletRequest ( PortletRequest req ) { } public String getApplicationKey ( ) { } protected ISessionFactory getSessionFactory ( ) { } protected ISessionStore newSessionStore ( ) { } public Session newSession ( ) { } public void initPortlet ( ) { } protected void internalInit ( ) { } public void destroyPortlet ( ) { } protected IRequestCycleFactory getDefaultRequestCycleFactory ( ) { } protected IRequestCycleProcessor newRenderRequestCycleProcessor ( ) { } protected IRequestCycleProcessor newActionRequestCycleProcessor ( ) { } public IRequestCycleProcessor getActionRequestCycleProcessor ( ) { } protected final IRequestCycleProcessor getRenderRequestCycleProcessor ( ) { } public final RequestLogger getRequestLogger ( ) { } public final void setRequestLogger ( RequestLogger logger ) { } void sessionDestroyed ( String sessionId ) { } public final String getSessionAttributePrefix ( final WicketPortletRequest request ) { } } 
public class ModeOptionPane extends AbstractOptionPane { public ModeOptionPane ( ) { } protected void _init ( ) { Mode [ ] modes = jEdit . getModes ( ) ; String [ ] modeNames = new String [ modes . length ] ; modeProps = new ModeOptionPane . ModeProperties [ modes . length ] ; for ( int i = 0 ; i < ( modes . length ) ; i ++ ) { modeProps [ i ] = new ModeOptionPane . ModeProperties ( modes [ i ] ) ; modeNames [ i ] = modes [ i ] . getName ( ) ; } mode = new JComboBox ( modeNames ) ; mode . addActionListener ( new ModeOptionPane . ActionHandler ( ) ) ; addComponent ( jEdit . getProperty ( "options.mode.mode" ) , mode ) ; useDefaults = new JCheckBox ( jEdit . getProperty ( "options.mode.useDefaults" ) ) ; useDefaults . addActionListener ( new ModeOptionPane . ActionHandler ( ) ) ; addComponent ( useDefaults ) ; addComponent ( jEdit . getProperty ( "options.mode.filenameGlob" ) , ( filenameGlob = new JTextField ( ) ) ) ; addComponent ( jEdit . getProperty ( "options.mode.firstlineGlob" ) , ( firstlineGlob = new JTextField ( ) ) ) ; String [ ] tabSizes = new String [ ] { "2" , "4" , "8" } ; addComponent ( jEdit . getProperty ( "options.editing.tabSize" ) , ( tabSize = new JComboBox ( tabSizes ) ) ) ; tabSize . setEditable ( true ) ; addComponent ( jEdit . getProperty ( "options.editing.indentSize" ) , ( indentSize = new JComboBox ( tabSizes ) ) ) ; indentSize . setEditable ( true ) ; String [ ] lineLens = new String [ ] { "0" , "72" , "76" , "80" } ; addComponent ( jEdit . getProperty ( "options.editing.maxLineLen" ) , ( maxLineLen = new JComboBox ( lineLens ) ) ) ; maxLineLen . setEditable ( true ) ; addComponent ( jEdit . getProperty ( "options.editing.wordBreakChars" ) , ( wordBreakChars = new JTextField ( ) ) ) ; <START_BUG> addComponent ( jEdit . getProperty ( "options.mode.noWordSep" ) , ( noWordSep = new JTextField ( ) ) ) ; <END_BUG> String [ ] foldModes = new String [ ] { "none" , "indent" , "explicit" } ; addComponent ( jEdit . getProperty ( "options.editing.folding" ) , ( folding = new JComboBox ( foldModes ) ) ) ; addComponent ( jEdit . getProperty ( "options.editing.collapseFolds" ) , ( collapseFolds = new JTextField ( ) ) ) ; addComponent ( ( indentOnTab = new JCheckBox ( jEdit . getProperty ( "options.editing.indentOnTab" ) ) ) ) ; addComponent ( ( indentOnEnter = new JCheckBox ( jEdit . getProperty ( "options.editing.indentOnEnter" ) ) ) ) ; addComponent ( ( noTabs = new JCheckBox ( jEdit . getProperty ( "options.editing.noTabs" ) ) ) ) ; selectMode ( ) ; } protected void _save ( ) { } private ModeOptionPane . ModeProperties [ ] modeProps ; private ModeOptionPane . ModeProperties current ; private JComboBox mode ; private JCheckBox useDefaults ; private JTextField filenameGlob ; private JTextField firstlineGlob ; private JComboBox tabSize ; private JComboBox indentSize ; private JComboBox maxLineLen ; private JTextField wordBreakChars ; private JTextField noWordSep ; private JComboBox folding ; private JTextField collapseFolds ; private JCheckBox noTabs ; private JCheckBox indentOnTab ; private JCheckBox indentOnEnter ; private void saveMode ( ) { } private void selectMode ( ) { } private void updateEnabled ( ) { } class ActionHandler implements ActionListener { public void actionPerformed ( ActionEvent evt ) { } } class ModeProperties { Mode mode ; boolean edited ; boolean loaded ; boolean useDefaults ; String filenameGlob ; String firstlineGlob ; String tabSize ; String indentSize ; String maxLineLen ; String wordBreakChars ; String noWordSep ; String folding ; String collapseFolds ; boolean noTabs ; boolean indentOnTab ; boolean indentOnEnter ; ModeProperties ( Mode mode ) { } void load ( ) { } void save ( ) { } } } 
public class MethodAnnotationAggregator { private static final Logger logger = Logger . getLogger ( MethodAnnotationAggregator . class ) ; public static < A extends Annotation , T > RuntimeAnnotationInformation < T > runtimeAnnotationInformation ( final Class < ? > componentClass , final EEApplicationClasses applicationClasses , final DeploymentReflectionIndex index , final Class < A > annotationType ) { final HashSet < MethodIdentifier > methodIdentifiers = new HashSet < MethodIdentifier > ( ) ; final Map < Method , List < T > > methods = new HashMap < Method , List < T > > ( ) ; final Map < String , List < T > > classAnnotations = new HashMap < String , List < T > > ( ) ; Class < ? > c = componentClass ; while ( ( c != null ) && ( c != ( Object . class ) ) ) { final ClassReflectionIndex < ? > classIndex = index . getClassIndex ( c ) ; final EEModuleClassDescription description = applicationClasses . getClassByName ( c . getName ( ) ) ; if ( description != null ) { ClassAnnotationInformation < A , T > annotationData = description . getAnnotationInformation ( annotationType ) ; if ( annotationData != null ) { if ( ! ( annotationData . getClassLevelAnnotations ( ) . isEmpty ( ) ) ) { classAnnotations . put ( c . getName ( ) , annotationData . getClassLevelAnnotations ( ) ) ; } for ( Map . Entry < MethodIdentifier , List < T > > entry : annotationData . getMethodLevelAnnotations ( ) . entrySet ( ) ) { final Method method = classIndex . getMethod ( entry . getKey ( ) ) ; if ( method != null ) { if ( ( Modifier . isPrivate ( method . getModifiers ( ) ) ) || ( ! ( methodIdentifiers . contains ( entry . getKey ( ) ) ) ) ) { methods . put ( method , entry . getValue ( ) ) ; } } else { <START_BUG> MethodAnnotationAggregator . logger . error ( ( ( ( ( ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>resolve<seq2seq4repair_space>method<seq2seq4repair_space>" + ( entry . getKey ( ) ) ) + "<seq2seq4repair_space>on<seq2seq4repair_space>class<seq2seq4repair_space>" ) + c ) + "<seq2seq4repair_space>with<seq2seq4repair_space>annotations<seq2seq4repair_space>" ) + ( entry . getValue ( ) ) ) ) ; <END_BUG> } } } } for ( Method method : classIndex . getMethods ( ) ) { if ( ! ( Modifier . isPrivate ( method . getModifiers ( ) ) ) ) { methodIdentifiers . add ( MethodIdentifier . getIdentifierForMethod ( method ) ) ; } } c = c . getSuperclass ( ) ; } return new RuntimeAnnotationInformation < T > ( classAnnotations , methods ) ; } public static < A extends Annotation , T > Set < Method > runtimeAnnotationPresent ( final Class < ? > componentClass , final EEApplicationClasses applicationClasses , final DeploymentReflectionIndex index , final Class < A > annotationType ) { } } 
public class StormSubmitter { public static Logger LOG = LoggerFactory . getLogger ( StormSubmitter . class ) ; private static Iface localNimbus = null ; public static void setLocalNimbus ( Nimbus . Iface localNimbusHandler ) { } public static void submitTopology ( String name , Map stormConf , StormTopology topology ) throws AlreadyAliveException , InvalidTopologyException { } public static void submitTopology ( String name , Map stormConf , StormTopology topology , SubmitOptions opts ) throws AlreadyAliveException , InvalidTopologyException { if ( ! ( Utils . isValidConf ( stormConf ) ) ) { throw new IllegalArgumentException ( "Storm<seq2seq4repair_space>conf<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>valid.<seq2seq4repair_space>Must<seq2seq4repair_space>be<seq2seq4repair_space>json-serializable" ) ; } stormConf = new HashMap ( stormConf ) ; stormConf . putAll ( Utils . readCommandLineOpts ( ) ) ; Map conf = Utils . readStormConfig ( ) ; conf . putAll ( stormConf ) ; try { String serConf = JSONValue . toJSONString ( stormConf ) ; if ( ( StormSubmitter . localNimbus ) != null ) { StormSubmitter . LOG . info ( ( ( "Submitting<seq2seq4repair_space>topology<seq2seq4repair_space>" + name ) + "<seq2seq4repair_space>in<seq2seq4repair_space>local<seq2seq4repair_space>mode" ) ) ; StormSubmitter . localNimbus . submitTopology ( name , null , serConf , topology ) ; } else { NimbusClient client = NimbusClient . getConfiguredClient ( conf ) ; if ( StormSubmitter . topologyNameExists ( conf , name ) ) { throw new RuntimeException ( ( ( "Topology<seq2seq4repair_space>with<seq2seq4repair_space>name<seq2seq4repair_space>`" + name ) + "`<seq2seq4repair_space>already<seq2seq4repair_space>exists<seq2seq4repair_space>on<seq2seq4repair_space>cluster" ) ) ; } StormSubmitter . submitJar ( conf ) ; try { StormSubmitter . LOG . info ( ( ( ( "Submitting<seq2seq4repair_space>topology<seq2seq4repair_space>" + name ) + "<seq2seq4repair_space>in<seq2seq4repair_space>distributed<seq2seq4repair_space>mode<seq2seq4repair_space>with<seq2seq4repair_space>conf<seq2seq4repair_space>" ) + serConf ) ) ; if ( opts != null ) { client . getClient ( ) . submitTopologyWithOpts ( name , StormSubmitter . submittedJar , serConf , topology , opts ) ; } else { client . getClient ( ) . submitTopology ( name , StormSubmitter . submittedJar , serConf , topology ) ; } } catch ( InvalidTopologyException e ) { <START_BUG> StormSubmitter . LOG . warn ( "Topology<seq2seq4repair_space>submission<seq2seq4repair_space>exception" , e ) ; <END_BUG> throw e ; } catch ( AlreadyAliveException e ) { StormSubmitter . LOG . warn ( "Topology<seq2seq4repair_space>already<seq2seq4repair_space>alive<seq2seq4repair_space>exception" , e ) ; throw e ; } finally { client . close ( ) ; } } StormSubmitter . LOG . info ( ( "Finished<seq2seq4repair_space>submitting<seq2seq4repair_space>topology:<seq2seq4repair_space>" + name ) ) ; } catch ( TException e ) { throw new RuntimeException ( e ) ; } } private static boolean topologyNameExists ( Map conf , String name ) { } private static String submittedJar = null ; private static void submitJar ( Map conf ) { } public static String submitJar ( Map conf , String localJar ) { } } 
public final class IOUtils { private static final Logger log = LoggerFactory . getLogger ( IOUtils . class ) ; private static final int DEFAULT_BUFFER_SIZE = 1024 * 4 ; public IOUtils ( ) { } public static void close ( final Closeable closeable ) throws IOException { } public static void closeQuietly ( final Closeable closeable ) { } public static byte [ ] toByteArray ( final InputStream input ) throws IOException { } public static byte [ ] toByteArray ( final Reader input ) throws IOException { } public static byte [ ] toByteArray ( final Reader input , final String encoding ) throws IOException { } public static char [ ] toCharArray ( final InputStream is ) throws IOException { } public static char [ ] toCharArray ( final InputStream is , final String encoding ) throws IOException { } public static char [ ] toCharArray ( final Reader input ) throws IOException { } public static String toString ( final InputStream input ) throws IOException { } public static String toString ( final InputStream input , final String encoding ) throws IOException { } public static String toString ( final Reader input ) throws IOException { } public static void write ( final byte [ ] data , final OutputStream output ) throws IOException { } public static void write ( final byte [ ] data , final Writer output ) throws IOException { } public static void write ( final byte [ ] data , final Writer output , final String encoding ) throws IOException { } public static void write ( final char [ ] data , final Writer output ) throws IOException { } public static void write ( final char [ ] data , final OutputStream output ) throws IOException { } public static void write ( final char [ ] data , final OutputStream output , final String encoding ) throws IOException { } public static void write ( final String data , final Writer output ) throws IOException { } public static void write ( final String data , final OutputStream output ) throws IOException { } public static void write ( final String data , final OutputStream output , final String encoding ) throws IOException { } public static void write ( final StringBuilder data , final Writer output ) throws IOException { } public static void write ( final StringBuilder data , final OutputStream output ) throws IOException { } public static void write ( final StringBuilder data , final OutputStream output , final String encoding ) throws IOException { } public static int copy ( final InputStream input , final OutputStream output ) throws IOException { } public static void copy ( final InputStream input , final Writer output ) throws IOException { } public static void copy ( final InputStream input , final Writer output , final String encoding ) throws IOException { } public static int copy ( final Reader input , final Writer output ) throws IOException { } public static void copy ( final Reader input , final OutputStream output ) throws IOException { } public static void copy ( final Reader input , final OutputStream output , final String encoding ) throws IOException { } public static boolean contentEquals ( InputStream input1 , InputStream input2 ) throws IOException { } public static boolean contentEquals ( Reader input1 , Reader input2 ) throws IOException { } public static Time getLastModified ( File file ) { if ( ( file . exists ( ) ) == false ) { return null ; } long millis = file . lastModified ( ) ; if ( millis == 0 ) { return null ; } <START_BUG> return Time . valueOf ( millis ) ; <END_BUG> } } 
public class ParameterizedSingleTypeReference extends ArrayTypeReference { public TypeReference [ ] typeArguments ; private boolean didResolve = false ; public ParameterizedSingleTypeReference ( char [ ] name , TypeReference [ ] typeArguments , int dim , long pos ) { } public void checkBounds ( Scope scope ) { } public TypeReference copyDims ( int dim ) { } public char [ ] [ ] getParameterizedTypeName ( ) { } protected TypeBinding getTypeBinding ( Scope scope ) { } private TypeBinding internalResolveType ( Scope scope , ReferenceBinding enclosingType , boolean checkBounds ) { this . constant = Constant . NotAConstant ; if ( this . didResolve ) { if ( ( ( this . resolvedType ) != null ) && ( ! ( this . resolvedType . isValidBinding ( ) ) ) ) return null ; return this . resolvedType ; } this . didResolve = true ; if ( enclosingType == null ) { this . resolvedType = scope . getType ( token ) ; if ( ! ( this . resolvedType . isValidBinding ( ) ) ) { reportInvalidType ( scope ) ; return null ; } enclosingType = this . resolvedType . enclosingType ( ) ; if ( ( enclosingType != null ) && ( enclosingType . isGenericType ( ) ) ) { ReferenceBinding currentType = ( ( ReferenceBinding ) ( this . resolvedType ) ) ; enclosingType = ( currentType . isStatic ( ) ) ? ( ( ReferenceBinding ) ( scope . environment ( ) . convertToRawType ( enclosingType ) ) ) : scope . environment ( ) . convertToParameterizedType ( enclosingType ) ; } } else { this . resolvedType = scope . getMemberType ( token , ( ( ReferenceBinding ) ( enclosingType . erasure ( ) ) ) ) ; if ( ! ( this . resolvedType . isValidBinding ( ) ) ) { scope . problemReporter ( ) . invalidEnclosingType ( this , this . resolvedType , enclosingType ) ; return null ; } if ( isTypeUseDeprecated ( this . resolvedType , scope ) ) scope . problemReporter ( ) . deprecatedType ( this . resolvedType , this ) ; } boolean isClassScope = ( scope . kind ) == ( Scope . CLASS_SCOPE ) ; TypeReference keep = null ; if ( isClassScope ) { keep = ( ( ClassScope ) ( scope ) ) . superTypeReference ; ( ( ClassScope ) ( scope ) ) . superTypeReference = null ; } ReferenceBinding currentType = ( ( ReferenceBinding ) ( this . resolvedType ) ) ; int argLength = this . typeArguments . length ; TypeBinding [ ] argTypes = new TypeBinding [ argLength ] ; boolean argHasError = false ; for ( int i = 0 ; i < argLength ; i ++ ) { TypeReference typeArgument = this . typeArguments [ i ] ; TypeBinding argType = ( isClassScope ) ? typeArgument . resolveTypeArgument ( ( ( ClassScope ) ( scope ) ) , currentType , i ) : typeArgument . resolveTypeArgument ( ( ( BlockScope ) ( scope ) ) , currentType , i ) ; if ( argType == null ) { argHasError = true ; } else { argTypes [ i ] = argType ; } } if ( argHasError ) return null ; if ( isClassScope ) { ( ( ClassScope ) ( scope ) ) . superTypeReference = keep ; if ( ( ( ClassScope ) ( scope ) ) . detectHierarchyCycle ( currentType , this , argTypes ) ) return null ; } TypeVariableBinding [ ] typeVariables = currentType . typeVariables ( ) ; <START_BUG> if ( typeVariables == ( NoTypeVariables ) ) { <END_BUG> scope . problemReporter ( ) . nonGenericTypeCannotBeParameterized ( this , currentType , argTypes ) ; return null ; } else if ( argLength != ( typeVariables . length ) ) { scope . problemReporter ( ) . incorrectArityForParameterizedType ( this , currentType , argTypes ) ; return null ; } else if ( ( ( ! ( currentType . isStatic ( ) ) ) && ( enclosingType != null ) ) && ( enclosingType . isRawType ( ) ) ) { scope . problemReporter ( ) . rawMemberTypeCannotBeParameterized ( this , scope . environment ( ) . createRawType ( ( ( ReferenceBinding ) ( currentType . erasure ( ) ) ) , enclosingType ) , argTypes ) ; return null ; } ParameterizedTypeBinding parameterizedType = scope . environment ( ) . createParameterizedType ( ( ( ReferenceBinding ) ( currentType . erasure ( ) ) ) , argTypes , enclosingType ) ; if ( checkBounds ) parameterizedType . boundCheck ( scope , this . typeArguments ) ; this . resolvedType = parameterizedType ; if ( isTypeUseDeprecated ( this . resolvedType , scope ) ) reportDeprecatedType ( scope ) ; if ( ( this . dimensions ) > 0 ) { if ( ( dimensions ) > 255 ) scope . problemReporter ( ) . tooManyDimensions ( this ) ; this . resolvedType = scope . createArrayType ( this . resolvedType , dimensions ) ; } return this . resolvedType ; } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope , boolean checkBounds ) { } public TypeBinding resolveType ( ClassScope scope ) { } public TypeBinding resolveTypeEnclosing ( BlockScope scope , ReferenceBinding enclosingType ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } public void traverse ( ASTVisitor visitor , ClassScope scope ) { } } 
public class SetClasspathOperation extends JavaModelOperation { IClasspathEntry [ ] oldResolvedPath ; IClasspathEntry [ ] newResolvedPath ; IClasspathEntry [ ] newRawPath ; boolean canChangeResource ; boolean needCycleCheck ; boolean needValidation ; boolean needSave ; IPath newOutputLocation ; public static final IClasspathEntry [ ] ReuseClasspath = new IClasspathEntry [ 0 ] ; public static final IClasspathEntry [ ] UpdateClasspath = new IClasspathEntry [ 0 ] ; public static final IPath ReuseOutputLocation = new Path ( "Reuse<seq2seq4repair_space>Existing<seq2seq4repair_space>Output<seq2seq4repair_space>Location" ) ; public SetClasspathOperation ( IJavaProject project , IClasspathEntry [ ] oldResolvedPath , IClasspathEntry [ ] newRawPath , IPath newOutputLocation , boolean canChangeResource , boolean needValidation , boolean needSave ) { } protected void addClasspathDeltas ( IPackageFragmentRoot [ ] roots , int flag , JavaElementDelta delta ) { } protected int classpathContains ( IClasspathEntry [ ] list , IClasspathEntry entry ) { } protected void collectAllSubfolders ( IFolder folder , ArrayList collection ) throws JavaModelException { } protected ArrayList determineAffectedPackageFragments ( IPath location ) throws JavaModelException { } protected void executeOperation ( ) throws JavaModelException { } protected void generateClasspathChangeDeltas ( IClasspathEntry [ ] oldResolvedPath , IClasspathEntry [ ] newResolvedPath , JavaModelManager manager , final JavaProject project ) { } protected JavaProject getProject ( ) { } private int getSourceAttachmentDeltaFlag ( IPath oldPath , IPath newPath , IPath sourcePath ) { } public boolean isReadOnly ( ) { } protected void saveClasspathIfNecessary ( ) throws JavaModelException { } public String toString ( ) { } private void updateClasspath ( ) throws JavaModelException { } protected void updateAffectedProjects ( IPath prerequisiteProjectPath ) { } protected void updateCycleMarkersIfNecessary ( IClasspathEntry [ ] newResolvedPath ) { } protected void updateOutputLocation ( ) throws JavaModelException { } protected void updateProjectReferencesIfNecessary ( ) throws JavaModelException { if ( ! ( this . canChangeResource ) ) return ; if ( ( ( this . newRawPath ) == ( SetClasspathOperation . ReuseClasspath ) ) || ( ( this . newRawPath ) == ( SetClasspathOperation . UpdateClasspath ) ) ) return ; JavaProject jproject = getProject ( ) ; String [ ] oldRequired = jproject . projectPrerequisites ( this . oldResolvedPath ) ; if ( ( this . newResolvedPath ) == null ) { <START_BUG> this . newResolvedPath = jproject . getResolvedClasspath ( this . newRawPath , true , this . needValidation ) ; <END_BUG> } String [ ] newRequired = jproject . projectPrerequisites ( this . newResolvedPath ) ; try { IProject project = jproject . getProject ( ) ; IProjectDescription description = project . getDescription ( ) ; IProject [ ] projectReferences = description . getReferencedProjects ( ) ; HashSet oldReferences = new HashSet ( projectReferences . length ) ; for ( int i = 0 ; i < ( projectReferences . length ) ; i ++ ) { String projectName = projectReferences [ i ] . getName ( ) ; oldReferences . add ( projectName ) ; } HashSet newReferences = ( ( HashSet ) ( oldReferences . clone ( ) ) ) ; for ( int i = 0 ; i < ( oldRequired . length ) ; i ++ ) { String projectName = oldRequired [ i ] ; newReferences . remove ( projectName ) ; } for ( int i = 0 ; i < ( newRequired . length ) ; i ++ ) { String projectName = newRequired [ i ] ; newReferences . add ( projectName ) ; } Iterator iter ; int newSize = newReferences . size ( ) ; checkIdentity : { if ( ( oldReferences . size ( ) ) == newSize ) { iter = newReferences . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( ! ( oldReferences . contains ( iter . next ( ) ) ) ) { break checkIdentity ; } } return ; } } String [ ] requiredProjectNames = new String [ newSize ] ; int index = 0 ; iter = newReferences . iterator ( ) ; while ( iter . hasNext ( ) ) { requiredProjectNames [ ( index ++ ) ] = ( ( String ) ( iter . next ( ) ) ) ; } Util . sort ( requiredProjectNames ) ; IProject [ ] requiredProjectArray = new IProject [ newSize ] ; IWorkspaceRoot wksRoot = project . getWorkspace ( ) . getRoot ( ) ; for ( int i = 0 ; i < newSize ; i ++ ) { requiredProjectArray [ i ] = wksRoot . getProject ( requiredProjectNames [ i ] ) ; } description . setReferencedProjects ( requiredProjectArray ) ; project . setDescription ( description , this . fMonitor ) ; } catch ( CoreException e ) { throw new JavaModelException ( e ) ; } } public IJavaModelStatus verify ( ) { } } 
public class DoubleDatatypeValidator extends AbstractNumericFacetValidator { public DoubleDatatypeValidator ( ) throws InvalidDatatypeFacetException { } public DoubleDatatypeValidator ( DatatypeValidator base , Hashtable facets , boolean derivedByList ) throws InvalidDatatypeFacetException { } public int compare ( String value1 , String value2 ) { } protected int compareValues ( Object value1 , Object value2 ) { } protected void setMaxInclusive ( String value ) { } protected void setMinInclusive ( String value ) { } protected void setMaxExclusive ( String value ) { } protected void setMinExclusive ( String value ) { } protected void setEnumeration ( Vector enumeration ) throws InvalidDatatypeValueException { if ( enumeration != null ) { fEnumeration = new Double [ enumeration . size ( ) ] ; Object baseEnum = null ; try { for ( int i = 0 ; i < ( enumeration . size ( ) ) ; i ++ ) { <START_BUG> fEnumeration [ i ] = new Double ( ( ( String ) ( enumeration . elementAt ( i ) ) ) ) ; <END_BUG> ( ( DoubleDatatypeValidator ) ( fBaseValidator ) ) . validate ( ( ( String ) ( enumeration . elementAt ( i ) ) ) , null ) ; } } catch ( Exception e ) { throw new InvalidDatatypeValueException ( e . getMessage ( ) ) ; } } } protected String getMaxInclusive ( boolean isBase ) { } protected String getMinInclusive ( boolean isBase ) { } protected String getMaxExclusive ( boolean isBase ) { } protected String getMinExclusive ( boolean isBase ) { } protected void checkContentEnum ( String content , Object state , Vector enumeration ) throws InvalidDatatypeValueException { } protected void checkContent ( String content , Object state , Vector enumeration , boolean asBase ) throws InvalidDatatypeValueException { } private static Double dValueOf ( String s ) throws NumberFormatException { } private void enumCheck ( double v , Double [ ] enumDoubles ) throws InvalidDatatypeValueException { } private int compareDoubles ( double d1 , double d2 ) { } } 
public class LocalizedFormatsTest { @ Test public void testMessageNumber ( ) { <START_BUG> Assert . assertEquals ( 309 , LocalizedFormats . values ( ) . length ) ; <END_BUG> } @ Test public void testAllKeysPresentInPropertiesFiles ( ) { } @ Test public void testAllPropertiesCorrespondToKeys ( ) { } @ Test public void testNoMissingFrenchTranslation ( ) { } @ Test public void testNoOpEnglishTranslation ( ) { } @ Test public void testVariablePartsConsistency ( ) { } } 
@ RunWith ( Arquillian . class ) @ RunAsClient public class SimpleStatelessWebserviceEndpointTestCase { @ ArquillianResource URL baseUrl ; private static final Logger log = Logger . getLogger ( SimpleStatelessWebserviceEndpointTestCase . class . getName ( ) ) ; @ Deployment ( testable = false ) public static JavaArchive createDeployment ( ) { final JavaArchive jar = ShrinkWrap . create ( JavaArchive . class , "stateless-ws-endpoint-example.jar" ) ; <START_BUG> jar . addPackage ( SimpleStatelessWebserviceEndpointImpl . class . getPackage ( ) ) ; <END_BUG> SimpleStatelessWebserviceEndpointTestCase . log . info ( jar . toString ( true ) ) ; return jar ; } @ Test public void testSimpleStatelessWebserviceEndpoint ( ) throws Exception { } @ Test public void testRemoteAccess ( ) throws Exception { } } 
public class StreamContextManager { private static Logger logger_ = Logger . getLogger ( StreamContextManager . class ) ; public static enum StreamCompletionAction { DELETE , STREAM ; } public static class StreamContext implements Serializable { private static Logger logger_ = Logger . getLogger ( StreamContextManager . StreamContext . class ) ; private static ICompactSerializer < StreamContextManager . StreamContext > serializer_ ; public static ICompactSerializer < StreamContextManager . StreamContext > serializer ( ) { } private String targetFile_ ; private long expectedBytes_ ; public StreamContext ( String targetFile , long expectedBytes ) { } public String getTargetFile ( ) { } public void setTargetFile ( String file ) { } public long getExpectedBytes ( ) { } public boolean equals ( Object o ) { } public int hashCode ( ) { } public String toString ( ) { } } public static class StreamContextSerializer implements ICompactSerializer < StreamContextManager . StreamContext > { public void serialize ( StreamContextManager . StreamContext sc , DataOutputStream dos ) throws IOException { } public StreamContextManager . StreamContext deserialize ( DataInputStream dis ) throws IOException { } } public static class StreamStatus { private static ICompactSerializer < StreamContextManager . StreamStatus > serializer_ ; public static ICompactSerializer < StreamContextManager . StreamStatus > serializer ( ) { } private String file_ ; private long expectedBytes_ ; private StreamContextManager . StreamCompletionAction action_ ; public StreamStatus ( String file , long expectedBytes ) { } public String getFile ( ) { } public long getExpectedBytes ( ) { } void setAction ( StreamContextManager . StreamCompletionAction action ) { } public StreamContextManager . StreamCompletionAction getAction ( ) { } } public static class StreamStatusSerializer implements ICompactSerializer < StreamContextManager . StreamStatus > { public void serialize ( StreamContextManager . StreamStatus streamStatus , DataOutputStream dos ) throws IOException { } public StreamContextManager . StreamStatus deserialize ( DataInputStream dis ) throws IOException { } } public static class StreamStatusMessage implements Serializable { private static ICompactSerializer < StreamContextManager . StreamStatusMessage > serializer_ ; public static ICompactSerializer < StreamContextManager . StreamStatusMessage > serializer ( ) { } public static Message makeStreamStatusMessage ( StreamContextManager . StreamStatusMessage streamStatusMessage ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; DataOutputStream dos = new DataOutputStream ( bos ) ; StreamContextManager . StreamStatusMessage . serializer ( ) . serialize ( streamStatusMessage , dos ) ; <START_BUG> return new Message ( StorageService . getLocalStorageEndPoint ( ) , "" , StorageService . bootStrapTerminateVerbHandler_ , new Object [ ] { bos . toByteArray ( ) } ) ; <END_BUG> } protected StreamContextManager . StreamStatus streamStatus_ ; public StreamStatusMessage ( StreamContextManager . StreamStatus streamStatus ) { } public StreamContextManager . StreamStatus getStreamStatus ( ) { } } public static class StreamStatusMessageSerializer implements ICompactSerializer < StreamContextManager . StreamStatusMessage > { public void serialize ( StreamContextManager . StreamStatusMessage streamStatusMessage , DataOutputStream dos ) throws IOException { } public StreamContextManager . StreamStatusMessage deserialize ( DataInputStream dis ) throws IOException { } } public static Map < String , List < StreamContextManager . StreamContext > > ctxBag_ = new Hashtable < String , List < StreamContextManager . StreamContext > > ( ) ; public static Map < String , List < StreamContextManager . StreamStatus > > streamStatusBag_ = new Hashtable < String , List < StreamContextManager . StreamStatus > > ( ) ; public static Map < String , IStreamComplete > streamNotificationHandlers_ = new HashMap < String , IStreamComplete > ( ) ; public static synchronized StreamContextManager . StreamContext getStreamContext ( String key ) { } public static synchronized StreamContextManager . StreamStatus getStreamStatus ( String key ) { } public static synchronized boolean isDone ( String key ) { } public static synchronized IStreamComplete getStreamCompletionHandler ( String key ) { } public static synchronized void removeStreamCompletionHandler ( String key ) { } public static synchronized void registerStreamCompletionHandler ( String key , IStreamComplete streamComplete ) { } public static synchronized void addStreamContext ( String key , StreamContextManager . StreamContext streamContext , StreamContextManager . StreamStatus streamStatus ) { } } 
public class CassandraDaemon extends AbstractCassandraDaemon { private static Logger logger = LoggerFactory . getLogger ( CassandraDaemon . class ) ; private TServer serverEngine ; protected void setup ( ) throws IOException { int listenPort = DatabaseDescriptor . getRpcPort ( ) ; InetAddress listenAddr = DatabaseDescriptor . getRpcAddress ( ) ; if ( listenAddr == null ) listenAddr = FBUtilities . getLocalAddress ( ) ; Thread . setDefaultUncaughtExceptionHandler ( new Thread . UncaughtExceptionHandler ( ) { public void uncaughtException ( Thread t , Throwable e ) { CassandraDaemon . logger . error ( ( "Uncaught<seq2seq4repair_space>exception<seq2seq4repair_space>in<seq2seq4repair_space>thread<seq2seq4repair_space>" + t ) , e ) ; if ( e instanceof OutOfMemoryError ) { System . exit ( 100 ) ; } } } ) ; try { SystemTable . checkHealth ( ) ; } catch ( ConfigurationException e ) { CassandraDaemon . logger . error ( "Fatal<seq2seq4repair_space>exception<seq2seq4repair_space>during<seq2seq4repair_space>initialization" , e ) ; System . exit ( 100 ) ; } try { DatabaseDescriptor . loadSchemas ( ) ; } catch ( IOException e ) { CassandraDaemon . logger . error ( "Fatal<seq2seq4repair_space>exception<seq2seq4repair_space>during<seq2seq4repair_space>initialization" , e ) ; System . exit ( 100 ) ; } for ( String table : DatabaseDescriptor . getTables ( ) ) { if ( CassandraDaemon . logger . isDebugEnabled ( ) ) CassandraDaemon . logger . debug ( ( "opening<seq2seq4repair_space>keyspace<seq2seq4repair_space>" + table ) ) ; Table . open ( table ) ; } CommitLog . recover ( ) ; instance . checkAllColumnFamilies ( ) ; UUID currentMigration = DatabaseDescriptor . getDefsVersion ( ) ; UUID lastMigration = Migration . getLastMigrationId ( ) ; if ( ( lastMigration != null ) && ( ( lastMigration . timestamp ( ) ) > ( currentMigration . timestamp ( ) ) ) ) { MigrationManager . applyMigrations ( currentMigration , lastMigration ) ; } StorageService . instance . initServer ( ) ; final CassandraServer cassandraServer = new CassandraServer ( ) ; Cassandra . Processor processor = new Cassandra . Processor ( cassandraServer ) ; TServerSocket tServerSocket = null ; try { tServerSocket = new TServerSocket ( new InetSocketAddress ( listenAddr , listenPort ) ) ; } catch ( TTransportException e ) { throw new IOException ( String . format ( "Unable<seq2seq4repair_space>to<seq2seq4repair_space>create<seq2seq4repair_space>thrift<seq2seq4repair_space>socket<seq2seq4repair_space>to<seq2seq4repair_space>%s:%s" , listenAddr , listenPort ) , e ) ; } CassandraDaemon . logger . info ( String . format ( "Binding<seq2seq4repair_space>thrift<seq2seq4repair_space>service<seq2seq4repair_space>to<seq2seq4repair_space>%s:%s" , listenAddr , listenPort ) ) ; <START_BUG> TProtocolFactory tProtocolFactory = new org . apache . thrift . protocol . TBinaryProtocol . Factory ( false , true , DatabaseDescriptor . getThriftMaxMessageLength ( ) ) ; <END_BUG> TTransportFactory inTransportFactory ; TTransportFactory outTransportFactory ; if ( DatabaseDescriptor . isThriftFramed ( ) ) { int tFramedTransportSize = DatabaseDescriptor . getThriftFramedTransportSize ( ) ; inTransportFactory = new TFramedTransport . Factory ( tFramedTransportSize ) ; outTransportFactory = new TFramedTransport . Factory ( tFramedTransportSize ) ; CassandraDaemon . logger . info ( "Using<seq2seq4repair_space>TFramedTransport<seq2seq4repair_space>with<seq2seq4repair_space>a<seq2seq4repair_space>max<seq2seq4repair_space>frame<seq2seq4repair_space>size<seq2seq4repair_space>of<seq2seq4repair_space>{}<seq2seq4repair_space>bytes." , tFramedTransportSize ) ; } else { inTransportFactory = new TTransportFactory ( ) ; outTransportFactory = new TTransportFactory ( ) ; } CustomTThreadPoolServer . Options options = new CustomTThreadPoolServer . Options ( ) ; options . minWorkerThreads = 64 ; SynchronousQueue < Runnable > executorQueue = new SynchronousQueue < Runnable > ( ) ; ExecutorService executorService = new ThreadPoolExecutor ( options . minWorkerThreads , options . maxWorkerThreads , 60 , TimeUnit . SECONDS , executorQueue ) { @ Override protected void afterExecute ( Runnable r , Throwable t ) { super . afterExecute ( r , t ) ; cassandraServer . logout ( ) ; } } ; serverEngine = new CustomTThreadPoolServer ( new org . apache . thrift . TProcessorFactory ( processor ) , tServerSocket , inTransportFactory , outTransportFactory , tProtocolFactory , tProtocolFactory , options , executorService ) ; } public void start ( ) { } public void stop ( ) { } public static void main ( String [ ] args ) { } } 
public class RootLoggerRemove extends AbstractLoggingSubsystemUpdate < Void > { private static final long serialVersionUID = - 9178350859833986971L ; public RootLoggerRemove ( ) { } protected < P > void applyUpdate ( UpdateContext updateContext , UpdateResultHandler < ? super Void , P > resultHandler , P param ) { final ServiceController < ? > service ; try { <START_BUG> service = updateContext . getServiceContainer ( ) . getRequiredService ( ROOT_LOGGER ) ; <END_BUG> } catch ( ServiceNotFoundException e ) { resultHandler . handleFailure ( e , param ) ; return ; } service . setMode ( REMOVE ) ; service . addListener ( new UpdateResultHandler . ServiceRemoveListener < P > ( resultHandler , param ) ) ; } public RootLoggerAdd getCompensatingUpdate ( LoggingSubsystemElement original ) { } protected void applyUpdate ( LoggingSubsystemElement element ) throws UpdateFailedException { } } 
public class AttrImpl extends NodeContainer implements Attr { static final long serialVersionUID = 7277707688218972102L ; protected boolean owned ; protected boolean specified = true ; protected AttrImpl ( DocumentImpl ownerDocument , String name ) { } protected AttrImpl ( ) { } public short getNodeType ( ) { } public void setNodeValue ( String value ) throws DOMException { } public String getNodeValue ( ) { } public Node getParentNode ( ) { } public Node cloneNode ( boolean deep ) { AttrImpl newattr = ( ( AttrImpl ) ( super . cloneNode ( deep ) ) ) ; <START_BUG> newattr . owned = owned ; <END_BUG> newattr . specified = specified ; return newattr ; } public String getName ( ) { } public void setValue ( String value ) { } public String getValue ( ) { } public boolean getSpecified ( ) { } public Element getElement ( ) { } public Element getOwnerElement ( ) { } public void normalize ( ) { } public void setSpecified ( boolean arg ) { } public String toString ( ) { } } 
public class TestRecursiveRelationships extends SingleEMFTestCase { private int _l1Nodes = 3 ; private int _l2Nodes = 3 ; public void setUp ( ) { <START_BUG> setUp ( Node . class ) ; <END_BUG> } public void testRecursiveNodes ( ) { } } 
public class Version { private Version ( ) { } public static String id ( ) { <START_BUG> return "4.5-SNAPSHOT-20080722-1051" ; <END_BUG> } public static void main ( String [ ] args ) { } } 
public class SizeSelectorTest extends BaseSelectorTest { private Project project ; public SizeSelectorTest ( String name ) { } public BaseSelector getInstance ( ) { } public void testValidate ( ) { } public void testSelectionBehaviour ( ) { SizeSelector s ; String results ; SizeSelector . ByteUnits kilo = new SizeSelector . ByteUnits ( ) ; kilo . setValue ( "K" ) ; SizeSelector . ByteUnits kibi = new SizeSelector . ByteUnits ( ) ; kibi . setValue ( "Ki" ) ; SizeSelector . ByteUnits tibi = new SizeSelector . ByteUnits ( ) ; tibi . setValue ( "Ti" ) ; SizeSelector . SizeComparisons less = new SizeSelector . SizeComparisons ( ) ; less . setValue ( "less" ) ; SizeSelector . SizeComparisons equal = new SizeSelector . SizeComparisons ( ) ; equal . setValue ( "equal" ) ; SizeSelector . SizeComparisons more = new SizeSelector . SizeComparisons ( ) ; more . setValue ( "more" ) ; try { makeBed ( ) ; s = ( ( SizeSelector ) ( getInstance ( ) ) ) ; s . setValue ( 10 ) ; s . setWhen ( less ) ; results = selectionString ( s ) ; assertEquals ( "TFFFFFFFFFFT" , results ) ; s = ( ( SizeSelector ) ( getInstance ( ) ) ) ; s . setValue ( 10 ) ; s . setWhen ( more ) ; results = selectionString ( s ) ; assertEquals ( "TTTTTTTTTTTT" , results ) ; s = ( ( SizeSelector ) ( getInstance ( ) ) ) ; s . setValue ( 32 ) ; s . setWhen ( equal ) ; results = selectionString ( s ) ; <START_BUG> assertEquals ( "TTFFTFFFFFFT" , results ) ; <END_BUG> s = ( ( SizeSelector ) ( getInstance ( ) ) ) ; s . setValue ( 7 ) ; s . setWhen ( more ) ; s . setUnits ( kilo ) ; results = selectionString ( s ) ; assertEquals ( "TFTFFTTTTTTT" , results ) ; s = ( ( SizeSelector ) ( getInstance ( ) ) ) ; s . setValue ( 7 ) ; s . setWhen ( more ) ; s . setUnits ( kibi ) ; results = selectionString ( s ) ; assertEquals ( "TFTFFFTTFTTT" , results ) ; s = ( ( SizeSelector ) ( getInstance ( ) ) ) ; s . setValue ( 99999 ) ; s . setWhen ( more ) ; s . setUnits ( tibi ) ; results = selectionString ( s ) ; assertEquals ( "TFFFFFFFFFFT" , results ) ; s = ( ( SizeSelector ) ( getInstance ( ) ) ) ; Parameter param1 = new Parameter ( ) ; Parameter param2 = new Parameter ( ) ; Parameter param3 = new Parameter ( ) ; param1 . setName ( "value" ) ; param1 . setValue ( "20" ) ; param2 . setName ( "units" ) ; param2 . setValue ( "Ki" ) ; param3 . setName ( "when" ) ; param3 . setValue ( "more" ) ; Parameter [ ] params = new Parameter [ ] { param1 , param2 , param3 } ; s . setParameters ( params ) ; results = selectionString ( s ) ; assertEquals ( "TFFFFFFTFFTT" , results ) ; } finally { cleanupBed ( ) ; } } } 
public class JasperReportsUtilsTests extends TestCase { public void testRenderAsCsvWithDataSource ( ) throws Exception { } public void testRenderAsCsvWithCollection ( ) throws Exception { } public void testRenderAsCsvWithExporterParameters ( ) throws Exception { } public void testRenderAsHtmlWithDataSource ( ) throws Exception { } public void testRenderAsHtmlWithCollection ( ) throws Exception { } public void testRenderAsHtmlWithExporterParameters ( ) throws Exception { } public void testRenderAsPdfWithDataSource ( ) throws Exception { } public void testRenderAsPdfWithCollection ( ) throws Exception { } public void testRenderAsPdfWithExporterParameters ( ) throws Exception { } public void testRenderAsXlsWithDataSource ( ) throws Exception { } public void testRenderAsXlsWithCollection ( ) throws Exception { } public void testRenderAsXlsWithExporterParameters ( ) throws Exception { } public void testRenderWithWriter ( ) throws Exception { } public void testRenderWithOutputStream ( ) throws Exception { } private void assertCsvOutputCorrect ( String output ) { } private void assertHtmlOutputCorrect ( String output ) { } private void assertPdfOutputCorrect ( byte [ ] output ) throws Exception { } private void assertXlsOutputCorrect ( byte [ ] output ) throws Exception { HSSFWorkbook workbook = new HSSFWorkbook ( new ByteArrayInputStream ( output ) ) ; HSSFSheet sheet = workbook . getSheetAt ( 0 ) ; assertNotNull ( "Sheet<seq2seq4repair_space>should<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>null" , sheet ) ; HSSFRow row = sheet . getRow ( 3 ) ; HSSFCell cell = row . getCell ( ( ( short ) ( 1 ) ) ) ; assertNotNull ( "Cell<seq2seq4repair_space>should<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>null" , cell ) ; <START_BUG> assertEquals ( "Cell<seq2seq4repair_space>content<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>Dear<seq2seq4repair_space>Lord!" , "Dear<seq2seq4repair_space>Lord!" , cell . getRichStringCellValue ( ) . getString ( ) ) ; <END_BUG> } private JasperReport getReport ( ) throws Exception { } private Map < String , Object > getParameters ( ) { } private JRDataSource getDataSource ( ) { } private List < PersonBean > getData ( ) { } private static class SimpleProgressMonitor implements JRExportProgressMonitor { private boolean invoked = false ; @ Override public void afterPageExport ( ) { } public boolean isInvoked ( ) { } } } 
public class IIOPJndiBindingProcessor implements DeploymentUnitProcessor { @ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final EEModuleDescription moduleDescription = deploymentUnit . getAttachment ( EE_MODULE_DESCRIPTION ) ; final Module module = deploymentUnit . getAttachment ( MODULE ) ; if ( moduleDescription == null ) { return ; } <START_BUG> if ( ! ( JdkORBDeploymentMarker . isJacORBDeployment ( deploymentUnit ) ) ) { <END_BUG> return ; } final ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; if ( ( DeploymentTypeMarker . isType ( WAR , deploymentUnit ) ) || ( DeploymentTypeMarker . isType ( APPLICATION_CLIENT , deploymentUnit ) ) ) { final ServiceName moduleContextServiceName = ContextNames . contextServiceNameOfModule ( moduleDescription . getApplicationName ( ) , moduleDescription . getModuleName ( ) ) ; bindService ( serviceTarget , moduleContextServiceName , module ) ; } for ( ComponentDescription component : moduleDescription . getComponentDescriptions ( ) ) { if ( ( component . getNamingMode ( ) ) == ( ComponentNamingMode . CREATE ) ) { final ServiceName compContextServiceName = ContextNames . contextServiceNameOfComponent ( moduleDescription . getApplicationName ( ) , moduleDescription . getModuleName ( ) , component . getComponentName ( ) ) ; bindService ( serviceTarget , compContextServiceName , module ) ; } } } private void bindService ( final ServiceTarget serviceTarget , final ServiceName contextServiceName , final Module module ) { } @ Override public void undeploy ( DeploymentUnit context ) { } } 
public class AspectDeclaration extends MemberTypeDeclaration { private Aspect aspectAttribute ; public PerClause perClause ; public ResolvedMember aspectOfMethod ; public ResolvedMember hasAspectMethod ; public boolean isPrivileged ; public EclipseObjectType typeX ; public EclipseWorld world ; public TypePattern dominatesPattern ; public AspectDeclaration ( CompilationResult compilationResult ) { } public boolean isAbstract ( ) { } public void resolve ( ) { } public void checkSpec ( ClassScope scope ) { } public void generateCode ( ClassFile enclosingClassFile ) { } public boolean needClassInitMethod ( ) { } protected void generateAttributes ( ClassFile classFile ) { } private void generatePerSupportMembers ( ClassFile classFile ) { } private static interface BodyGenerator { public void generate ( CodeStream codeStream ) { } } private void generateMethod ( ClassFile classFile , ResolvedMember member , AspectDeclaration . BodyGenerator gen ) { } private void generateMethod ( ClassFile classFile , MethodBinding methodBinding , AspectDeclaration . BodyGenerator gen ) { } private void generatePerCflowAspectOfMethod ( ClassFile classFile ) { } private void generatePerCflowHasAspectMethod ( ClassFile classFile ) { } private void generatePerCflowPushMethod ( ClassFile classFile ) { } private void generatePerCflowAjcClinitMethod ( ClassFile classFile ) { } private TypeBinding generatePerObjectInterface ( ClassFile classFile ) { } private void generatePerObjectAspectOfMethod ( ClassFile classFile , final TypeBinding interfaceType ) { } private void generatePerObjectHasAspectMethod ( ClassFile classFile , final TypeBinding interfaceType ) { } private void generatePerObjectBindMethod ( ClassFile classFile , final TypeBinding interfaceType ) { } private void generatePerSingletonAspectOfMethod ( ClassFile classFile ) { } private void generatePerSingletonHasAspectMethod ( ClassFile classFile ) { } private void generatePerSingletonAjcClinitMethod ( ClassFile classFile ) { } private Kind lookupPerClauseKind ( ReferenceBinding binding ) { <START_BUG> if ( binding instanceof SourceTypeBinding ) { <END_BUG> SourceTypeBinding sourceSc = ( ( SourceTypeBinding ) ( binding ) ) ; if ( ( sourceSc . scope . referenceContext ) instanceof AspectDeclaration ) { PerClause perClause = ( ( AspectDeclaration ) ( sourceSc . scope . referenceContext ) ) . perClause ; if ( perClause == null ) return lookupPerClauseKind ( binding . superclass ( ) ) ; else return perClause . getKind ( ) ; } else { return null ; } } else { return null ; } } private void buildPerClause ( ClassScope scope ) { } private PerClause resolvePerClause ( ) { } public void buildInterTypeAndPerClause ( ClassScope classScope ) { } public String toString ( int tab ) { } public String toStringBody ( int tab ) { } public String toStringHeader ( ) { } } 
@ WebServlet ( name = "CallEjbServlet" , urlPatterns = { "/CallEjbServlet" } ) public class CallEjbServlet extends HttpServlet { @ EJB MyEjb ejb ; protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws IOException , ServletException { Context ctx = null ; try { Properties env = new Properties ( ) ; String address = System . getProperty ( "node0" , "localhost" ) ; address = NetworkUtils . formatPossibleIpv6Address ( address ) ; <START_BUG> env . put ( Context . PROVIDER_URL , ( ( "http-remoting://" + address ) + ":8080" ) ) ; <END_BUG> env . put ( Context . INITIAL_CONTEXT_FACTORY , "org.jboss.naming.remote.client.InitialContextFactory" ) ; ctx = new InitialContext ( env ) ; MyObject obj = ( ( MyObject ) ( ctx . lookup ( "loc/stub" ) ) ) ; Writer writer = resp . getWriter ( ) ; writer . write ( ejb . doIt ( ) ) ; writer . write ( obj . doIt ( "Hello" ) ) ; writer . flush ( ) ; } catch ( NamingException e ) { throw new RuntimeException ( e ) ; } finally { if ( ctx != null ) { try { ctx . close ( ) ; } catch ( NamingException e ) { throw new RuntimeException ( e ) ; } } } } } 
public class EjbLookupInjectionSource extends InjectionSource { private final String lookup ; private final String targetTypeName ; private final Class < ? > targetType ; public EjbLookupInjectionSource ( final String lookup , final String targetType ) { } public EjbLookupInjectionSource ( final String lookup , final Class < ? > targetType ) { } @ Override public void getResourceValue ( final ResolutionContext resolutionContext , final ServiceBuilder < ? > serviceBuilder , final DeploymentPhaseContext phaseContext , final Injector < ManagedReferenceFactory > injector ) throws DeploymentUnitProcessingException { final Class < ? > type ; if ( ( targetType ) != null ) { type = targetType ; } else if ( ( targetTypeName ) != null ) { final DeploymentClassIndex index = phaseContext . getDeploymentUnit ( ) . getAttachment ( CLASS_INDEX ) ; try { type = index . classIndex ( targetTypeName ) . getModuleClass ( ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>load<seq2seq4repair_space>EJB<seq2seq4repair_space>type<seq2seq4repair_space>" + ( targetTypeName ) ) , e ) ; } } else { type = null ; } injector . inject ( new ManagedReferenceFactory ( ) { @ Override public ManagedReference getReference ( ) { try { final Object value = new InitialContext ( ) . lookup ( lookup ) ; return new ManagedReference ( ) { @ Override public void release ( ) { } @ Override public Object getInstance ( ) { <START_BUG> if ( type != null ) { <END_BUG> return PortableRemoteObject . narrow ( value , type ) ; } else { return value ; } } } ; } catch ( NamingException e ) { throw new RuntimeException ( e ) ; } } } ) ; } @ Override public boolean equals ( final Object o ) { } @ Override public int hashCode ( ) { } } 
public class CopyfileTest extends TaskdefsTest { public CopyfileTest ( String name ) { } public void setUp ( ) { } public void test1 ( ) { } public void test2 ( ) { } public void test3 ( ) { } public void test4 ( ) { <START_BUG> expectLog ( "test4" , "Warning:<seq2seq4repair_space>src<seq2seq4repair_space>==<seq2seq4repair_space>dest" ) ; <END_BUG> } public void test5 ( ) { } } 
class DocCommentParser extends AbstractCommentParser { private Javadoc docComment ; private AST ast ; DocCommentParser ( AST ast , Scanner scanner , boolean check ) { } public Javadoc parse ( int [ ] positions ) { } public Javadoc parse ( int start , int length ) { } private void setComment ( int start , int length ) { } public String toString ( ) { } protected Object createArgumentReference ( char [ ] name , int dim , boolean isVarargs , Object typeRef , long [ ] dimPositions , long argNamePos ) throws InvalidInputException { try { MethodRefParameter argument = this . ast . newMethodRefParameter ( ) ; ASTNode node = ( ( ASTNode ) ( typeRef ) ) ; int argStart = node . getStartPosition ( ) ; int argEnd = ( ( node . getStartPosition ( ) ) + ( node . getLength ( ) ) ) - 1 ; if ( dim > 0 ) argEnd = ( ( int ) ( dimPositions [ ( dim - 1 ) ] ) ) ; if ( argNamePos >= 0 ) argEnd = ( ( int ) ( argNamePos ) ) ; if ( ( name . length ) != 0 ) { SimpleName argName = this . ast . newSimpleName ( new String ( name ) ) ; argument . setName ( argName ) ; int argNameStart = ( ( int ) ( argNamePos > > > 32 ) ) ; argName . setSourceRange ( argNameStart , ( ( argEnd - argNameStart ) + 1 ) ) ; } Type argType = null ; if ( ( node . getNodeType ( ) ) == ( ASTNode . PRIMITIVE_TYPE ) ) { argType = ( ( PrimitiveType ) ( node ) ) ; } else { Name argTypeName = ( ( Name ) ( node ) ) ; argType = this . ast . newSimpleType ( argTypeName ) ; argType . setSourceRange ( argStart , node . getLength ( ) ) ; } <START_BUG> if ( dim > 0 ) { <END_BUG> for ( int i = 0 ; i < dim ; i ++ ) { argType = this . ast . newArrayType ( argType ) ; argType . setSourceRange ( argStart , ( ( ( ( int ) ( dimPositions [ i ] ) ) - argStart ) + 1 ) ) ; } } argument . setType ( argType ) ; argument . setSourceRange ( argStart , ( ( argEnd - argStart ) + 1 ) ) ; return argument ; } catch ( ClassCastException ex ) { throw new InvalidInputException ( ) ; } } protected Object createFieldReference ( Object receiver ) throws InvalidInputException { } protected Object createMethodReference ( Object receiver , List arguments ) throws InvalidInputException { } protected void createTag ( ) { } protected Object createTypeReference ( int primitiveToken ) { } protected boolean parseReturn ( ) { } protected boolean parseTag ( int previousPosition ) throws InvalidInputException { } protected boolean pushParamName ( boolean isTypeParam ) { } protected boolean pushSeeRef ( Object statement ) { } protected void pushText ( int start , int end ) { } protected void refreshInlineTagPosition ( int previousPosition ) { } protected boolean pushThrowName ( Object typeRef ) { } protected void updateDocComment ( ) { } } 
public final class EditBook extends AuthenticatedHtmlPage { static final Book otherBook = new Book ( "Frisbee<seq2seq4repair_space>Techniques" , "Marty<seq2seq4repair_space>van<seq2seq4repair_space>Hoff" , Book . FICTION ) ; public EditBook ( final Book book ) { } public static PageLink link ( final String name , final long id ) { return new PageLink ( name , new IPageLink ( ) { public Page getPage ( ) { return new EditBook ( Book . get ( id ) ) ; } <START_BUG> public Class getIdentity ( ) { <END_BUG> return EditBook . class ; } } ) ; } public static final class EditBookForm extends Form { private Book book ; public EditBookForm ( final String componentName , final Book book , final FeedbackPanel feedback ) { } public final void handleSubmit ( ) { } } } 
public class MarshallingHttpMessageConverterTests { private MarshallingHttpMessageConverter converter ; private Marshaller marshaller ; private Unmarshaller unmarshaller ; @ Before public void setUp ( ) { } @ Test public void read ( ) throws Exception { } @ Test public void write ( ) throws Exception { String body = "<root>Hello<seq2seq4repair_space>World</root>" ; MockHttpOutputMessage outputMessage = new MockHttpOutputMessage ( ) ; marshaller . marshal ( eq ( body ) , isA ( StreamResult . class ) ) ; replay ( marshaller , unmarshaller ) ; <START_BUG> converter . write ( body , outputMessage ) ; <END_BUG> assertEquals ( "Invalid<seq2seq4repair_space>content-type" , new MediaType ( "application" , "xml" ) , outputMessage . getHeaders ( ) . getContentType ( ) ) ; verify ( marshaller , unmarshaller ) ; } } 
public class RemoteDomainControllerTestCase { private ManagementCommunicationService communicationService ; private DomainControllerOperationHandler operationHandler ; private RemoteDomainControllerConnection domainControllerConnection ; @ Before public void setup ( ) throws Exception { final ScheduledExecutorService executorService = Executors . newScheduledThreadPool ( 10 ) ; communicationService = new ManagementCommunicationService ( ) ; communicationService . getThreadFactoryInjector ( ) . inject ( Executors . defaultThreadFactory ( ) ) ; communicationService . getExecutorServiceInjector ( ) . inject ( executorService ) ; <START_BUG> final NetworkInterfaceService networkInterfaceService = new NetworkInterfaceService ( "test" , false , false , true , null ) ; <END_BUG> networkInterfaceService . start ( null ) ; communicationService . getInterfaceInjector ( ) . inject ( networkInterfaceService . getValue ( ) ) ; communicationService . getPortInjector ( ) . inject ( 12345 ) ; operationHandler = new DomainControllerOperationHandler ( ) ; operationHandler . getThreadFactoryInjector ( ) . inject ( Executors . defaultThreadFactory ( ) ) ; operationHandler . getExecutorServiceInjector ( ) . inject ( executorService ) ; operationHandler . getLocalFileRepositoryInjector ( ) . inject ( new org . jboss . as . server . manager . LocalFileRepository ( new ServerManagerEnvironment ( System . getProperties ( ) , false , System . in , System . out , System . err , "test" , InetAddress . getLocalHost ( ) , 3223 , InetAddress . getLocalHost ( ) , 3223 , "java" ) ) ) ; final DomainController domainController = new DomainController ( ) ; domainController . getDomainConfigDirInjector ( ) . inject ( new File ( getClass ( ) . getResource ( "/test/configuration" ) . toURI ( ) ) ) ; File tmpDir = new File ( System . getProperty ( "java.io.tmpdir" ) ) ; File deploymentDir = new File ( tmpDir , ( "domain-deployments-" + ( ( int ) ( Math . random ( ) ) ) ) ) ; deploymentDir . deleteOnExit ( ) ; deploymentDir . mkdirs ( ) ; domainController . getDomainDeploymentsDirInjector ( ) . inject ( deploymentDir ) ; final XMLMapper mapper = Factory . create ( ) ; StandardElementReaderRegistrar . Factory . getRegistrar ( ) . registerStandardDomainReaders ( mapper ) ; domainController . getXmlMapperInjector ( ) . inject ( mapper ) ; domainController . getScheduledExecutorServiceInjector ( ) . inject ( executorService ) ; domainController . start ( null ) ; operationHandler . getDomainControllerInjector ( ) . inject ( domainController ) ; operationHandler . start ( null ) ; communicationService . addHandler ( operationHandler ) ; communicationService . start ( null ) ; domainControllerConnection = new RemoteDomainControllerConnection ( "sm" , InetAddress . getLocalHost ( ) , 12345 , InetAddress . getLocalHost ( ) , 11223 , null , 1000 , Executors . newScheduledThreadPool ( 2 ) , Executors . defaultThreadFactory ( ) ) ; } @ Test public void testRegister ( ) throws Exception { } } 
public class ValidatorImpl extends AbstractValidator { private static final Localizer _loc = Localizer . forPackage ( ValidatorImpl . class ) ; private ValidatorFactory _validatorFactory = null ; private Validator _validator = null ; private ValidationMode _mode = ValidationMode . AUTO ; private OpenJPAConfiguration _conf = null ; private Map < Integer , Class < ? > [ ] > _validationGroups = new HashMap < Integer , Class < ? > [ ] > ( ) ; private static HashMap < String , Integer > _vgMapping = new HashMap < String , Integer > ( ) ; public static final String VG_PRE_PERSIST = "javax.persistence.validation.group.pre-persist" ; public static final String VG_PRE_REMOVE = "javax.persistence.validation.group.pre-remove" ; public static final String VG_PRE_UPDATE = "javax.persistence.validation.group.pre-update" ; public ValidatorImpl ( ) { } public ValidatorImpl ( Configuration conf ) { } public ValidatorImpl ( ValidatorFactory validatorFactory , ValidationMode mode ) { } private void initialize ( ) { } public void addValidationGroup ( String validationGroupName , Class < ? > ... vgs ) { } public void addValidationGroup ( Integer event , Class < ? > ... validationGroup ) { } public void addValidationGroup ( String validationGroupName , String group ) { } private Class < ? > [ ] getValidationGroup ( String vgName , String group ) { } public Class < ? > [ ] getValidationGroup ( Integer event ) { } public boolean isValidating ( Integer event ) { } public BeanDescriptor getConstraintsForClass ( Class < ? > cls ) { } @ Override public < T > ValidationException validate ( T arg0 , int event ) { } @ Override public < T > ValidationException validateProperty ( T arg0 , String property , int event ) { } @ Override public < T > ValidationException validateValue ( Class < T > arg0 , String arg1 , Object arg2 , int event ) { } @ Override public < T > boolean validating ( T arg0 , int event ) { } private Integer findEvent ( String validationProperty ) { } private ValidatorFactory getDefaultValidatorFactory ( ) { ValidatorFactory factory = null ; try { <START_BUG> factory = Validation . buildDefaultValidatorFactory ( ) ; <END_BUG> } catch ( javax . validation e ) { } return factory ; } private void addDefaultValidationGroups ( ) { } } 
public class TreeColumn extends Item { int labelHandle ; int imageHandle ; int buttonHandle ; Tree parent ; int modelIndex ; int lastButton ; int lastTime ; int lastX ; int lastWidth ; boolean customDraw ; boolean useFixedWidth ; String toolTipText ; public TreeColumn ( Tree parent , int style ) { } public TreeColumn ( Tree parent , int style , int index ) { } public void addControlListener ( ControlListener listener ) { } public void addSelectionListener ( SelectionListener listener ) { } static int checkStyle ( int style ) { } protected void checkSubclass ( ) { } void createWidget ( int index ) { } void deregister ( ) { } void destroyWidget ( ) { } public int getAlignment ( ) { } public boolean getMoveable ( ) { } public Tree getParent ( ) { } public boolean getResizable ( ) { } public String getToolTipText ( ) { } public int getWidth ( ) { } int gtk_clicked ( int widget ) { } int gtk_mnemonic_activate ( int widget , int arg1 ) { } int gtk_size_allocate ( int widget , int allocation ) { } void hookEvents ( ) { } public void pack ( ) { checkWidget ( ) ; int width = 0 ; if ( ( buttonHandle ) != 0 ) { GtkRequisition requisition = new GtkRequisition ( ) ; OS . gtk_widget_size_request ( buttonHandle , requisition ) ; width = requisition . width ; } if ( ( ( parent . style ) & ( SWT . VIRTUAL ) ) != 0 ) { } else { int iter = OS . g_malloc ( OS . GtkTreeIter_sizeof ( ) ) ; if ( OS . gtk_tree_model_get_iter_first ( parent . modelHandle , iter ) ) { do { <START_BUG> width = Math . max ( width , parent . calculateWidth ( handle , iter ) ) ; <END_BUG> } while ( OS . gtk_tree_model_iter_next ( parent . modelHandle , iter ) ) ; } OS . g_free ( iter ) ; } setWidth ( width ) ; } void register ( ) { } void releaseHandle ( ) { } void releaseParent ( ) { } public void removeControlListener ( ControlListener listener ) { } public void removeSelectionListener ( SelectionListener listener ) { } public void setAlignment ( int alignment ) { } void setFontDescription ( int font ) { } public void setImage ( Image image ) { } public void setMoveable ( boolean moveable ) { } public void setResizable ( boolean resizable ) { } public void setText ( String string ) { } public void setToolTipText ( String string ) { } void setToolTipText ( Shell shell , String newString ) { } public void setWidth ( int width ) { } } 
public class StatGraphVisualizer extends AbstractVisualizer implements ActionListener , Clearable { private static transient Logger log = LoggingManager . getLoggerForClass ( ) ; private final String [ ] COLUMNS = new String [ ] { JMeterUtils . getResString ( "URL" ) , JMeterUtils . getResString ( "aggregate_report_count" ) , JMeterUtils . getResString ( "average" ) , JMeterUtils . getResString ( "aggregate_report_median" ) , JMeterUtils . getResString ( "aggregate_report_90%_line" ) , JMeterUtils . getResString ( "aggregate_report_min" ) , JMeterUtils . getResString ( "aggregate_report_max" ) , JMeterUtils . getResString ( "aggregate_report_error%" ) , JMeterUtils . getResString ( "aggregate_report_rate" ) , JMeterUtils . getResString ( "aggregate_report_bandwidth" ) } ; private final String [ ] GRAPH_COLUMNS = new String [ ] { JMeterUtils . getResString ( "average" ) , JMeterUtils . getResString ( "aggregate_report_median" ) , JMeterUtils . getResString ( "aggregate_report_90%_line" ) , JMeterUtils . getResString ( "aggregate_report_min" ) , JMeterUtils . getResString ( "aggregate_report_max" ) } ; private final String TOTAL_ROW_LABEL = JMeterUtils . getResString ( "aggregate_report_total_label" ) ; protected JTable myJTable ; protected JScrollPane myScrollPane ; private transient ObjectTableModel model ; Map tableRows = Collections . synchronizedMap ( new HashMap ( ) ) ; protected AxisGraph graphPanel = null ; protected VerticalPanel graph = null ; protected JScrollPane graphScroll = null ; protected JSplitPane spane = null ; protected JLabeledChoice columns = new JLabeledChoice ( JMeterUtils . getResString ( "aggregate_graph_column" ) , GRAPH_COLUMNS ) ; protected double [ ] [ ] data = null ; protected JButton displayButton = new JButton ( JMeterUtils . getResString ( "aggregate_graph_display" ) ) ; protected JButton saveGraph = new JButton ( JMeterUtils . getResString ( "aggregate_graph_save" ) ) ; protected JButton saveTable = new JButton ( JMeterUtils . getResString ( "aggregate_graph_save_table" ) ) ; JLabeledTextField graphTitle = new JLabeledTextField ( JMeterUtils . getResString ( "aggregate_graph_user_title" ) ) ; JLabeledTextField graphWidth = new JLabeledTextField ( JMeterUtils . getResString ( "aggregate_graph_width" ) ) ; JLabeledTextField graphHeight = new JLabeledTextField ( JMeterUtils . getResString ( "aggregate_graph_height" ) ) ; protected String yAxisLabel = JMeterUtils . getResString ( "aggregate_graph_response_time" ) ; protected String yAxisTitle = JMeterUtils . getResString ( "aggregate_graph_ms" ) ; protected boolean saveGraphToFile = false ; protected int defaultWidth = 400 ; protected int defaultHeight = 300 ; public StatGraphVisualizer ( ) { } public String getLabelResource ( ) { } public void add ( SampleResult res ) { } public void clear ( ) { } public TestElement createTestElement ( ) { } private void init ( ) { } public void makeGraph ( ) { String wstr = graphWidth . getText ( ) ; String hstr = graphHeight . getText ( ) ; if ( ( wstr . length ( ) ) == 0 ) { wstr = "450" ; } if ( ( hstr . length ( ) ) == 0 ) { hstr = "250" ; } int width = Integer . parseInt ( wstr ) ; int height = Integer . parseInt ( hstr ) ; graphPanel . setData ( this . getData ( ) ) ; graphPanel . setHeight ( height ) ; graphPanel . setWidth ( width ) ; graphPanel . setTitle ( graphTitle . getText ( ) ) ; graphPanel . setXAxisLabels ( getAxisLabels ( ) ) ; graphPanel . setXAxisTitle ( columns . getText ( ) ) ; graphPanel . setYAxisLabels ( this . yAxisLabel ) ; graphPanel . setYAxisTitle ( this . yAxisTitle ) ; graphPanel . setPreferredSize ( new Dimension ( width , height ) ) ; <START_BUG> graph . resize ( new Dimension ( graph . getWidth ( ) , ( height + 120 ) ) ) ; <END_BUG> spane . repaint ( ) ; } public double [ ] [ ] getData ( ) { } public String [ ] getAxisLabels ( ) { } public Vector getAllTableData ( ) { } public void actionPerformed ( ActionEvent event ) { } public JComponent getPrintableComponent ( ) { } } 
@ Listener public class CacheRegistry < K , V > implements Registry < K , V > { private final List < Registry . Listener < K , V > > listeners = new CopyOnWriteArrayList < > ( ) ; private final RegistryEntryProvider < K , V > provider ; private final Cache < Node , Map . Entry < K , V > > cache ; private final CacheInvoker invoker ; private final Group group ; private final NodeFactory < Address > factory ; public CacheRegistry ( CacheRegistryFactoryConfiguration < K , V > config , RegistryEntryProvider < K , V > provider ) { } @ Override public void close ( ) { } @ Override public void addListener ( Registry . Listener < K , V > listener ) { } @ Override public void removeListener ( Registry . Listener < K , V > listener ) { } @ Override public Group getGroup ( ) { } @ Override public Map < K , V > getEntries ( ) { } @ Override public Map . Entry < K , V > getEntry ( Node node ) { } @ Override public Map . Entry < K , V > getLocalEntry ( ) { } @ TopologyChanged public void topologyChanged ( TopologyChangedEvent < Address , Node > event ) { if ( event . isPre ( ) ) return ; List < Address > newAddresses = event . getConsistentHashAtEnd ( ) . getMembers ( ) ; if ( ! ( newAddresses . get ( 0 ) . equals ( event . getCache ( ) . getCacheManager ( ) . getAddress ( ) ) ) ) return ; Set < Address > addresses = new java . util . HashSet ( event . getConsistentHashAtStart ( ) . getMembers ( ) ) ; addresses . removeAll ( newAddresses ) ; final List < Node > nodes = new java . util . ArrayList ( addresses . size ( ) ) ; for ( Address address : addresses ) { nodes . add ( this . factory . createNode ( address ) ) ; } CacheRegistry < K , V > . Operation < Map < K , V > > operation = new Operation < Map < K , V > > ( ) { @ Override public Map < K , V > invoke ( Cache < Node , Map . Entry < K , V > > cache ) { Map < K , V > removed = new HashMap < > ( ) ; for ( Node node : nodes ) { Map . Entry < K , V > old = cache . remove ( node ) ; if ( old != null ) { removed . put ( old . getKey ( ) , old . getValue ( ) ) ; } } return removed ; } } ; <START_BUG> Map < K , V > removed = this . invoker . invoke ( this . cache , operation , FORCE_SYNCHRONOUS ) ; <END_BUG> if ( ! ( removed . isEmpty ( ) ) ) { for ( Listener < K , V > listener : this . listeners ) { listener . removedEntries ( removed ) ; } } } @ CacheEntryModified public void modified ( CacheEntryModifiedEvent < Node , Map . Entry < K , V > > event ) { } @ CacheEntryRemoved public void removed ( CacheEntryRemovedEvent < Node , Map . Entry < K , V > > event ) { } abstract class Operation < R > implements CacheInvoker . Operation < Node , Map . Entry < K , V > , R > { } } 
public static final SimpleAttributeDefinition RELEASE_CODENAME = org . jboss . as . controller . SimpleAttributeDefinitionBuilder . create ( ModelDescriptionConstants . RELEASE_CODENAME , ModelType . STRING , false ) . setValidator ( DomainRootDefinition . NOT_NULL_STRING_LENGTH_ONE_VALIDATOR ) . build ( ) ; public static final SimpleAttributeDefinition PRODUCT_NAME = org . jboss . as . controller . SimpleAttributeDefinitionBuilder . create ( ModelDescriptionConstants . PRODUCT_NAME , ModelType . STRING , true ) . setValidator ( DomainRootDefinition . NOT_NULL_STRING_LENGTH_ONE_VALIDATOR ) . build ( ) ; public static final SimpleAttributeDefinition PRODUCT_VERSION = org . jboss . as . controller . SimpleAttributeDefinitionBuilder . create ( ModelDescriptionConstants . PRODUCT_VERSION , ModelType . STRING , true ) . setValidator ( DomainRootDefinition . NOT_NULL_STRING_LENGTH_ONE_VALIDATOR ) . build ( ) ; public static final SimpleAttributeDefinition MANAGEMENT_MAJOR_VERSION = org . jboss . as . controller . SimpleAttributeDefinitionBuilder . create ( ModelDescriptionConstants . MANAGEMENT_MAJOR_VERSION , ModelType . INT , false ) . setValidator ( new org . jboss . as . controller . operations . validation . IntRangeValidator ( 1 ) ) . build ( ) ; public static final SimpleAttributeDefinition MANAGEMENT_MINOR_VERSION = org . jboss . as . controller . SimpleAttributeDefinitionBuilder . create ( ModelDescriptionConstants . MANAGEMENT_MINOR_VERSION , ModelType . INT , false ) . setValidator ( new org . jboss . as . controller . operations . validation . IntRangeValidator ( 0 ) ) . build ( ) ; public static final SimpleAttributeDefinition MANAGEMENT_MICRO_VERSION = org . jboss . as . controller . SimpleAttributeDefinitionBuilder . create ( ModelDescriptionConstants . MANAGEMENT_MICRO_VERSION , ModelType . INT , false ) . setValidator ( new org . jboss . as . controller . operations . validation . IntRangeValidator ( 0 ) ) . build ( ) ; public static final SimpleAttributeDefinition PROCESS_TYPE = org . jboss . as . controller . SimpleAttributeDefinitionBuilder . create ( ServerDescriptionConstants . PROCESS_TYPE , ModelType . STRING ) . setStorageRuntime ( ) . setValidator ( DomainRootDefinition . NOT_NULL_STRING_LENGTH_ONE_VALIDATOR ) . build ( ) ; public static final SimpleAttributeDefinition LAUNCH_TYPE = org . jboss . as . controller . SimpleAttributeDefinitionBuilder . create ( ServerDescriptionConstants . LAUNCH_TYPE , ModelType . STRING ) . setValidator ( new org . jboss . as . controller . operations . validation . EnumValidator < org . jboss . as . server . ServerEnvironment . LaunchType > ( org . jboss . as . server . ServerEnvironment . LaunchType . class , false , false ) ) . setStorageRuntime ( ) . build ( ) ; public static final SimpleAttributeDefinition LOCAL_HOST_NAME = org . jboss . as . controller . SimpleAttributeDefinitionBuilder . create ( ModelDescriptionConstants . LOCAL_HOST_NAME , ModelType . STRING , true ) . setValidator ( DomainRootDefinition . NOT_NULL_STRING_LENGTH_ONE_VALIDATOR ) . setStorageRuntime ( ) . build ( ) ; private final DomainController domainController ; private final LocalHostControllerInfo hostControllerInfo ; private final HostControllerEnvironment environment ; private final ExtensibleConfigurationPersister configurationPersister ; private final ContentRepository contentRepo ; private final HostFileRepository fileRepository ; private final boolean isMaster ; private final ExtensionRegistry extensionRegistry ; private final IgnoredDomainResourceRegistry ignoredDomainResourceRegistry ; private final PathManagerService pathManager ; private final DomainControllerRuntimeIgnoreTransformationRegistry runtimeIgnoreTransformationRegistry ; private final DelegatingConfigurableAuthorizer authorizer ; public DomainRootDefinition ( final DomainController domainController , final HostControllerEnvironment environment , final ExtensibleConfigurationPersister configurationPersister , final ContentRepository contentRepo , final HostFileRepository fileRepository , final boolean isMaster , final LocalHostControllerInfo hostControllerInfo , final ExtensionRegistry extensionRegistry , final IgnoredDomainResourceRegistry ignoredDomainResourceRegistry , final PathManagerService pathManager , final DomainControllerRuntimeIgnoreTransformationRegistry runtimeIgnoreTransformationRegistry , final DelegatingConfigurableAuthorizer authorizer ) { } @ Override public void registerAttributes ( ManagementResourceRegistration resourceRegistration ) { } @ Override public void registerOperations ( ManagementResourceRegistration resourceRegistration ) { } @ Override public void registerChildren ( ManagementResourceRegistration resourceRegistration ) { super . registerChildren ( resourceRegistration ) ; resourceRegistration . registerSubModel ( SystemPropertyResourceDefinition . createForDomainOrHost ( DOMAIN ) ) ; resourceRegistration . registerSubModel ( new org . jboss . as . controller . resource . InterfaceDefinition ( InterfaceAddHandler . NAMED_INSTANCE , InterfaceRemoveHandler . INSTANCE , false ) ) ; resourceRegistration . registerSubModel ( CoreManagementResourceDefinition . forDomain ( authorizer ) ) ; resourceRegistration . registerSubModel ( new ProfileResourceDefinition ( extensionRegistry ) ) ; resourceRegistration . registerSubModel ( PathResourceDefinition . createNamed ( pathManager ) ) ; resourceRegistration . registerSubModel ( DomainDeploymentResourceDefinition . createForDomainRoot ( isMaster , contentRepo , fileRepository ) ) ; resourceRegistration . registerSubModel ( new org . jboss . as . server . deploymentoverlay . DeploymentOverlayDefinition ( null , contentRepo , fileRepository ) ) ; <START_BUG> resourceRegistration . registerSubModel ( new ServerGroupResourceDefinition ( isMaster , contentRepo , fileRepository , runtimeIgnoreTransformationRegistry ) ) ; <END_BUG> resourceRegistration . registerSubModel ( new org . jboss . as . controller . resource . SocketBindingGroupResourceDefinition ( SocketBindingGroupAddHandler . INSTANCE , DomainSocketBindingGroupRemoveHandler . INSTANCE , true , SocketBindingResourceDefinition . INSTANCE , RemoteDestinationOutboundSocketBindingResourceDefinition . INSTANCE , LocalDestinationOutboundSocketBindingResourceDefinition . INSTANCE ) ) ; resourceRegistration . registerSubModel ( new org . jboss . as . management . client . content . ManagedDMRContentTypeResourceDefinition ( contentRepo , ModelDescriptionConstants . ROLLOUT_PLAN , PathElement . pathElement ( ModelDescriptionConstants . MANAGEMENT_CLIENT_CONTENT , ModelDescriptionConstants . ROLLOUT_PLANS ) , new DomainRootDefinition . RolloutPlanValidator ( ) , DomainResolver . getResolver ( ModelDescriptionConstants . ROLLOUT_PLANS ) , DomainResolver . getResolver ( ModelDescriptionConstants . ROLLOUT_PLAN ) ) ) ; resourceRegistration . registerSubModel ( new org . jboss . as . controller . extension . ExtensionResourceDefinition ( extensionRegistry , true , false , ( ! ( isMaster ) ) ) ) ; DomainTransformers . initializeDomainRegistry ( extensionRegistry . getTransformerRegistry ( ) ) ; } public void initialize ( ManagementResourceRegistration resourceRegistration ) { } public static class RolloutPlanValidator extends AbstractParameterValidator { private static final List < String > ALLOWED_SERVER_GROUP_CHILDREN = Arrays . asList ( ModelDescriptionConstants . ROLLING_TO_SERVERS , ModelDescriptionConstants . MAX_FAILURE_PERCENTAGE , ModelDescriptionConstants . MAX_FAILED_SERVERS ) ; @ Override public void validateParameter ( String parameterName , ModelNode plan ) throws OperationFailedException { } public static void validateInSeriesServerGroup ( ModelNode serverGroup ) throws OperationFailedException { } } } 
public abstract class AbstractServer { static final Logger log = Logger . getLogger ( "org.jboss.as.server" ) ; private ServerModel config ; private ServiceContainer serviceContainer ; private final ServerEnvironment environment ; protected AbstractServer ( final ServerEnvironment environment ) { } public ServerEnvironment getEnvironment ( ) { } public ServerModel getConfig ( ) { } public abstract void start ( ) throws ServerStartException { } void start ( final ServerModel config ) throws ServerStartException { if ( config == null ) { throw new IllegalArgumentException ( "null<seq2seq4repair_space>standalone<seq2seq4repair_space>config" ) ; } this . config = config ; <START_BUG> AbstractServer . log . infof ( "Starting<seq2seq4repair_space>server<seq2seq4repair_space>'%s'" , config . getServerName ( ) ) ; <END_BUG> serviceContainer = Factory . create ( ) ; final ServerStartupListener listener = new ServerStartupListener ( createListenerCallback ( ) ) ; try { final ServerStartBatchBuilder subsystemBatchBuilder = new ServerStartBatchBuilder ( serviceContainer . batchBuilder ( ) , listener ) ; subsystemBatchBuilder . addListener ( listener ) ; final ServiceActivatorContext subsystemActivatorContext = new org . jboss . msc . service . ServiceActivatorContextImpl ( subsystemBatchBuilder ) ; config . activateSubsystems ( subsystemActivatorContext ) ; listener . startBatch ( new Runnable ( ) { @ Override public void run ( ) { final ServerStartBatchBuilder deploymentBatchBuilder = new ServerStartBatchBuilder ( serviceContainer . batchBuilder ( ) , listener ) ; deploymentBatchBuilder . addListener ( listener ) ; final ServiceActivatorContext deploymentActivatorContext = new org . jboss . msc . service . ServiceActivatorContextImpl ( deploymentBatchBuilder ) ; listener . startBatch ( null ) ; config . activateDeployments ( deploymentActivatorContext ) ; listener . finish ( ) ; try { deploymentBatchBuilder . install ( ) ; listener . finishBatch ( ) ; } catch ( ServiceRegistryException e ) { throw new RuntimeException ( e ) ; } } } ) ; subsystemBatchBuilder . install ( ) ; listener . finishBatch ( ) ; } catch ( Throwable t ) { throw new ServerStartException ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>start<seq2seq4repair_space>server" , t ) ; } } public void stop ( ) { } abstract Callback createListenerCallback ( ) { } } 
void onStart ( ) throws IOException { } public String cfStats ( String newLineSeparator ) { } List < SSTableReader > forceAntiCompaction ( Collection < Range > ranges , InetAddress target ) { } public String getColumnFamilyName ( ) { } private static String getColumnFamilyFromFileName ( String filename ) { } public static int getGenerationFromFileName ( String filename ) { } synchronized String getTempSSTablePath ( ) { } public String getTempSSTableFileName ( ) { } Future < ? > switchMemtable ( Memtable oldMemtable , final boolean writeCommitLog ) throws IOException { } void switchBinaryMemtable ( String key , byte [ ] buffer ) throws IOException { } public void forceFlushIfExpired ( ) throws IOException { } public Future < ? > forceFlush ( ) throws IOException { } void forceBlockingFlush ( ) throws IOException , InterruptedException , ExecutionException { } public void forceFlushBinary ( ) { } Memtable apply ( String key , ColumnFamily columnFamily ) throws IOException { } void applyBinary ( String key , byte [ ] buffer ) throws IOException { } static ColumnFamily removeDeleted ( ColumnFamily cf ) { } public static int getDefaultGCBefore ( ) { } public static ColumnFamily removeDeleted ( ColumnFamily cf , int gcBefore ) { } private static void removeDeletedStandard ( ColumnFamily cf , int gcBefore ) { } private static void removeDeletedSuper ( ColumnFamily cf , int gcBefore ) { } void onMemtableFlush ( CommitLog . CommitLogContext cLogCtx ) throws IOException { } public void addSSTable ( SSTableReader sstable ) { } static Set < List < SSTableReader > > getCompactionBuckets ( Iterable < SSTableReader > files , long min ) { } int doCompaction ( int minThreshold , int maxThreshold ) throws IOException { } void doMajorCompaction ( long skip ) throws IOException { } void doMajorCompactionInternal ( long skip ) throws IOException { } long getExpectedCompactedFileSize ( Iterable < SSTableReader > sstables ) { } SSTableReader getMaxSizeFile ( Iterable < SSTableReader > sstables ) { } List < SSTableReader > doAntiCompaction ( Collection < Range > ranges , InetAddress target ) throws IOException { } void forceCleanup ( ) { } void doCleanupCompaction ( ) throws IOException { } void doCleanup ( SSTableReader sstable ) throws IOException { } List < SSTableReader > doFileAntiCompaction ( Collection < SSTableReader > sstables , final Collection < Range > ranges , InetAddress target ) throws IOException { } private int doFileCompaction ( Collection < SSTableReader > sstables ) throws IOException { } int doFileCompaction ( Collection < SSTableReader > sstables , int gcBefore ) throws IOException { } private void gcAfterRpcTimeout ( ) { } void doReadonlyCompaction ( InetAddress initiator ) throws IOException { } private long getTotalBytes ( Iterable < SSTableReader > sstables ) { } public static List < Memtable > getUnflushedMemtables ( String cfName ) { } static Set < Memtable > getMemtablesPendingFlushNotNull ( String columnFamilyName ) { } Condition submitFlush ( final IFlushable flushable ) { } public boolean isSuper ( ) { } public int getMemtableColumnsCount ( ) { } public int getMemtableDataSize ( ) { } public int getMemtableSwitchCount ( ) { } private Memtable getMemtableThreadSafe ( ) { } public Iterator < DecoratedKey > memtableKeyIterator ( ) throws InterruptedException , ExecutionException { } public Collection < SSTableReader > getSSTables ( ) { } public int getReadCount ( ) { } public double getReadLatency ( ) { } public int getPendingTasks ( ) { } public int getWriteCount ( ) { } public double getWriteLatency ( ) { } public ColumnFamily getColumnFamily ( String key , QueryPath path , byte [ ] start , byte [ ] finish , boolean reversed , int limit ) throws IOException { } public ColumnFamily getColumnFamily ( QueryFilter filter ) throws IOException { } public ColumnFamily getColumnFamily ( QueryFilter filter , int gcBefore ) throws IOException { } private ColumnFamily getColumnFamilyInternal ( QueryFilter filter , int gcBefore ) throws IOException { } public RangeReply getKeyRange ( final String startWith , final String stopAt , int maxResults ) throws IOException , InterruptedException , ExecutionException { } public RangeReply getKeyRangeRaw ( final DecoratedKey startWith , final DecoratedKey stopAt , int maxResults ) throws IOException , InterruptedException , ExecutionException { } public RangeSliceReply getRangeSlice ( byte [ ] super_column , final DecoratedKey startKey , final DecoratedKey finishKey , int keyMax , SliceRange sliceRange , List < byte [ ] > columnNames ) throws IOException , InterruptedException , ExecutionException { RangeReply rr = getKeyRangeRaw ( startKey , finishKey , keyMax ) ; List < Row > rows = new ArrayList < Row > ( rr . keys . size ( ) ) ; final QueryPath queryPath = new QueryPath ( columnFamily_ , super_column , null ) ; final SortedSet < byte [ ] > columnNameSet = new TreeSet < byte [ ] > ( getComparator ( ) ) ; if ( columnNames != null ) columnNameSet . addAll ( columnNames ) ; for ( String key : rr . keys ) { QueryFilter filter = ( sliceRange == null ) ? new NamesQueryFilter ( key , queryPath , columnNameSet ) : new SliceQueryFilter ( key , queryPath , sliceRange . start , sliceRange . finish , sliceRange . reversed , sliceRange . count ) ; rows . add ( new Row ( key , getColumnFamily ( filter ) ) ) ; } <START_BUG> return new RangeSliceReply ( rows , rr . rangeCompletedLocally ) ; <END_BUG> } public AbstractType getComparator ( ) { } public void snapshot ( String snapshotName ) throws IOException { } void clearUnsafe ( ) { } private static class AntiCompactionIterator extends CompactionIterator { public AntiCompactionIterator ( Collection < SSTableReader > sstables , Collection < Range > ranges , int gcBefore , boolean isMajor ) throws IOException { } private static Iterator getCollatedRangeIterator ( Collection < SSTableReader > sstables , final Collection < Range > ranges ) throws IOException { } public void close ( ) throws IOException { } } } 
public class ServerManager extends AbstractMgmtTestBase { private int mgmtPort ; private String mgmtHostName ; public ServerManager ( ) { } public ServerManager ( String mgmtHostName , int mgmtPort ) { } public ServerManager ( String mgmtHostName ) { } public int getMgmtPort ( ) { } public void addConnector ( Connector conn , int port , String keyPEMFile , String certPEMFile , String keyStoreFile , String password ) throws Exception { } private ModelNode getAddSocketBindingOp ( Connector conn , int port ) { } private ModelNode getAddConnectorOp ( Connector conn , String keyPEMFile , String certPEMFile , String keyStoreFile , String password ) { ModelNode op = createOpNode ( ( ( "subsystem=web/connector=test-" + ( conn . getName ( ) ) ) + "-connector" ) , "add" ) ; op . get ( "socket-binding" ) . set ( ( "test-" + ( conn . getName ( ) ) ) ) ; op . get ( "scheme" ) . set ( conn . getScheme ( ) ) ; <START_BUG> op . get ( "protocol" ) . set ( conn . getProtrocol ( ) ) ; <END_BUG> op . get ( "secure" ) . set ( conn . isSecure ( ) ) ; op . get ( "enabled" ) . set ( true ) ; if ( conn . isSecure ( ) ) { ModelNode ssl = new ModelNode ( ) ; if ( conn . equals ( HTTPSNATIVE ) ) { ssl . get ( "certificate-key-file" ) . set ( keyPEMFile ) ; ssl . get ( "certificate-file" ) . set ( certPEMFile ) ; } else { ssl . get ( "certificate-key-file" ) . set ( keyStoreFile ) ; } ssl . get ( "password" ) . set ( password ) ; op . get ( "ssl" ) . set ( ssl ) ; } return op ; } public void removeConnector ( Connector conn , String checkURL ) throws Exception { } private ModelNode getRemoveSocketBindingOp ( Connector conn ) { } private ModelNode getRemoveConnectorOp ( Connector conn ) { } public HashSet < String > getConnectorList ( ) throws Exception { } public void initModelControllerClient ( ) { } } 
public class SSOMutator < V > implements Mutator { private final Cache < String , V > cache ; private final CacheInvoker invoker ; private final String id ; final V value ; public SSOMutator ( Cache < String , V > cache , CacheInvoker invoker , String id , V value ) { } @ Override public void mutate ( ) { <START_BUG> this . invoker . invoke ( this . cache , new MutateOperation < String , V > ( this . id , this . value ) , IGNORE_RETURN_VALUES ) ; <END_BUG> } } 
public class OrRule extends AbstractRule { private final Rule rule1 ; private final Rule rule2 ; private OrRule ( Rule firstParam , Rule secondParam ) { } public static Rule getRule ( Rule firstParam , Rule secondParam ) { } public static Rule getRule ( Stack stack ) { if ( ( stack . size ( ) ) < 2 ) { <START_BUG> throw new IllegalArgumentException ( ( "Invalid<seq2seq4repair_space>OR<seq2seq4repair_space>rule<seq2seq4repair_space>-<seq2seq4repair_space>expected<seq2seq4repair_space>two<seq2seq4repair_space>rules<seq2seq4repair_space>but<seq2seq4repair_space>provided<seq2seq4repair_space>" + ( stack . size ( ) ) ) ) ; <END_BUG> } Object o2 = stack . pop ( ) ; Object o1 = stack . pop ( ) ; if ( ( o2 instanceof Rule ) && ( o1 instanceof Rule ) ) { Rule p2 = ( ( Rule ) ( o2 ) ) ; Rule p1 = ( ( Rule ) ( o1 ) ) ; return new OrRule ( p1 , p2 ) ; } else { throw new IllegalArgumentException ( ( ( ( "Invalid<seq2seq4repair_space>OR<seq2seq4repair_space>rule:<seq2seq4repair_space>" + o2 ) + "..." ) + o1 ) ) ; } } public boolean evaluate ( LoggingEvent event ) { } } 
public class ViewRegistry extends RegistryManager implements IRegistryChangeListener , IViewRegistry { private List views ; private boolean dirtyViews ; private List categories ; private boolean dirtyCategories ; private Category miscCategory ; protected static final String TAG_DESCRIPTION = "description" ; private class ViewRegistryElement { private List viewDescriptors ; private List categoryDescriptors ; public ViewRegistryElement ( ) { } public void addCategory ( Category element ) { } public void addViewDescriptor ( IViewDescriptor element ) { } public List getCategories ( ) { } public List getViewDescriptors ( ) { } } public ViewRegistry ( ) { } public void add ( Category desc ) { } public void add ( IViewDescriptor desc ) { dirtyViews = true ; ViewRegistry . ViewRegistryElement element = new ViewRegistry . ViewRegistryElement ( ) ; element . addViewDescriptor ( desc ) ; <START_BUG> add ( element , desc . getConfigurationElement ( ) . getDeclaringExtension ( ) . getDeclaringPluginDescriptor ( ) . getUniqueIdentifier ( ) ) ; <END_BUG> } public Object buildNewCacheObject ( IExtensionDelta delta ) { } public IViewDescriptor find ( String id ) { } public Category findCategory ( String id ) { } public Category [ ] getCategories ( ) { } public int getCategoryCount ( ) { } public Category getMiscCategory ( ) { } public int getViewCount ( ) { } public IViewDescriptor [ ] getViews ( ) { } public void mapViewsToCategories ( ) { } private void buildViews ( ) { } private void buildCategories ( ) { } public void postChangeProcessing ( ) { } } 
public class IndexManager extends JobManager implements IIndexConstants { public IWorkspace workspace ; public SimpleLookupTable indexNames = new SimpleLookupTable ( ) ; private Map indexes = new HashMap ( 5 ) ; private boolean needToSave = false ; private static final CRC32 checksumCalculator = new CRC32 ( ) ; private IPath javaPluginLocation = null ; private SimpleLookupTable indexStates = null ; private File savedIndexNamesFile = new File ( getJavaPluginWorkingLocation ( ) . append ( "savedIndexNames.txt" ) . toOSString ( ) ) ; public static Integer SAVED_STATE = new Integer ( 0 ) ; public static Integer UPDATING_STATE = new Integer ( 1 ) ; public static Integer UNKNOWN_STATE = new Integer ( 2 ) ; public static Integer REBUILDING_STATE = new Integer ( 3 ) ; public synchronized void aboutToUpdateIndex ( IPath path , Integer newIndexState ) { } public void addBinary ( IFile resource , IPath indexPath ) { } public void addSource ( IFile resource , IPath indexPath ) { } String computeIndexName ( IPath path ) { } public synchronized Index getIndex ( IPath path , boolean reuseExistingFile , boolean createIfMissing ) { } public synchronized Index getIndexForUpdate ( IPath path , boolean reuseExistingFile , boolean createIfMissing ) { } private SimpleLookupTable getIndexStates ( ) { } private IPath getJavaPluginWorkingLocation ( ) { } public void indexDocument ( SearchDocument searchDocument , SearchParticipant searchParticipant , Index index , IPath indexPath ) throws IOException { } public void indexAll ( IProject project ) { } public void indexLibrary ( IPath path , IProject requestingProject ) { } public void indexSourceFolder ( JavaProject javaProject , IPath sourceFolder , final char [ ] [ ] exclusionPattern ) { } public void jobWasCancelled ( IPath path ) { } protected synchronized void moveToNextJob ( ) { } protected void notifyIdle ( long idlingTime ) { } public Index peekAtIndex ( IPath path ) { } public String processName ( ) { } private void rebuildIndex ( String indexName , IPath path ) { } public synchronized Index recreateIndex ( IPath path ) { try { Index index = ( ( Index ) ( this . indexes . get ( path ) ) ) ; <START_BUG> ReadWriteMonitor monitor = index . monitor ; <END_BUG> String indexPath = computeIndexName ( path ) ; if ( JobManager . VERBOSE ) JobManager . verbose ( ( ( ( "-><seq2seq4repair_space>recreating<seq2seq4repair_space>index:<seq2seq4repair_space>" + indexPath ) + "<seq2seq4repair_space>for<seq2seq4repair_space>path:<seq2seq4repair_space>" ) + ( path . toOSString ( ) ) ) ) ; index = new Index ( indexPath , ( "Index<seq2seq4repair_space>for<seq2seq4repair_space>" + ( path . toOSString ( ) ) ) , false ) ; indexes . put ( path , index ) ; index . monitor = monitor ; return index ; } catch ( IOException e ) { if ( JobManager . VERBOSE ) { JobManager . verbose ( ( "-><seq2seq4repair_space>failed<seq2seq4repair_space>to<seq2seq4repair_space>recreate<seq2seq4repair_space>index<seq2seq4repair_space>for<seq2seq4repair_space>path:<seq2seq4repair_space>" + ( path . toOSString ( ) ) ) ) ; e . printStackTrace ( ) ; } return null ; } } public void remove ( String resourceName , IPath indexedContainer ) { } public synchronized void removeIndex ( IPath path ) { } public synchronized void removeIndexFamily ( IPath path ) { } public void removeSourceFolderFromIndex ( JavaProject javaProject , IPath sourceFolder , char [ ] [ ] exclusionPatterns ) { } public void reset ( ) { } public void saveIndex ( Index index ) throws IOException { } public void saveIndexes ( ) { } public void scheduleDocumentIndexing ( final SearchDocument searchDocument , final IPath indexPath , final SearchParticipant searchParticipant ) { } public void shutdown ( ) { } public String toString ( ) { } private char [ ] readIndexState ( ) { } private void updateIndexState ( String indexName , Integer indexState ) { } } 
public class CounterConfigGui extends AbstractPreProcessorGui { private JLabeledTextField startField ; private JLabeledTextField incrField ; private JLabeledTextField endField ; private JLabeledTextField varNameField ; private JCheckBox perUserField ; public CounterConfigGui ( ) { } public String getLabelResource ( ) { } public TestElement createTestElement ( ) { } public void modifyTestElement ( TestElement c ) { if ( c instanceof CounterConfig ) { CounterConfig config = ( ( CounterConfig ) ( c ) ) ; config . setStart ( startField . getText ( ) ) ; <START_BUG> if ( ( endField . getText ( ) . length ( ) ) > 0 ) { <END_BUG> config . setEnd ( endField . getText ( ) ) ; } config . setIncrement ( incrField . getText ( ) ) ; config . setVarName ( varNameField . getText ( ) ) ; config . setIsPerUser ( perUserField . isSelected ( ) ) ; } super . configureTestElement ( c ) ; } public void configure ( TestElement element ) { } private void init ( ) { } } 
public class RemoteProxyControllerProtocolTestCase { final RemoteProxyControllerProtocolTestCase . DelegatingChannelHandler handler = new RemoteProxyControllerProtocolTestCase . DelegatingChannelHandler ( ) ; RemoteChannelPairSetup channels ; @ Before public void start ( ) throws Exception { channels = new RemoteChannelPairSetup ( ) ; channels . setupRemoting ( handler ) ; <START_BUG> channels . startChannels ( ) ; <END_BUG> } @ After public void stop ( ) throws Exception { } @ Test @ Ignore ( "OperationMessageHandlerProxy<seq2seq4repair_space>turned<seq2seq4repair_space>off<seq2seq4repair_space>temporarily" ) public void testOperationMessageHandler ( ) throws Exception { } @ Test public void testOperationControlFailed ( ) throws Exception { } @ Test public void testOperationControlExceptionInController ( ) throws Exception { } @ Test public void testTransactionCommit ( ) throws Exception { } @ Test public void testTransactionRollback ( ) throws Exception { } @ Test public void testAttachmentInputStreams ( ) throws Exception { } @ Test public void testClosesBeforePrepare ( ) throws Exception { } private void assertArrays ( byte [ ] expected , byte [ ] actual ) { } private RemoteProxyController setupProxyHandlers ( RemoteProxyControllerProtocolTestCase . MockModelController controller ) { } private abstract static class MockModelController implements ModelController { protected volatile ModelNode operation ; ModelNode getOperation ( ) { } @ Override public ModelControllerClient createClient ( Executor executor ) { } } private static class CommitProxyOperationControl implements ProxyOperationControl { final AtomicInteger txCompletionStatus = new AtomicInteger ( ( - 1 ) ) ; OperationTransaction tx ; @ Override public void operationPrepared ( OperationTransaction transaction , ModelNode result ) { } @ Override public void operationFailed ( ModelNode response ) { } @ Override public void operationCompleted ( ModelNode response ) { } } private static class TestFuture < T > extends AsyncFutureTask < T > { protected TestFuture ( ) { } void done ( T result ) { } } static class DelegatingChannelHandler implements ManagementMessageHandler { private ManagementMessageHandler delegate ; @ Override public synchronized void handleMessage ( Channel channel , DataInput input , ManagementProtocolHeader header ) throws IOException { } public synchronized void setDelegate ( ManagementMessageHandler delegate ) { } @ Override public void shutdown ( ) { } @ Override public boolean awaitCompletion ( long timeout , TimeUnit unit ) throws InterruptedException { } @ Override public void shutdownNow ( ) { } } } 
class InternalSpelExpressionParser extends TemplateAwareExpressionParser { private String expressionString ; private List < Token > tokenStream ; private int tokenStreamLength ; private int tokenStreamPointer ; private Stack < SpelNodeImpl > constructedNodes = new Stack < SpelNodeImpl > ( ) ; private SpelParserConfiguration configuration ; public InternalSpelExpressionParser ( SpelParserConfiguration configuration ) { } @ Override protected SpelExpression doParseExpression ( String expressionString , ParserContext context ) throws ParseException { } private SpelNodeImpl eatExpression ( ) { } private SpelNodeImpl eatLogicalOrExpression ( ) { } private SpelNodeImpl eatLogicalAndExpression ( ) { } private SpelNodeImpl eatRelationalExpression ( ) { } private SpelNodeImpl eatSumExpression ( ) { } private SpelNodeImpl eatProductExpression ( ) { } private SpelNodeImpl eatPowerExpression ( ) { } private SpelNodeImpl eatUnaryExpression ( ) { } private SpelNodeImpl eatPrimaryExpression ( ) { } private boolean maybeEatNode ( ) { } private SpelNodeImpl maybeEatNonDottedNode ( ) { } private SpelNodeImpl eatDottedNode ( ) { } private boolean maybeEatFunctionOrVar ( ) { } private SpelNodeImpl [ ] maybeEatMethodArgs ( ) { } private void eatConstructorArgs ( List < SpelNodeImpl > accumulatedArguments ) { } private void consumeArguments ( List < SpelNodeImpl > accumulatedArguments ) { } private int positionOf ( Token t ) { } private SpelNodeImpl eatStartNode ( ) { } private boolean maybeEatBeanReference ( ) { } private boolean maybeEatTypeReference ( ) { } private boolean maybeEatNullReference ( ) { if ( peekToken ( IDENTIFIER ) ) { Token nullToken = peekToken ( ) ; <START_BUG> if ( ! ( nullToken . stringValue ( ) . equals ( "null" ) ) ) { <END_BUG> return false ; } nextToken ( ) ; constructedNodes . push ( new org . springframework . expression . spel . ast . NullLiteral ( toPos ( nullToken ) ) ) ; return true ; } return false ; } private boolean maybeEatProjection ( boolean nullSafeNavigation ) { } private boolean maybeEatInlineList ( ) { } private boolean maybeEatIndexer ( ) { } private boolean maybeEatSelection ( boolean nullSafeNavigation ) { } private SpelNodeImpl eatPossiblyQualifiedId ( ) { } private boolean maybeEatMethodOrProperty ( boolean nullSafeNavigation ) { } private boolean maybeEatConstructorReference ( ) { } private void push ( SpelNodeImpl newNode ) { } private SpelNodeImpl pop ( ) { } private boolean maybeEatLiteral ( ) { } private boolean maybeEatParenExpression ( ) { } private Token maybeEatRelationalOperator ( ) { } private Token eatToken ( TokenKind expectedKind ) { } private boolean peekToken ( TokenKind desiredTokenKind ) { } private boolean peekToken ( TokenKind desiredTokenKind , boolean consumeIfMatched ) { } private boolean peekToken ( TokenKind possible1 , TokenKind possible2 ) { } private boolean peekToken ( TokenKind possible1 , TokenKind possible2 , TokenKind possible3 ) { } private boolean peekIdentifierToken ( String identifierString ) { } private boolean peekSelectToken ( ) { } private boolean moreTokens ( ) { } private Token nextToken ( ) { } private Token peekToken ( ) { } private void raiseInternalException ( int pos , SpelMessage message , Object ... inserts ) { } public String toString ( Token t ) { } private void checkRightOperand ( Token token , SpelNodeImpl operandExpression ) { } private int toPos ( Token t ) { } private int toPos ( int start , int end ) { } } 
public class RuntimeMXBeanAttributeHandler extends AbstractPlatformMBeanAttributeHandler { public static RuntimeMXBeanAttributeHandler INSTANCE = new RuntimeMXBeanAttributeHandler ( ) ; private RuntimeMXBeanAttributeHandler ( ) { } @ Override protected void executeReadAttribute ( OperationContext context , ModelNode operation ) throws OperationFailedException { } @ Override protected void executeWriteAttribute ( OperationContext context , ModelNode operation ) throws OperationFailedException { } @ Override protected void register ( ManagementResourceRegistration registration ) { } static void storeResult ( final String name , final ModelNode store ) { if ( ( ( PlatformMBeanUtil . JVM_MAJOR_VERSION ) > 6 ) && ( OBJECT_NAME . equals ( name ) ) ) { store . set ( ManagementFactory . RUNTIME_MXBEAN_NAME ) ; } else if ( NAME . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ) ; } else if ( VM_NAME . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getVmName ( ) ) ; } else if ( VM_VENDOR . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getVmVendor ( ) ) ; } else if ( VM_VERSION . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getVmVersion ( ) ) ; } else if ( SPEC_NAME . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getSpecName ( ) ) ; } else if ( SPEC_VENDOR . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getSpecVendor ( ) ) ; } else if ( SPEC_VERSION . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getSpecVersion ( ) ) ; } else if ( MANAGEMENT_SPEC_VERSION . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getManagementSpecVersion ( ) ) ; } else if ( CLASS_PATH . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getClassPath ( ) ) ; } else if ( LIBRARY_PATH . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getLibraryPath ( ) ) ; } else if ( BOOT_CLASS_PATH_SUPPORTED . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . isBootClassPathSupported ( ) ) ; } else if ( BOOT_CLASS_PATH . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getBootClassPath ( ) ) ; } else if ( INPUT_ARGUMENTS . equals ( name ) ) { store . setEmptyList ( ) ; for ( String arg : ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) ) { store . add ( arg ) ; } } else if ( UPTIME . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getUptime ( ) ) ; } else if ( START_TIME . equals ( name ) ) { store . set ( ManagementFactory . getRuntimeMXBean ( ) . getStartTime ( ) ) ; } else if ( SYSTEM_PROPERTIES . equals ( name ) ) { store . setEmptyObject ( ) ; final TreeMap < String , String > sorted = new TreeMap < String , String > ( ManagementFactory . getRuntimeMXBean ( ) . getSystemProperties ( ) ) ; for ( Map . Entry < String , String > prop : sorted . entrySet ( ) ) { final ModelNode propNode = store . get ( prop . getKey ( ) ) ; if ( ( prop . getValue ( ) ) != null ) { propNode . set ( prop . getValue ( ) ) ; } } } else if ( ( RUNTIME_READ_ATTRIBUTES . contains ( name ) ) || ( RUNTIME_METRICS . contains ( name ) ) ) { <START_BUG> throw new IllegalStateException ( String . format ( "Read<seq2seq4repair_space>support<seq2seq4repair_space>for<seq2seq4repair_space>attribute<seq2seq4repair_space>%s<seq2seq4repair_space>was<seq2seq4repair_space>not<seq2seq4repair_space>properly<seq2seq4repair_space>implemented" , name ) ) ; <END_BUG> } } } 
public abstract class AbstractMoveFolderAction extends AbstractColumbaAction implements Observer , ISelectionListener { private AbstractFolder lastSelectedFolder ; public AbstractMoveFolderAction ( FrameMediator frameMediator , String name ) { } protected abstract boolean isActionEnabledByIndex ( int folderIndex ) { } private void registerSortingObserver ( ) { } public void update ( Observable o , Object arg ) { } private void enableAction ( ) { } private void reenableActionFromSelectedFolder ( ) { if ( ( lastSelectedFolder ) == null ) { setEnabled ( false ) ; } else { IFolderItem item = lastSelectedFolder . getConfiguration ( ) ; <START_BUG> if ( item . get ( "property" , "accessrights" ) . equals ( "user" ) ) { <END_BUG> int index = lastSelectedFolder . getParent ( ) . getIndex ( lastSelectedFolder ) ; setEnabled ( isActionEnabledByIndex ( index ) ) ; } else { setEnabled ( false ) ; } } } public void selectionChanged ( SelectionChangedEvent e ) { } protected AbstractFolder getLastSelectedFolder ( ) { } } 
public class IMAPMailCheckingAction extends AbstractMailCheckingAction { private int accountUid ; public IMAPMailCheckingAction ( AccountItem accountItem ) { } public void check ( ) { } public boolean isCheckAll ( ) { IMAPRootFolder imapRootFolder = ( ( IMAPRootFolder ) ( FolderTreeModel . getInstance ( ) . getImapFolder ( accountUid ) ) ) ; <START_BUG> return ! ( imapRootFolder . getAccountItem ( ) . getImapItem ( ) . getBoolean ( "exclude_from_checkall" , false ) ) ; <END_BUG> } } 
class BufferedDeletes { static final int BYTES_PER_DEL_TERM = ( ( 9 * ( RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ) + ( 7 * ( RamUsageEstimator . NUM_BYTES_OBJECT_HEADER ) ) ) + ( 10 * ( RamUsageEstimator . NUM_BYTES_INT ) ) ; static final int BYTES_PER_DEL_DOCID = ( ( 2 * ( RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ) + ( RamUsageEstimator . NUM_BYTES_OBJECT_HEADER ) ) + ( RamUsageEstimator . NUM_BYTES_INT ) ; static final int BYTES_PER_DEL_QUERY = ( ( ( 5 * ( RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ) + ( 2 * ( RamUsageEstimator . NUM_BYTES_OBJECT_HEADER ) ) ) + ( 2 * ( RamUsageEstimator . NUM_BYTES_INT ) ) ) + 24 ; final AtomicInteger numTermDeletes = new AtomicInteger ( ) ; final Map < Term , Integer > terms = new HashMap < Term , Integer > ( ) ; final Map < Query , Integer > queries = new HashMap < Query , Integer > ( ) ; final List < Integer > docIDs = new ArrayList < Integer > ( ) ; public static final Integer MAX_INT = Integer . valueOf ( Integer . MAX_VALUE ) ; final AtomicLong bytesUsed ; private static final boolean VERBOSE_DELETES = false ; long gen ; public BufferedDeletes ( ) { } BufferedDeletes ( AtomicLong bytesUsed ) { } @ Override public String toString ( ) { if ( BufferedDeletes . VERBOSE_DELETES ) { return ( ( ( ( ( ( ( ( ( ( "gen=" + ( gen ) ) + "<seq2seq4repair_space>numTerms=" ) + ( numTermDeletes ) ) + ",<seq2seq4repair_space>terms=" ) + ( terms ) ) + ",<seq2seq4repair_space>queries=" ) + ( queries ) ) + ",<seq2seq4repair_space>docIDs=" ) + ( docIDs ) ) + ",<seq2seq4repair_space>bytesUsed=" ) + ( bytesUsed ) ; } else { String s = "gen=" + ( gen ) ; if ( ( numTermDeletes . get ( ) ) != 0 ) { <START_BUG> s += ( ( ( ( "<seq2seq4repair_space>" + ( numTermDeletes . get ( ) ) ) + "<seq2seq4repair_space>deleted<seq2seq4repair_space>terms<seq2seq4repair_space>(unique<seq2seq4repair_space>count=" ) + ( terms . size ( ) ) ) + ")<seq2seq4repair_space>terms=" ) + ( terms . keySet ( ) ) ; <END_BUG> } if ( ( queries . size ( ) ) != 0 ) { s += ( "<seq2seq4repair_space>" + ( queries . size ( ) ) ) + "<seq2seq4repair_space>deleted<seq2seq4repair_space>queries" ; } if ( ( docIDs . size ( ) ) != 0 ) { s += ( "<seq2seq4repair_space>" + ( docIDs . size ( ) ) ) + "<seq2seq4repair_space>deleted<seq2seq4repair_space>docIDs" ; } if ( ( bytesUsed . get ( ) ) != 0 ) { s += "<seq2seq4repair_space>bytesUsed=" + ( bytesUsed . get ( ) ) ; } return s ; } } public void addQuery ( Query query , int docIDUpto ) { } public void addDocID ( int docID ) { } public void addTerm ( Term term , int docIDUpto ) { } void clear ( ) { } void clearDocIDs ( ) { } boolean any ( ) { } } 
public class NewHostControllerBootstrap { private static final Logger log = Logger . getLogger ( "org.jboss.as.host.controller" ) ; static final ServiceName SERVICE_NAME_BASE = JBOSS . append ( "host" , "controller" ) ; static final int DEFAULT_POOL_SIZE = 20 ; private final ServiceContainer serviceContainer = Factory . create ( "host-controller" ) ; private final HostControllerEnvironment environment ; private final byte [ ] authCode ; public NewHostControllerBootstrap ( final HostControllerEnvironment environment , final byte [ ] authCode ) { } public void start ( ) throws Exception { final ServiceTarget serviceTarget = serviceContainer ; <START_BUG> final ProcessControllerConnectionService processControllerClient = new ProcessControllerConnectionService ( environment , authCode ) ; <END_BUG> serviceTarget . addService ( SERVICE_NAME , processControllerClient ) . install ( ) ; final ServiceName threadFactoryServiceName = NewHostControllerBootstrap . SERVICE_NAME_BASE . append ( "thread-factory" ) ; final ServiceName executorServiceName = NewHostControllerBootstrap . SERVICE_NAME_BASE . append ( "executor" ) ; serviceTarget . addService ( threadFactoryServiceName , new ThreadFactoryService ( ) ) . install ( ) ; final NewHostControllerBootstrap . HostControllerExecutorService executorService = new NewHostControllerBootstrap . HostControllerExecutorService ( ) ; serviceTarget . addService ( executorServiceName , executorService ) . addDependency ( threadFactoryServiceName , ThreadFactory . class , executorService . threadFactoryValue ) . install ( ) ; AbsolutePathService . addService ( HOME_DIR , environment . getHomeDir ( ) . getAbsolutePath ( ) , serviceTarget ) ; AbsolutePathService . addService ( DOMAIN_CONFIG_DIR , environment . getDomainConfigurationDir ( ) . getAbsolutePath ( ) , serviceTarget ) ; DomainModelControllerService . addService ( serviceTarget , environment , new ControlledProcessState ( false ) ) ; } static final class HostControllerExecutorService implements Service < Executor > { final InjectedValue < ThreadFactory > threadFactoryValue = new InjectedValue < ThreadFactory > ( ) ; private ScheduledExecutorService executorService ; @ Override public synchronized void start ( final StartContext context ) throws StartException { } @ Override public synchronized void stop ( final StopContext context ) { } @ Override public synchronized ScheduledExecutorService getValue ( ) throws IllegalStateException { } } } 
class AppClientServerConfiguration { private AppClientServerConfiguration ( ) { } public static List < ModelNode > serverConfiguration ( final String filePath , final String deploymentName , final String globalModules , final String hostUrl , final List < String > parameters ) { } private static void webservices ( final List < ModelNode > nodes ) { } private static void appclient ( List < ModelNode > nodes , final String filePath , final String deploymentName , final String hostUrl , final List < String > parameters ) { } private static void naming ( List < ModelNode > nodes ) { } private static void ee ( List < ModelNode > nodes , final String globalModules ) { } private static void ejb3 ( List < ModelNode > nodes ) { } private static void security ( List < ModelNode > nodes ) { } private static void jacorb ( List < ModelNode > nodes ) { } private static void transactions ( List < ModelNode > nodes ) { } private static void socketBindings ( List < ModelNode > nodes ) { } private static void interfaces ( List < ModelNode > nodes ) { ModelNode add = new ModelNode ( ) ; add . get ( OP_ADDR ) . set ( new ModelNode ( ) . setEmptyList ( ) ) . add ( INTERFACE , "public" ) ; add . get ( OP ) . set ( ADD ) ; <START_BUG> add . get ( CRITERIA ) . add ( ) . set ( "inet-address" , "127.0.0.1" ) ; <END_BUG> nodes . add ( add ) ; } private static void loadExtension ( List < ModelNode > nodes , String moduleName ) { } } 
@ Deprecated public class LengthNormModifier { public static void main ( String [ ] args ) throws IOException { } private Directory dir ; private Similarity sim ; public LengthNormModifier ( Directory d , Similarity s ) { } public void reSetNorms ( String field ) throws IOException { String fieldName = StringHelper . intern ( field ) ; int [ ] termCounts = new int [ 0 ] ; IndexReader reader = IndexReader . open ( dir , false ) ; try { termCounts = new int [ reader . maxDoc ( ) ] ; Bits delDocs = MultiFields . getDeletedDocs ( reader ) ; DocsEnum docs = null ; Terms terms = MultiFields . getTerms ( reader , field ) ; if ( terms != null ) { TermsEnum termsEnum = terms . iterator ( ) ; while ( ( termsEnum . next ( ) ) != null ) { docs = termsEnum . docs ( delDocs , docs ) ; int doc ; while ( ( doc = docs . nextDoc ( ) ) != ( DocsEnum . NO_MORE_DOCS ) ) { termCounts [ doc ] += docs . freq ( ) ; } } } for ( int d = 0 ; d < ( termCounts . length ) ; d ++ ) { <START_BUG> if ( ! ( reader . isDeleted ( d ) ) ) { <END_BUG> byte norm = Similarity . encodeNorm ( sim . lengthNorm ( fieldName , termCounts [ d ] ) ) ; reader . setNorm ( d , fieldName , norm ) ; } } } finally { reader . close ( ) ; } } } 
public class PageResource extends WizardPage implements Listener { public static final String PAGE_NAME = "DecryptPageResource" ; private Button bOpen = null ; private Button bEchoKeyPassword = null ; private Button bEchoKeystorePassword = null ; private Combo cEncryptionId = null ; private Text tKeystore = null ; private Text tKeystorePassword = null ; private Text tKeyName = null ; private Text tKeyPassword = null ; private IFile file ; private Decryption decryption = null ; private static final int LABELWIDTH = 120 ; public PageResource ( final Decryption decryption , final IFile file ) { } public void createControl ( final Composite parent ) { } private void createPageContent ( final Composite parent ) { } private void determineIds ( ) { String [ ] ids = null ; try { <START_BUG> ids = Utils . getIds ( file , "encryption" ) ; <END_BUG> } catch ( Exception ex ) { ids = new String [ ] { } ; } cEncryptionId . setItems ( ids ) ; cEncryptionId . select ( 0 ) ; } private void addListeners ( ) { } private void updateStatus ( final String message , final int status ) { } private void dialogChanged ( ) { } public void handleEvent ( final Event e ) { } private void echoPassword ( final Event e ) { } private void openKeystore ( ) { } public boolean isPageComplete ( ) { } private void saveDataToModel ( ) { } private void loadSettings ( ) { } private void storeSettings ( ) { } } 
String value = null ; int posEq = name . indexOf ( "=" ) ; if ( posEq > 0 ) { value = name . substring ( ( posEq + 1 ) ) ; name = name . substring ( 0 , posEq ) ; } else if ( i < ( ( args . length ) - 1 ) ) { value = args [ ( ++ i ) ] ; } else { throw new BuildException ( ( "Missing<seq2seq4repair_space>value<seq2seq4repair_space>for<seq2seq4repair_space>property<seq2seq4repair_space>" + name ) ) ; } definedProps . put ( name , value ) ; } else if ( arg . equals ( "-logger" ) ) { if ( ( loggerClassname ) != null ) { throw new BuildException ( ( "Only<seq2seq4repair_space>one<seq2seq4repair_space>logger<seq2seq4repair_space>class<seq2seq4repair_space>may<seq2seq4repair_space>" + "<seq2seq4repair_space>be<seq2seq4repair_space>specified." ) ) ; } try { loggerClassname = args [ ( ++ i ) ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { throw new BuildException ( ( "You<seq2seq4repair_space>must<seq2seq4repair_space>specify<seq2seq4repair_space>a<seq2seq4repair_space>classname<seq2seq4repair_space>when" + "<seq2seq4repair_space>using<seq2seq4repair_space>the<seq2seq4repair_space>-logger<seq2seq4repair_space>argument" ) ) ; } } else if ( arg . equals ( "-inputhandler" ) ) { if ( ( inputHandlerClassname ) != null ) { throw new BuildException ( ( "Only<seq2seq4repair_space>one<seq2seq4repair_space>input<seq2seq4repair_space>handler<seq2seq4repair_space>class<seq2seq4repair_space>may<seq2seq4repair_space>" + "be<seq2seq4repair_space>specified." ) ) ; } try { inputHandlerClassname = args [ ( ++ i ) ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { throw new BuildException ( ( "You<seq2seq4repair_space>must<seq2seq4repair_space>specify<seq2seq4repair_space>a<seq2seq4repair_space>classname<seq2seq4repair_space>when" + ( "<seq2seq4repair_space>using<seq2seq4repair_space>the<seq2seq4repair_space>-inputhandler" + "<seq2seq4repair_space>argument" ) ) ) ; } } else if ( arg . equals ( "-emacs" ) ) { emacsMode = true ; } else if ( arg . equals ( "-projecthelp" ) ) { projectHelp = true ; } else if ( arg . equals ( "-find" ) ) { if ( i < ( ( args . length ) - 1 ) ) { searchForThis = args [ ( ++ i ) ] ; } else { searchForThis = Main . DEFAULT_BUILD_FILENAME ; } } else if ( arg . startsWith ( "-propertyfile" ) ) { try { propertyFiles . addElement ( args [ ( i + 1 ) ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You<seq2seq4repair_space>must<seq2seq4repair_space>specify<seq2seq4repair_space>a<seq2seq4repair_space>property<seq2seq4repair_space>filename<seq2seq4repair_space>when<seq2seq4repair_space>" + "using<seq2seq4repair_space>the<seq2seq4repair_space>-propertyfile<seq2seq4repair_space>argument" ; throw new BuildException ( msg ) ; } } else if ( ( arg . equals ( "-k" ) ) || ( arg . equals ( "-keep-going" ) ) ) { keepGoingMode = true ; } else if ( arg . startsWith ( "-" ) ) { String msg = "Unknown<seq2seq4repair_space>argument:<seq2seq4repair_space>" + arg ; System . out . println ( msg ) ; Main . printUsage ( ) ; throw new BuildException ( "" ) ; } else { targets . addElement ( arg ) ; } } if ( ( buildFile ) == null ) { if ( searchForThis != null ) { buildFile = findBuildFile ( System . getProperty ( "user.dir" ) , searchForThis ) ; } else { buildFile = new File ( Main . DEFAULT_BUILD_FILENAME ) ; } } if ( ! ( buildFile . exists ( ) ) ) { System . out . println ( ( ( "Buildfile:<seq2seq4repair_space>" + ( buildFile ) ) + "<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>exist!" ) ) ; throw new BuildException ( "Build<seq2seq4repair_space>failed" ) ; } if ( buildFile . isDirectory ( ) ) { System . out . println ( ( ( "What?<seq2seq4repair_space>Buildfile:<seq2seq4repair_space>" + ( buildFile ) ) + "<seq2seq4repair_space>is<seq2seq4repair_space>a<seq2seq4repair_space>dir!" ) ) ; throw new BuildException ( "Build<seq2seq4repair_space>failed" ) ; } for ( int propertyFileIndex = 0 ; propertyFileIndex < ( propertyFiles . size ( ) ) ; propertyFileIndex ++ ) { String filename = ( ( String ) ( propertyFiles . elementAt ( propertyFileIndex ) ) ) ; Properties props = new Properties ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( filename ) ; props . load ( fis ) ; } catch ( IOException e ) { System . out . println ( ( ( ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>load<seq2seq4repair_space>property<seq2seq4repair_space>file<seq2seq4repair_space>" + filename ) + ":<seq2seq4repair_space>" ) + ( e . getMessage ( ) ) ) ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { } } } Enumeration propertyNames = props . propertyNames ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String name = ( ( String ) ( propertyNames . nextElement ( ) ) ) ; if ( ( definedProps . getProperty ( name ) ) == null ) { definedProps . put ( name , props . getProperty ( name ) ) ; } } } if ( ( msgOutputLevel ) >= ( Project . MSG_INFO ) ) { System . out . println ( ( "Buildfile:<seq2seq4repair_space>" + ( buildFile ) ) ) ; } if ( logTo != null ) { Main . out = logTo ; Main . err = logTo ; System . setOut ( Main . out ) ; <START_BUG> System . setErr ( Main . out ) ; <END_BUG> } readyToRun = true ; } private File getParentFile ( File file ) { } private File findBuildFile ( String start , String suffix ) throws BuildException { } private void runBuild ( ClassLoader coreLoader ) throws BuildException { } protected void addBuildListeners ( Project project ) { } private void addInputHandler ( Project project ) throws BuildException { } private BuildLogger createLogger ( ) { } private static void printUsage ( ) { } private static void printVersion ( ) throws BuildException { } private static String antVersion = null ; public static synchronized String getAntVersion ( ) throws BuildException { } private static void printDescription ( Project project ) { } private static void printTargets ( Project project , boolean printSubTargets ) { } private static int findTargetPosition ( Vector names , String name ) { } private static void printTargets ( Project project , Vector names , Vector descriptions , String heading , int maxlen ) { } } 
public class PlatformMBeanResourceUnitTestCase { private static ServiceContainer container ; private static ModelController controller ; private static ModelControllerClient client ; @ BeforeClass public static void setupController ( ) throws InterruptedException { } @ AfterClass public static void shutdownServiceContainer ( ) { } @ Test public void testRootResource ( ) throws IOException { } @ Test public void testBufferPoolMXBean ( ) throws IOException { } @ Test public void testClassLoadingMXBean ( ) throws IOException { } @ Test public void testCompilationMXBean ( ) throws IOException { } @ Test public void testGarbageCollectorMXBean ( ) throws IOException { } @ Test public void testMemoryMXBean ( ) throws IOException { } @ Test public void testMemoryManagerMXBean ( ) throws IOException { } @ Test public void testMemoryPoolMXBean ( ) throws IOException { } @ Test public void testOperatingSystemMXBean ( ) throws IOException { } @ Ignore ( "[AS7-2185]" ) @ Test public void testPlatformLoggingMXBean ( ) throws IOException { } @ Test public void testRuntimeMXBean ( ) throws IOException { } @ Test public void testThreadingMXBean ( ) throws IOException { } private long findMainThread ( ModelNode result ) { } private List < ModelNode > rootWithNamedChildResourceTest ( final String childType ) throws IOException { } private PlatformMBeanResourceUnitTestCase . DescribedResource basicResourceTest ( final String type , final String name ) throws IOException { } private void validateResource ( ModelNode description , ModelNode resource ) { } private ModelNode executeOp ( ModelNode op , boolean expectFailure ) throws IOException { ModelNode response = PlatformMBeanResourceUnitTestCase . client . execute ( op ) ; if ( expectFailure ) { Assert . assertEquals ( FAILED , response . get ( OUTCOME ) . asString ( ) ) ; return response . get ( FAILURE_DESCRIPTION ) ; } else { <START_BUG> Assert . assertEquals ( SUCCESS , response . get ( OUTCOME ) . asString ( ) ) ; <END_BUG> return response . get ( RESULT ) ; } } private static ModelNode getOperation ( final String opName , final String type , final String name ) { } private static ModelNode getAddress ( final String type , final String name ) { } private static class DescribedResource { final ModelNode description ; final ModelNode resource ; public DescribedResource ( ModelNode description , ModelNode resource ) { } } } 
) ; throw new DOMException ( DOMException . NOT_SUPPORTED_ERR , msg ) ; } } else if ( name . equalsIgnoreCase ( DOM_ELEMENT_CONTENT_WHITESPACE ) ) { if ( ! state ) { String msg = DOMMessageFormatter . formatMessage ( DOM_DOMAIN , "FEATURE_NOT_SUPPORTED" , new Object [ ] { name } ) ; throw new DOMException ( DOMException . NOT_SUPPORTED_ERR , msg ) ; } } else if ( name . equalsIgnoreCase ( DOMConfigurationImpl . SEND_PSVI ) ) { if ( ! state ) { String msg = DOMMessageFormatter . formatMessage ( DOM_DOMAIN , "FEATURE_NOT_SUPPORTED" , new Object [ ] { name } ) ; throw new DOMException ( DOMException . NOT_SUPPORTED_ERR , msg ) ; } } else if ( name . equalsIgnoreCase ( DOM_PSVI ) ) { features = ( ( short ) ( ( state ) ? ( features ) | ( DOMConfigurationImpl . PSVI ) : ( features ) & ( ~ ( DOMConfigurationImpl . PSVI ) ) ) ) ; } else { found = false ; } } if ( ( ! found ) || ( ! ( value instanceof Boolean ) ) ) { found = true ; if ( name . equalsIgnoreCase ( DOM_ERROR_HANDLER ) ) { if ( ( value instanceof DOMErrorHandler ) || ( value == null ) ) { fErrorHandlerWrapper . setErrorHandler ( ( ( DOMErrorHandler ) ( value ) ) ) ; setErrorHandler ( fErrorHandlerWrapper ) ; } else { String msg = DOMMessageFormatter . formatMessage ( DOM_DOMAIN , "TYPE_MISMATCH_ERR" , new Object [ ] { name } ) ; throw new DOMException ( DOMException . TYPE_MISMATCH_ERR , msg ) ; } } else if ( name . equalsIgnoreCase ( DOM_RESOURCE_RESOLVER ) ) { if ( ( value instanceof LSResourceResolver ) || ( value == null ) ) { try { setEntityResolver ( new DOMEntityResolverWrapper ( ( ( LSResourceResolver ) ( value ) ) ) ) ; } catch ( XMLConfigurationException e ) { } } else { String msg = DOMMessageFormatter . formatMessage ( DOM_DOMAIN , "TYPE_MISMATCH_ERR" , new Object [ ] { name } ) ; throw new DOMException ( DOMException . TYPE_MISMATCH_ERR , msg ) ; } } else if ( name . equalsIgnoreCase ( DOM_SCHEMA_LOCATION ) ) { if ( ( value instanceof String ) || ( value == null ) ) { try { setProperty ( ( ( Constants . JAXP_PROPERTY_PREFIX ) + ( Constants . SCHEMA_SOURCE ) ) , value ) ; } catch ( XMLConfigurationException e ) { } } else { String msg = DOMMessageFormatter . formatMessage ( DOM_DOMAIN , "TYPE_MISMATCH_ERR" , new Object [ ] { name } ) ; throw new DOMException ( DOMException . TYPE_MISMATCH_ERR , msg ) ; } } else if ( name . equalsIgnoreCase ( DOM_SCHEMA_TYPE ) ) { if ( ( value instanceof String ) || ( value == null ) ) { try { if ( value == null ) { setProperty ( ( ( Constants . JAXP_PROPERTY_PREFIX ) + ( Constants . SCHEMA_LANGUAGE ) ) , null ) ; } else if ( value . equals ( NS_XMLSCHEMA ) ) { setProperty ( ( ( Constants . JAXP_PROPERTY_PREFIX ) + ( Constants . SCHEMA_LANGUAGE ) ) , NS_XMLSCHEMA ) ; } else if ( value . equals ( NS_DTD ) ) { setProperty ( ( ( Constants . JAXP_PROPERTY_PREFIX ) + ( Constants . SCHEMA_LANGUAGE ) ) , NS_DTD ) ; } } catch ( XMLConfigurationException e ) { } } else { String msg = DOMMessageFormatter . formatMessage ( DOM_DOMAIN , "TYPE_MISMATCH_ERR" , new Object [ ] { name } ) ; throw new DOMException ( DOMException . TYPE_MISMATCH_ERR , msg ) ; } } else if ( name . equalsIgnoreCase ( DOMConfigurationImpl . ENTITY_RESOLVER ) ) { if ( ( value instanceof XMLEntityResolver ) || ( value == null ) ) { try { setEntityResolver ( ( ( XMLEntityResolver ) ( value ) ) ) ; } catch ( XMLConfigurationException e ) { } } else { String msg = DOMMessageFormatter . formatMessage ( DOM_DOMAIN , "TYPE_MISMATCH_ERR" , new Object [ ] { name } ) ; throw new DOMException ( DOMException . TYPE_MISMATCH_ERR , msg ) ; } } else if ( name . equalsIgnoreCase ( DOMConfigurationImpl . SYMBOL_TABLE ) ) { if ( value instanceof SymbolTable ) { setProperty ( DOMConfigurationImpl . SYMBOL_TABLE , value ) ; } else { String msg = DOMMessageFormatter . formatMessage ( DOM_DOMAIN , "TYPE_MISMATCH_ERR" , new Object [ ] { name } ) ; throw new DOMException ( DOMException . TYPE_MISMATCH_ERR , msg ) ; } } else if ( name . equalsIgnoreCase ( DOMConfigurationImpl . GRAMMAR_POOL ) ) { <START_BUG> if ( value instanceof XMLGrammarPool ) { <END_BUG> setProperty ( DOMConfigurationImpl . GRAMMAR_POOL , value ) ; } else { String msg = DOMMessageFormatter . formatMessage ( DOM_DOMAIN , "TYPE_MISMATCH_ERR" , new Object [ ] { name } ) ; throw new DOMException ( DOMException . TYPE_MISMATCH_ERR , msg ) ; } } else { String msg = DOMMessageFormatter . formatMessage ( DOM_DOMAIN , "FEATURE_NOT_FOUND" , new Object [ ] { name } ) ; throw new DOMException ( DOMException . NOT_FOUND_ERR , msg ) ; } } } public Object getParameter ( String name ) throws DOMException { } public boolean canSetParameter ( String name , Object value ) { } public DOMStringList getParameterNames ( ) { } protected void reset ( ) throws XNIException { } protected void checkProperty ( String propertyId ) throws XMLConfigurationException { } protected void addComponent ( XMLComponent component ) { } protected ValidationManager createValidationManager ( ) { } protected final void setDTDValidatorFactory ( String version ) { } } 
public abstract class Driver20 extends InternalDriver implements Driver { private static final String [ ] BOOLEAN_CHOICES = new String [ ] { "false" , "true" } ; private Class antiGCDriverManager ; public void boot ( boolean create , Properties properties ) throws StandardException { } public void stop ( ) { } public EmbedResultSet newEmbedResultSet ( EmbedConnection conn , ResultSet results , boolean forMetaData , EmbedStatement statement , boolean isAtomic ) throws SQLException { } public abstract BrokeredConnection newBrokeredConnection ( BrokeredConnectionControl control ) { } public DriverPropertyInfo [ ] getPropertyInfo ( String url , Properties info ) throws SQLException { if ( info != null ) { if ( Boolean . valueOf ( info . getProperty ( SHUTDOWN_ATTR ) ) . booleanValue ( ) ) { return new DriverPropertyInfo [ 0 ] ; } } String dbname = InternalDriver . getDatabaseName ( url , info ) ; FormatableProperties finfo = getAttributes ( url , info ) ; info = null ; boolean encryptDB = Boolean . valueOf ( finfo . getProperty ( DATA_ENCRYPTION ) ) . booleanValue ( ) ; String encryptpassword = finfo . getProperty ( BOOT_PASSWORD ) ; <START_BUG> if ( ( ( dbname . length ( ) ) == 0 ) || ( encryptDB = true && ( encryptpassword == null ) ) ) { <END_BUG> String [ ] [ ] connStringAttributes = new String [ ] [ ] { new String [ ] { Attribute . DBNAME_ATTR , MessageId . CONN_DATABASE_IDENTITY } , new String [ ] { Attribute . CRYPTO_PROVIDER , MessageId . CONN_CRYPTO_PROVIDER } , new String [ ] { Attribute . CRYPTO_ALGORITHM , MessageId . CONN_CRYPTO_ALGORITHM } , new String [ ] { Attribute . CRYPTO_KEY_LENGTH , MessageId . CONN_CRYPTO_KEY_LENGTH } , new String [ ] { Attribute . CRYPTO_EXTERNAL_KEY , MessageId . CONN_CRYPTO_EXTERNAL_KEY } , new String [ ] { Attribute . TERRITORY , MessageId . CONN_LOCALE } , new String [ ] { Attribute . COLLATION , MessageId . CONN_COLLATION } , new String [ ] { Attribute . USERNAME_ATTR , MessageId . CONN_USERNAME_ATTR } , new String [ ] { Attribute . LOG_DEVICE , MessageId . CONN_LOG_DEVICE } , new String [ ] { Attribute . ROLL_FORWARD_RECOVERY_FROM , MessageId . CONN_ROLL_FORWARD_RECOVERY_FROM } , new String [ ] { Attribute . CREATE_FROM , MessageId . CONN_CREATE_FROM } , new String [ ] { Attribute . RESTORE_FROM , MessageId . CONN_RESTORE_FROM } } ; String [ ] [ ] connBooleanAttributes = new String [ ] [ ] { new String [ ] { Attribute . SHUTDOWN_ATTR , MessageId . CONN_SHUT_DOWN_CLOUDSCAPE } , new String [ ] { Attribute . DEREGISTER_ATTR , MessageId . CONN_DEREGISTER_AUTOLOADEDDRIVER } , new String [ ] { Attribute . CREATE_ATTR , MessageId . CONN_CREATE_DATABASE } , new String [ ] { Attribute . DATA_ENCRYPTION , MessageId . CONN_DATA_ENCRYPTION } , new String [ ] { Attribute . UPGRADE_ATTR , MessageId . CONN_UPGRADE_DATABASE } } ; String [ ] [ ] connStringSecretAttributes = new String [ ] [ ] { new String [ ] { Attribute . BOOT_PASSWORD , MessageId . CONN_BOOT_PASSWORD } , new String [ ] { Attribute . PASSWORD_ATTR , MessageId . CONN_PASSWORD_ATTR } } ; DriverPropertyInfo [ ] optionsNoDB = new DriverPropertyInfo [ ( ( connStringAttributes . length ) + ( connBooleanAttributes . length ) ) + ( connStringSecretAttributes . length ) ] ; int attrIndex = 0 ; for ( int i = 0 ; i < ( connStringAttributes . length ) ; i ++ , attrIndex ++ ) { optionsNoDB [ attrIndex ] = new DriverPropertyInfo ( connStringAttributes [ i ] [ 0 ] , finfo . getProperty ( connStringAttributes [ i ] [ 0 ] ) ) ; optionsNoDB [ attrIndex ] . description = MessageService . getTextMessage ( connStringAttributes [ i ] [ 1 ] ) ; } optionsNoDB [ 0 ] . choices = Monitor . getMonitor ( ) . getServiceList ( DATABASE_MODULE ) ; optionsNoDB [ 0 ] . value = dbname ; for ( int i = 0 ; i < ( connStringSecretAttributes . length ) ; i ++ , attrIndex ++ ) { optionsNoDB [ attrIndex ] = new DriverPropertyInfo ( connStringSecretAttributes [ i ] [ 0 ] , ( ( finfo . getProperty ( connStringSecretAttributes [ i ] [ 0 ] ) ) == null ? "" : "****" ) ) ; optionsNoDB [ attrIndex ] . description = MessageService . getTextMessage ( connStringSecretAttributes [ i ] [ 1 ] ) ; } for ( int i = 0 ; i < ( connBooleanAttributes . length ) ; i ++ , attrIndex ++ ) { optionsNoDB [ attrIndex ] = new DriverPropertyInfo ( connBooleanAttributes [ i ] [ 0 ] , Boolean . valueOf ( ( finfo == null ? "" : finfo . getProperty ( connBooleanAttributes [ i ] [ 0 ] ) ) ) . toString ( ) ) ; optionsNoDB [ attrIndex ] . description = MessageService . getTextMessage ( connBooleanAttributes [ i ] [ 1 ] ) ; optionsNoDB [ attrIndex ] . choices = Driver20 . BOOLEAN_CHOICES ; } return optionsNoDB ; } return new DriverPropertyInfo [ 0 ] ; } public void checkSystemPrivileges ( String user , Permission perm ) throws Exception { } } 
@ RunAsClient @ RunWith ( Arquillian . class ) public class DeploymentTestCase { private static final long TIMEOUT = 10000 ; private static final String WAR_JBOSS_FILE = "jboss-web.xml" ; private static final String JAR_JBOSS_FILE = "jboss.xml" ; private static final String EAR_JBOSS_FILE = "jboss-app.xml" ; @ ArquillianResource private ManagementClient managementClient ; @ Deployment public static Archive < ? > fakeDeployment ( ) { } @ Test public void testDeployUndeployEAR ( ) throws Exception { } private DeploymentManager getDeploymentManager ( ) throws Exception { } private ProgressObject jsr88Deploy ( DeploymentManager manager , Archive < ? > archive ) throws Exception { } private ProgressObject jsr88Undeploy ( DeploymentManager manager , TargetModuleID [ ] resultTargetModuleIDs ) throws Exception { } private StateType awaitCompletion ( ProgressObject progress , long timeout ) throws InterruptedException { } private void assertServletAccess ( String context ) throws IOException { <START_BUG> URL servletURL = new URL ( ( "http://localhost:8080/" + context ) ) ; <END_BUG> BufferedReader br = new BufferedReader ( new InputStreamReader ( servletURL . openStream ( ) ) ) ; String message = br . readLine ( ) ; assertEquals ( "Hello<seq2seq4repair_space>World!" , message ) ; } private InputStream createDeploymentPlan ( String deploymentFile ) throws Exception { } private Archive < ? > getWebArchive ( ) { } private Archive < ? > getEjbArchive ( ) { } private Archive < ? > getEarArchive ( ) { } } 
abstract class AbstractTrie < K , V > extends AbstractMap < K , V > implements Serializable , Trie < K , V > { private static final long serialVersionUID = 5826987063535505652L ; protected final KeyAnalyzer < ? super K > keyAnalyzer ; public AbstractTrie ( final KeyAnalyzer < ? super K > keyAnalyzer ) { } public KeyAnalyzer < ? super K > getKeyAnalyzer ( ) { } public K selectKey ( final K key ) { } public V selectValue ( final K key ) { } @ Override public String toString ( ) { } @ SuppressWarnings ( "unchecked" ) final K castKey ( final Object key ) { } final int lengthInBits ( final K key ) { } final int bitsPerElement ( ) { } final boolean isBitSet ( final K key , final int bitIndex , final int lengthInBits ) { } final int bitIndex ( final K key , final K foundKey ) { } final boolean compareKeys ( final K key , final K other ) { if ( key == null ) { return other == null ; } else if ( other == null ) { <START_BUG> return key == null ; <END_BUG> } return ( keyAnalyzer . compare ( key , other ) ) == 0 ; } static boolean compare ( final Object a , final Object b ) { } abstract static class BasicEntry < K , V > implements Serializable , Map . Entry < K , V > { private static final long serialVersionUID = - 944364551314110330L ; protected K key ; protected V value ; private final int hashCode ; public BasicEntry ( final K key ) { } public BasicEntry ( final K key , final V value ) { } public V setKeyValue ( final K key , final V value ) { } public K getKey ( ) { } public V getValue ( ) { } public V setValue ( final V value ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( final Object o ) { } @ Override public String toString ( ) { } } } 
public class Submitter { public static final int STOCK_LEVEL = 0 ; public static final int ORDER_STATUS_BY_NAME = 1 ; public static final int ORDER_STATUS_BY_ID = 2 ; public static final int PAYMENT_BY_NAME = 3 ; public static final int PAYMENT_BY_ID = 4 ; public static final int DELIVERY_SCHEDULE = 5 ; public static final int NEW_ORDER = 6 ; public static final int NEW_ORDER_ROLLBACK = 7 ; private final Display display ; private final Operations ops ; private final OERandom rand ; private final short maxW ; private final int [ ] transactionCount ; public static OERandom getRuntimeRandom ( Connection conn ) throws SQLException { } public static Submitter stockLevelOnly ( Display display , Operations ops , OERandom rand , short maxW ) { } public static Submitter orderStatusByIdOnly ( Display display , Operations ops , OERandom rand , short maxW ) { } public static Submitter orderStatusByNameOnly ( Display display , Operations ops , OERandom rand , short maxW ) { } public static Submitter paymentByIdOnly ( Display display , Operations ops , OERandom rand , short maxW ) { } public static Submitter paymentByNameOnly ( Display display , Operations ops , OERandom rand , short maxW ) { } public static Submitter newOrderOnly ( Display display , Operations ops , OERandom rand , short maxW ) { } public Submitter ( Display display , Operations ops , OERandom rand , short maxW ) { } public void clearTransactionCount ( ) { } public long runTransactions ( final Object displayData , final int count ) throws Exception { } public void runTransaction ( final Object displayData ) throws Exception { } protected int mixType ( final int chooseType ) { } protected void runNewOrder ( Object displayData , boolean forRollback ) throws Exception { short homeWarehouse = warehouse ( ) ; final int orderItemCount = rand . randomInt ( 5 , 15 ) ; int [ ] items = new int [ orderItemCount ] ; short [ ] quantities = new short [ orderItemCount ] ; short [ ] supplyW = new short [ orderItemCount ] ; for ( int i = 0 ; i < orderItemCount ; i ++ ) { items [ i ] = rand . NURand8191 ( ) ; if ( ( ( maxW ) == 1 ) || ( ( rand . randomInt ( 1 , 100 ) ) > 1 ) ) { supplyW [ i ] = homeWarehouse ; } else { short sw = warehouse ( ) ; while ( sw == homeWarehouse ) sw = warehouse ( ) ; supplyW [ i ] = sw ; } supplyW [ i ] = ( ( rand . randomInt ( 1 , 100 ) ) > 1 ) ? homeWarehouse : warehouse ( ) ; quantities [ i ] = ( ( short ) ( rand . randomInt ( 1 , 10 ) ) ) ; } if ( forRollback ) { <START_BUG> items [ orderItemCount ] = 2334432 ; <END_BUG> } ops . newOrder ( display , displayData , homeWarehouse , rand . district ( ) , rand . NURand1023 ( ) , items , quantities , supplyW ) ; } protected void runScheduleDelivery ( Object displayData ) { } protected void runPayment ( Object displayData , boolean byName ) throws Exception { } private final short warehouse ( ) { } protected void runStockLevel ( Object displayData ) throws Exception { } protected void runOrderStatus ( Object displayData , boolean byName ) throws Exception { } public void printReport ( PrintStream out ) { } private String transactionCount ( String name , int count , int total ) { } private String percent ( int count , int total ) { } public int [ ] getTransactionCount ( ) { } } 
public class TestCalendarFields extends BaseKernelTest { public TestCalendarFields ( String name ) { } public void setUp ( ) { } public void testFieldDefaultTimeZone ( ) { } public void testTimeZoneEquals ( ) { CalendarFields c1 = new CalendarFields ( ) ; CalendarFields c2 = new CalendarFields ( ) ; assertTimeZonesEquals ( c1 , c2 ) ; OpenJPAEntityManager pm ; pm = getPM ( ) ; startTx ( pm ) ; pm . persist ( c2 ) ; int id2 = c2 . getId ( ) ; assertTimeZonesEquals ( c1 , c2 ) ; endTx ( pm ) ; assertTimeZonesEquals ( c1 , c2 ) ; endEm ( pm ) ; pm = getPM ( ) ; c2 = ( ( CalendarFields ) ( pm . find ( CalendarFields . class , id2 ) ) ) ; assertTimeZonesEquals ( c1 , c2 ) ; <START_BUG> assertTimeZonesEquals ( c1 , ( ( CalendarFields ) ( pm . detach ( c2 ) ) ) ) ; <END_BUG> endEm ( pm ) ; } public void testCalendarQuery ( ) { } private static Calendar newCalendar ( Date date , String tz ) { } public void testMutateCalendarDirties ( ) { } private static void setTimeInMillis ( Calendar cal , long millis ) { } private void assertTimeZonesEquals ( CalendarFields c1 , CalendarFields c2 ) { } } 
public class Argument extends LocalDeclaration { private static final char [ ] SET = "set" . toCharArray ( ) ; public Argument ( char [ ] name , long posNom , TypeReference tr , int modifiers ) { } public void bind ( MethodScope scope , TypeBinding typeBinding , boolean used ) { } public int getKind ( ) { } public boolean isVarArgs ( ) { } public StringBuffer print ( int indent , StringBuffer output ) { } public StringBuffer printStatement ( int indent , StringBuffer output ) { } public TypeBinding resolveForCatch ( BlockScope scope ) { TypeBinding exceptionType = this . type . resolveType ( scope , true ) ; boolean hasError ; if ( exceptionType == null ) { hasError = true ; } else { hasError = false ; switch ( exceptionType . kind ( ) ) { case Binding . PARAMETERIZED_TYPE : if ( exceptionType . isBoundParameterizedType ( ) ) { hasError = true ; scope . problemReporter ( ) . invalidParameterizedExceptionType ( exceptionType , this ) ; } break ; case Binding . TYPE_PARAMETER : scope . problemReporter ( ) . invalidTypeVariableAsException ( exceptionType , this ) ; hasError = true ; break ; case Binding . ARRAY_TYPE : if ( ( ( ( ArrayBinding ) ( exceptionType ) ) . leafComponentType ) == ( TypeBinding . VOID ) ) { scope . problemReporter ( ) . variableTypeCannotBeVoidArray ( this ) ; hasError = true ; } break ; } <START_BUG> if ( ( exceptionType . findSuperTypeOriginatingFrom ( TypeIds . T_JavaLangThrowable , true ) ) == null ) { <END_BUG> scope . problemReporter ( ) . cannotThrowType ( this . type , exceptionType ) ; hasError = true ; } } Binding existingVariable = scope . getBinding ( name , Binding . VARIABLE , this , false ) ; if ( ( existingVariable != null ) && ( existingVariable . isValidBinding ( ) ) ) { if ( ( existingVariable instanceof LocalVariableBinding ) && ( ( this . hiddenVariableDepth ) == 0 ) ) { scope . problemReporter ( ) . redefineArgument ( this ) ; } else { scope . problemReporter ( ) . localVariableHiding ( this , existingVariable , false ) ; } } this . binding = new LocalVariableBinding ( this , exceptionType , modifiers , false ) ; ASTNode . resolveAnnotations ( scope , this . annotations , this . binding ) ; scope . addLocalVariable ( binding ) ; binding . setConstant ( Constant . NotAConstant ) ; if ( hasError ) return null ; return exceptionType ; } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } public void traverse ( ASTVisitor visitor , ClassScope scope ) { } } 
@ ThreadLeakScope ( Scope . NONE ) public class HdfsLockFactoryTest extends SolrTestCaseJ4 { private static MiniDFSCluster dfsCluster ; @ BeforeClass public static void beforeClass ( ) throws Exception { } @ AfterClass public static void afterClass ( ) throws Exception { } @ Before public void setUp ( ) throws Exception { } @ After public void tearDown ( ) throws Exception { } @ Test public void testBasic ( ) throws IOException { URI uri = HdfsLockFactoryTest . dfsCluster . getURI ( ) ; Path lockPath = new Path ( uri . toString ( ) , "/basedir/lock" ) ; HdfsLockFactory lockFactory = new HdfsLockFactory ( lockPath , new Configuration ( ) ) ; Lock lock = lockFactory . makeLock ( "testlock" ) ; boolean success = lock . obtain ( ) ; assertTrue ( "We<seq2seq4repair_space>could<seq2seq4repair_space>not<seq2seq4repair_space>get<seq2seq4repair_space>the<seq2seq4repair_space>lock<seq2seq4repair_space>when<seq2seq4repair_space>it<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>available" , success ) ; success = lock . obtain ( ) ; assertFalse ( "We<seq2seq4repair_space>got<seq2seq4repair_space>the<seq2seq4repair_space>lock<seq2seq4repair_space>but<seq2seq4repair_space>it<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>unavailble" , success ) ; <START_BUG> lock . release ( ) ; <END_BUG> success = lock . obtain ( ) ; assertTrue ( "We<seq2seq4repair_space>could<seq2seq4repair_space>not<seq2seq4repair_space>get<seq2seq4repair_space>the<seq2seq4repair_space>lock<seq2seq4repair_space>when<seq2seq4repair_space>it<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>available" , success ) ; success = lock . obtain ( ) ; assertFalse ( "We<seq2seq4repair_space>got<seq2seq4repair_space>the<seq2seq4repair_space>lock<seq2seq4repair_space>but<seq2seq4repair_space>it<seq2seq4repair_space>should<seq2seq4repair_space>be<seq2seq4repair_space>unavailble" , success ) ; } } 
public final class RemotingExtension implements Extension { private static final SubsystemFactory < RemotingSubsystemElement > FACTORY = new SubsystemFactory < RemotingSubsystemElement > ( ) { public RemotingSubsystemElement createSubsystemElement ( ) { } } ; public void initialize ( ExtensionContext context ) { <START_BUG> context . registerSubsystem ( REMOTING_1_0 . getUriString ( ) , RemotingExtension . FACTORY , RemotingSubsystemParser . getInstance ( ) ) ; <END_BUG> } public void activate ( final ServiceActivatorContext context ) { } } 
public class URLCodec implements BinaryDecoder , BinaryEncoder , StringDecoder , StringEncoder { private static final int RADIX = 16 ; protected String charset ; protected static byte ESCAPE_CHAR = '%' ; protected static final BitSet WWW_FORM_URL = new BitSet ( 256 ) ; public URLCodec ( ) { } public URLCodec ( String charset ) { } public static final byte [ ] encodeUrl ( BitSet urlsafe , byte [ ] bytes ) { } public static final byte [ ] decodeUrl ( byte [ ] bytes ) throws DecoderException { if ( bytes == null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < ( bytes . length ) ; i ++ ) { int b = bytes [ i ] ; if ( b == '+' ) { buffer . write ( '<seq2seq4repair_space>' ) ; } else if ( b == '%' ) { try { int u = URLCodec . toCharacterDigit ( bytes [ ( ++ i ) ] ) ; int l = URLCodec . toCharacterDigit ( bytes [ ( ++ i ) ] ) ; buffer . write ( ( ( char ) ( ( u << 4 ) + l ) ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { <START_BUG> throw new DecoderException ( "Invalid<seq2seq4repair_space>URL<seq2seq4repair_space>encoding:<seq2seq4repair_space>" ) ; <END_BUG> } } else { buffer . write ( b ) ; } } return buffer . toByteArray ( ) ; } private static int toCharacterDigit ( byte b ) throws DecoderException { } public byte [ ] encode ( byte [ ] bytes ) { } public byte [ ] decode ( byte [ ] bytes ) throws DecoderException { } public String encode ( String pString , String charset ) throws UnsupportedEncodingException { } public String encode ( String pString ) throws EncoderException { } public String decode ( String pString , String charset ) throws UnsupportedEncodingException , DecoderException { } public String decode ( String pString ) throws DecoderException { } public Object encode ( Object pObject ) throws EncoderException { } public Object decode ( Object pObject ) throws DecoderException { } public String getEncoding ( ) { } public String getDefaultCharset ( ) { } } 
class SingleSignOnAdd extends AbstractAddStepHandler { @ Override protected void populateModel ( ModelNode operation , ModelNode model ) throws OperationFailedException { } @ Override protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode model ) throws OperationFailedException { final PathAddress address = PathAddress . pathAddress ( operation . get ( OP_ADDR ) ) ; final PathAddress hostAddress = address . subAddress ( 0 , ( ( address . size ( ) ) - 1 ) ) ; final PathAddress serverAddress = hostAddress . subAddress ( 0 , ( ( hostAddress . size ( ) ) - 1 ) ) ; final ModelNode domainModelNode = DOMAIN . resolveModelAttribute ( context , model ) ; final ModelNode pathNode = PATH . resolveModelAttribute ( context , model ) ; final String domain = ( domainModelNode . isDefined ( ) ) ? domainModelNode . asString ( ) : null ; final String path = ( pathNode . isDefined ( ) ) ? pathNode . asString ( ) : null ; final boolean secure = SECURE . resolveModelAttribute ( context , model ) . asBoolean ( ) ; final boolean httpOnly = HTTP_ONLY . resolveModelAttribute ( context , model ) . asBoolean ( ) ; final String cookieName = COOKIE_NAME . resolveModelAttribute ( context , model ) . asString ( ) ; final String serverName = serverAddress . getLastElement ( ) . getValue ( ) ; final String hostName = hostAddress . getLastElement ( ) . getValue ( ) ; final ServiceName serviceName = UndertowService . ssoServiceName ( serverName , hostName ) ; final ServiceName virtualHostServiceName = UndertowService . virtualHostName ( serverName , hostName ) ; final ServiceTarget target = context . getServiceTarget ( ) ; ServiceName managerServiceName = serviceName . append ( "manager" ) ; <START_BUG> SingleSignOnManagerService . build ( target , managerServiceName , virtualHostServiceName ) . setInitialMode ( ON_DEMAND ) . install ( ) ; <END_BUG> final SingleSignOnService service = new SingleSignOnService ( domain , path , httpOnly , secure , cookieName ) ; target . addService ( serviceName , service ) . addDependency ( virtualHostServiceName , Host . class , service . getHost ( ) ) . addDependency ( managerServiceName , SingleSignOnManager . class , service . getSingleSignOnSessionManager ( ) ) . setInitialMode ( ACTIVE ) . install ( ) ; } } 
public final class FeedbackPanel extends Panel implements IValidationFeedback { private static final long serialVersionUID = - 3385823935971399988L ; private final FeedbackPanel . MessageListView messageListView ; private static final class MessageListView extends ListView { public MessageListView ( final String name ) { } protected void populateItem ( final ListItem listItem ) { } } public FeedbackPanel ( final String componentName ) { } public void setMaxMessages ( int maxMessages ) { } public void updateValidationFeedback ( final Form form ) { messageListView . setModel ( getPage ( ) . getFeedbackMessages ( ) . model ( form ) ) ; <START_BUG> messageListView . invalidateModel ( ) ; <END_BUG> } } 
public class DynamicFilterTest extends BuildFileTest { public DynamicFilterTest ( String name ) { } public void setUp ( ) { } public void tearDown ( ) { } public void testCustomFilter ( ) throws IOException { } private void assertStringContains ( String string , String contains ) { } private void assertStringNotContains ( String string , String contains ) { } private String getFileString ( String filename ) throws IOException { Reader r = null ; try { r = new FileReader ( getProject ( ) . resolveFile ( filename ) ) ; <START_BUG> return FileUtils . newFileUtils ( ) . readFully ( r ) ; <END_BUG> } finally { try { r . close ( ) ; } catch ( Throwable ignore ) { } } } private String getFileString ( String target , String filename ) throws IOException { } private void expectFileContains ( String name , String contains ) throws IOException { } private void expectFileContains ( String target , String name , String contains ) throws IOException { } public static class CustomFilter implements ChainableReader { char replace = 'x' ; char with = 'y' ; public void setReplace ( char replace ) { } public void setWith ( char with ) { } public Reader chain ( final Reader rdr ) { } } } 
public class SecurityDependencyProcessor implements DeploymentUnitProcessor { public static final ModuleIdentifier PICKETBOX_ID = ModuleIdentifier . create ( PICKETBOX . getName ( ) , PICKETBOX . getSlot ( ) ) ; public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( MODULE_SPECIFICATION ) ; <START_BUG> moduleSpecification . addDependency ( new org . jboss . as . server . deployment . module . ModuleDependency ( moduleLoader , SecurityDependencyProcessor . PICKETBOX_ID , false , true , false ) ) ; <END_BUG> } public void undeploy ( DeploymentUnit context ) { } } 
public class BoundedQueueThreadPoolService implements Service < ManagedQueueExecutorService > { private final InjectedValue < ThreadFactory > threadFactoryValue = new InjectedValue < ThreadFactory > ( ) ; private final InjectedValue < Executor > handoffExecutorValue = new InjectedValue < Executor > ( ) ; private ManagedQueueExecutorService executor ; private int coreThreads ; private int maxThreads ; private int queueLength ; private boolean blocking ; private TimeSpec keepAlive ; private boolean allowCoreTimeout ; public BoundedQueueThreadPoolService ( int coreThreads , int maxThreads , int queueLength , boolean blocking , TimeSpec keepAlive , boolean allowCoreTimeout ) { } public synchronized void start ( final StartContext context ) throws StartException { } public synchronized void stop ( final StopContext context ) { } public synchronized ManagedQueueExecutorService getValue ( ) throws IllegalStateException { final ManagedQueueExecutorService value = this . executor ; if ( value == null ) { <START_BUG> throw ROOT_LOGGER . boundedQueueThreadPoolExecutorUninitialized ( ) ; <END_BUG> } return value ; } public Injector < ThreadFactory > getThreadFactoryInjector ( ) { } public Injector < Executor > getHandoffExecutorInjector ( ) { } public synchronized void setCoreThreads ( int coreThreads ) { } public synchronized void setMaxThreads ( int maxThreads ) { } public synchronized void setKeepAlive ( TimeSpec keepAlive ) { } public synchronized void setAllowCoreTimeout ( boolean allowCoreTimeout ) { } public int getCurrentThreadCount ( ) { } public int getLargestThreadCount ( ) { } TimeUnit getKeepAliveUnit ( ) { } public int getRejectedCount ( ) { } public int getQueueSize ( ) { } } 
public void setJvm ( String value ) { } public Argument createJvmarg ( ) { } public void setDir ( File dir ) { } public void addSysproperty ( Environment . Variable sysp ) { } public void addConfiguredSysproperty ( Environment . Variable sysp ) { } public void addSyspropertyset ( PropertySet sysp ) { } public Path createClasspath ( ) { } public Path createBootclasspath ( ) { } public void addEnv ( Environment . Variable var ) { } public void setNewenvironment ( boolean newenv ) { } private void preConfigure ( BaseTest test ) { } public void addTest ( JUnitTest test ) { } public BatchTest createBatchTest ( ) { } public void addFormatter ( FormatterElement fe ) { } public void setIncludeantruntime ( boolean b ) { } public void setShowOutput ( boolean showOutput ) { } public void setOutputToFormatters ( boolean outputToFormatters ) { } public void setLogFailedTests ( boolean logFailedTests ) { } public void addAssertions ( Assertions asserts ) { } public Permissions createPermissions ( ) { } public void setCloneVm ( boolean cloneVm ) { } public JUnitTask ( ) throws Exception { } public void setTempdir ( File tmpDir ) { } public void setEnableTestListenerEvents ( boolean b ) { } public boolean getEnableTestListenerEvents ( ) { } public void init ( ) { } private static JUnitTaskMirror createMirror ( JUnitTask task , ClassLoader loader ) { } protected void setupJUnitDelegate ( ) { } public void execute ( ) throws BuildException { } protected void execute ( JUnitTest arg ) throws BuildException { } private void validateTestName ( String testName ) throws BuildException { } protected void execute ( List testList ) throws BuildException { } private JUnitTask . TestResultHolder executeAsForked ( JUnitTest test , ExecuteWatchdog watchdog , File casesFile ) throws BuildException { } private void checkIncludeAntRuntime ( CommandlineJava cmd ) { } private boolean equalsWithOutAndErr ( String summaryOption ) { } private void checkIncludeSummary ( CommandlineJava cmd ) { } private void checkForkedPath ( CommandlineJava cmd ) { } private static boolean urlEquals ( URL u1 , URL u2 ) { } private static String maybeStripJarAndClass ( URL u ) { } private File createTempPropertiesFile ( String prefix ) { } protected void handleOutput ( String output ) { } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { } protected void handleFlush ( String output ) { } public void handleErrorOutput ( String output ) { } public void handleErrorFlush ( String output ) { } private JUnitTask . TestResultHolder executeInVM ( JUnitTest arg ) throws BuildException { } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { } protected OutputStream getDefaultOutput ( ) { } protected Enumeration getIndividualTests ( ) { } private void checkMethodLists ( ) throws BuildException { } protected Enumeration allTests ( ) { } private FormatterElement [ ] mergeFormatters ( JUnitTest test ) { } protected File getOutput ( FormatterElement fe , JUnitTest test ) { } protected void addClasspathEntry ( String resource ) { } private boolean addClasspathResource ( String resource ) { } static final String TIMEOUT_MESSAGE = "Timeout<seq2seq4repair_space>occurred.<seq2seq4repair_space>Please<seq2seq4repair_space>note<seq2seq4repair_space>the<seq2seq4repair_space>time<seq2seq4repair_space>in<seq2seq4repair_space>the<seq2seq4repair_space>report<seq2seq4repair_space>does" + "<seq2seq4repair_space>not<seq2seq4repair_space>reflect<seq2seq4repair_space>the<seq2seq4repair_space>time<seq2seq4repair_space>until<seq2seq4repair_space>the<seq2seq4repair_space>timeout." ; private void logTimeout ( FormatterElement [ ] feArray , JUnitTest test , String testCase ) { } private void logVmCrash ( FormatterElement [ ] feArray , JUnitTest test , String testCase ) { } private void logVmExit ( FormatterElement [ ] feArray , JUnitTest test , String message , String testCase ) { } private void createClassLoader ( ) { } protected void cleanup ( ) { } private void deleteClassLoader ( ) { } protected CommandlineJava getCommandline ( ) { } private static final class ForkedTestConfiguration { private boolean filterTrace ; private boolean haltOnError ; private boolean haltOnFailure ; private String errorProperty ; private String failureProperty ; ForkedTestConfiguration ( boolean filterTrace , boolean haltOnError , boolean haltOnFailure , String errorProperty , String failureProperty ) { } ForkedTestConfiguration ( JUnitTest test ) { } public boolean equals ( Object other ) { } public int hashCode ( ) { } } public static final class ForkMode extends EnumeratedAttribute { public static final String ONCE = "once" ; public static final String PER_TEST = "perTest" ; public static final String PER_BATCH = "perBatch" ; public ForkMode ( ) { } public ForkMode ( String value ) { } public String [ ] getValues ( ) { } } protected Collection executeOrQueue ( Enumeration testList , boolean runIndividual ) { } protected void actOnTestResult ( int exitValue , boolean wasKilled , JUnitTest test , String name ) { } protected void actOnTestResult ( JUnitTask . TestResultHolder result , JUnitTest test , String name ) { } protected static class TestResultHolder { public int exitCode = JUnitTestRunnerMirror . ERRORS ; public boolean timedOut = false ; public boolean crashed = false ; } protected static class JUnitLogOutputStream extends LogOutputStream { private Task task ; public JUnitLogOutputStream ( Task task , int level ) { } protected void processLine ( String line , int level ) { } } protected static class JUnitLogStreamHandler extends PumpStreamHandler { public JUnitLogStreamHandler ( Task task , int outlevel , int errlevel ) { } } static final String NAME_OF_DUMMY_TEST = "Batch-With-Multiple-Tests" ; private static JUnitTest createDummyTestForBatchTest ( JUnitTest test ) { JUnitTest t = ( ( JUnitTest ) ( test . clone ( ) ) ) ; <START_BUG> int index = test . getName ( ) . indexOf ( '.' ) ; <END_BUG> String pack = ( index > 0 ) ? test . getName ( ) . substring ( 0 , ( index + 1 ) ) : "" ; t . setName ( ( pack + ( JUnitTask . NAME_OF_DUMMY_TEST ) ) ) ; return t ; } private static void printDual ( BufferedWriter w , PrintStream s , String text ) throws IOException { } private static void printlnDual ( BufferedWriter w , PrintStream s , String text ) throws IOException { } } 
try { ResolvedType rtx = tx . resolve ( ( ( AjLookupEnvironment ) ( declare . scope . environment ( ) ) ) . factory . getWorld ( ) ) ; if ( ! ( rtx . isInterface ( ) ) ) kindOfDP = "extends<seq2seq4repair_space>" ; } catch ( Throwable t ) { } } String typename = tp . toString ( ) ; if ( ( typename . lastIndexOf ( "." ) ) != ( - 1 ) ) { typename = typename . substring ( ( ( typename . lastIndexOf ( "." ) ) + 1 ) ) ; } details . append ( typename ) ; if ( ( i + 1 ) < ( newParents . length ) ) details . append ( "," ) ; } node . setDetails ( ( kindOfDP + ( details . toString ( ) ) ) ) ; } else if ( ( declare . declareDecl ) instanceof DeclareSoft ) { node . setKind ( IProgramElement . Kind . DECLARE_SOFT ) ; DeclareSoft ds = ( ( DeclareSoft ) ( declare . declareDecl ) ) ; node . setName ( ( name + ( AsmElementFormatter . DECLARE_SOFT ) ) ) ; node . setDetails ( genTypePatternLabel ( ds . getException ( ) ) ) ; } else if ( ( declare . declareDecl ) instanceof DeclarePrecedence ) { node . setKind ( IProgramElement . Kind . DECLARE_PRECEDENCE ) ; DeclarePrecedence ds = ( ( DeclarePrecedence ) ( declare . declareDecl ) ) ; node . setName ( ( name + ( AsmElementFormatter . DECLARE_PRECEDENCE ) ) ) ; node . setDetails ( genPrecedenceListLabel ( ds . getPatterns ( ) ) ) ; } else if ( ( declare . declareDecl ) instanceof DeclareAnnotation ) { DeclareAnnotation deca = ( ( DeclareAnnotation ) ( declare . declareDecl ) ) ; String thekind = deca . getKind ( ) . toString ( ) ; node . setName ( ( ( name + "@" ) + ( thekind . substring ( 3 ) ) ) ) ; if ( ( deca . getKind ( ) ) == ( DeclareAnnotation . AT_CONSTRUCTOR ) ) { node . setKind ( DECLARE_ANNOTATION_AT_CONSTRUCTOR ) ; } else if ( ( deca . getKind ( ) ) == ( DeclareAnnotation . AT_FIELD ) ) { node . setKind ( DECLARE_ANNOTATION_AT_FIELD ) ; } else if ( ( deca . getKind ( ) ) == ( DeclareAnnotation . AT_METHOD ) ) { node . setKind ( DECLARE_ANNOTATION_AT_METHOD ) ; } else if ( ( deca . getKind ( ) ) == ( DeclareAnnotation . AT_TYPE ) ) { node . setKind ( DECLARE_ANNOTATION_AT_TYPE ) ; } node . setDetails ( genDecaLabel ( deca ) ) ; } else { node . setKind ( ERROR ) ; node . setName ( AsmElementFormatter . DECLARE_UNKNONWN ) ; } } else if ( methodDeclaration instanceof InterTypeDeclaration ) { InterTypeDeclaration itd = ( ( InterTypeDeclaration ) ( methodDeclaration ) ) ; String name = ( ( itd . getOnType ( ) . toString ( ) ) + "." ) + ( new String ( itd . getDeclaredSelector ( ) ) ) ; if ( methodDeclaration instanceof InterTypeFieldDeclaration ) { node . setKind ( INTER_TYPE_FIELD ) ; node . setName ( name ) ; } else if ( methodDeclaration instanceof InterTypeMethodDeclaration ) { node . setKind ( INTER_TYPE_METHOD ) ; node . setName ( name ) ; } else if ( methodDeclaration instanceof InterTypeConstructorDeclaration ) { node . setKind ( INTER_TYPE_CONSTRUCTOR ) ; node . setName ( ( ( ( itd . getOnType ( ) . toString ( ) ) + "." ) + ( itd . getOnType ( ) . toString ( ) ) ) ) ; } else { node . setKind ( ERROR ) ; node . setName ( name ) ; } node . setCorrespondingType ( itd . returnType . toString ( ) ) ; if ( ( node . getKind ( ) ) != ( Kind . INTER_TYPE_FIELD ) ) { setParameters ( methodDeclaration , node ) ; } } else { if ( methodDeclaration . isConstructor ( ) ) { node . setKind ( CONSTRUCTOR ) ; } else { node . setKind ( METHOD ) ; <START_BUG> if ( ( true && ( methodDeclaration != null ) ) && ( ( methodDeclaration . annotations ) != null ) ) { <END_BUG> for ( int i = 0 ; i < ( methodDeclaration . annotations . length ) ; i ++ ) { Annotation annotation = methodDeclaration . annotations [ i ] ; String annotationSig = new String ( annotation . type . getTypeBindingPublic ( methodDeclaration . scope ) . signature ( ) ) ; if ( ( annotationSig != null ) && ( ( annotationSig . charAt ( 1 ) ) == 'o' ) ) { if ( "Lorg/aspectj/lang/annotation/Pointcut;" . equals ( annotationSig ) ) { node . setKind ( POINTCUT ) ; break ; } else if ( ( ( ( ( "Lorg/aspectj/lang/annotation/Before;" . equals ( annotationSig ) ) || ( "Lorg/aspectj/lang/annotation/After;" . equals ( annotationSig ) ) ) || ( "Lorg/aspectj/lang/annotation/AfterReturning;" . equals ( annotationSig ) ) ) || ( "Lorg/aspectj/lang/annotation/AfterThrowing;" . equals ( annotationSig ) ) ) || ( "Lorg/aspectj/lang/annotation/Around;" . equals ( annotationSig ) ) ) { node . setKind ( ADVICE ) ; node . setDetails ( AsmElementFormatter . POINTCUT_ANONYMOUS ) ; break ; } } } } } node . setName ( new String ( methodDeclaration . selector ) ) ; setParameters ( methodDeclaration , node ) ; } } private String genDecaLabel ( DeclareAnnotation deca ) { } private String genPrecedenceListLabel ( TypePatternList list ) { } private void setParameters ( MethodDeclaration md , IProgramElement pe ) { } private boolean acceptArgument ( String name , String type ) { } public String genTypePatternLabel ( TypePattern tp ) { } public String genDeclareMessage ( String message ) { } private String translatePointcutName ( String name ) { } } 
public abstract class WebApplication extends Application { private final Map bufferedResponses = new HashMap ( ) ; private IRequestCycleProcessor requestCycleProcessor ; private String sessionAttributePrefix ; private ISessionFactory sessionFactory = new ISessionFactory ( ) { private static final long serialVersionUID = 1L ; public Session newSession ( ) { } } ; private WicketServlet wicketServlet ; public WebApplication ( ) { } public final String getSessionAttributePrefix ( final WebRequest request ) { } public final WicketServlet getWicketServlet ( ) { } public final void mount ( String path , IRequestTargetUrlCodingStrategy encoder ) { } public final void mount ( String path , Package p ) { } public final void mount ( String path , PackageName packageName ) { } public final void mountBookmarkablePage ( String path , Class bookmarkablePageClass ) { } public final void mountBookmarkablePage ( String path , Class bookmarkablePageClass , String pageMapName ) { } public final void setSessionFactory ( final ISessionFactory sessionFactory ) { } public final void setWicketServlet ( final WicketServlet wicketServlet ) { } public final void unmount ( String path ) { } protected IRequestCycleFactory getDefaultRequestCycleFactory ( ) { } protected IRequestCycleProcessor getDefaultRequestCycleProcessor ( ) { } protected ISessionFactory getSessionFactory ( ) { } protected void init ( ) { } protected void internalDestroy ( ) { } protected void internalInit ( ) { } protected WebRequest newWebRequest ( final HttpServletRequest servletRequest ) { } protected WebResponse newWebResponse ( final HttpServletResponse servletResponse ) { } final void addBufferedResponse ( String sessionId , String bufferId , BufferedHttpServletResponse renderedResponse ) { } final void clearBufferedResponses ( String sessionId ) { } final WebSession getSession ( final WebRequest request ) { final HttpSession httpSession = request . getHttpServletRequest ( ) . getSession ( false ) ; final String sessionAttribute = ( getSessionAttributePrefix ( request ) ) + ( Session . SESSION_ATTRIBUTE_NAME ) ; WebSession webSession = null ; if ( httpSession != null ) { webSession = ( ( WebSession ) ( httpSession . getAttribute ( sessionAttribute ) ) ) ; } if ( webSession == null ) { final Session session = getSessionFactory ( ) . newSession ( ) ; if ( session instanceof WebSession ) { webSession = ( ( WebSession ) ( session ) ) ; } else { throw new WicketRuntimeException ( "Session<seq2seq4repair_space>created<seq2seq4repair_space>by<seq2seq4repair_space>a<seq2seq4repair_space>WebApplication<seq2seq4repair_space>session<seq2seq4repair_space>factory<seq2seq4repair_space>must<seq2seq4repair_space>be<seq2seq4repair_space>a<seq2seq4repair_space>subclass<seq2seq4repair_space>of<seq2seq4repair_space>WebSession" ) ; } webSession . setLocale ( request . getLocale ( ) ) ; if ( httpSession != null ) { httpSession . setAttribute ( sessionAttribute , webSession ) ; } } webSession . setApplication ( this ) ; <START_BUG> webSession . init ( getSessionAttributePrefix ( request ) ) ; <END_BUG> return webSession ; } final BufferedHttpServletResponse popBufferedResponse ( String sessionId , String bufferId ) { } private void checkMountPath ( String path ) { } } 
final class OrderedIntDoubleMapping implements Serializable , Cloneable { private static final double DEFAULT_VALUE = 0.0 ; private int [ ] indices ; private double [ ] values ; private int numMappings ; OrderedIntDoubleMapping ( ) { } OrderedIntDoubleMapping ( int capacity ) { } private OrderedIntDoubleMapping ( int [ ] indices , double [ ] values , int numMappings ) { } int [ ] getIndices ( ) { } double [ ] getValues ( ) { } int getNumMappings ( ) { } private void growTo ( int newCapacity ) { } private int find ( int index ) { } public double get ( int index ) { } public void set ( int index , double value ) { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public String toString ( ) { } @ Override public OrderedIntDoubleMapping clone ( ) { <START_BUG> return new OrderedIntDoubleMapping ( indices , values , numMappings ) ; <END_BUG> } } 
public class TestReverseStringFilter extends BaseTokenStreamTestCase { public void testFilter ( ) throws Exception { } public void testFilterWithMark ( ) throws Exception { } public void testReverseString ( ) throws Exception { } public void testReverseChar ( ) throws Exception { } @ Deprecated public void testBackCompat ( ) throws Exception { } public void testReverseSupplementary ( ) throws Exception { } public void testReverseSupplementaryChar ( ) throws Exception { } public void testRandomStrings ( ) throws Exception { Analyzer a = new Analyzer ( ) { @ Override protected TokenStreamComponents createComponents ( String fieldName , Reader reader ) { Tokenizer tokenizer = new MockTokenizer ( reader , MockTokenizer . WHITESPACE , false ) ; return new TokenStreamComponents ( tokenizer , new ReverseStringFilter ( TEST_VERSION_CURRENT , tokenizer ) ) ; } } ; <START_BUG> checkRandomData ( random ( ) , a , ( 10000 * ( RANDOM_MULTIPLIER ) ) ) ; <END_BUG> } public void testEmptyTerm ( ) throws IOException { } } 
public class TermQueryPrefixTreeStrategy extends PrefixTreeStrategy { public TermQueryPrefixTreeStrategy ( SpatialPrefixTree grid , String fieldName ) { } @ Override public Filter makeFilter ( SpatialArgs args ) { final SpatialOperation op = args . getOperation ( ) ; <START_BUG> if ( ! ( SpatialOperation . is ( op , IsWithin , Intersects , BBoxWithin , BBoxIntersects ) ) ) <END_BUG> throw new org . apache . lucene . spatial . query . UnsupportedSpatialOperation ( op ) ; Shape shape = args . getShape ( ) ; int detailLevel = grid . getLevelForDistance ( args . resolveDistErr ( ctx , distErrPct ) ) ; List < Node > cells = grid . getNodes ( shape , detailLevel , false ) ; TermsFilter filter = new TermsFilter ( ) ; for ( Node cell : cells ) { filter . addTerm ( new org . apache . lucene . index . Term ( getFieldName ( ) , cell . getTokenString ( ) ) ) ; } return filter ; } } 
public class CollectionProperty extends MultiProperty { private static final long serialVersionUID = 221L ; private Collection < JMeterProperty > value ; private transient Collection < JMeterProperty > savedValue ; public CollectionProperty ( String name , Collection value ) { } public CollectionProperty ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } public void remove ( String prop ) { } public void set ( int index , String prop ) { } public void set ( int index , JMeterProperty prop ) { } public JMeterProperty get ( int row ) { } public void remove ( int index ) { } public void setObjectValue ( Object v ) { } @ Override public PropertyIterator iterator ( ) { } public String getStringValue ( ) { } public Object getObjectValue ( ) { } public int size ( ) { } @ Override public Object clone ( ) { } private Collection < JMeterProperty > cloneCollection ( ) { try { @ SuppressWarnings ( "unchecked" ) Collection < JMeterProperty > newCol = value . getClass ( ) . newInstance ( ) ; PropertyIterator iter = iterator ( ) ; while ( iter . hasNext ( ) ) { <START_BUG> newCol . add ( iter . next ( ) . clone ( ) ) ; <END_BUG> } return newCol ; } catch ( Exception e ) { log . error ( "Couldn't<seq2seq4repair_space>clone<seq2seq4repair_space>collection" , e ) ; return value ; } } public void setCollection ( Collection coll ) { } @ Override public void clear ( ) { } @ Override public void addProperty ( JMeterProperty prop ) { } public void addItem ( Object item ) { } @ Override protected Class < ? extends JMeterProperty > getPropertyType ( ) { } public void recoverRunningVersion ( TestElement owner ) { } @ Override public void setRunningVersion ( boolean running ) { } } 
public class StandardToStringStyleTest extends TestCase { private final Integer base = new Integer ( 5 ) ; private final String baseStr = "Integer" ; private static final StandardToStringStyle STYLE = new StandardToStringStyle ( ) ; public StandardToStringStyleTest ( String name ) { } public static void main ( String [ ] args ) { } public static Test suite ( ) { } @ Override protected void setUp ( ) throws Exception { } @ Override protected void tearDown ( ) throws Exception { super . tearDown ( ) ; <START_BUG> ToStringBuilder . setDefaultStyle ( StandardToStringStyleTest . STYLE ) ; <END_BUG> } public void testBlank ( ) { } public void testAppendSuper ( ) { } public void testObject ( ) { } public void testPerson ( ) { } public void testLong ( ) { } public void testObjectArray ( ) { } public void testLongArray ( ) { } public void testLongArrayArray ( ) { } } 
public class SMTPMin { static Category cat = Category . getInstance ( SMTPMin . class ) ; public static void main ( String [ ] argv ) { } static void usage ( String msg ) { } static void init ( String configFile ) { } static void test ( ) { int i = 0 ; SMTPMin . cat . debug ( ( "Message<seq2seq4repair_space>" + ( i ++ ) ) ) ; SMTPMin . cat . debug ( ( "Message<seq2seq4repair_space>" + ( i ++ ) ) , new Exception ( "Just<seq2seq4repair_space>testing." ) ) ; SMTPMin . cat . info ( ( "Message<seq2seq4repair_space>" + ( i ++ ) ) ) ; SMTPMin . cat . warn ( ( "Message<seq2seq4repair_space>" + ( i ++ ) ) ) ; SMTPMin . cat . error ( ( "Message<seq2seq4repair_space>" + ( i ++ ) ) ) ; SMTPMin . cat . log ( Priority . FATAL , ( "Message<seq2seq4repair_space>" + ( i ++ ) ) ) ; <START_BUG> Category . shutdown ( ) ; <END_BUG> Thread . currentThread ( ) . getThreadGroup ( ) . list ( ) ; } } 
public class EclipseWorld extends World { public static boolean DEBUG = false ; public AjBuildManager buildManager ; private LookupEnvironment lookupEnvironment ; private Map addedTypeBindings = new HashMap ( ) ; public static EclipseWorld forLookupEnvironment ( LookupEnvironment env ) { } public static EclipseWorld fromScopeLookupEnvironment ( Scope scope ) { } public EclipseWorld ( LookupEnvironment lookupEnvironment , IMessageHandler handler ) { } public Advice concreteAdvice ( AjAttribute . AdviceAttribute attribute , Pointcut pointcut , Member signature ) { } public ConcreteTypeMunger concreteTypeMunger ( ResolvedTypeMunger munger , ResolvedTypeX aspectType ) { } protected ResolvedTypeX resolveObjectType ( TypeX ty ) { } public ResolvedTypeX fromEclipse ( ReferenceBinding binding ) { } public ResolvedTypeX [ ] fromEclipse ( ReferenceBinding [ ] bindings ) { } private static String getName ( TypeBinding binding ) { } public static TypeX fromBinding ( TypeBinding binding ) { } public static TypeX [ ] fromBindings ( TypeBinding [ ] bindings ) { } public static AstNode astForLocation ( IHasPosition location ) { } public Collection getTypeMungers ( ) { } public static ResolvedMember makeResolvedMember ( MethodBinding binding ) { } public static ResolvedMember makeResolvedMember ( FieldBinding binding ) { } public TypeBinding makeTypeBinding ( TypeX typeX ) { TypeBinding ret = ( ( TypeBinding ) ( addedTypeBindings . get ( typeX ) ) ) ; if ( ret != null ) return ret ; if ( typeX . isPrimitive ( ) ) { if ( typeX == ( ResolvedTypeX . BOOLEAN ) ) return BaseTypes . BooleanBinding ; if ( typeX == ( ResolvedTypeX . BYTE ) ) return BaseTypes . ByteBinding ; if ( typeX == ( ResolvedTypeX . CHAR ) ) return BaseTypes . CharBinding ; if ( typeX == ( ResolvedTypeX . DOUBLE ) ) return BaseTypes . DoubleBinding ; if ( typeX == ( ResolvedTypeX . FLOAT ) ) return BaseTypes . FloatBinding ; if ( typeX == ( ResolvedTypeX . INT ) ) return BaseTypes . IntBinding ; if ( typeX == ( ResolvedTypeX . LONG ) ) return BaseTypes . LongBinding ; if ( typeX == ( ResolvedTypeX . SHORT ) ) return BaseTypes . ShortBinding ; if ( typeX == ( ResolvedTypeX . VOID ) ) return BaseTypes . VoidBinding ; throw new RuntimeException ( ( "weird<seq2seq4repair_space>primitive<seq2seq4repair_space>type<seq2seq4repair_space>" + typeX ) ) ; } else if ( typeX . isArray ( ) ) { int dim = 0 ; while ( typeX . isArray ( ) ) { dim ++ ; typeX = typeX . getComponentType ( ) ; } <START_BUG> return new ArrayBinding ( makeTypeBinding ( typeX ) , dim ) ; <END_BUG> } else { ResolvedTypeX rt = typeX . resolve ( this ) ; if ( rt == ( ResolvedTypeX . MISSING ) ) { throw new RuntimeException ( ( "shouldn't<seq2seq4repair_space>be<seq2seq4repair_space>missing:<seq2seq4repair_space>" + typeX ) ) ; } return ( ( EclipseObjectType ) ( rt ) ) . getBinding ( ) ; } } public TypeBinding [ ] makeTypeBindings ( TypeX [ ] types ) { } private ReferenceBinding [ ] makeReferenceBindings ( TypeX [ ] types ) { } public FieldBinding makeFieldBinding ( ResolvedMember member ) { } public MethodBinding makeMethodBinding ( ResolvedMember member ) { } public MethodBinding makeMethodBindingForCall ( Member member ) { } public void finishedCompilationUnit ( CompilationUnitDeclaration unit ) { } public void addTypeBinding ( TypeBinding binding ) { } public Shadow makeShadow ( AstNode location , ReferenceContext context ) { } public Shadow makeShadow ( ReferenceContext context ) { } } 
class WebConnectorMetrics implements OperationStepHandler { static WebConnectorMetrics INSTANCE = new WebConnectorMetrics ( ) ; static final String [ ] NO_LOCATION = new String [ 0 ] ; static final String [ ] ATTRIBUTES = new String [ ] { Constants . BYTES_SENT , Constants . BYTES_RECEIVED , Constants . PROCESSING_TIME , Constants . ERROR_COUNT , Constants . MAX_TIME , Constants . REQUEST_COUNT } ; @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { <START_BUG> if ( ( context . getType ( ) ) == ( Type . SERVER ) ) { <END_BUG> context . addStep ( new OperationStepHandler ( ) { @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { final PathAddress address = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) ; final String name = address . getLastElement ( ) . getValue ( ) ; final String attributeName = operation . require ( NAME ) . asString ( ) ; final ServiceController < ? > controller = context . getServiceRegistry ( false ) . getService ( JBOSS_WEB_CONNECTOR . append ( name ) ) ; if ( controller != null ) { try { final Connector connector = ( ( Connector ) ( controller . getValue ( ) ) ) ; final ModelNode result = context . getResult ( ) ; if ( ( ( connector . getProtocolHandler ( ) ) != null ) && ( ( connector . getProtocolHandler ( ) . getRequestGroupInfo ( ) ) != null ) ) { RequestGroupInfo info = connector . getProtocolHandler ( ) . getRequestGroupInfo ( ) ; if ( BYTES_SENT . equals ( attributeName ) ) { result . set ( ( "" + ( info . getBytesSent ( ) ) ) ) ; } else if ( BYTES_RECEIVED . equals ( attributeName ) ) { result . set ( ( "" + ( info . getBytesReceived ( ) ) ) ) ; } else if ( PROCESSING_TIME . equals ( attributeName ) ) { result . set ( ( "" + ( info . getProcessingTime ( ) ) ) ) ; } else if ( ERROR_COUNT . equals ( attributeName ) ) { result . set ( ( "" + ( info . getErrorCount ( ) ) ) ) ; } else if ( MAX_TIME . equals ( attributeName ) ) { result . set ( ( "" + ( info . getMaxTime ( ) ) ) ) ; } else if ( REQUEST_COUNT . equals ( attributeName ) ) { result . set ( ( "" + ( info . getRequestCount ( ) ) ) ) ; } } } catch ( Exception e ) { throw new OperationFailedException ( new ModelNode ( ) . set ( WebMessages . MESSAGES . failedToGetMetrics ( e . getMessage ( ) ) ) ) ; } } else { context . getResult ( ) . set ( WebMessages . MESSAGES . noMetricsAvailable ( ) ) ; } context . completeStep ( ) ; } } , RUNTIME ) ; } else { context . getResult ( ) . set ( WebMessages . MESSAGES . noMetricsAvailable ( ) ) ; } context . completeStep ( ) ; } } 
public abstract class EJBComponent extends AbstractComponent implements org . jboss . ejb3 . context . spi . EJBComponent , TransactionalComponent { private static Logger log = Logger . getLogger ( EJBComponent . class ) ; private final ConcurrentMap < MethodIntf , ConcurrentMap < String , ConcurrentMap < ArrayKey , TransactionAttributeType > > > txAttrs ; private final EJBUtilities utilities ; private final boolean isBeanManagedTransaction ; private static volatile boolean youHaveBeenWarnedEJBTHREE2120 = false ; protected EJBComponent ( final EJBComponentConfiguration configuration ) { } @ Override public ApplicationException getApplicationException ( Class < ? > exceptionClass ) { } @ Override public EJBHome getEJBHome ( ) throws IllegalStateException { } @ Override public EJBLocalHome getEJBLocalHome ( ) throws IllegalStateException { } @ Override public boolean getRollbackOnly ( ) throws IllegalStateException { } @ Override public TimerService getTimerService ( ) throws IllegalStateException { } @ Deprecated public TransactionAttributeType getTransactionAttributeType ( Method method ) { } public TransactionAttributeType getTransactionAttributeType ( MethodIntf methodIntf , Method method ) { ConcurrentMap < String , ConcurrentMap < ArrayKey , TransactionAttributeType > > perMethodIntf = txAttrs . get ( methodIntf ) ; if ( perMethodIntf == null ) throw new IllegalStateException ( ( "Can't<seq2seq4repair_space>find<seq2seq4repair_space>tx<seq2seq4repair_space>attrs<seq2seq4repair_space>for<seq2seq4repair_space>" + methodIntf ) ) ; ConcurrentMap < ArrayKey , TransactionAttributeType > perMethod = perMethodIntf . get ( method . getName ( ) ) ; if ( perMethod == null ) throw new IllegalStateException ( ( ( ( "Can't<seq2seq4repair_space>find<seq2seq4repair_space>tx<seq2seq4repair_space>attrs<seq2seq4repair_space>for<seq2seq4repair_space>method<seq2seq4repair_space>name<seq2seq4repair_space>" + ( method . getName ( ) ) ) + "<seq2seq4repair_space>via<seq2seq4repair_space>" ) + methodIntf ) ) ; <START_BUG> TransactionAttributeType txAttr = perMethod . get ( new ArrayKey ( method . getParameterTypes ( ) ) ) ; <END_BUG> if ( txAttr == null ) throw new IllegalStateException ( ( ( ( "Can't<seq2seq4repair_space>find<seq2seq4repair_space>tx<seq2seq4repair_space>attr<seq2seq4repair_space>for<seq2seq4repair_space>method<seq2seq4repair_space>" + method ) + "<seq2seq4repair_space>via<seq2seq4repair_space>" ) + methodIntf ) ) ; return txAttr ; } @ Override public TransactionManager getTransactionManager ( ) { } public TransactionSynchronizationRegistry getTransactionSynchronizationRegistry ( ) { } @ Override public int getTransactionTimeout ( Method method ) { } @ Override public UserTransaction getUserTransaction ( ) throws IllegalStateException { } private boolean isBeanManagedTransaction ( ) { } @ Override public boolean isCallerInRole ( Principal callerPrincipal , String roleName ) throws IllegalStateException { } @ Override public Object lookup ( String name ) throws IllegalArgumentException { } @ Override public void setRollbackOnly ( ) throws IllegalStateException { } } 
public abstract class Evaluator { EvaluationContext context ; INameEnvironment environment ; Map options ; IRequestor requestor ; IProblemFactory problemFactory ; Evaluator ( EvaluationContext context , INameEnvironment environment , Map options , IRequestor requestor , IProblemFactory problemFactory ) { } protected abstract void addEvaluationResultForCompilationProblem ( Map resultsByIDs , IProblem problem , char [ ] cuSource ) { } protected EvaluationResult [ ] evaluationResultsForCompilationProblems ( CompilationResult result , char [ ] cuSource ) { } ClassFile [ ] getClasses ( ) { final char [ ] source = getSource ( ) ; final ArrayList classDefinitions = new ArrayList ( ) ; class CompilerRequestor implements ICompilerRequestor { boolean hasErrors = false ; public void acceptResult ( CompilationResult result ) { if ( result . hasProblems ( ) ) { EvaluationResult [ ] evalResults = evaluationResultsForCompilationProblems ( result , source ) ; for ( int i = 0 ; i < ( evalResults . length ) ; i ++ ) { EvaluationResult evalResult = evalResults [ i ] ; IProblem [ ] problems = evalResult . getProblems ( ) ; for ( int j = 0 ; j < ( problems . length ) ; j ++ ) { Evaluator . this . requestor . acceptProblem ( problems [ j ] , evalResult . getEvaluationID ( ) , evalResult . getEvaluationType ( ) ) ; } } } if ( result . hasErrors ( ) ) { <START_BUG> hasErrors = true ; <END_BUG> } else { ClassFile [ ] classFiles = result . getClassFiles ( ) ; for ( int i = 0 ; i < ( classFiles . length ) ; i ++ ) { ClassFile classFile = classFiles [ i ] ; classDefinitions . add ( classFile ) ; } } } } CompilerRequestor compilerRequestor = new CompilerRequestor ( ) ; Compiler compiler = getCompiler ( compilerRequestor ) ; compiler . compile ( new ICompilationUnit [ ] { new ICompilationUnit ( ) { public char [ ] getFileName ( ) { return CharOperation . concat ( Evaluator . this . getClassName ( ) , SuffixConstants . SUFFIX_java ) ; } public char [ ] getContents ( ) { return source ; } public char [ ] getMainTypeName ( ) { return Evaluator . this . getClassName ( ) ; } public char [ ] [ ] getPackageName ( ) { return null ; } } } ) ; if ( compilerRequestor . hasErrors ) { return null ; } else { ClassFile [ ] result = new ClassFile [ classDefinitions . size ( ) ] ; classDefinitions . toArray ( result ) ; return result ; } } protected abstract char [ ] getClassName ( ) { } Compiler getCompiler ( ICompilerRequestor compilerRequestor ) { } protected abstract char [ ] getSource ( ) { } } 
inVMConnector . registerOperationHandler ( REMOVE , TransportConfigOperationHandlers . REMOVE , CONNECTOR_REMOVE ) ; IN_VM_ATTR . registerAttributes ( inVMConnector , registerRuntimeOnly ) ; MessagingExtension . createParamRegistration ( inVMConnector ) ; final ManagementResourceRegistration bridge = serverRegistration . registerSubModel ( PathElement . pathElement ( BRIDGE ) , BRIDGE_RESOURCE ) ; bridge . registerOperationHandler ( ADD , BridgeAdd . INSTANCE , BridgeAdd . INSTANCE , false ) ; bridge . registerOperationHandler ( REMOVE , BridgeRemove . INSTANCE , BridgeRemove . INSTANCE , false ) ; BridgeWriteAttributeHandler . INSTANCE . registerAttributes ( bridge , registerRuntimeOnly ) ; if ( registerRuntimeOnly ) { BridgeControlHandler . INSTANCE . register ( bridge ) ; } final ManagementResourceRegistration cluster = serverRegistration . registerSubModel ( PathElement . pathElement ( CLUSTER_CONNECTION ) , CLUSTER_CONNECTION_RESOURCE ) ; cluster . registerOperationHandler ( ADD , ClusterConnectionAdd . INSTANCE , ClusterConnectionAdd . INSTANCE , false ) ; cluster . registerOperationHandler ( REMOVE , ClusterConnectionRemove . INSTANCE , ClusterConnectionRemove . INSTANCE , false ) ; ClusterConnectionWriteAttributeHandler . INSTANCE . registerAttributes ( cluster , registerRuntimeOnly ) ; if ( registerRuntimeOnly ) { ClusterConnectionControlHandler . INSTANCE . register ( cluster ) ; } final ManagementResourceRegistration groupingHandler = serverRegistration . registerSubModel ( MessagingExtension . GROUPING_HANDLER_PATH , GROUPING_HANDLER_RESOURCE ) ; groupingHandler . registerOperationHandler ( ADD , GroupingHandlerAdd . INSTANCE , GroupingHandlerAdd . INSTANCE ) ; groupingHandler . registerOperationHandler ( REMOVE , GroupingHandlerRemove . INSTANCE , GroupingHandlerRemove . INSTANCE ) ; GroupingHandlerWriteAttributeHandler . INSTANCE . registerAttributes ( groupingHandler , registerRuntimeOnly ) ; final ManagementResourceRegistration connectorService = serverRegistration . registerSubModel ( PathElement . pathElement ( CONNECTOR_SERVICE ) , CONNECTOR_SERVICE_RESOURCE ) ; connectorService . registerOperationHandler ( ADD , ConnectorServiceAdd . INSTANCE , ConnectorServiceAdd . INSTANCE , false ) ; connectorService . registerOperationHandler ( REMOVE , ConnectorServiceRemove . INSTANCE , ConnectorServiceRemove . INSTANCE , false ) ; ConnectorServiceWriteAttributeHandler . INSTANCE . registerAttributes ( connectorService , registerRuntimeOnly ) ; final ManagementResourceRegistration connectorServiceParam = connectorService . registerSubModel ( PathElement . pathElement ( CommonAttributes . PARAM ) , CONNECTOR_SERVICE_PARAM_RESOURCE ) ; connectorServiceParam . registerOperationHandler ( ADD , ConnectorServiceParamAdd . INSTANCE , ConnectorServiceParamAdd . INSTANCE , false ) ; connectorServiceParam . registerOperationHandler ( REMOVE , ConnectorServiceParamRemove . INSTANCE , ConnectorServiceParamRemove . INSTANCE , false ) ; connectorServiceParam . registerReadWriteAttribute ( VALUE . getName ( ) , null , ConnectorServiceParamWriteAttributeHandler . INSTANCE , CONFIGURATION ) ; for ( final String path : CommonAttributes . PATHS ) { ManagementResourceRegistration bindings = serverRegistration . registerSubModel ( PathElement . pathElement ( PATH , path ) , new MessagingSubsystemProviders . PathProvider ( path ) ) ; MessagingPathHandlers . register ( bindings ) ; } final ManagementResourceRegistration cfs = serverRegistration . registerSubModel ( MessagingExtension . CFS_PATH , CF ) ; cfs . registerOperationHandler ( ADD , ConnectionFactoryAdd . INSTANCE , CF_ADD , false ) ; cfs . registerOperationHandler ( REMOVE , ConnectionFactoryRemove . INSTANCE , CF_REMOVE , false ) ; ConnectionFactoryWriteAttributeHandler . INSTANCE . registerAttributes ( cfs ) ; if ( registerRuntimeOnly ) { ConnectionFactoryReadAttributeHandler . INSTANCE . registerAttributes ( cfs ) ; } ConnectionFactoryAddJndiHandler . INSTANCE . registerOperation ( cfs ) ; final ManagementResourceRegistration resourceAdapters = serverRegistration . registerSubModel ( MessagingExtension . RA_PATH , RA ) ; resourceAdapters . registerOperationHandler ( ADD , PooledConnectionFactoryAdd . INSTANCE , RA_ADD , false ) ; resourceAdapters . registerOperationHandler ( REMOVE , PooledConnectionFactoryRemove . INSTANCE , RA_REMOVE ) ; PooledConnectionFactoryWriteAttributeHandler . INSTANCE . registerAttributes ( resourceAdapters , registerRuntimeOnly ) ; final ManagementResourceRegistration queues = serverRegistration . registerSubModel ( MessagingExtension . JMS_QUEUE_PATH , JMS_QUEUE_RESOURCE ) ; queues . registerOperationHandler ( ADD , JMSQueueAdd . INSTANCE , JMSQueueAdd . INSTANCE , false ) ; queues . registerOperationHandler ( REMOVE , JMSQueueRemove . INSTANCE , JMSQueueRemove . INSTANCE , false ) ; JmsQueueConfigurationWriteHandler . INSTANCE . registerAttributes ( queues , registerRuntimeOnly ) ; JMSQueueAddJndiHandler . INSTANCE . registerOperation ( queues ) ; if ( registerRuntimeOnly ) { JmsQueueReadAttributeHandler . INSTANCE . registerAttributes ( queues ) ; JMSQueueControlHandler . INSTANCE . registerOperations ( queues ) ; } final ManagementResourceRegistration topics = serverRegistration . registerSubModel ( MessagingExtension . TOPIC_PATH , JMS_TOPIC_RESOURCE ) ; topics . registerOperationHandler ( ADD , JMSTopicAdd . INSTANCE , JMSTopicAdd . INSTANCE , false ) ; topics . registerOperationHandler ( REMOVE , JMSTopicRemove . INSTANCE , JMSTopicRemove . INSTANCE , false ) ; JMSTopicConfigurationWriteHandler . INSTANCE . registerAttributes ( topics ) ; JMSTopicAddJndiHandler . INSTANCE . registerOperation ( topics ) ; if ( registerRuntimeOnly ) { JMSTopicReadAttributeHandler . INSTANCE . registerAttributes ( topics ) ; JMSTopicControlHandler . INSTANCE . registerOperations ( topics ) ; } final ManagementResourceRegistration securitySettings = serverRegistration . registerSubModel ( MessagingExtension . SECURITY_SETTING , MessagingSubsystemProviders . SECURITY_SETTING ) ; securitySettings . registerOperationHandler ( ADD , SecuritySettingAdd . INSTANCE , SecuritySettingAdd . INSTANCE ) ; securitySettings . registerOperationHandler ( REMOVE , SecuritySettingRemove . INSTANCE , SecuritySettingRemove . INSTANCE ) ; final ManagementResourceRegistration securityRole = securitySettings . registerSubModel ( MessagingExtension . SECURITY_ROLE , MessagingSubsystemProviders . SECURITY_ROLE ) ; securityRole . registerOperationHandler ( ADD , SecurityRoleAdd . INSTANCE , SecurityRoleAdd . INSTANCE ) ; securityRole . registerOperationHandler ( REMOVE , SecurityRoleRemove . INSTANCE , SecurityRoleRemove . INSTANCE ) ; SecurityRoleAttributeHandler . INSTANCE . registerAttributes ( securityRole , registerRuntimeOnly ) ; if ( context . isRuntimeOnlyRegistrationValid ( ) ) { ResourceDefinition deploymentsDef = new org . jboss . as . controller . SimpleResourceDefinition ( PathElement . pathElement ( SUBSYSTEM , MessagingExtension . SUBSYSTEM_NAME ) , MessagingExtension . getResourceDescriptionResolver ( "deployed" ) ) ; final ManagementResourceRegistration deploymentsRegistration = subsystem . registerDeploymentModel ( deploymentsDef ) ; <START_BUG> final ManagementResourceRegistration serverModel = deploymentsRegistration . registerSubModel ( DeploymentHornetQServerResourceDefinition . INSTANCE ) ; <END_BUG> final ManagementResourceRegistration deploymentQueue = serverModel . registerSubModel ( MessagingExtension . JMS_QUEUE_PATH , JMS_QUEUE_RESOURCE ) ; JmsQueueReadAttributeHandler . INSTANCE . registerAttributes ( deploymentQueue ) ; JMSQueueControlHandler . INSTANCE . registerOperations ( deploymentQueue ) ; final ManagementResourceRegistration deploymentTopics = serverModel . registerSubModel ( MessagingExtension . TOPIC_PATH , JMS_TOPIC_RESOURCE ) ; JMSTopicReadAttributeHandler . INSTANCE . registerAttributes ( deploymentTopics ) ; JMSTopicControlHandler . INSTANCE . registerOperations ( deploymentTopics ) ; } } public void initializeParsers ( ExtensionParsingContext context ) { } static void createParamRegistration ( final ManagementResourceRegistration parent ) { } } 
public class LocalVariable extends JavaElement implements ILocalVariable , ISourceReference { public int declarationSourceStart ; public int declarationEnd ; public int nameStart ; public int nameEnd ; public LocalVariable ( JavaElement parent , String name , int declarationSourceStart , int declarationEnd , int nameStart , int nameEnd ) { } protected void closing ( Object info ) throws JavaModelException { } protected Object createElementInfo ( ) { } public boolean equals ( Object o ) { } protected void generateInfos ( Object info , HashMap newElements , IProgressMonitor pm ) throws JavaModelException { } public IJavaElement getHandleFromMemento ( String token , StringTokenizer memento , WorkingCopyOwner owner ) { } public String getHandleMemento ( ) { } protected char getHandleMementoDelimiter ( ) { } public IResource getCorrespondingResource ( ) throws JavaModelException { } public int getElementType ( ) { } public ISourceRange getNameRange ( ) { } public IPath getPath ( ) { } public IResource getResource ( ) { } public String getSource ( ) throws JavaModelException { <START_BUG> IOpenable openable = getOpenableParent ( ) ; <END_BUG> IBuffer buffer = openable . getBuffer ( ) ; if ( buffer == null ) { return null ; } ISourceRange range = getSourceRange ( ) ; int offset = range . getOffset ( ) ; int length = range . getLength ( ) ; if ( ( offset == ( - 1 ) ) || ( length == 0 ) ) { return null ; } try { return buffer . getText ( offset , length ) ; } catch ( RuntimeException e ) { return null ; } } public ISourceRange getSourceRange ( ) throws JavaModelException { } public IResource getUnderlyingResource ( ) throws JavaModelException { } public int hashCode ( ) { } } 
public class ExpressionStatement extends Statement { private Expression expression = null ; ExpressionStatement ( AST ast ) { } public int getNodeType ( ) { } ASTNode clone ( AST target ) { ExpressionStatement result = new ExpressionStatement ( target ) ; result . setSourceRange ( this . getStartPosition ( ) , this . getLength ( ) ) ; <START_BUG> result . setLeadingComment ( getLeadingComment ( ) ) ; <END_BUG> result . setExpression ( ( ( Expression ) ( getExpression ( ) . clone ( target ) ) ) ) ; return result ; } public boolean subtreeMatch ( ASTMatcher matcher , Object other ) { } void accept0 ( ASTVisitor visitor ) { } public Expression getExpression ( ) { } public void setExpression ( Expression expression ) { } int memSize ( ) { } int treeSize ( ) { } } 
public abstract class AbstractAvailableCondition implements Condition { private Path m_classpath = new Path ( ) ; public void addClasspath ( final Path classpath ) throws TaskException { <START_BUG> m_classpath . addPath ( classpath ) ; <END_BUG> } protected ClassLoader buildClassLoader ( final TaskContext context ) throws TaskException { } } 
public class DropTargetEffect extends DropTargetAdapter { Control control ; public DropTargetEffect ( Control control ) { } public Control getControl ( ) { } public Widget getItem ( int x , int y ) { } Widget getItem ( Table table , int x , int y ) { } Widget getItem ( Tree tree , int x , int y ) { Point point = new Point ( x , y ) ; point = tree . toControl ( point ) ; TreeItem item = tree . getItem ( point ) ; if ( item == null ) { Rectangle area = tree . getClientArea ( ) ; if ( area . contains ( point ) ) { int treeBottom = ( area . y ) + ( area . height ) ; item = tree . getTopItem ( ) ; while ( item != null ) { Rectangle rect = item . getBounds ( ) ; int itemBottom = ( rect . y ) + ( rect . height ) ; <START_BUG> if ( ( ( rect . y ) <= ( point . y ) ) && ( ( point . y ) <= itemBottom ) ) <END_BUG> return item ; if ( itemBottom > treeBottom ) break ; item = nextItem ( tree , item ) ; } return null ; } } return item ; } TreeItem nextItem ( Tree tree , TreeItem item ) { } TreeItem previousItem ( Tree tree , TreeItem item ) { } } 
public class DivertRemove extends AbstractRemoveStepHandler implements DescriptionProvider { public static final DivertRemove INSTANCE = new DivertRemove ( ) ; private DivertRemove ( ) { } @ Override protected void performRemove ( OperationContext context , ModelNode operation , ModelNode model ) throws OperationFailedException { } @ Override protected void recoverServices ( OperationContext context , ModelNode operation , ModelNode model ) throws OperationFailedException { final ServiceRegistry registry = context . getServiceRegistry ( true ) ; final ServiceName hqServiceName = MessagingServices . getHornetQServiceName ( PathAddress . pathAddress ( operation . get ( OP_ADDR ) ) ) ; final ServiceController < ? > hqService = registry . getService ( hqServiceName ) ; if ( ( hqService != null ) && ( ( hqService . getState ( ) ) == ( State . UP ) ) ) { final String name = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) . getLastElement ( ) . getValue ( ) ; <START_BUG> final DivertConfiguration divertConfiguration = DivertAdd . createDivertConfiguration ( name , model ) ; <END_BUG> HornetQServer server = HornetQServer . class . cast ( hqService . getValue ( ) ) ; DivertAdd . createDivert ( name , divertConfiguration , server . getHornetQServerControl ( ) ) ; } } @ Override public ModelNode getModelDescription ( Locale locale ) { } } 
public class LazilyCompactedRow extends AbstractCompactedRow implements IIterableColumns { private final List < SSTableIdentityIterator > rows ; private final boolean major ; private final int gcBefore ; private final DataOutputBuffer headerBuffer ; private ColumnFamily emptyColumnFamily ; private LazilyCompactedRow . LazyColumnIterator iter ; private int columnCount ; private long columnSerializedSize ; public LazilyCompactedRow ( List < SSTableIdentityIterator > rows , boolean major , int gcBefore ) { } public void write ( DataOutput out ) throws IOException { } public void update ( MessageDigest digest ) { } public boolean isEmpty ( ) { <START_BUG> boolean cfIrrelevant = ( ColumnFamilyStore . removeDeleted ( emptyColumnFamily , gcBefore ) ) == null ; <END_BUG> return cfIrrelevant && ( ( columnCount ) == 0 ) ; } public int getEstimatedColumnCount ( ) { } public AbstractType getComparator ( ) { } public Iterator < IColumn > iterator ( ) { } private class LazyColumnIterator extends ReducingIterator < IColumn , IColumn > { ColumnFamily container = emptyColumnFamily . cloneMeShallow ( ) ; long serializedSize = 4 ; int size = 0 ; public LazyColumnIterator ( Iterator < IColumn > source ) { } @ Override protected boolean isEqual ( IColumn o1 , IColumn o2 ) { } public void reduce ( IColumn current ) { } protected IColumn getReduced ( ) { } } } 
public class TextChatComposite extends Composite { public static final Trace trace = Trace . create ( "textchatcomposite" ) ; protected static final int DEFAULT_INPUT_HEIGHT = 25 ; protected static final int DEFAULT_INPUT_SEPARATOR = 5 ; protected String TEXT_INPUT_INIT = MessageLoader . getString ( "TextChatComposite.textinputinit" ) ; protected Color meColor = null ; protected Color otherColor = null ; protected Color systemColor = null ; protected StyledText styledText ; protected TextViewer textoutput ; protected Text textinput ; protected int [ ] sashWeights = new int [ ] { 90 , 10 } ; protected ChatLayout cl = null ; protected boolean isTyping ; protected String initText ; protected ITextInputHandler inputHandler ; SimpleDateFormat df = new SimpleDateFormat ( "hh:mm<seq2seq4repair_space>a" ) ; protected IUser localUser ; protected IUser remoteUser ; protected boolean showTimestamp = true ; private Action outputClear = null ; private Action outputCopy = null ; private Action outputPaste = null ; private Action outputSelectAll = null ; public TextChatComposite ( Composite parent , int style , String initText , ITextInputHandler handler , IUser localUser , IUser remoteUser ) { } private void makeActions ( ) { } protected void outputClear ( ) { } protected void outputCopy ( ) { } protected void outputPaste ( ) { } protected void outputSelectAll ( ) { } private void hookContextMenu ( ) { } private void fillContextMenu ( IMenuManager manager ) { } public void setLocalUser ( IUser newUser ) { } public void setRemoteUser ( IUser remoteUser ) { } public IUser getRemoteUser ( ) { } protected String getCurrentDateTime ( ) { } private String makeLineWithTimestamp ( String line ) { } public IUser getLocalUser ( ) { } public void appendText ( ChatLine text ) { } protected void handleKeyPressed ( KeyEvent evt ) { <START_BUG> if ( ( evt . keyCode ) == ( SWT . CR ) ) { <END_BUG> handleEnter ( ) ; } } protected void handleEnter ( ) { } protected void clearInput ( ) { } protected void sendTextLineInput ( String text ) { } protected void sendStartedTyping ( ) { } protected String getShellName ( ) { } public void dispose ( ) { } protected void setDisposed ( ) { } protected void checkSubclass ( ) { } } 
class MemoryMXBeanAttributeHandler extends AbstractPlatformMBeanAttributeHandler { static final MemoryMXBeanAttributeHandler INSTANCE = new MemoryMXBeanAttributeHandler ( ) ; private MemoryMXBeanAttributeHandler ( ) { } @ Override protected void executeReadAttribute ( OperationContext context , ModelNode operation ) throws OperationFailedException { final String name = operation . require ( NAME ) . asString ( ) ; <START_BUG> if ( OBJECT_NAME . getName ( ) . equals ( name ) ) { <END_BUG> context . getResult ( ) . set ( ManagementFactory . MEMORY_MXBEAN_NAME ) ; } else if ( OBJECT_PENDING_FINALIZATION_COUNT . equals ( name ) ) { context . getResult ( ) . set ( ManagementFactory . getMemoryMXBean ( ) . getObjectPendingFinalizationCount ( ) ) ; } else if ( HEAP_MEMORY_USAGE . equals ( name ) ) { final ModelNode mu = PlatformMBeanUtil . getDetypedMemoryUsage ( ManagementFactory . getMemoryMXBean ( ) . getHeapMemoryUsage ( ) ) ; context . getResult ( ) . set ( mu ) ; } else if ( NON_HEAP_MEMORY_USAGE . equals ( name ) ) { final ModelNode mu = PlatformMBeanUtil . getDetypedMemoryUsage ( ManagementFactory . getMemoryMXBean ( ) . getNonHeapMemoryUsage ( ) ) ; context . getResult ( ) . set ( mu ) ; } else if ( VERBOSE . equals ( name ) ) { context . getResult ( ) . set ( ManagementFactory . getMemoryMXBean ( ) . isVerbose ( ) ) ; } else if ( ( MEMORY_METRICS . contains ( name ) ) || ( MEMORY_READ_WRITE_ATTRIBUTES . contains ( name ) ) ) { throw ROOT_LOGGER . badReadAttributeImpl ( name ) ; } else { throw unknownAttribute ( operation ) ; } } @ Override protected void executeWriteAttribute ( OperationContext context , ModelNode operation ) throws OperationFailedException { } } 
public class RequestHandlerStackTest extends BaseRequestHandlerStackTest { public RequestHandlerStackTest ( ) { } private boolean testFlag1 ; private boolean testFlag2 ; private boolean testFlag3 ; private boolean testFlag4 ; private boolean detachedFlag1 ; private boolean detachedFlag2 ; private boolean detachedFlag3 ; private boolean detachedFlag4 ; private void initFlags ( ) { } public void test1 ( ) { initFlags ( ) ; final Response originalResponse = newResponse ( ) ; final RequestHandlerStack stack = newStack ( originalResponse ) ; final IRequestHandler handler3 = new IRequestHandler ( ) { public void respond ( IRequestCycle requestCycle ) { testFlag3 = false ; } public void detach ( IRequestCycle requestCycle ) { detachedFlag3 = true ; } } ; final IRequestHandler handler2 = new IRequestHandler ( ) { public void respond ( IRequestCycle requestCycle ) { testFlag2 = false ; stack . replaceAllRequestHandlers ( handler3 ) ; testFlag2 = true ; } public void detach ( IRequestCycle requestCycle ) { detachedFlag2 = true ; } } ; final IRequestHandler handler1 = new IRequestHandler ( ) { public void respond ( IRequestCycle requestCycle ) { testFlag1 = false ; Response resp = newResponse ( ) ; stack . setResponse ( resp ) ; stack . executeRequestHandler ( handler2 ) ; assertEquals ( stack . getResponse ( ) , resp ) ; testFlag1 = true ; } public void detach ( IRequestCycle requestCycle ) { detachedFlag1 = true ; } } ; stack . executeRequestHandler ( handler1 ) ; assertEquals ( stack . getResponse ( ) , originalResponse ) ; stack . detach ( ) ; <START_BUG> assertTrue ( testFlag1 ) ; <END_BUG> assertFalse ( testFlag2 ) ; assertFalse ( testFlag3 ) ; assertTrue ( detachedFlag1 ) ; assertTrue ( detachedFlag2 ) ; assertTrue ( detachedFlag3 ) ; } public void test2 ( ) { } public void test3 ( ) { } } 
public class VirtualFolder extends MessageFolder { protected int nextUid ; protected HeaderList headerList ; public VirtualFolder ( FolderItem item , String path ) { } public VirtualFolder ( String name , String type , String path ) { } protected Object generateNextUid ( ) { } public void setNextUid ( int next ) { } public JDialog showFilterDialog ( AbstractMailFrameController frameController ) { } public boolean exists ( Object uid ) throws Exception { } public HeaderList getHeaderList ( ) throws Exception { } public void addSearchToHistory ( ) throws Exception { VirtualFolder searchFolder = ( ( VirtualFolder ) ( treeModel . getFolder ( 106 ) ) ) ; if ( ! ( searchFolder . equals ( this ) ) ) { return ; } if ( ( searchFolder . getChildCount ( ) ) >= 10 ) { MessageFolder child = ( ( MessageFolder ) ( searchFolder . getChildAt ( 0 ) ) ) ; child . removeFromParent ( ) ; } String name = "search<seq2seq4repair_space>result" ; VirtualFolder newFolder = null ; try { newFolder = ( ( VirtualFolder ) ( FolderFactory . getInstance ( ) . createChild ( searchFolder , name , "VirtualFolder" ) ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return ; } if ( newFolder == null ) { return ; } int uid = getFolderItem ( ) . getInteger ( "property" , "source_uid" ) ; boolean includes = getFolderItem ( ) . getBoolean ( "property" , "include_subfolders" ) ; FolderItem newFolderItem = newFolder . getFolderItem ( ) ; newFolderItem . set ( "property" , "source_uid" , uid ) ; newFolderItem . set ( "property" , "include_subfolders" , includes ) ; newFolderItem . getElement ( "filter" ) . removeFromParent ( ) ; newFolderItem . getRoot ( ) . addElement ( ( ( XmlElement ) ( getFolderItem ( ) . getElement ( "filter" ) . clone ( ) ) ) ) ; FilterCriteria newc = new Filter ( getFolderItem ( ) . getElement ( "filter" ) ) . getFilterRule ( ) . get ( 0 ) ; StringBuffer buf = new StringBuffer ( ) ; if ( newc . getType ( ) . equalsIgnoreCase ( "flags" ) ) { System . out . println ( "flags<seq2seq4repair_space>found" ) ; buf . append ( newc . getType ( ) ) ; buf . append ( "<seq2seq4repair_space>(" ) ; buf . append ( newc . getCriteriaString ( ) ) ; buf . append ( "<seq2seq4repair_space>" ) ; buf . append ( newc . getPattern ( ) ) ; buf . append ( ")" ) ; } else if ( newc . getType ( ) . equalsIgnoreCase ( "custom<seq2seq4repair_space>headerfield" ) ) { buf . append ( newc . getHeaderItemString ( ) ) ; buf . append ( "<seq2seq4repair_space>(" ) ; buf . append ( newc . getCriteriaString ( ) ) ; buf . append ( "<seq2seq4repair_space>" ) ; buf . append ( newc . getPattern ( ) ) ; buf . append ( ")" ) ; } else { buf . append ( newc . getType ( ) ) ; buf . append ( "<seq2seq4repair_space>(" ) ; buf . append ( newc . getCriteriaString ( ) ) ; buf . append ( "<seq2seq4repair_space>" ) ; buf . append ( newc . getPattern ( ) ) ; buf . append ( ")" ) ; } <START_BUG> newFolder . renameFolder ( buf . toString ( ) ) ; <END_BUG> treeModel . nodeStructureChanged ( searchFolder ) ; treeModel . nodeChanged ( newFolder ) ; } protected void applySearch ( ) throws Exception { } protected void applySearch ( MessageFolder parent , Filter filter ) throws Exception { } public DefaultSearchEngine getSearchEngine ( ) { } public Filter getFilter ( ) { } public Object getVirtualUid ( MessageFolder parent , Object uid ) throws Exception { } public void add ( ColumbaHeader header , MessageFolder f , Object uid ) throws Exception { } public void markMessage ( Object [ ] uids , int variant ) throws Exception { } protected void removeMessage ( Object uid ) throws Exception { } public MimePart getMimePart ( Object uid , Integer [ ] address ) throws Exception { } public MimeTree getMimePartTree ( Object uid ) throws Exception { } public ColumbaHeader getMessageHeader ( Object uid ) throws Exception { } public ColumbaMessage getMessage ( Object uid , WorkerStatusController worker ) throws Exception { } public Object [ ] searchMessages ( Filter filter , Object [ ] uids ) throws Exception { } public Object [ ] searchMessages ( Filter filter ) throws Exception { } public String getDefaultChild ( ) { } public static XmlElement getDefaultProperties ( ) { } public FolderCommandReference [ ] getCommandReference ( FolderCommandReference [ ] r ) { } public boolean tryToGetLock ( Object locker ) { } public Object [ ] getUids ( ) throws Exception { } public Object addMessage ( InputStream in ) throws Exception { } public Object getAttribute ( Object uid , String key ) throws Exception { } public Flags getFlags ( Object uid ) throws Exception { } public Header getHeaderFields ( Object uid , String [ ] keys ) throws Exception { } public InputStream getMessageSourceStream ( Object uid ) throws Exception { } public InputStream getMimePartBodyStream ( Object uid , Integer [ ] address ) throws Exception { } public InputStream getMimePartSourceStream ( Object uid , Integer [ ] address ) throws Exception { } public boolean supportsAddMessage ( ) { } public boolean supportsAddFolder ( AbstractFolder newFolder ) { } public void innerCopy ( MailboxInterface destFolder , Object [ ] uids ) { } public void setAttribute ( Object uid , String key , Object value ) throws Exception { } public Attributes getAttributes ( Object uid ) throws Exception { } public Object addMessage ( InputStream in , Attributes attributes ) throws Exception { } public HeaderListStorage getHeaderListStorage ( ) { } } 
class WebConnectorMetrics implements OperationStepHandler { static WebConnectorMetrics INSTANCE = new WebConnectorMetrics ( ) ; protected static final SimpleAttributeDefinition BYTES_SENT = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . BYTES_SENT , org . jboss . dmr . ModelType . INT , true ) . setStorageRuntime ( ) . build ( ) ; protected static final SimpleAttributeDefinition BYTES_RECEIVED = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . BYTES_RECEIVED , org . jboss . dmr . ModelType . INT , true ) . setStorageRuntime ( ) . build ( ) ; protected static final SimpleAttributeDefinition PROCESSING_TIME = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . PROCESSING_TIME , org . jboss . dmr . ModelType . INT , true ) . setStorageRuntime ( ) . build ( ) ; protected static final SimpleAttributeDefinition ERROR_COUNT = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . ERROR_COUNT , org . jboss . dmr . ModelType . INT , true ) . setStorageRuntime ( ) . build ( ) ; protected static final SimpleAttributeDefinition MAX_TIME = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . MAX_TIME , org . jboss . dmr . ModelType . INT , true ) . setStorageRuntime ( ) . build ( ) ; protected static final SimpleAttributeDefinition REQUEST_COUNT = new org . jboss . as . controller . SimpleAttributeDefinitionBuilder ( Constants . REQUEST_COUNT , org . jboss . dmr . ModelType . INT , true ) . setStorageRuntime ( ) . build ( ) ; @ Deprecated static final String [ ] ATTRIBUTES_OLD = new String [ ] { Constants . BYTES_SENT , Constants . BYTES_RECEIVED , Constants . PROCESSING_TIME , Constants . ERROR_COUNT , Constants . MAX_TIME , Constants . REQUEST_COUNT } ; static final SimpleAttributeDefinition [ ] ATTRIBUTES = new SimpleAttributeDefinition [ ] { WebConnectorMetrics . BYTES_SENT , WebConnectorMetrics . BYTES_RECEIVED , WebConnectorMetrics . PROCESSING_TIME , WebConnectorMetrics . ERROR_COUNT , WebConnectorMetrics . MAX_TIME , WebConnectorMetrics . REQUEST_COUNT } ; @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { if ( context . isNormalServer ( ) ) { context . addStep ( new OperationStepHandler ( ) { @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { final PathAddress address = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) ; final String name = address . getLastElement ( ) . getValue ( ) ; final String attributeName = operation . require ( NAME ) . asString ( ) ; final ServiceController < ? > controller = context . getServiceRegistry ( false ) . getService ( JBOSS_WEB_CONNECTOR . append ( name ) ) ; if ( controller != null ) { try { final Connector connector = ( ( Connector ) ( controller . getValue ( ) ) ) ; final ModelNode result = context . getResult ( ) ; if ( ( ( connector . getProtocolHandler ( ) ) != null ) && ( ( connector . getProtocolHandler ( ) . getRequestGroupInfo ( ) ) != null ) ) { RequestGroupInfo info = connector . getProtocolHandler ( ) . getRequestGroupInfo ( ) ; if ( Constants . BYTES_SENT . equals ( attributeName ) ) { result . set ( ( "" + ( info . getBytesSent ( ) ) ) ) ; } else if ( Constants . BYTES_RECEIVED . equals ( attributeName ) ) { result . set ( ( "" + ( info . getBytesReceived ( ) ) ) ) ; } else if ( Constants . PROCESSING_TIME . equals ( attributeName ) ) { result . set ( ( "" + ( info . getProcessingTime ( ) ) ) ) ; } else if ( Constants . ERROR_COUNT . equals ( attributeName ) ) { result . set ( ( "" + ( info . getErrorCount ( ) ) ) ) ; } else if ( Constants . MAX_TIME . equals ( attributeName ) ) { result . set ( ( "" + ( info . getMaxTime ( ) ) ) ) ; } else if ( Constants . REQUEST_COUNT . equals ( attributeName ) ) { result . set ( ( "" + ( info . getRequestCount ( ) ) ) ) ; } } } catch ( Exception e ) { throw new OperationFailedException ( new ModelNode ( ) . set ( WebMessages . MESSAGES . failedToGetMetrics ( e . getMessage ( ) ) ) ) ; } } else { context . getResult ( ) . set ( WebMessages . MESSAGES . noMetricsAvailable ( ) ) ; } context . completeStep ( NOOP_ROLLBACK_HANDLER ) ; } } , RUNTIME ) ; } else { context . getResult ( ) . set ( WebMessages . MESSAGES . noMetricsAvailable ( ) ) ; } <START_BUG> context . completeStep ( NOOP_ROLLBACK_HANDLER ) ; <END_BUG> } } 
public void deselectAll ( ) { } void dropDown ( boolean drop ) { } Label getAssociatedLabel ( ) { } public Control [ ] getChildren ( ) { } public boolean getEditable ( ) { } public String getItem ( int index ) { } public int getItemCount ( ) { } public int getItemHeight ( ) { } public String [ ] getItems ( ) { } char getMnemonic ( String string ) { } public Point getSelection ( ) { } public int getSelectionIndex ( ) { } public int getStyle ( ) { } public String getText ( ) { } public int getTextHeight ( ) { } public int getTextLimit ( ) { } public int getVisibleItemCount ( ) { } void handleFocus ( int type ) { } public int indexOf ( String string ) { } public int indexOf ( String string , int start ) { } void initAccessible ( ) { AccessibleAdapter accessibleAdapter = new AccessibleAdapter ( ) { public void getName ( AccessibleEvent e ) { String name = null ; Label label = getAssociatedLabel ( ) ; if ( label != null ) { name = stripMnemonic ( label . getText ( ) ) ; } e . result = name ; } public void getKeyboardShortcut ( AccessibleEvent e ) { String shortcut = null ; Label label = getAssociatedLabel ( ) ; if ( label != null ) { String text = label . getText ( ) ; if ( text != null ) { char mnemonic = getMnemonic ( text ) ; if ( mnemonic != ' ' ) { shortcut = "Alt+" + mnemonic ; } } } e . result = shortcut ; } public void getHelp ( AccessibleEvent e ) { e . result = getToolTipText ( ) ; } } ; getAccessible ( ) . addAccessibleListener ( accessibleAdapter ) ; text . getAccessible ( ) . addAccessibleListener ( accessibleAdapter ) ; list . getAccessible ( ) . addAccessibleListener ( accessibleAdapter ) ; arrow . getAccessible ( ) . addAccessibleListener ( new AccessibleAdapter ( ) { public void getName ( AccessibleEvent e ) { e . result = ( isDropped ( ) ) ? "Close" : "Open" ; } public void getKeyboardShortcut ( AccessibleEvent e ) { e . result = "Alt+Down<seq2seq4repair_space>Arrow" ; } public void getHelp ( AccessibleEvent e ) { e . result = getToolTipText ( ) ; } } ) ; getAccessible ( ) . addAccessibleTextListener ( new AccessibleTextAdapter ( ) { public void getCaretOffset ( AccessibleTextEvent e ) { e . offset = text . getCaretPosition ( ) ; } } ) ; getAccessible ( ) . addAccessibleControlListener ( new AccessibleControlAdapter ( ) { public void getChildAtPoint ( AccessibleControlEvent e ) { Point testPoint = toControl ( e . x , e . y ) ; if ( getBounds ( ) . contains ( testPoint ) ) { e . childID = ACC . CHILDID_SELF ; } } public void getLocation ( AccessibleControlEvent e ) { Rectangle location = getBounds ( ) ; Point pt = toDisplay ( location . x , location . y ) ; e . x = pt . x ; e . y = pt . y ; e . width = location . width ; e . height = location . height ; } public void getChildCount ( AccessibleControlEvent e ) { e . detail = 0 ; } public void getRole ( AccessibleControlEvent e ) { e . detail = ACC . ROLE_COMBOBOX ; } public void getState ( AccessibleControlEvent e ) { e . detail = ACC . STATE_NORMAL ; } public void getValue ( AccessibleControlEvent e ) { e . result = getText ( ) ; } } ) ; text . getAccessible ( ) . addAccessibleControlListener ( new AccessibleControlAdapter ( ) { public void getRole ( AccessibleControlEvent e ) { e . detail = ( text . getEditable ( ) ) ? ACC . ROLE_TEXT : ACC . ROLE_LABEL ; } } ) ; arrow . getAccessible ( ) . addAccessibleControlListener ( new AccessibleControlAdapter ( ) { public void getDefaultAction ( AccessibleControlEvent e ) { <START_BUG> e . result = ( isDropped ( ) ) ? "Close" : "Open" ; <END_BUG> } } ) ; } boolean isDropped ( ) { } public boolean isFocusControl ( ) { } void internalLayout ( boolean changed ) { } void listEvent ( Event event ) { } void popupEvent ( Event event ) { } public void redraw ( ) { } public void redraw ( int x , int y , int width , int height , boolean all ) { } public void remove ( int index ) { } public void remove ( int start , int end ) { } public void remove ( String string ) { } public void removeAll ( ) { } public void removeModifyListener ( ModifyListener listener ) { } public void removeSelectionListener ( SelectionListener listener ) { } public void select ( int index ) { } public void setBackground ( Color color ) { } public void setEditable ( boolean editable ) { } public void setEnabled ( boolean enabled ) { } public boolean setFocus ( ) { } public void setFont ( Font font ) { } public void setForeground ( Color color ) { } public void setItem ( int index , String string ) { } public void setItems ( String [ ] items ) { } public void setLayout ( Layout layout ) { } public void setSelection ( Point selection ) { } public void setText ( String string ) { } public void setTextLimit ( int limit ) { } public void setToolTipText ( String string ) { } public void setVisible ( boolean visible ) { } public void setVisibleItemCount ( int count ) { } String stripMnemonic ( String string ) { } void textEvent ( Event event ) { } } 
public class AjaxTimerBehaviorTest extends WicketTestCase { private static final Logger log = LoggerFactory . getLogger ( AjaxTimerBehaviorTest . class ) ; public AjaxTimerBehaviorTest ( String name ) { } public void testAddToAjaxUpdate ( ) { } public void testAddToWebPage ( ) { } private void validate ( AjaxTimerBehaviorTest . MyAjaxSelfUpdatingTimerBehavior timer , boolean inBodyOnLoad ) { String document = tester . getServletResponse ( ) . getDocument ( ) ; String updateScript = timer . getUpdateScript ( ) ; if ( inBodyOnLoad ) { <START_BUG> String bodyOnLoadUpdateScript = ( "Wicket.Event.add(window,<seq2seq4repair_space>\"load\",<seq2seq4repair_space>function()<seq2seq4repair_space>{<seq2seq4repair_space>" + updateScript ) + ";});" ; <END_BUG> validateTimerScript ( document , bodyOnLoadUpdateScript ) ; } else { validateTimerScript ( document , updateScript ) ; } tester . executeBehavior ( timer ) ; if ( inBodyOnLoad ) { updateScript = timer . getUpdateScript ( ) ; } document = tester . getServletResponse ( ) . getDocument ( ) ; validateTimerScript ( document , updateScript ) ; } private void validateTimerScript ( String document , String updateScript ) { } private static final String quote ( String s ) { } static class MyAjaxSelfUpdatingTimerBehavior extends AjaxSelfUpdatingTimerBehavior { private static final long serialVersionUID = 1L ; private final Duration duration ; String updateScript ; public MyAjaxSelfUpdatingTimerBehavior ( Duration updateInterval ) { } @ Override protected void onComponentRendered ( ) { } public String getUpdateScript ( ) { } } } 
public class GenericSubsystemDescribeHandler implements OperationStepHandler , DescriptionProvider { public static final GenericSubsystemDescribeHandler INSTANCE = new GenericSubsystemDescribeHandler ( ) ; protected GenericSubsystemDescribeHandler ( ) { } @ Override public void execute ( final OperationContext context , final ModelNode operation ) throws OperationFailedException { } protected void describe ( final Resource resource , final ModelNode address , ModelNode result , final ImmutableManagementResourceRegistration registration ) { <START_BUG> if ( ( ( ( registration . isRemote ( ) ) || ( registration . isRuntimeOnly ( ) ) ) || ( resource . isProxy ( ) ) ) || ( resource . isRuntime ( ) ) ) { <END_BUG> return ; } final Set < PathElement > children = registration . getChildAddresses ( EMPTY_ADDRESS ) ; result . add ( createAddOperation ( address , resource . getModel ( ) , children ) ) ; for ( final PathElement element : children ) { if ( element . isMultiTarget ( ) ) { final String childType = element . getKey ( ) ; for ( final Resource . ResourceEntry entry : resource . getChildren ( childType ) ) { final ImmutableManagementResourceRegistration childRegistration = registration . getSubModel ( PathAddress . pathAddress ( PathElement . pathElement ( childType , entry . getName ( ) ) ) ) ; final ModelNode childAddress = address . clone ( ) ; childAddress . add ( childType , entry . getName ( ) ) ; describe ( entry , childAddress , result , childRegistration ) ; } } else { final Resource child = resource . getChild ( element ) ; final ImmutableManagementResourceRegistration childRegistration = registration . getSubModel ( PathAddress . pathAddress ( element ) ) ; final ModelNode childAddress = address . clone ( ) ; childAddress . add ( element . getKey ( ) , element . getValue ( ) ) ; describe ( child , childAddress , result , childRegistration ) ; } } } protected ModelNode createAddOperation ( final ModelNode address , final ModelNode subModel , final Set < PathElement > children ) { } @ Override public ModelNode getModelDescription ( Locale locale ) { } } 
public class RaActivate implements OperationStepHandler { static final RaActivate INSTANCE = new RaActivate ( ) ; public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { final ModelNode address = operation . require ( OP_ADDR ) ; final String idName = PathAddress . pathAddress ( address ) . getLastElement ( ) . getValue ( ) ; final String raName = context . readResource ( EMPTY_ADDRESS ) . getModel ( ) . get ( "archive" ) . asString ( ) ; if ( context . isNormalServer ( ) ) { context . addStep ( new OperationStepHandler ( ) { public void execute ( final OperationContext context , ModelNode operation ) throws OperationFailedException { final ServiceVerificationHandler svh = new ServiceVerificationHandler ( ) ; ServiceName restartedServiceName = RaOperationUtil . restartIfPresent ( context , raName , idName , svh ) ; if ( restartedServiceName == null ) { RaOperationUtil . activate ( context , idName , svh ) ; } context . addStep ( svh , VERIFY ) ; context . completeStep ( new OperationContext . RollbackHandler ( ) { @ Override public void handleRollback ( OperationContext context , ModelNode operation ) { try { <START_BUG> RaOperationUtil . removeIfActive ( context , raName ) ; <END_BUG> } catch ( OperationFailedException e ) { } } } ) ; } } , RUNTIME ) ; } context . stepCompleted ( ) ; } } 
@ RunWith ( Arquillian . class ) public class ServerInModuleDeploymentTestCase { @ Test public void testDeploymentStreamApi ( ) throws Exception { } @ Test public void testDeploymentFileApi ( ) throws Exception { } @ Test public void testFilesystemScannerRegistration ( ) throws Exception { } @ Test public void testFilesystemDeployment_Marker ( ) throws Exception { } @ Test public void testFilesystemDeployment_Auto ( ) throws Exception { } @ Test public void testExplodedFilesystemDeployment ( ) throws Exception { } private ModelNode addDeploymentScanner ( final File deployDir , final ModelControllerClient client , final String scannerName , final boolean autoDeployZipped ) throws IOException { } private void removeDeploymentScanner ( final ModelControllerClient client , final String scannerName ) throws IOException { } private File createDeploymentDir ( String dir ) { } private void testDeployments ( ModelControllerClient client , ServerInModuleDeploymentTestCase . DeploymentExecutor deploymentExecutor ) throws Exception { <START_BUG> final MBeanServerConnection mbeanServer = JMXConnectorFactory . connect ( new JMXServiceURL ( "service:jmx:remote://127.0.0.1:9999" ) ) . getMBeanServerConnection ( ) ; <END_BUG> final ObjectName name = new ObjectName ( "jboss.test:service=testdeployments" ) ; try { deploymentExecutor . initialDeploy ( ) ; PollingUtils . retryWithTimeout ( 10000 , new PollingUtils . WaitForMBeanTask ( mbeanServer , name ) ) ; Assert . assertNotNull ( mbeanServer . getMBeanInfo ( name ) ) ; deploymentExecutor . fullReplace ( ) ; PollingUtils . retryWithTimeout ( 10000 , new PollingUtils . WaitForMBeanTask ( mbeanServer , name ) ) ; Assert . assertNotNull ( mbeanServer . getMBeanInfo ( name ) ) ; deploymentExecutor . undeploy ( ) ; try { long start = System . currentTimeMillis ( ) ; while ( ( ( System . currentTimeMillis ( ) ) - start ) < 10000 ) { mbeanServer . getMBeanInfo ( name ) ; Thread . sleep ( 100 ) ; } Assert . fail ( "Should<seq2seq4repair_space>not<seq2seq4repair_space>have<seq2seq4repair_space>found<seq2seq4repair_space>MBean" ) ; } catch ( Exception expected ) { } } finally { } } private void awaitDeploymentExecution ( Future < ? > future ) { } private static void cleanFile ( File toClean ) { } private interface DeploymentExecutor { void initialDeploy ( ) throws IOException { } void fullReplace ( ) throws IOException { } void undeploy ( ) throws IOException { } } private static class TestNotificationListener implements NotificationListener { private final ObjectName name ; private volatile CountDownLatch latch = new CountDownLatch ( 1 ) ; private TestNotificationListener ( ObjectName name ) { } @ Override public void handleNotification ( Notification notification , Object handback ) { } void reset ( int i ) { } void await ( ) throws Exception { } } } 
public class ImportDeclaration extends SourceRefElement implements IImportDeclaration { protected String name ; protected boolean isOnDemand ; protected ImportDeclaration ( ImportContainer parent , String name , boolean isOnDemand ) { } public boolean equals ( Object o ) { } public String getElementName ( ) { } public String getNameWithoutStar ( ) { } public int getElementType ( ) { } public int getFlags ( ) throws JavaModelException { } protected void getHandleMemento ( StringBuffer buff ) { } protected char getHandleMementoDelimiter ( ) { } public IJavaElement getPrimaryElement ( boolean checkOwner ) { } public boolean isOnDemand ( ) { } public String readableName ( ) { } protected void toStringInfo ( int tab , StringBuffer buffer , Object info , boolean showResolvedInfo ) { <START_BUG> buffer . append ( this . tabString ( tab ) ) ; <END_BUG> buffer . append ( "import<seq2seq4repair_space>" ) ; toStringName ( buffer ) ; if ( info == null ) { buffer . append ( "<seq2seq4repair_space>(not<seq2seq4repair_space>open)" ) ; } } } 
public class MethodInvokingJobDetailFactoryBean extends ArgumentConvertingMethodInvoker implements BeanClassLoaderAware , BeanFactoryAware , BeanNameAware , FactoryBean < Object > , InitializingBean { private String name ; private String group = Scheduler . DEFAULT_GROUP ; private boolean concurrent = true ; private String targetBeanName ; private String [ ] jobListenerNames ; private String beanName ; private ClassLoader beanClassLoader = ClassUtils . getDefaultClassLoader ( ) ; private BeanFactory beanFactory ; private JobDetail jobDetail ; public void setName ( String name ) { } public void setGroup ( String group ) { } public void setConcurrent ( boolean concurrent ) { } public void setTargetBeanName ( String targetBeanName ) { } public void setJobListenerNames ( String [ ] names ) { } public void setBeanName ( String beanName ) { } public void setBeanClassLoader ( ClassLoader classLoader ) { } public void setBeanFactory ( BeanFactory beanFactory ) { } @ Override protected Class resolveClassName ( String className ) throws ClassNotFoundException { } public void afterPropertiesSet ( ) throws ClassNotFoundException , NoSuchMethodException { } protected void postProcessJobDetail ( JobDetail jobDetail ) { } @ Override public Class getTargetClass ( ) { } @ Override public Object getTargetObject ( ) { } public Object getObject ( ) { } public Class < ? > getObjectType ( ) { } public boolean isSingleton ( ) { } public static class MethodInvokingJob extends QuartzJobBean { protected static final Log logger = LogFactory . getLog ( MethodInvokingJobDetailFactoryBean . MethodInvokingJob . class ) ; private MethodInvoker methodInvoker ; public void setMethodInvoker ( MethodInvoker methodInvoker ) { } @ Override protected void executeInternal ( JobExecutionContext context ) throws JobExecutionException { try { <START_BUG> this . methodInvoker . invoke ( ) ; <END_BUG> } catch ( InvocationTargetException ex ) { if ( ( ex . getTargetException ( ) ) instanceof JobExecutionException ) { throw ( ( JobExecutionException ) ( ex . getTargetException ( ) ) ) ; } else { throw new JobMethodInvocationFailedException ( this . methodInvoker , ex . getTargetException ( ) ) ; } } catch ( Exception ex ) { throw new JobMethodInvocationFailedException ( this . methodInvoker , ex ) ; } } } public static class StatefulMethodInvokingJob extends MethodInvokingJobDetailFactoryBean . MethodInvokingJob implements StatefulJob { } } 
public class WithinPointcut extends Pointcut { TypePattern type ; public WithinPointcut ( TypePattern type ) { } public FuzzyBoolean match ( Shadow shadow ) { } public void write ( DataOutputStream s ) throws IOException { } public static Pointcut read ( DataInputStream s , ISourceContext context ) throws IOException { } public void resolveBindings ( IScope scope , Bindings bindings ) { <START_BUG> type = type . resolveBindings ( scope , bindings , false ) ; <END_BUG> } public void postRead ( ResolvedTypeX enclosingType ) { } public boolean equals ( Object other ) { } public int hashCode ( ) { } public String toString ( ) { } public Test findResidue ( Shadow shadow , ExposedState state ) { } public Pointcut concretize1 ( ResolvedTypeX inAspect , IntMap bindings ) { } } 
public class VFSResourceLoader implements ResourceLoader { private final ModuleIdentifier moduleIdentifier ; private final VirtualFile root ; private final String rootName ; private final Manifest manifest ; private final MountHandle mountHandle ; public VFSResourceLoader ( final ModuleIdentifier moduleIdentifier , final String rootName , final VirtualFile root , final MountHandle mountHandle ) throws IOException { } public ClassSpec getClassSpec ( final String name ) throws IOException { } public PackageSpec getPackageSpec ( final String name ) throws IOException { } private static String getDefinedAttribute ( Attributes . Name name , Attributes entryAttribute , Attributes mainAttribute ) { } public String getLibrary ( final String name ) { } public String getRootName ( ) { } public PathFilter getExportFilter ( ) { } public Resource getResource ( final String name ) { try { final VirtualFile file = root . getChild ( name ) ; if ( ! ( file . exists ( ) ) ) { return null ; } <START_BUG> return new VFSResourceLoader . VFSEntryResource ( file , root . toURL ( ) ) ; <END_BUG> } catch ( MalformedURLException e ) { return null ; } } public Collection < String > getPaths ( ) { } static class VFSEntryResource implements Resource { private final VirtualFile entry ; private final URL resourceURL ; VFSEntryResource ( final VirtualFile entry , final URL resourceURL ) { } public String getName ( ) { } public URL getURL ( ) { } public InputStream openStream ( ) throws IOException { } public long getSize ( ) { } } } 
public class ConnectionPropertyAdd extends AbstractAddStepHandler implements DescriptionProvider { public static final ConnectionPropertyAdd INSTANCE = new ConnectionPropertyAdd ( ) ; @ Override public ModelNode getModelDescription ( Locale locale ) { } @ Override protected void populateModel ( ModelNode operation , ModelNode modelNode ) throws OperationFailedException { } @ Override protected void performRuntime ( OperationContext context , ModelNode operation , ModelNode recoveryEnvModel , ServiceVerificationHandler verificationHandler , List < ServiceController < ? > > serviceControllers ) throws OperationFailedException { <START_BUG> final String configPropertyValue = Constants . CONNECTION_PROPERTY_VALUE . validateResolvedOperation ( recoveryEnvModel ) . asString ( ) ; <END_BUG> final ModelNode address = operation . require ( OP_ADDR ) ; PathAddress path = PathAddress . pathAddress ( address ) ; final String jndiName = path . getElement ( ( ( path . size ( ) ) - 2 ) ) . getValue ( ) ; final String configPropertyName = PathAddress . pathAddress ( address ) . getLastElement ( ) . getValue ( ) ; ServiceName serviceName = SERVICE_NAME_BASE . append ( jndiName ) . append ( configPropertyName ) ; ServiceName dsServiceName = SERVICE_NAME_BASE . append ( jndiName ) ; final ServiceRegistry registry = context . getServiceRegistry ( true ) ; final ServiceName dataSourceConfigServiceName = SERVICE_NAME_BASE . append ( jndiName ) ; final ServiceController < ? > dataSourceConfigController = registry . getService ( dataSourceConfigServiceName ) ; if ( ( dataSourceConfigController != null ) && ( ! ( ( ( org . jboss . jca . common . api . metadata . ds . DataSource ) ( dataSourceConfigController . getValue ( ) ) ) . isEnabled ( ) ) ) ) { final ServiceTarget serviceTarget = context . getServiceTarget ( ) ; final ConnectionPropertiesService service = new ConnectionPropertiesService ( configPropertyName , configPropertyValue ) ; serviceTarget . addService ( serviceName , service ) . setInitialMode ( ACTIVE ) . addDependency ( dsServiceName , ModifiableDataSource . class , service . getDSInjector ( ) ) . addListener ( verificationHandler ) . install ( ) ; context . addStep ( verificationHandler , VERIFY ) ; } else { context . reloadRequired ( ) ; } } } 
public class InterceptorsAnnotationParsingProcessor implements DeploymentUnitProcessor { private static final DotName INTERCEPTORS_ANNOTATION_NAME = DotName . createSimple ( Interceptors . class . getName ( ) ) ; private static final DotName EXCLUDE_DEFAULT_ANNOTATION_NAME = DotName . createSimple ( ExcludeDefaultInterceptors . class . getName ( ) ) ; private static final DotName EXCLUDE_CLASS_ANNOTATION_NAME = DotName . createSimple ( ExcludeClassInterceptors . class . getName ( ) ) ; public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { } private void processInterceptors ( final EEModuleDescription eeModuleDescription , final AnnotationInstance annotation , final CompositeIndex index ) throws DeploymentUnitProcessingException { } private void processMethodInterceptor ( final EEModuleDescription eeModuleDescription , final MethodInfo methodInfo , final AnnotationInstance annotation , final CompositeIndex index ) { } private void processClassInterceptor ( final EEModuleDescription eeModuleDescription , final ClassInfo classInfo , final AnnotationInstance annotation , final CompositeIndex index ) { } private void processExcludeDefault ( final EEModuleDescription eeModuleDescription , final AnnotationInstance annotation , final CompositeIndex index ) throws DeploymentUnitProcessingException { } private void processClassExcludeDefault ( EEModuleDescription eeModuleDescription , final ClassInfo classInfo , final CompositeIndex index ) { } private void processMethodExcludeDefault ( EEModuleDescription eeModuleDescription , MethodInfo methodInfo , final CompositeIndex index ) { } private void processExcludeClass ( final EEModuleDescription eeModuleDescription , final AnnotationInstance annotation , final CompositeIndex index ) throws DeploymentUnitProcessingException { } public void undeploy ( DeploymentUnit context ) { } private static MethodIdentifier methodIdentifierFromMethodInfo ( MethodInfo methodInfo ) { } private Collection < ComponentDescription > getApplicableComponents ( final CompositeIndex index , final ClassInfo klass , final EEModuleDescription eeModuleDescription ) { Set < ComponentDescription > componentDescriptions = new HashSet < ComponentDescription > ( ) ; final List < ComponentDescription > descriptions = eeModuleDescription . getComponentsByClassName ( klass . name ( ) . toString ( ) ) ; <START_BUG> if ( componentDescriptions . isEmpty ( ) ) { <END_BUG> componentDescriptions . addAll ( descriptions ) ; } else { componentDescriptions . addAll ( this . getKnownSubClassComponents ( index , klass , eeModuleDescription ) ) ; } return componentDescriptions ; } private Collection < ComponentDescription > getKnownSubClassComponents ( final CompositeIndex index , final ClassInfo superClass , final EEModuleDescription eeModuleDescription ) { } } 
public class ProgressView extends ViewPart implements IViewPart { ProgressTreeViewer viewer ; Action cancelAction ; public void createPartControl ( Composite parent ) { } public void setFocus ( ) { } protected void initContentProvider ( ) { } private void initContextMenu ( ) { } private void initPulldownMenu ( ) { IMenuManager menuMgr = ( ( org . eclipse . ui . internal . ViewSite ) ( getSite ( ) ) ) . getActionBars ( ) . getMenuManager ( ) ; menuMgr . add ( new Action ( ProgressMessages . getString ( "ProgressView.VerboseAction" ) , IAction . AS_CHECK_BOX ) { public void run ( ) { ProgressViewUpdater updater = ProgressViewUpdater . getSingleton ( ) ; updater . debug = ! ( updater . debug ) ; setChecked ( updater . debug ) ; updater . refreshAll ( ) ; } } ) ; <START_BUG> menuMgr . add ( new Action ( "&Toggle<seq2seq4repair_space>Floating<seq2seq4repair_space>Window" ) { <END_BUG> public void run ( ) { AnimationManager . getInstance ( ) . toggleFloatingWindow ( ) ; } } ) ; } private IStructuredSelection getSelection ( ) { } JobInfo getSelectedInfo ( ) { } private void createCancelAction ( ) { } } 
public class SwitchStatement extends Statement { public Expression expression ; public Statement [ ] statements ; public BlockScope scope ; public int explicitDeclarations ; public Label breakLabel ; public CaseStatement [ ] cases ; public CaseStatement defaultCase ; public int blockStart ; public int caseCount ; int [ ] constants ; public SyntheticMethodBinding synthetic ; int preSwitchInitStateIndex = - 1 ; int mergedInitStateIndex = - 1 ; public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public StringBuffer printStatement ( int indent , StringBuffer output ) { } public void resolve ( BlockScope upperScope ) { try { boolean isEnumSwitch = false ; TypeBinding expressionType = expression . resolveType ( upperScope ) ; if ( expressionType == null ) return ; expression . computeConversion ( upperScope , expressionType , expressionType ) ; checkType : { if ( expressionType . isBaseType ( ) ) { if ( expression . isConstantValueOfTypeAssignableToType ( expressionType , IntBinding ) ) break checkType ; if ( expressionType . isCompatibleWith ( IntBinding ) ) break checkType ; } else if ( expressionType . isEnum ( ) ) { isEnumSwitch = true ; break checkType ; } else if ( upperScope . isBoxingCompatibleWith ( expressionType , IntBinding ) ) { expression . computeConversion ( upperScope , IntBinding , expressionType ) ; break checkType ; } upperScope . problemReporter ( ) . incorrectSwitchType ( expression , expressionType ) ; return ; } if ( ( statements ) != null ) { scope = new BlockScope ( upperScope ) ; int length ; cases = new CaseStatement [ length = statements . length ] ; this . constants = new int [ length ] ; CaseStatement [ ] duplicateCaseStatements = null ; int duplicateCaseStatementsCounter = 0 ; int counter = 0 ; for ( int i = 0 ; i < length ; i ++ ) { Constant constant ; final Statement statement = statements [ i ] ; if ( ( constant = statement . resolveCase ( scope , expressionType , this ) ) != ( Constant . NotAConstant ) ) { int key = constant . intValue ( ) ; for ( int j = 0 ; j < counter ; j ++ ) { if ( ( this . constants [ j ] ) == key ) { final CaseStatement currentCaseStatement = ( ( CaseStatement ) ( statement ) ) ; if ( duplicateCaseStatements == null ) { scope . problemReporter ( ) . duplicateCase ( cases [ j ] ) ; scope . problemReporter ( ) . duplicateCase ( currentCaseStatement ) ; duplicateCaseStatements = new CaseStatement [ length ] ; duplicateCaseStatements [ ( duplicateCaseStatementsCounter ++ ) ] = cases [ j ] ; duplicateCaseStatements [ ( duplicateCaseStatementsCounter ++ ) ] = currentCaseStatement ; } else { boolean found = false ; searchReportedDuplicate : for ( int k = 2 ; k < duplicateCaseStatementsCounter ; k ++ ) { if ( ( duplicateCaseStatements [ k ] ) == statement ) { found = true ; break searchReportedDuplicate ; } } if ( ! found ) { scope . problemReporter ( ) . duplicateCase ( currentCaseStatement ) ; duplicateCaseStatements [ ( duplicateCaseStatementsCounter ++ ) ] = currentCaseStatement ; } } } } this . constants [ ( counter ++ ) ] = key ; } } if ( length != counter ) { System . arraycopy ( this . constants , 0 , ( this . constants = new int [ counter ] ) , 0 , counter ) ; } } else { if ( ( ( this . bits ) & ( ASTNode . UndocumentedEmptyBlock ) ) != 0 ) { upperScope . problemReporter ( ) . undocumentedEmptyBlock ( this . blockStart , this . sourceEnd ) ; } } if ( ( isEnumSwitch && ( ( defaultCase ) == null ) ) && ( ( upperScope . compilerOptions ( ) . getSeverity ( IncompleteEnumSwitch ) ) != ( ProblemSeverities . Ignore ) ) ) { int constantCount = ( ( this . constants ) == null ) ? 0 : this . constants . length ; if ( ( constantCount == ( caseCount ) ) && ( ( caseCount ) != ( ( ( ReferenceBinding ) ( expressionType ) ) . enumConstantCount ( ) ) ) ) { FieldBinding [ ] enumFields = ( ( ReferenceBinding ) ( expressionType . erasure ( ) ) ) . fields ( ) ; for ( int i = 0 , max = enumFields . length ; i < max ; i ++ ) { FieldBinding enumConstant = enumFields [ i ] ; <START_BUG> if ( ( ( enumConstant . modifiers ) & ( AccEnum ) ) == 0 ) <END_BUG> continue ; findConstant : { for ( int j = 0 ; j < ( caseCount ) ; j ++ ) { if ( ( enumConstant . id ) == ( this . constants [ j ] ) ) break findConstant ; } upperScope . problemReporter ( ) . missingEnumConstantCase ( this , enumConstant ) ; } } } } } finally { if ( ( this . scope ) != null ) this . scope . enclosingCase = null ; } } public void traverse ( ASTVisitor visitor , BlockScope blockScope ) { } public void branchChainTo ( Label label ) { } } 
public class EditorsPreferencePage extends PreferencePage implements IWorkbenchPreferencePage { private static final int REUSE_INDENT = 10 ; protected Composite editorReuseGroup ; private Button reuseEditors ; protected Button showMultipleEditorTabs ; protected Button useIPersistableEditor ; private Composite editorReuseIndentGroup ; private Composite editorReuseThresholdGroup ; private IntegerFieldEditor reuseEditorsThreshold ; private Group dirtyEditorReuseGroup ; private Button openNewEditor ; private Button promptToReuseEditor ; private IntegerFieldEditor recentFilesEditor ; private IPropertyChangeListener validityChangeListener = new IPropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent event ) { } } ; private Button promptWhenStillOpenEditor ; protected Control createContents ( Composite parent ) { Composite composite = createComposite ( parent ) ; createEditorHistoryGroup ( composite ) ; createSpace ( composite ) ; createShowMultipleEditorTabsPref ( composite ) ; createUseIPersistablePref ( composite ) ; createPromptWhenStillOpenPref ( composite ) ; createEditorReuseGroup ( composite ) ; <START_BUG> ( ( TabBehaviour ) ( Tweaklets . get ( TabBehaviour . class ) ) ) . setPreferenceVisibility ( editorReuseGroup , showMultipleEditorTabs ) ; <END_BUG> updateValidState ( ) ; setHelpContext ( parent ) ; return composite ; } protected void setHelpContext ( Composite parent ) { } protected void createSpace ( Composite parent ) { } protected void createShowMultipleEditorTabsPref ( Composite composite ) { } protected void createUseIPersistablePref ( Composite composite ) { } protected void createPromptWhenStillOpenPref ( Composite composite ) { } protected Composite createComposite ( Composite parent ) { } public void init ( IWorkbench workbench ) { } protected void performDefaults ( ) { } public boolean performOk ( ) { } protected IPreferenceStore doGetPreferenceStore ( ) { } protected IPreferenceStore getAPIPreferenceStore ( ) { } protected void updateValidState ( ) { } protected void createEditorReuseGroup ( Composite composite ) { } protected void createEditorHistoryGroup ( Composite composite ) { } } 
public class SevenZFile { static final int SIGNATURE_HEADER_SIZE = 32 ; private static final int DRAIN_BUF_SIZE = 64 * 1024 ; private RandomAccessFile file ; private final Archive archive ; private int currentEntryIndex = - 1 ; private int currentFolderIndex = - 1 ; private InputStream currentFolderInputStream = null ; private InputStream currentEntryInputStream = null ; private byte [ ] password ; static final byte [ ] sevenZSignature = new byte [ ] { ( ( byte ) ( '7' ) ) , ( ( byte ) ( 'z' ) ) , ( ( byte ) ( 188 ) ) , ( ( byte ) ( 175 ) ) , ( ( byte ) ( 39 ) ) , ( ( byte ) ( 28 ) ) } ; public SevenZFile ( final File filename , final byte [ ] password ) throws IOException { } public SevenZFile ( final File filename ) throws IOException { } public void close ( ) throws IOException { } public SevenZArchiveEntry getNextEntry ( ) throws IOException { } private Archive readHeaders ( byte [ ] password ) throws IOException { } private StartHeader readStartHeader ( final int startHeaderCrc ) throws IOException { } private void readHeader ( final DataInput header , final Archive archive ) throws IOException { } private void readArchiveProperties ( final DataInput input ) throws IOException { } private DataInputStream readEncodedHeader ( final DataInputStream header , final Archive archive , byte [ ] password ) throws IOException { } private void readStreamsInfo ( final DataInput header , final Archive archive ) throws IOException { } private void readPackInfo ( final DataInput header , final Archive archive ) throws IOException { } private void readUnpackInfo ( final DataInput header , final Archive archive ) throws IOException { } private void readSubStreamsInfo ( final DataInput header , final Archive archive ) throws IOException { } private Folder readFolder ( final DataInput header ) throws IOException { } private BitSet readAllOrBits ( final DataInput header , final int size ) throws IOException { } private BitSet readBits ( final DataInput header , final int size ) throws IOException { } private void readFilesInfo ( final DataInput header , final Archive archive ) throws IOException { } private void calculateStreamMap ( final Archive archive ) throws IOException { } private void buildDecodingStream ( ) throws IOException { } private void drainPreviousEntry ( ) throws IOException { } private InputStream buildDecoderStack ( final Folder folder , final long folderOffset , final int firstPackStreamIndex ) throws IOException { } public int read ( ) throws IOException { } public int read ( byte [ ] b ) throws IOException { } public int read ( byte [ ] b , int off , int len ) throws IOException { } private static long readUint64 ( final DataInput in ) throws IOException { <START_BUG> int firstByte = in . readUnsignedByte ( ) ; <END_BUG> int mask = 128 ; long value = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { if ( ( firstByte & mask ) == 0 ) { return value | ( ( firstByte & ( mask - 1 ) ) << ( 8 * i ) ) ; } long nextByte = in . readUnsignedByte ( ) ; value |= nextByte << ( 8 * i ) ; mask >>>= 1 ; } return value ; } } 
public class MockRestServiceServer { private final List < RequestMatcherClientHttpRequest > expectedRequests = new LinkedList < RequestMatcherClientHttpRequest > ( ) ; private final List < RequestMatcherClientHttpRequest > actualRequests = new LinkedList < RequestMatcherClientHttpRequest > ( ) ; private MockRestServiceServer ( ) { } public static MockRestServiceServer createServer ( RestTemplate restTemplate ) { } public static MockRestServiceServer createServer ( AsyncRestTemplate asyncRestTemplate ) { } public static MockRestServiceServer createServer ( RestGatewaySupport restGateway ) { } public ResponseActions expect ( RequestMatcher requestMatcher ) { } public void verify ( ) { } private String getVerifyMessage ( ) { } private class RequestMatcherClientHttpRequestFactory implements AsyncClientHttpRequestFactory , ClientHttpRequestFactory { private Iterator < RequestMatcherClientHttpRequest > requestIterator ; @ Override public ClientHttpRequest createRequest ( URI uri , HttpMethod httpMethod ) throws IOException { } @ Override public AsyncClientHttpRequest createAsyncRequest ( URI uri , HttpMethod httpMethod ) throws IOException { } private RequestMatcherClientHttpRequest createRequestInternal ( URI uri , HttpMethod httpMethod ) { Assert . notNull ( uri , "'uri'<seq2seq4repair_space>must<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>null" ) ; Assert . notNull ( httpMethod , "'httpMethod'<seq2seq4repair_space>must<seq2seq4repair_space>not<seq2seq4repair_space>be<seq2seq4repair_space>null" ) ; if ( ( this . requestIterator ) == null ) { this . requestIterator = MockRestServiceServer . this . expectedRequests . iterator ( ) ; } if ( ! ( this . requestIterator . hasNext ( ) ) ) { <START_BUG> throw new AssertionError ( "No<seq2seq4repair_space>further<seq2seq4repair_space>requests<seq2seq4repair_space>expected" ) ; <END_BUG> } RequestMatcherClientHttpRequest request = this . requestIterator . next ( ) ; request . setURI ( uri ) ; request . setMethod ( httpMethod ) ; MockRestServiceServer . this . actualRequests . add ( request ) ; return request ; } } } 
private String getString ( Localizer localizer , String key , Component component ) { } public String substitute ( String string , Map < String , Object > vars ) throws IllegalStateException { } private Map < String , Object > addDefaultVars ( Map < String , Object > params ) { } private String getLabel ( ) { } } private final class RequiredStateChange extends Change { private static final long serialVersionUID = 1L ; private final boolean required = isRequired ( ) ; @ Override public void undo ( ) { } } private class ValidatableAdapter implements IValidatable < T > { public void error ( IValidationError error ) { } public T getValue ( ) { } public boolean isValid ( ) { } } public static String VALUE_SEPARATOR = ";" ; private static final String [ ] EMPTY_STRING_ARRAY = new String [ ] { "" } ; private static final short FLAG_PERSISTENT = FLAG_RESERVED2 ; private static final short FLAG_REQUIRED = FLAG_RESERVED3 ; private static final String NO_RAW_INPUT = "[-NO-RAW-INPUT-]" ; private static final long serialVersionUID = 1L ; protected static final short FLAG_CONVERT_EMPTY_INPUT_STRING_TO_NULL = FLAG_RESERVED1 ; public static final void visitFormComponentsPostOrder ( Component component , final FormComponent . IVisitor visitor ) { } private static final Object visitFormComponentsPostOrderHelper ( Component component , final FormComponent . IVisitor visitor ) { } public static final void visitComponentsPostOrder ( Component component , final Component . IVisitor < Component > visitor ) { } private static final Object visitComponentsPostOrderHelper ( Component component , final Component . IVisitor < Component > visitor ) { } private transient T convertedInput ; private String rawInput = FormComponent . NO_RAW_INPUT ; private String typeName ; private Object validators = null ; public FormComponent ( final String id ) { } public FormComponent ( final String id , IModel < T > model ) { } public final FormComponent < T > add ( final IValidator < T > validator ) { } public final FormComponent < T > add ( final IValidator < T > ... validators ) { } public boolean checkRequired ( ) { } public final void clearInput ( ) { } public void error ( IValidationError error ) { } public final T getConvertedInput ( ) { } public final void setConvertedInput ( T convertedInput ) { } public Form < ? > getForm ( ) { } public String getInput ( ) { } public String [ ] getInputAsArray ( ) { } public String getInputName ( ) { } public final String getRawInput ( ) { } @ SuppressWarnings ( "unchecked" ) public final Class < T > getType ( ) { } public String getValidatorKeyPrefix ( ) { } public final List < IValidator < T > > getValidators ( ) { } public final String getValue ( ) { } public final boolean hasRawInput ( ) { } public final void inputChanged ( ) { } public final void invalid ( ) { } public boolean isInputNullable ( ) { } public boolean isMultiPart ( ) { } public final boolean isPersistent ( ) { } public boolean isRequired ( ) { } public final boolean isValid ( ) { } public boolean processChildren ( ) { } public final void processInput ( ) { } public FormComponent < T > setLabel ( IModel < String > labelModel ) { } @ Deprecated public void setModelValue ( final String value ) { } public void setModelValue ( final String [ ] value ) { } public final FormComponent < T > setPersistent ( final boolean persistent ) { } public final FormComponent < T > setRequired ( final boolean required ) { } public final FormComponent < T > setType ( Class < ? > type ) { } public void updateModel ( ) { } public final void valid ( ) { } public void validate ( ) { } @ SuppressWarnings ( "unchecked" ) private void validators_add ( final IValidator < T > validator ) { } @ SuppressWarnings ( "unchecked" ) private IValidator < T > validators_get ( int index ) { } private int validators_size ( ) { } @ SuppressWarnings ( "unchecked" ) protected void convertInput ( ) { } private void reportValidationError ( ConversionException e , ValidationError error ) { } @ SuppressWarnings ( "unchecked" ) protected T convertValue ( String [ ] value ) throws ConversionException { } protected String getModelValue ( ) { } protected final int inputAsInt ( ) { } protected final int inputAsInt ( final int defaultValue ) { } protected final int [ ] inputAsIntArray ( ) { } @ Override protected void internalOnModelChanged ( ) { } @ Override protected void onComponentTag ( final ComponentTag tag ) { tag . put ( "name" , getInputName ( ) ) ; <START_BUG> if ( ( ! ( FormComponent . isEnabled ( ) ) ) || ( ! ( FormComponent . isEnableAllowed ( ) ) ) ) { <END_BUG> onDisabled ( tag ) ; } super . onComponentTag ( tag ) ; } @ Override protected void onDetach ( ) { } protected void onDisabled ( final ComponentTag tag ) { } protected void onInvalid ( ) { } protected void onValid ( ) { } protected boolean shouldTrimInput ( ) { } protected final String trim ( String string ) { } protected boolean supportsPersistence ( ) { } protected final void validateRequired ( ) { } private void reportRequiredError ( ) { } protected final void validateValidators ( ) { } public final IValidatable < T > newValidatable ( ) { } @ SuppressWarnings ( "unchecked" ) public final IModel < T > getModel ( ) { } public final void setModel ( IModel < T > model ) { } @ SuppressWarnings ( "unchecked" ) public final T getModelObject ( ) { } public final void setModelObject ( T object ) { } } 
public class MultivariateNormalDistribution extends AbstractMultivariateRealDistribution { private final double [ ] means ; private final RealMatrix covarianceMatrix ; private final RealMatrix covarianceMatrixInverse ; private final double covarianceMatrixDeterminant ; private final RealMatrix samplingMatrix ; public MultivariateNormalDistribution ( final double [ ] means , final double [ ] [ ] covariances ) throws DimensionMismatchException , NonPositiveDefiniteMatrixException , SingularMatrixException { } public MultivariateNormalDistribution ( RandomGenerator rng , final double [ ] means , final double [ ] [ ] covariances ) throws DimensionMismatchException , NonPositiveDefiniteMatrixException , SingularMatrixException { } public double [ ] getMeans ( ) { } public RealMatrix getCovariances ( ) { } public double density ( final double [ ] vals ) throws DimensionMismatchException { final int dim = getDimension ( ) ; if ( ( vals . length ) != dim ) { throw new DimensionMismatchException ( vals . length , dim ) ; } <START_BUG> return ( ( FastMath . pow ( ( 2 * ( FastMath . PI ) ) , ( ( - dim ) / 2 ) ) ) * ( FastMath . pow ( covarianceMatrixDeterminant , ( - 0.5 ) ) ) ) * ( getExponentTerm ( vals ) ) ; <END_BUG> } public double [ ] getStandardDeviations ( ) { } public double [ ] sample ( ) { } private double getExponentTerm ( final double [ ] values ) { } } 
public class DateTimeDV extends AbstractDateTimeDV { public Object getActualValue ( String content , ValidationContext context ) throws InvalidDatatypeValueException { try { <START_BUG> return parse ( content ) ; <END_BUG> } catch ( Exception ex ) { throw new InvalidDatatypeValueException ( "cvc-datatype-valid.1.2.1" , new Object [ ] { content , "dateTime" } ) ; } } protected int [ ] parse ( String str ) throws SchemaDateTimeException { } } 
public class EncodingTest extends TestCase { public void test_1 ( ) throws Exception { WicketTester tester = new WicketTester ( ) ; tester . startPage ( Home . class ) ; tester . assertContains ( "Wicket<seq2seq4repair_space>Examples<seq2seq4repair_space>-<seq2seq4repair_space>encodings" ) ; <START_BUG> tester . assertContains ( "Hello<seq2seq4repair_space>world!<seq2seq4repair_space>Test:<seq2seq4repair_space>" ) ; <END_BUG> } } 
class MozillaDelegate { Browser browser ; MozillaDelegate ( Browser browser ) { } static Browser findBrowser ( int handle ) { } static char [ ] mbcsToWcs ( String codePage , byte [ ] buffer ) { } static byte [ ] wcsToMbcs ( String codePage , String string , boolean terminate ) { } int getHandle ( ) { } String getLibraryName ( ) { } String getSWTInitLibraryName ( ) { <START_BUG> return "swt-xpcominit" ; <END_BUG> } void handleFocus ( ) { } boolean hookEnterExit ( ) { } void init ( ) { } boolean needsSpinup ( ) { } void onDispose ( int embedHandle ) { } void setSize ( int embedHandle , int width , int height ) { } } 
public class ModClusterEnableContext implements OperationStepHandler , DescriptionProvider { static final ModClusterEnableContext INSTANCE = new ModClusterEnableContext ( ) ; @ Override public ModelNode getModelDescription ( Locale locale ) { } @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { <START_BUG> if ( ( context . getType ( ) ) == ( Type . SERVER ) ) { <END_BUG> context . addStep ( new OperationStepHandler ( ) { @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { ServiceController < ? > controller = context . getServiceRegistry ( false ) . getService ( NAME ) ; ModCluster modcluster = ( ( ModCluster ) ( controller . getValue ( ) ) ) ; ModClusterLogger . ROOT_LOGGER . debugf ( "enable-context:<seq2seq4repair_space>%s" , operation ) ; ContextHost contexthost = new ContextHost ( operation ) ; modcluster . enableContext ( contexthost . webhost , contexthost . webcontext ) ; context . completeStep ( ) ; } } , RUNTIME ) ; } context . completeStep ( ) ; } } 
final class BcelMethod extends ResolvedMember { private Method method ; private boolean isAjSynthetic ; private ShadowMunger associatedShadowMunger ; private ResolvedPointcutDefinition preResolvedPointcut ; private ResolvedType [ ] annotationTypes = null ; private AnnotationX [ ] annotations = null ; private EffectiveSignatureAttribute effectiveSignature ; private MethodDeclarationLineNumberAttribute declarationLineNumber ; private ResolvedType [ ] resolvedAnnotations ; private World world ; private BcelObjectType bcelObjectType ; BcelMethod ( BcelObjectType declaringType , Method method ) { } private void unpackJavaAttributes ( ) { } private void unpackAjAttributes ( World world ) { associatedShadowMunger = null ; <START_BUG> List as = BcelAttributes . readAjAttributes ( getDeclaringType ( ) . getClassName ( ) , method . getAttributes ( ) , getSourceContext ( world ) , world . getMessageHandler ( ) ) ; <END_BUG> processAttributes ( world , as ) ; as = AtAjAttributes . readAj5MethodAttributes ( method , this , world . resolve ( getDeclaringType ( ) ) , preResolvedPointcut , getSourceContext ( world ) , world . getMessageHandler ( ) ) ; processAttributes ( world , as ) ; } private void processAttributes ( World world , List as ) { } public boolean isAjSynthetic ( ) { } public ShadowMunger getAssociatedShadowMunger ( ) { } public EffectiveSignatureAttribute getEffectiveSignature ( ) { } public boolean hasDeclarationLineNumberInfo ( ) { } public int getDeclarationLineNumber ( ) { } public int getDeclarationOffset ( ) { } public ISourceLocation getSourceLocation ( ) { } public Kind getKind ( ) { } public boolean hasAnnotation ( UnresolvedType ofType ) { } public AnnotationX [ ] getAnnotations ( ) { } public ResolvedType [ ] getAnnotationTypes ( ) { } public void addAnnotation ( AnnotationX annotation ) { } private void ensureAnnotationTypesRetrieved ( ) { } private boolean canBeParameterized = false ; public boolean canBeParameterized ( ) { } private boolean unpackedGenericSignature = false ; private UnresolvedType genericReturnType = null ; private UnresolvedType [ ] genericParameterTypes = null ; public UnresolvedType [ ] getGenericParameterTypes ( ) { } public UnresolvedType getGenericReturnType ( ) { } private void unpackGenericSignature ( ) { } } 
public class FilenameUtils { public static final char EXTENSION_SEPARATOR = '.' ; public static final String EXTENSION_SEPARATOR_STR = Character . toString ( FilenameUtils . EXTENSION_SEPARATOR ) ; private static final char UNIX_SEPARATOR = '/' ; private static final char WINDOWS_SEPARATOR = '\\' ; private static final char SYSTEM_SEPARATOR = File . separatorChar ; private static final char OTHER_SEPARATOR ; public FilenameUtils ( ) { } static boolean isSystemWindows ( ) { } private static boolean isSeparator ( char ch ) { } public static String normalize ( String filename ) { } public static String normalize ( String filename , boolean unixSeparator ) { } public static String normalizeNoEndSeparator ( String filename ) { } public static String normalizeNoEndSeparator ( String filename , boolean unixSeparator ) { } private static String doNormalize ( String filename , char separator , boolean keepSeparator ) { } public static String concat ( String basePath , String fullFilenameToAdd ) { } public static String separatorsToUnix ( String path ) { } public static String separatorsToWindows ( String path ) { } public static String separatorsToSystem ( String path ) { } public static int getPrefixLength ( String filename ) { } public static int indexOfLastSeparator ( String filename ) { } public static int indexOfExtension ( String filename ) { } public static String getPrefix ( String filename ) { } public static String getPath ( String filename ) { } public static String getPathNoEndSeparator ( String filename ) { } private static String doGetPath ( String filename , int separatorAdd ) { } public static String getFullPath ( String filename ) { } public static String getFullPathNoEndSeparator ( String filename ) { } private static String doGetFullPath ( String filename , boolean includeSeparator ) { } public static String getName ( String filename ) { } public static String getBaseName ( String filename ) { } public static String getExtension ( String filename ) { } public static String removeExtension ( String filename ) { } public static boolean equals ( String filename1 , String filename2 ) { } public static boolean equalsOnSystem ( String filename1 , String filename2 ) { } public static boolean equalsNormalized ( String filename1 , String filename2 ) { } public static boolean equalsNormalizedOnSystem ( String filename1 , String filename2 ) { } public static boolean equals ( String filename1 , String filename2 , boolean normalized , IOCase caseSensitivity ) { if ( ( filename1 == null ) || ( filename2 == null ) ) { <START_BUG> return filename1 == filename2 ; <END_BUG> } if ( normalized ) { filename1 = FilenameUtils . normalize ( filename1 ) ; filename2 = FilenameUtils . normalize ( filename2 ) ; if ( ( filename1 == null ) || ( filename2 == null ) ) { throw new NullPointerException ( "Error<seq2seq4repair_space>normalizing<seq2seq4repair_space>one<seq2seq4repair_space>or<seq2seq4repair_space>both<seq2seq4repair_space>of<seq2seq4repair_space>the<seq2seq4repair_space>file<seq2seq4repair_space>names" ) ; } } if ( caseSensitivity == null ) { caseSensitivity = IOCase . SENSITIVE ; } return caseSensitivity . checkEquals ( filename1 , filename2 ) ; } public static boolean isExtension ( String filename , String extension ) { } public static boolean isExtension ( String filename , String [ ] extensions ) { } public static boolean isExtension ( String filename , Collection < String > extensions ) { } public static boolean wildcardMatch ( String filename , String wildcardMatcher ) { } public static boolean wildcardMatchOnSystem ( String filename , String wildcardMatcher ) { } public static boolean wildcardMatch ( String filename , String wildcardMatcher , IOCase caseSensitivity ) { } static String [ ] splitOnTokens ( String text ) { } } 
public class JavaBuilder extends IncrementalProjectBuilder { IProject currentProject ; IJavaProject javaProject ; IWorkspaceRoot workspaceRoot ; ClasspathLocation [ ] classpath ; IContainer outputFolder ; IContainer [ ] sourceFolders ; SimpleLookupTable prereqOutputFolders ; State lastState ; BuildNotifier notifier ; char [ ] [ ] resourceFilters ; public static final String JAVA_EXTENSION = "java" ; public static final String CLASS_EXTENSION = "class" ; public static final String JAR_EXTENSION = "jar" ; public static final String ZIP_EXTENSION = "zip" ; public static final String OPTION_ResourceCopyFilter = "org.eclipse.jdt.core.builder.resourceCopyExclusionFilters" ; public static boolean DEBUG = false ; static final String ProblemMarkerTag = IJavaModelMarker . JAVA_MODEL_PROBLEM_MARKER ; static ArrayList builtProjects = null ; public static IMarker [ ] getProblemsFor ( IResource resource ) { } public static void removeProblemsFor ( IResource resource ) { } public static State readState ( DataInputStream in ) throws IOException { } public static void writeState ( Object state , DataOutputStream out ) throws IOException { } public JavaBuilder ( ) { } protected IProject [ ] build ( int kind , Map ignored , IProgressMonitor monitor ) throws CoreException { } private void buildAll ( ) { } private void buildDeltas ( SimpleLookupTable deltas ) { } private void cleanup ( ) { } private void clearLastState ( ) { } private void createFolder ( IContainer folder ) throws CoreException { } boolean filterResource ( IResource resource ) { } private SimpleLookupTable findDeltas ( ) { notifier . subTask ( Util . bind ( "build.readingDelta" , currentProject . getName ( ) ) ) ; IResourceDelta delta = getDelta ( currentProject ) ; <START_BUG> SimpleLookupTable deltas = new SimpleLookupTable ( ) ; <END_BUG> if ( delta != null ) { deltas . put ( currentProject , delta ) ; } else { if ( JavaBuilder . DEBUG ) System . out . println ( ( "Missing<seq2seq4repair_space>delta<seq2seq4repair_space>for:<seq2seq4repair_space>" + ( currentProject . getName ( ) ) ) ) ; notifier . subTask ( "" ) ; return null ; } Object [ ] keyTable = prereqOutputFolders . keyTable ; for ( int i = 0 , l = keyTable . length ; i < l ; i ++ ) { IProject prereqProject = ( ( IProject ) ( keyTable [ i ] ) ) ; if ( ( prereqProject != null ) && ( lastState . isStructurallyChanged ( prereqProject , getLastState ( prereqProject ) ) ) ) { notifier . subTask ( Util . bind ( "build.readingDelta" , prereqProject . getName ( ) ) ) ; delta = getDelta ( prereqProject ) ; if ( delta != null ) { deltas . put ( prereqProject , delta ) ; } else { if ( JavaBuilder . DEBUG ) System . out . println ( ( "Missing<seq2seq4repair_space>delta<seq2seq4repair_space>for:<seq2seq4repair_space>" + ( prereqProject . getName ( ) ) ) ) ; notifier . subTask ( "" ) ; return null ; } } } notifier . subTask ( "" ) ; return deltas ; } private State getLastState ( IProject project ) { } private IProject [ ] getRequiredProjects ( ) { } private boolean hasClasspathChanged ( ) { } private boolean hasOutputLocationChanged ( ) { } private void initializeBuilder ( ) throws CoreException { } private void recordNewState ( State state ) { } public String toString ( ) { } } 
public class SimplePasswordStrengthCheckerTestCase { private Keyboard keyboard = new SimpleKeyboard ( ) ; private Dictionary dictionary = new SimpleDictionary ( ) ; public static final PasswordCheckUtil PCU = PasswordCheckUtil . create ( null ) ; public static final PasswordRestriction ALPHA_RESTRICTION = SimplePasswordStrengthCheckerTestCase . PCU . createAlphaRestriction ( 1 ) ; public static final PasswordRestriction SYMBOL_RESTRICTION = SimplePasswordStrengthCheckerTestCase . PCU . createSymbolRestriction ( 1 ) ; public static final PasswordRestriction DIGIT_RESTRICTION = SimplePasswordStrengthCheckerTestCase . PCU . createDigitRestriction ( 1 ) ; public static final LengthRestriction LENGTH_RESTRICTION = new LengthRestriction ( 8 ) ; @ Test public void testLengthRestriction ( ) { } @ Test public void testDigitsRestriction ( ) { } @ Test public void testSymbolsRestriction ( ) { } @ Test public void testAlphaRestriction ( ) { } @ Test public void testAdHocRestriction ( ) { List < PasswordRestriction > restrictions = new ArrayList < PasswordRestriction > ( ) ; restrictions . add ( SimplePasswordStrengthCheckerTestCase . ALPHA_RESTRICTION ) ; restrictions . add ( SimplePasswordStrengthCheckerTestCase . SYMBOL_RESTRICTION ) ; SimplePasswordStrengthChecker checker = new SimplePasswordStrengthChecker ( restrictions , this . dictionary , this . keyboard ) ; String pwd = "!#*_3x" ; List < PasswordRestriction > adHocRestrictions = new ArrayList < PasswordRestriction > ( ) ; <START_BUG> ValueRestriction restriction = new ValueRestriction ( new String [ ] { pwd } , true ) ; <END_BUG> adHocRestrictions . add ( restriction ) ; PasswordStrengthCheckResult result = checker . check ( "" , pwd , adHocRestrictions ) ; assertNotNull ( result ) ; assertNotNull ( result . getPassedRestrictions ( ) ) ; assertNotNull ( result . getRestrictionFailures ( ) ) ; assertEquals ( 2 , result . getPassedRestrictions ( ) . size ( ) ) ; assertEquals ( 1 , result . getRestrictionFailures ( ) . size ( ) ) ; assertNotNull ( result . getStrength ( ) ) ; assertEquals ( SimplePasswordStrengthCheckerTestCase . ALPHA_RESTRICTION , result . getPassedRestrictions ( ) . get ( 0 ) ) ; assertEquals ( SimplePasswordStrengthCheckerTestCase . SYMBOL_RESTRICTION , result . getPassedRestrictions ( ) . get ( 1 ) ) ; assertEquals ( DomainManagementMessages . MESSAGES . passwordMustNotBeEqual ( pwd ) . getMessage ( ) , result . getRestrictionFailures ( ) . get ( 0 ) . getMessage ( ) ) ; } } 
public final class Main { public static void main ( String [ ] args ) { } private static StandaloneServer create ( String [ ] args ) { } Properties props = new Properties ( System . getProperties ( ) ) ; private Main ( ) { } private StandaloneServer boot ( final String [ ] args ) { StandaloneServer server = null ; try { ServerEnvironment config = Main . determineEnvironment ( args , props ) ; if ( config == null ) { abort ( null ) ; } else { if ( config . isStandalone ( ) ) { <START_BUG> server = new StandaloneServer ( config ) ; <END_BUG> } else { throw new IllegalStateException ( ) ; } server . start ( ) ; return server ; } } catch ( Throwable t ) { abort ( t ) ; } return null ; } private void abort ( Throwable t ) { } public static ServerEnvironment determineEnvironment ( String [ ] args , Properties systemProperties ) { } private static URL makeURL ( String urlspec ) throws MalformedURLException { } } 
public abstract class RungeKuttaIntegrator extends AbstractIntegrator { private final double [ ] c ; private final double [ ] [ ] a ; private final double [ ] b ; private final RungeKuttaStepInterpolator prototype ; private final double step ; protected RungeKuttaIntegrator ( final String name , final double [ ] c , final double [ ] [ ] a , final double [ ] b , final RungeKuttaStepInterpolator prototype , final double step ) { } public double integrate ( final FirstOrderDifferentialEquations equations , final double t0 , final double [ ] y0 , final double t , final double [ ] y ) throws DerivativeException , IntegratorException { sanityChecks ( equations , t0 , y0 , t , y ) ; setEquations ( equations ) ; resetEvaluations ( ) ; final boolean forward = t > t0 ; final int stages = ( c . length ) + 1 ; if ( y != y0 ) { System . arraycopy ( y0 , 0 , y , 0 , y0 . length ) ; } final double [ ] [ ] yDotK = new double [ stages ] [ ] ; for ( int i = 0 ; i < stages ; ++ i ) { yDotK [ i ] = new double [ y0 . length ] ; } final double [ ] yTmp = new double [ y0 . length ] ; AbstractStepInterpolator interpolator ; if ( ( requiresDenseOutput ( ) ) || ( ! ( eventsHandlersManager . isEmpty ( ) ) ) ) { final RungeKuttaStepInterpolator rki = ( ( RungeKuttaStepInterpolator ) ( prototype . copy ( ) ) ) ; rki . reinitialize ( this , yTmp , yDotK , forward ) ; interpolator = rki ; } else { <START_BUG> interpolator = new DummyStepInterpolator ( yTmp , forward ) ; <END_BUG> } interpolator . storeTime ( t0 ) ; stepStart = t0 ; stepSize = ( forward ) ? step : - ( step ) ; for ( StepHandler handler : stepHandlers ) { handler . reset ( ) ; } CombinedEventsManager manager = addEndTimeChecker ( t0 , t , eventsHandlersManager ) ; boolean lastStep = false ; while ( ! lastStep ) { interpolator . shift ( ) ; for ( boolean loop = true ; loop ; ) { computeDerivatives ( stepStart , y , yDotK [ 0 ] ) ; for ( int k = 1 ; k < stages ; ++ k ) { for ( int j = 0 ; j < ( y0 . length ) ; ++ j ) { double sum = ( a [ ( k - 1 ) ] [ 0 ] ) * ( yDotK [ 0 ] [ j ] ) ; for ( int l = 1 ; l < k ; ++ l ) { sum += ( a [ ( k - 1 ) ] [ l ] ) * ( yDotK [ l ] [ j ] ) ; } yTmp [ j ] = ( y [ j ] ) + ( ( stepSize ) * sum ) ; } computeDerivatives ( ( ( stepStart ) + ( ( c [ ( k - 1 ) ] ) * ( stepSize ) ) ) , yTmp , yDotK [ k ] ) ; } for ( int j = 0 ; j < ( y0 . length ) ; ++ j ) { double sum = ( b [ 0 ] ) * ( yDotK [ 0 ] [ j ] ) ; for ( int l = 1 ; l < stages ; ++ l ) { sum += ( b [ l ] ) * ( yDotK [ l ] [ j ] ) ; } yTmp [ j ] = ( y [ j ] ) + ( ( stepSize ) * sum ) ; } interpolator . storeTime ( ( ( stepStart ) + ( stepSize ) ) ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = ( manager . getEventTime ( ) ) - ( stepStart ) ; if ( ( Math . abs ( dt ) ) <= ( Math . ulp ( stepStart ) ) ) { loop = false ; } else { stepSize = dt ; } } else { loop = false ; } } final double nextStep = ( stepStart ) + ( stepSize ) ; System . arraycopy ( yTmp , 0 , y , 0 , y0 . length ) ; manager . stepAccepted ( nextStep , y ) ; lastStep = manager . stop ( ) ; interpolator . storeTime ( nextStep ) ; for ( StepHandler handler : stepHandlers ) { handler . handleStep ( interpolator , lastStep ) ; } stepStart = nextStep ; if ( ( manager . reset ( stepStart , y ) ) && ( ! lastStep ) ) { computeDerivatives ( stepStart , y , yDotK [ 0 ] ) ; } stepSize = ( forward ) ? step : - ( step ) ; } final double stopTime = stepStart ; stepStart = Double . NaN ; stepSize = Double . NaN ; return stopTime ; } } 
public class CleanDatabaseTestSetup extends BaseJDBCTestSetup { public CleanDatabaseTestSetup ( Test test ) { } protected void setUp ( ) throws Exception { } protected void decorateSQL ( Statement s ) throws SQLException { } protected void tearDown ( ) throws Exception { } public static void cleanDatabase ( Connection conn ) throws SQLException { } private static final String [ ] CLEAR_DB_PROPERTIES = new String [ ] { "derby.database.classpath" } ; private static void clearProperties ( Connection conn ) throws SQLException { } private static void removeObjects ( Connection conn ) throws SQLException { DatabaseMetaData dmd = conn . getMetaData ( ) ; SQLException sqle = null ; for ( int count = 0 ; count < 5 ; count ++ ) { List schemas = new ArrayList ( ) ; ResultSet rs = dmd . getSchemas ( ) ; while ( rs . next ( ) ) { String schema = rs . getString ( "TABLE_SCHEM" ) ; if ( schema . startsWith ( "SYS" ) ) continue ; if ( schema . equals ( "SQLJ" ) ) continue ; if ( schema . equals ( "NULLID" ) ) continue ; schemas . add ( schema ) ; } rs . close ( ) ; sqle = null ; for ( Iterator i = schemas . iterator ( ) ; i . hasNext ( ) ; ) { String schema = ( ( String ) ( i . next ( ) ) ) ; try { JDBC . dropSchema ( dmd , schema ) ; } catch ( SQLException e ) { <START_BUG> sqle = null ; <END_BUG> } } if ( sqle == null ) return ; } throw sqle ; } private static final String [ ] COMPRESS_DB_OBJECTS = new String [ ] { "SYS.SYSDEPENDS" } ; private static void compressObjects ( Connection conn ) throws SQLException { } } 
public class Test_org_eclipse_swt_widgets_TableItem extends Test_org_eclipse_swt_widgets_Item { public Test_org_eclipse_swt_widgets_TableItem ( String name ) { } public static void main ( String [ ] args ) { } protected void setUp ( ) { } public void test_ConstructorLorg_eclipse_swt_widgets_TableI ( ) { } public void test_ConstructorLorg_eclipse_swt_widgets_TableII ( ) { } public void test_getBackground ( ) { } public void test_getBackgroundI ( ) { } public void test_getBoundsI ( ) { } public void test_getChecked ( ) { } public void test_getFont ( ) { } public void test_getFontI ( ) { } public void test_getForeground ( ) { } public void test_getForegroundI ( ) { } public void test_getGrayed ( ) { } public void test_getImageBoundsI ( ) { } public void test_getImageI ( ) { } public void test_getImageIndent ( ) { } public void test_getParent ( ) { } public void test_getTextI ( ) { } public void test_setBackgroundILorg_eclipse_swt_graphics_Color ( ) { } public void test_setBackgroundLorg_eclipse_swt_graphics_Color ( ) { } public void test_setCheckedZ ( ) { } public void test_setFontLorg_eclipse_swt_graphics_Font ( ) { } public void test_setFontILorg_eclipse_swt_graphics_Font ( ) { } public void test_setForegroundILorg_eclipse_swt_graphics_Color ( ) { } public void test_setForegroundLorg_eclipse_swt_graphics_Color ( ) { } public void test_setGrayedZ ( ) { } public void test_setImage$Lorg_eclipse_swt_graphics_Image ( ) { } public void test_setImageILorg_eclipse_swt_graphics_Image ( ) { } public void test_setImageIndentI ( ) { <START_BUG> if ( ( SwtJunit . isCarbon ) || ( SwtJunit . isGTK ) ) { <END_BUG> tableItem . setImageIndent ( 1 ) ; return ; } assertEquals ( 0 , tableItem . getImageIndent ( ) ) ; tableItem . setImageIndent ( 1 ) ; assertEquals ( 1 , tableItem . getImageIndent ( ) ) ; tableItem . setImageIndent ( ( - 1 ) ) ; assertEquals ( 1 , tableItem . getImageIndent ( ) ) ; } public void test_setText$Ljava_lang_String ( ) { } public void test_setTextILjava_lang_String ( ) { } public static Test suite ( ) { } public static Vector methodNames ( ) { } protected void runTest ( ) throws Throwable { } Table table ; TableItem tableItem ; private void makeCleanEnvironment ( ) { } } 
public abstract class BehavioralFeature extends Feature { public boolean _isQuery ; public Vector _parameter = new Vector ( ) ; public Vector _raisedException = new Vector ( ) ; public BehavioralFeature ( ) { } public BehavioralFeature ( Name name ) { } public BehavioralFeature ( String nameStr ) { } public boolean getIsQuery ( ) { } public void setIsQuery ( boolean x ) throws PropertyVetoException { } public Classifier getReturnType ( ) { } public void setReturnType ( Classifier rt ) throws PropertyVetoException { Parameter p = findParameter ( RETURN_NAME ) ; if ( p == null ) { <START_BUG> p = new Parameter ( rt , Parameter . RETURN_NAME ) ; <END_BUG> addParameter ( p ) ; } else { p . setType ( rt ) ; } } public Parameter findParameter ( Name n ) { } public Vector getParameter ( ) { } public void setParameter ( Vector x ) throws PropertyVetoException { } public void addParameter ( Parameter x ) throws PropertyVetoException { } public void removeParameter ( Parameter x ) throws PropertyVetoException { } public Vector getRaisedException ( ) { } public void setRaisedException ( Vector x ) throws PropertyVetoException { } public void addRaisedException ( MMException x ) throws PropertyVetoException { } public void removeRaisedException ( MMException x ) throws PropertyVetoException { } static final long serialVersionUID = 7697916359219415113L ; } 
public class ArgoFileFilter extends FileFilter { public boolean accept ( File f ) { } public String getExtension ( File f ) { } public String getDescription ( ) { <START_BUG> return "Argo<seq2seq4repair_space>v0.3.1<seq2seq4repair_space>native<seq2seq4repair_space>file<seq2seq4repair_space>type" ; <END_BUG> } } 
public class ExpandItem extends Item { ExpandBar parent ; Control control ; boolean expanded ; boolean hover ; int x ; int y ; int width ; int height ; int imageHeight ; int imageWidth ; static final int TEXT_INSET = 6 ; static final int BORDER = 1 ; static final int CHEVRON_SIZE = 24 ; public ExpandItem ( ExpandBar parent , int style ) { } public ExpandItem ( ExpandBar parent , int style , int index ) { } static ExpandBar checkNull ( ExpandBar control ) { } private void drawChevron ( int hDC , RECT rect ) { } void drawItem ( GC gc , int hTheme , RECT clipRect , boolean drawFocus ) { } void destroyWidget ( ) { } public Control getControl ( ) { } public boolean getExpanded ( ) { } public int getHeaderHeight ( ) { } public int getHeight ( ) { } public ExpandBar getParent ( ) { } int getPreferredWidth ( int hTheme , int hDC ) { } void redraw ( boolean all ) { } void releaseHandle ( ) { } void releaseWidget ( ) { } void setBounds ( int x , int y , int width , int height , boolean move , boolean size ) { } public void setControl ( Control control ) { } public void setExpanded ( boolean expanded ) { checkWidget ( ) ; this . expanded = expanded ; <START_BUG> parent . showItem ( parent . indexOf ( this ) ) ; <END_BUG> } public void setHeight ( int height ) { } public void setImage ( Image image ) { } public void setText ( String string ) { } } 
public Expression containsValue ( Value map , Value arg ) { } public Expression isInstance ( Value val , Class c ) { } public Expression and ( Expression exp1 , Expression exp2 ) { } public Expression or ( Expression exp1 , Expression exp2 ) { } public Expression not ( Expression exp ) { } public Expression bindVariable ( Value var , Value val ) { } public Expression bindKeyVariable ( Value var , Value val ) { } public Expression bindValueVariable ( Value var , Value val ) { } public Expression startsWith ( Value v1 , Value v2 ) { } public Expression endsWith ( Value v1 , Value v2 ) { } public Expression notMatches ( Value v1 , Value v2 , String single , String multi , String esc ) { } public Expression matches ( Value v1 , Value v2 , String single , String multi , String esc ) { } public Subquery newSubquery ( ClassMetaData candidate , boolean subs , String alias ) { } public Path newPath ( ) { } public Path newPath ( Value val ) { } public Literal newLiteral ( Object val , int ptype ) { } public Literal newTypeLiteral ( Object val , int ptype ) { } public Value getThis ( ) { } public Value getNull ( ) { } public < T extends Date > Value getCurrentDate ( Class < T > dateType ) { } public < T extends Date > Value getCurrentTime ( Class < T > dateType ) { } public < T extends Date > Value getCurrentTimestamp ( Class < T > dateType ) { } public Parameter newParameter ( Object name , Class type ) { } public Parameter newCollectionValuedParameter ( Object key , Class type ) { } public Value newExtension ( FilterListener listener , Value target , Value arg ) { } public Value newAggregate ( AggregateListener listener , Value arg ) { } public Arguments newArgumentList ( Value v1 , Value v2 ) { } public Arguments newArgumentList ( Value ... vs ) { } public Value newUnboundVariable ( String name , Class type ) { } public Value newBoundVariable ( String name , Class type ) { } public Value cast ( Value val , Class cls ) { } public Value add ( Value v1 , Value v2 ) { } public Value subtract ( Value v1 , Value v2 ) { } public Value multiply ( Value v1 , Value v2 ) { } public Value divide ( Value v1 , Value v2 ) { } public Value mod ( Value v1 , Value v2 ) { } public Value abs ( Value val ) { } public Value indexOf ( Value v1 , Value v2 ) { } public Value concat ( Value v1 , Value v2 ) { } public Value stringLength ( Value str ) { } public Value trim ( Value str , Value trimChar , Boolean where ) { } public Value sqrt ( Value val ) { } public Value substring ( Value v1 , Value v2 ) { } public Value toUpperCase ( Value val ) { } public Value toLowerCase ( Value val ) { } public Value avg ( Value val ) { } public Value count ( Value val ) { } public Value distinct ( Value val ) { } public Value max ( Value val ) { } public Value min ( Value val ) { } public Value sum ( Value val ) { } public Value any ( Value val ) { } public Value all ( Value val ) { } public Value size ( Value val ) { } public Value index ( Value val ) { } public Value type ( Value val ) { } public Value mapEntry ( Value key , Value val ) { } public Value mapKey ( Value key , Value val ) { } public Value getKey ( Value val ) { } public Value getObjectId ( Value val ) { } public Value getMapValue ( Value map , Value arg ) { } private Value getLiteralRawString ( Value val ) { if ( val instanceof Lit ) { Lit lit = ( ( Lit ) ( val ) ) ; <START_BUG> StringBuffer value = new StringBuffer ( ) ; <END_BUG> int pType = lit . getParseType ( ) ; if ( ( pType == ( Literal . TYPE_SQ_STRING ) ) || ( pType == ( Literal . TYPE_STRING ) ) ) value . append ( "'" ) . append ( lit . getValue ( ) . toString ( ) ) . append ( "'" ) ; else if ( pType == ( Literal . TYPE_BOOLEAN ) ) { if ( ( ( Boolean ) ( lit . getValue ( ) ) ) ) value . append ( "1" ) ; else value . append ( "0" ) ; } else if ( pType == ( Literal . TYPE_ENUM ) ) { lit . setRaw ( true ) ; return val ; } else value . append ( lit . getValue ( ) . toString ( ) ) ; lit . setValue ( new Raw ( value . toString ( ) ) ) ; return lit ; } return val ; } public Value simpleCaseExpression ( Value caseOperand , Expression [ ] exp , Value val1 ) { } public Value generalCaseExpression ( Expression [ ] exp , Value val ) { } public Expression whenCondition ( Expression exp , Value val ) { } public Expression whenScalar ( Value val1 , Value val2 ) { } public Value coalesceExpression ( Value [ ] vals ) { } public Value nullIfExpression ( Value val1 , Value val2 ) { } public Value newFunction ( String functionName , Class < ? > resultType , Value ... args ) { } } 
public class IncomingStreamReader { private static final Logger logger = LoggerFactory . getLogger ( IncomingStreamReader . class ) ; protected final PendingFile localFile ; protected final PendingFile remoteFile ; protected final StreamInSession session ; private final Socket socket ; public IncomingStreamReader ( StreamHeader header , Socket socket ) throws IOException { } public void read ( ) throws IOException { } private SSTableReader streamIn ( DataInput input , PendingFile localFile , PendingFile remoteFile ) throws IOException { ColumnFamilyStore cfs = Table . open ( localFile . desc . ksname ) . getColumnFamilyStore ( localFile . desc . cfname ) ; DecoratedKey key ; SSTableWriter writer = new SSTableWriter ( localFile . getFilename ( ) , remoteFile . estimatedKeys ) ; CompactionController controller = null ; try { BytesReadTracker in = new BytesReadTracker ( input ) ; for ( Pair < Long , Long > section : localFile . sections ) { long length = ( section . right ) - ( section . left ) ; long bytesRead = 0 ; while ( bytesRead < length ) { <START_BUG> in . reset ( ) ; <END_BUG> key = SSTableReader . decodeKey ( StorageService . getPartitioner ( ) , localFile . desc , ByteBufferUtil . readWithShortLength ( in ) ) ; long dataSize = SSTableReader . readRowSize ( in , localFile . desc ) ; ColumnFamily cf = null ; if ( cfs . metadata . getDefaultValidator ( ) . isCommutative ( ) ) { if ( controller == null ) controller = new CompactionController ( cfs , Collections . < SSTableReader > emptyList ( ) , Integer . MAX_VALUE , true ) ; SSTableIdentityIterator iter = new SSTableIdentityIterator ( cfs . metadata , in , key , 0 , dataSize , true ) ; AbstractCompactedRow row = controller . getCompactedRow ( iter ) ; writer . append ( row ) ; writer . updateMaxTimestamp ( row . maxTimestamp ( ) ) ; if ( row instanceof PrecompactedRow ) { cf = ( ( PrecompactedRow ) ( row ) ) . getFullColumnFamily ( ) ; } } else { IndexHelper . skipBloomFilter ( in ) ; IndexHelper . skipIndex ( in ) ; cf = ColumnFamily . create ( cfs . metadata ) ; ColumnFamily . serializer ( ) . deserializeFromSSTableNoColumns ( cf , in ) ; ColumnFamily . serializer ( ) . deserializeColumns ( in , cf , true , true ) ; writer . append ( key , cf ) ; } ColumnFamily cached = cfs . getRawCachedRow ( key ) ; if ( cached != null ) { switch ( remoteFile . type ) { case AES : if ( dataSize > ( DatabaseDescriptor . getInMemoryCompactionLimit ( ) ) ) { IncomingStreamReader . logger . warn ( "Found<seq2seq4repair_space>a<seq2seq4repair_space>cached<seq2seq4repair_space>row<seq2seq4repair_space>over<seq2seq4repair_space>the<seq2seq4repair_space>in<seq2seq4repair_space>memory<seq2seq4repair_space>compaction<seq2seq4repair_space>limit<seq2seq4repair_space>during<seq2seq4repair_space>post-streaming<seq2seq4repair_space>rebuilt;<seq2seq4repair_space>it<seq2seq4repair_space>is<seq2seq4repair_space>highly<seq2seq4repair_space>recommended<seq2seq4repair_space>to<seq2seq4repair_space>avoid<seq2seq4repair_space>huge<seq2seq4repair_space>row<seq2seq4repair_space>on<seq2seq4repair_space>column<seq2seq4repair_space>family<seq2seq4repair_space>with<seq2seq4repair_space>row<seq2seq4repair_space>cache<seq2seq4repair_space>enabled." ) ; cfs . invalidateCachedRow ( key ) ; } else { assert cf != null ; cfs . updateRowCache ( key , cf ) ; } break ; default : cfs . invalidateCachedRow ( key ) ; break ; } } bytesRead += in . getBytesRead ( ) ; remoteFile . progress += in . getBytesRead ( ) ; } } return writer . closeAndOpenReader ( ) ; } finally { writer . cleanupIfNecessary ( ) ; } } private void retry ( ) throws IOException { } } 
public class Label { public CodeStream codeStream ; static final int POS_NOT_SET = - 1 ; public int position = Label . POS_NOT_SET ; int [ ] forwardReferences = new int [ 10 ] ; int forwardReferenceCount = 0 ; private boolean isWide = false ; public Label ( ) { } public Label ( CodeStream codeStream ) { } void addForwardReference ( int iPos ) { } void appendForwardReferencesFrom ( Label otherLabel ) { } void branch ( ) { } void branchWide ( ) { } public boolean hasForwardReferences ( ) { } public void inlineForwardReferencesFromLabelsTargeting ( int gotoLocation ) { } public boolean isStandardLabel ( ) { } public void place ( ) { if ( ( position ) == ( Label . POS_NOT_SET ) ) { position = codeStream . position ; codeStream . addLabel ( this ) ; int oldPosition = position ; boolean optimizedBranch = false ; if ( ( forwardReferenceCount ) != 0 ) { if ( optimizedBranch = ( ( ( forwardReferences [ ( ( forwardReferenceCount ) - 1 ) ] ) + 2 ) == ( position ) ) && ( ( codeStream . bCodeStream [ ( ( codeStream . classFileOffset ) - 3 ) ] ) == ( OPC_goto ) ) ) { codeStream . position = position -= 3 ; codeStream . classFileOffset -= 3 ; ( forwardReferenceCount ) -- ; int index = ( codeStream . pcToSourceMapSize ) - 2 ; if ( ( codeStream . lastEntryPC ) == oldPosition ) { codeStream . lastEntryPC = position ; } if ( ( index >= 0 ) && ( ( codeStream . pcToSourceMap [ index ] ) == ( position ) ) ) { codeStream . pcToSourceMapSize -= 2 ; } if ( codeStream . generateLocalVariableTableAttributes ) { LocalVariableBinding [ ] locals = codeStream . locals ; for ( int i = 0 , max = locals . length ; i < max ; i ++ ) { LocalVariableBinding local = locals [ i ] ; if ( ( local != null ) && ( ( local . initializationCount ) > 0 ) ) { if ( ( local . initializationPCs [ ( ( ( ( local . initializationCount ) - 1 ) << 1 ) + 1 ) ] ) == oldPosition ) { if ( ( local . initializationPCs [ ( ( ( local . initializationCount ) - 1 ) << 1 ) ] ) == oldPosition ) { local . initializationPCs [ ( ( ( local . initializationCount ) - 1 ) << 1 ) ] = position ; } local . initializationPCs [ ( ( ( ( local . initializationCount ) - 1 ) << 1 ) + 1 ) ] = position ; } } } } } } for ( int i = 0 ; i < ( forwardReferenceCount ) ; i ++ ) { int offset = ( ( position ) - ( forwardReferences [ i ] ) ) + 1 ; if ( ( offset > 32767 ) && ( ! ( this . codeStream . wideMode ) ) ) { <START_BUG> throw new AbortMethod ( null ) ; <END_BUG> } if ( this . codeStream . wideMode ) { if ( this . isWide ) { codeStream . writeSignedWord ( forwardReferences [ i ] , offset ) ; } else { codeStream . writeSignedShort ( forwardReferences [ i ] , ( ( short ) ( offset ) ) ) ; } } else { codeStream . writeSignedShort ( forwardReferences [ i ] , ( ( short ) ( offset ) ) ) ; } } if ( optimizedBranch ) { for ( int i = 0 ; i < ( codeStream . countLabels ) ; i ++ ) { Label label = codeStream . labels [ i ] ; if ( oldPosition == ( label . position ) ) { label . position = position ; if ( label instanceof CaseLabel ) { int offset = ( position ) - ( ( ( CaseLabel ) ( label ) ) . instructionPosition ) ; for ( int j = 0 ; j < ( label . forwardReferenceCount ) ; j ++ ) { int forwardPosition = label . forwardReferences [ j ] ; codeStream . writeSignedWord ( forwardPosition , offset ) ; } } else { for ( int j = 0 ; j < ( label . forwardReferenceCount ) ; j ++ ) { int forwardPosition = label . forwardReferences [ j ] ; int offset = ( ( position ) - forwardPosition ) + 1 ; if ( ( offset > 32767 ) && ( ! ( this . codeStream . wideMode ) ) ) { throw new AbortMethod ( CodeStream . RESTART_IN_WIDE_MODE ) ; } if ( this . codeStream . wideMode ) { if ( this . isWide ) { codeStream . writeSignedWord ( forwardPosition , offset ) ; } else { codeStream . writeSignedShort ( forwardPosition , ( ( short ) ( offset ) ) ) ; } } else { codeStream . writeSignedShort ( forwardPosition , ( ( short ) ( offset ) ) ) ; } } } } } } } } public String toString ( ) { } public void resetStateForCodeGeneration ( ) { } } 
public class Assert { protected Assert ( ) { } public static void assertTrue ( String message , boolean condition ) { } public static void assertTrue ( boolean condition ) { } public static void assertFalse ( String message , boolean condition ) { } public static void assertFalse ( boolean condition ) { } public static void fail ( String message ) { } public static void fail ( ) { } public static void assertEquals ( String message , Object expected , Object actual ) { } public static void assertEquals ( Object expected , Object actual ) { } public static void assertEquals ( String message , String expected , String actual ) { } public static void assertEquals ( String expected , String actual ) { } public static void assertEquals ( String message , double expected , double actual , double delta ) { } public static void assertEquals ( double expected , double actual , double delta ) { } public static void assertEquals ( String message , float expected , float actual , float delta ) { } public static void assertEquals ( float expected , float actual , float delta ) { } public static void assertEquals ( String message , long expected , long actual ) { } public static void assertEquals ( long expected , long actual ) { } public static void assertEquals ( String message , boolean expected , boolean actual ) { <START_BUG> Assert . assertEquals ( message , new Boolean ( expected ) , new Boolean ( actual ) ) ; <END_BUG> } public static void assertEquals ( boolean expected , boolean actual ) { } public static void assertEquals ( String message , byte expected , byte actual ) { } public static void assertEquals ( byte expected , byte actual ) { } public static void assertEquals ( String message , char expected , char actual ) { } public static void assertEquals ( char expected , char actual ) { } public static void assertEquals ( String message , short expected , short actual ) { } public static void assertEquals ( short expected , short actual ) { } public static void assertEquals ( String message , int expected , int actual ) { } public static void assertEquals ( int expected , int actual ) { } public static void assertNotNull ( Object object ) { } public static void assertNotNull ( String message , Object object ) { } public static void assertNull ( Object object ) { } public static void assertNull ( String message , Object object ) { } public static void assertSame ( String message , Object expected , Object actual ) { } public static void assertSame ( Object expected , Object actual ) { } public static void assertNotSame ( String message , Object expected , Object actual ) { } public static void assertNotSame ( Object expected , Object actual ) { } private static void failSame ( String message ) { } private static void failNotSame ( String message , Object expected , Object actual ) { } private static void failNotEquals ( String message , Object expected , Object actual ) { } static String format ( String message , Object expected , Object actual ) { } } 
public class InitBinderDataBinderFactory extends DefaultDataBinderFactory { private final List < InvocableHandlerMethod > binderMethods ; public InitBinderDataBinderFactory ( List < InvocableHandlerMethod > binderMethods , WebBindingInitializer initializer ) { } @ Override public void initBinder ( WebDataBinder binder , NativeWebRequest request ) throws Exception { for ( InvocableHandlerMethod binderMethod : this . binderMethods ) { if ( ! ( isBinderMethodApplicable ( binderMethod , binder ) ) ) { continue ; } Object returnValue = binderMethod . invokeForRequest ( request , null , binder ) ; if ( returnValue != null ) { <START_BUG> throw new IllegalStateException ( ( "This<seq2seq4repair_space>@InitBinder<seq2seq4repair_space>method<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>return<seq2seq4repair_space>void:<seq2seq4repair_space>" + binderMethod ) ) ; <END_BUG> } } } protected boolean isBinderMethodApplicable ( HandlerMethod binderMethod , WebDataBinder binder ) { } } 
public class TestSynchronizedCollection < E > extends AbstractTestCollection < E > { public TestSynchronizedCollection ( String testName ) { } @ Override public Collection < E > makeObject ( ) { <START_BUG> return SynchronizedCollection . decorate ( new ArrayList < E > ( ) ) ; <END_BUG> } @ Override public Collection < E > makeConfirmedCollection ( ) { } @ Override public Collection < E > makeConfirmedFullCollection ( ) { } @ Override public String getCompatibilityVersion ( ) { } } 
public class Recorder < T > extends HiddenField < Object > { private static final long serialVersionUID = 1L ; private static final String [ ] EMPTY_IDS = new String [ 0 ] ; private String [ ] ids ; private final Palette < T > palette ; private boolean attached = false ; public Palette < T > getPalette ( ) { } public Recorder ( String id , Palette < T > palette ) { } @ Override protected void onBeforeRender ( ) { } private void initIds ( ) { IChoiceRenderer < T > renderer = getPalette ( ) . getChoiceRenderer ( ) ; <START_BUG> StringBuffer modelStringBuffer = new StringBuffer ( ) ; <END_BUG> Collection < T > modelCollection = getPalette ( ) . getModelCollection ( ) ; if ( modelCollection == null ) { throw new WicketRuntimeException ( ( "Expected<seq2seq4repair_space>getPalette().getModelCollection()<seq2seq4repair_space>to<seq2seq4repair_space>return<seq2seq4repair_space>a<seq2seq4repair_space>non-null<seq2seq4repair_space>value." + "<seq2seq4repair_space>Please<seq2seq4repair_space>make<seq2seq4repair_space>sure<seq2seq4repair_space>you<seq2seq4repair_space>have<seq2seq4repair_space>model<seq2seq4repair_space>object<seq2seq4repair_space>assigned<seq2seq4repair_space>to<seq2seq4repair_space>the<seq2seq4repair_space>palette" ) ) ; } Iterator < T > selection = modelCollection . iterator ( ) ; int i = 0 ; while ( selection . hasNext ( ) ) { modelStringBuffer . append ( renderer . getIdValue ( selection . next ( ) , ( i ++ ) ) ) ; if ( selection . hasNext ( ) ) { modelStringBuffer . append ( "," ) ; } } String modelString = modelStringBuffer . toString ( ) ; setDefaultModel ( new org . apache . wicket . model . Model < String > ( modelString ) ) ; updateIds ( modelString ) ; } @ Override protected void onValid ( ) { } @ SuppressWarnings ( "unchecked" ) public Iterator < T > getSelectedChoices ( ) { } public Iterator < T > getUnselectedChoices ( ) { } @ Override protected void onInvalid ( ) { } private void updateIds ( ) { } private void updateIds ( String value ) { } } 
public class BinaryMemtable implements IFlushable < DecoratedKey > { private static Logger logger_ = Logger . getLogger ( BinaryMemtable . class ) ; private int threshold_ = ( ( DatabaseDescriptor . getBMTThreshold ( ) ) * 1024 ) * 1024 ; private AtomicInteger currentSize_ = new AtomicInteger ( 0 ) ; private String table_ ; private String cfName_ ; private boolean isFrozen_ = false ; private Map < DecoratedKey , byte [ ] > columnFamilies_ = new org . cliffc . high_scale_lib . NonBlockingHashMap < DecoratedKey , byte [ ] > ( ) ; Lock lock_ = new ReentrantLock ( ) ; Condition condition_ ; private final IPartitioner partitioner_ = StorageService . getPartitioner ( ) ; BinaryMemtable ( String table , String cfName ) throws IOException { } public int getMemtableThreshold ( ) { } void resolveSize ( int oldSize , int newSize ) { } boolean isThresholdViolated ( ) { } String getColumnFamily ( ) { } void put ( String key , byte [ ] buffer ) throws IOException { } private void resolve ( String key , byte [ ] buffer ) { } public List < DecoratedKey > getSortedKeys ( ) { } public SSTableReader writeSortedContents ( List < DecoratedKey > sortedKeys ) throws IOException { BinaryMemtable . logger_ . info ( ( "Writing<seq2seq4repair_space>" + ( this ) ) ) ; ColumnFamilyStore cfStore = Table . open ( table_ ) . getColumnFamilyStore ( cfName_ ) ; String path = cfStore . getTempSSTablePath ( ) ; SSTableWriter writer = new SSTableWriter ( path , sortedKeys . size ( ) , StorageService . getPartitioner ( ) ) ; for ( DecoratedKey key : sortedKeys ) { byte [ ] bytes = columnFamilies_ . get ( key ) ; assert ( bytes . length ) > 0 ; writer . append ( key , bytes ) ; } <START_BUG> SSTableReader sstable = writer . closeAndOpenReader ( ) ; <END_BUG> BinaryMemtable . logger_ . info ( ( "Completed<seq2seq4repair_space>flushing<seq2seq4repair_space>" + ( writer . getFilename ( ) ) ) ) ; return sstable ; } } 
public final class HtmlHandler extends AbstractMarkupFilter { private static final Logger log = LoggerFactory . getLogger ( HtmlHandler . class ) ; private final ArrayListStack < ComponentTag > stack = new ArrayListStack < ComponentTag > ( ) ; private static final Map < String , Boolean > doesNotRequireCloseTag = new HashMap < String , Boolean > ( ) ; public HtmlHandler ( ) { } public MarkupElement nextTag ( ) throws ParseException { <START_BUG> final ComponentTag tag = ( ( ComponentTag ) ( getParent ( ) . nextTag ( ) ) ) ; <END_BUG> if ( tag == null ) { while ( ( stack . size ( ) ) > 0 ) { final ComponentTag top = stack . peek ( ) ; if ( ! ( HtmlHandler . requiresCloseTag ( top . getName ( ) ) ) ) { stack . pop ( ) ; } else { throw new org . apache . wicket . markup . WicketParseException ( "Tag<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>have<seq2seq4repair_space>a<seq2seq4repair_space>close<seq2seq4repair_space>tag:" , top ) ; } } return tag ; } if ( HtmlHandler . log . isDebugEnabled ( ) ) { HtmlHandler . log . debug ( ( ( ( "tag:<seq2seq4repair_space>" + ( tag . toUserDebugString ( ) ) ) + ",<seq2seq4repair_space>stack:<seq2seq4repair_space>" ) + ( stack ) ) ) ; } if ( tag . isOpen ( ) ) { stack . push ( tag ) ; } else if ( tag . isClose ( ) ) { if ( ( stack . size ( ) ) > 0 ) { ComponentTag top = stack . pop ( ) ; boolean mismatch = ! ( top . hasEqualTagName ( tag ) ) ; if ( mismatch ) { top . setHasNoCloseTag ( true ) ; while ( mismatch && ( ! ( HtmlHandler . requiresCloseTag ( top . getName ( ) ) ) ) ) { top . setHasNoCloseTag ( true ) ; if ( stack . isEmpty ( ) ) { break ; } top = stack . pop ( ) ; mismatch = ! ( top . hasEqualTagName ( tag ) ) ; } if ( mismatch ) { throw new ParseException ( ( ( ( "Tag<seq2seq4repair_space>" + ( top . toUserDebugString ( ) ) ) + "<seq2seq4repair_space>has<seq2seq4repair_space>a<seq2seq4repair_space>mismatched<seq2seq4repair_space>close<seq2seq4repair_space>tag<seq2seq4repair_space>at<seq2seq4repair_space>" ) + ( tag . toUserDebugString ( ) ) ) , top . getPos ( ) ) ; } } tag . setOpenTag ( top ) ; } else { throw new org . apache . wicket . markup . WicketParseException ( "Tag<seq2seq4repair_space>does<seq2seq4repair_space>not<seq2seq4repair_space>have<seq2seq4repair_space>a<seq2seq4repair_space>matching<seq2seq4repair_space>open<seq2seq4repair_space>tag:" , tag ) ; } } else if ( tag . isOpenClose ( ) ) { tag . setOpenTag ( tag ) ; } return tag ; } public static boolean requiresCloseTag ( final String name ) { } } 
public class TestIndexReaderReopen extends LuceneTestCase { private File indexDir ; public void testReopen ( ) throws Exception { } public void testParallelReaderReopen ( ) throws Exception { } public void testCommitReopenFS ( ) throws IOException { } public void testCommitRecreateFS ( ) throws IOException { } public void testCommitReopenRAM ( ) throws IOException { } public void testCommitRecreateRAM ( ) throws IOException { } private void doTestReopenWithCommit ( Random random , Directory dir , boolean withReopen ) throws IOException { } public void testMultiReaderReopen ( ) throws Exception { } public void testMixedReaders ( ) throws Exception { } private void performDefaultTests ( TestIndexReaderReopen . TestReopen test ) throws Exception { } public void testReferenceCounting ( ) throws IOException { } public void testReferenceCountingMultiReader ( ) throws IOException { } public void testReferenceCountingParallelReader ( ) throws IOException { } public void testNormsRefCounting ( ) throws IOException { } private void performTestsWithExceptionInReopen ( TestIndexReaderReopen . TestReopen test ) throws Exception { } public void testThreadSafety ( ) throws Exception { } private static class ReaderCouple { ReaderCouple ( IndexReader r1 , IndexReader r2 ) { } IndexReader newReader ; IndexReader refreshedReader ; } private abstract static class ReaderThreadTask { protected volatile boolean stopped ; public void stop ( ) { } public abstract void run ( ) throws Exception { } } private static class ReaderThread extends Thread { private TestIndexReaderReopen . ReaderThreadTask task ; private Throwable error ; ReaderThread ( TestIndexReaderReopen . ReaderThreadTask task ) { } public void stopThread ( ) { } @ Override public void run ( ) { } } private Object createReaderMutex = new Object ( ) ; private TestIndexReaderReopen . ReaderCouple refreshReader ( IndexReader reader , boolean hasChanges ) throws IOException { } TestIndexReaderReopen . ReaderCouple refreshReader ( IndexReader reader , TestIndexReaderReopen . TestReopen test , int modify , boolean hasChanges ) throws IOException { } public static void createIndex ( Random random , Directory dir , boolean multiSegment ) throws IOException { } public static Document createDocument ( int n , int numFields ) { } static void modifyIndex ( int i , Directory dir ) throws IOException { } private void assertReaderClosed ( IndexReader reader , boolean checkSubReaders , boolean checkNormsClosed ) { } private void assertRefCountEquals ( int refCount , IndexReader reader ) { } private abstract static class TestReopen { protected abstract IndexReader openReader ( ) throws IOException { } protected abstract void modifyIndex ( int i ) throws IOException { } } @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; <START_BUG> indexDir = new File ( TEMP_DIR , "IndexReaderReopen" ) ; <END_BUG> } public void testCloseOrig ( ) throws Throwable { } public void testDeletes ( ) throws Throwable { } public void testDeletes2 ( ) throws Throwable { } private static class KeepAllCommits implements IndexDeletionPolicy { public void onInit ( List < ? extends IndexCommit > commits ) { } public void onCommit ( List < ? extends IndexCommit > commits ) { } } public void testReopenOnCommit ( ) throws Throwable { } } 
public abstract class DiscoveryTest extends AbstractDiscoveryTest { protected IServiceInfo serviceInfo ; protected IServiceInfo serviceInfo2 ; protected IServiceInfo serviceInfo3 ; protected String containerUnderTest ; protected long waitTimeForProvider = 1000 ; protected Comparator comparator = new ServiceInfoComparator ( ) ; private String protocol = PROTOCOL ; private String scope = SCOPE ; private String namingAuthority = NAMINGAUTHORITY ; protected IContainer container = null ; protected IDiscoveryContainerAdapter discoveryContainer = null ; public DiscoveryTest ( String name ) { } protected IDiscoveryContainerAdapter getAdapter ( Class clazz ) { } protected IServiceID createServiceID ( String serviceType , String serviceName ) throws Exception { } protected void registerService ( IServiceInfo serviceInfo ) throws Exception { } protected void unregisterService ( IServiceInfo serviceInfo ) throws Exception { } protected void setWaitTimeForProvider ( long aWaitTimeForProvider ) { } protected void setComparator ( Comparator comparator ) { } protected void setProtocol ( String protocol ) { } protected void setScope ( String scope ) { } protected void setNamingAuthority ( String namingAuthority ) { } protected String getServiceType ( ) { } protected void setUp ( ) throws Exception { super . setUp ( ) ; assertNotNull ( containerUnderTest ) ; assertTrue ( containerUnderTest . startsWith ( "ecf.discovery." ) ) ; container = ContainerFactory . getDefault ( ) . createContainer ( containerUnderTest ) ; discoveryContainer = getAdapter ( IDiscoveryContainerAdapter . class ) ; assertNotNull ( container ) ; assertNotNull ( discoveryContainer ) ; final Properties props = new Properties ( ) ; final URI uri = createDefaultURI ( ) ; IServiceID serviceID = ( ( IServiceID ) ( IDFactory . getDefault ( ) . createID ( discoveryContainer . getServicesNamespace ( ) , new Object [ ] { getServiceType ( ) , getHost ( ) } ) ) ) ; assertNotNull ( serviceID ) ; final ServiceProperties serviceProperties = new ServiceProperties ( props ) ; serviceProperties . setPropertyString ( ( ( DiscoveryTest . class . getName ( ) ) + "servicePropertiesString" ) , "serviceProperties" ) ; serviceProperties . setProperty ( ( ( DiscoveryTest . class . getName ( ) ) + "servicePropertiesIntegerMax" ) , new Integer ( Integer . MIN_VALUE ) ) ; serviceProperties . setProperty ( ( ( DiscoveryTest . class . getName ( ) ) + "servicePropertiesIntegerMin" ) , new Integer ( Integer . MAX_VALUE ) ) ; serviceProperties . setProperty ( ( ( DiscoveryTest . class . getName ( ) ) + "servicePropertiesBoolean" ) , new Boolean ( false ) ) ; <START_BUG> serviceProperties . setPropertyBytes ( ( ( DiscoveryTest . class . getName ( ) ) + "servicePropertiesByte" ) , new byte [ ] { 'a' , 'b' , 'c' , 'd' } ) ; <END_BUG> serviceInfo = new org . eclipse . ecf . discovery . ServiceInfo ( uri , serviceID , 1 , 1 , serviceProperties ) ; assertNotNull ( serviceInfo ) ; IServiceID serviceID2 = ( ( IServiceID ) ( IDFactory . getDefault ( ) . createID ( discoveryContainer . getServicesNamespace ( ) , new Object [ ] { "_service._ecf._tests2._fooProtocol.fooScope._fooNA" , getHost ( ) } ) ) ) ; assertNotNull ( serviceID ) ; final ServiceProperties serviceProperties2 = new ServiceProperties ( props ) ; serviceProperties2 . setPropertyString ( "serviceProperties2" , "serviceProperties2" ) ; serviceInfo2 = new org . eclipse . ecf . discovery . ServiceInfo ( uri , serviceID2 , 2 , 2 , serviceProperties2 ) ; assertNotNull ( serviceInfo2 ) ; IServiceID serviceID3 = ( ( IServiceID ) ( IDFactory . getDefault ( ) . createID ( discoveryContainer . getServicesNamespace ( ) , new Object [ ] { "_service._ecf._tests3._barProtocol.barScope._barNA" , getHost ( ) } ) ) ) ; assertNotNull ( serviceID ) ; final ServiceProperties serviceProperties3 = new ServiceProperties ( props ) ; serviceProperties3 . setPropertyString ( "serviceProperties3" , "serviceProperties3" ) ; serviceInfo3 = new org . eclipse . ecf . discovery . ServiceInfo ( uri , serviceID3 , 3 , 3 , serviceProperties3 ) ; assertNotNull ( serviceInfo3 ) ; } protected void tearDown ( ) throws Exception { } protected void registerService ( ) { } protected void unregisterService ( ) { } public void testConnect ( ) { } public void testConnectTwoTimes ( ) { } public void testDisconnect ( ) { } public void testReconnect ( ) { } public void testGetServiceInfo ( ) { } public void testGetServiceInfoWithNull ( ) { } public void testGetServiceTypes ( ) { } public void testGetServices ( ) { } public void testGetServicesIServiceTypeID ( ) { } public void testGetServicesIServiceTypeIDWithNull ( ) { } public void testRegisterService ( ) { } public void testRegisterServiceWithNull ( ) { } public void testUnregisterService ( ) { } public void testUnregisterServiceWithNull ( ) { } public void testDispose ( ) { } protected void addServiceListener ( TestListener serviceListener ) { } public void testAddServiceListenerIServiceListener ( ) { } public void testAddServiceListenerIServiceListenerWithNull ( ) { } public void testAddServiceListenerIServiceTypeIDIServiceListener ( ) { } private void addListenerRegisterAndWait ( TestListener testServiceListener , IServiceInfo aServiceInfo ) { } public void testAddServiceListenerIServiceTypeIDIServiceListenerWithNull ( ) { } public void testAddServiceTypeListener ( ) { } protected IServiceTypeListener createServiceTypeListener ( ) { } public void testAddServiceTypeListenerWithNull ( ) { } public void testGetConnectNamespace ( ) { } public void testGetID ( ) { } public void testGetServicesNamespace ( ) { } public void testRemoveServiceListenerIServiceListener ( ) { } public void testRemoveServiceListenerIServiceListenerWithNull ( ) { } public void testRemoveServiceListenerIServiceTypeIDIServiceListener ( ) { } public void testRemoveServiceListenerIServiceTypeIDIServiceListenerWithNull ( ) { } public void testRemoveServiceTypeListener ( ) { } public void testRemoveServiceTypeListenerWithNull ( ) { } } 
public class Resources extends DataType implements ResourceCollection { public static final ResourceCollection NONE = new ResourceCollection ( ) { public boolean isFilesystemOnly ( ) { } public Iterator iterator ( ) { } public int size ( ) { } } ; public static final Iterator EMPTY_ITERATOR = new Iterator ( ) { public Object next ( ) { } public boolean hasNext ( ) { } public void remove ( ) { } } ; private class MyCollection extends AbstractCollection { private int size ; MyCollection ( ) { } public int size ( ) { } public Iterator iterator ( ) { } private class MyIterator implements Iterator { private Iterator rci = getNested ( ) . iterator ( ) ; private Iterator ri = null ; public boolean hasNext ( ) { } public Object next ( ) { } public void remove ( ) { } } } private Vector rc ; private Collection coll ; public synchronized void add ( ResourceCollection c ) { } public synchronized Iterator iterator ( ) { } public synchronized int size ( ) { } public boolean isFilesystemOnly ( ) { } public synchronized String toString ( ) { } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { for ( Iterator i = getNested ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof DataType ) { <START_BUG> invokeCircularReferenceCheck ( ( ( DataType ) ( o ) ) , stk , p ) ; <END_BUG> } } setChecked ( true ) ; } } protected void invalidateExistingIterators ( ) { } private ResourceCollection getRef ( ) { } private synchronized void validate ( ) { } private synchronized List getNested ( ) { } } 
public class TestTimeLimitingCollector extends LuceneTestCase { private static final int SLOW_DOWN = 3 ; private static final long TIME_ALLOWED = 17 * ( TestTimeLimitingCollector . SLOW_DOWN ) ; private static final double MULTI_THREAD_SLACK = 7 ; private static final int N_DOCS = 3000 ; private static final int N_THREADS = 50 ; private Searcher searcher ; private Directory directory ; private IndexReader reader ; private final String FIELD_NAME = "body" ; private Query query ; @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; final String [ ] docText = new String [ ] { "docThatNeverMatchesSoWeCanRequireLastDocCollectedToBeGreaterThanZero" , "one<seq2seq4repair_space>blah<seq2seq4repair_space>three" , "one<seq2seq4repair_space>foo<seq2seq4repair_space>three<seq2seq4repair_space>multiOne" , "one<seq2seq4repair_space>foobar<seq2seq4repair_space>three<seq2seq4repair_space>multiThree" , "blueberry<seq2seq4repair_space>pancakes" , "blueberry<seq2seq4repair_space>pie" , "blueberry<seq2seq4repair_space>strudel" , "blueberry<seq2seq4repair_space>pizza" } ; directory = newDirectory ( ) ; <START_BUG> RandomIndexWriter iw = new RandomIndexWriter ( random , directory ) ; <END_BUG> for ( int i = 0 ; i < ( TestTimeLimitingCollector . N_DOCS ) ; i ++ ) { add ( docText [ ( i % ( docText . length ) ) ] , iw ) ; } reader = iw . getReader ( ) ; iw . close ( ) ; searcher = newSearcher ( reader ) ; String qtxt = "one" ; for ( int i = 1 ; i < ( docText . length ) ; i ++ ) { qtxt += '<seq2seq4repair_space>' + ( docText [ i ] ) ; } QueryParser queryParser = new QueryParser ( TEST_VERSION_CURRENT , FIELD_NAME , new org . apache . lucene . analysis . MockAnalyzer ( random ) ) ; query = queryParser . parse ( qtxt ) ; searcher . search ( query , null , 1000 ) ; } @ Override public void tearDown ( ) throws Exception { } private void add ( String value , RandomIndexWriter iw ) throws IOException { } private void search ( Collector collector ) throws Exception { } public void testSearch ( ) { } private void doTestSearch ( ) { } private Collector createTimedCollector ( TestTimeLimitingCollector . MyHitCollector hc , long timeAllowed , boolean greedy ) { } public void testTimeoutGreedy ( ) { } public void testTimeoutNotGreedy ( ) { } private void doTestTimeout ( boolean multiThreaded , boolean greedy ) { } private long maxTime ( boolean multiThreaded ) { } private String maxTimeStr ( boolean multiThreaded ) { } public void testModifyResolution ( ) { } public void testSearchMultiThreaded ( ) throws Exception { } public void testTimeoutMultiThreaded ( ) throws Exception { } private void doTestMultiThreads ( final boolean withTimeout ) throws Exception { } private class MyHitCollector extends Collector { private final BitSet bits = new BitSet ( ) ; private int slowdown = 0 ; private int lastDocCollected = - 1 ; private int docBase = 0 ; public void setSlowDown ( int milliseconds ) { } public int hitCount ( ) { } public int getLastDocCollected ( ) { } @ Override public void setScorer ( Scorer scorer ) throws IOException { } @ Override public void collect ( final int doc ) throws IOException { } @ Override public void setNextReader ( IndexReader reader , int base ) { } @ Override public boolean acceptsDocsOutOfOrder ( ) { } } } 
public class WizardNewFileCreationPage extends WizardPage implements Listener { private static final int SIZING_CONTAINER_GROUP_HEIGHT = 250 ; private IStructuredSelection currentSelection ; private IFile newFile ; private IPath linkTargetPath ; private String initialFileName ; private IPath initialContainerFullPath ; private Composite topLevel ; private ResourceAndContainerGroup resourceGroup ; private Button advancedButton ; private CreateLinkedResourceGroup linkedResourceGroup ; public WizardNewFileCreationPage ( String pageName , IStructuredSelection selection ) { } protected void createAdvancedControls ( Composite parent ) { } public void createControl ( Composite parent ) { } protected void createFile ( IFile fileHandle , InputStream contents , IProgressMonitor monitor ) throws CoreException { } protected IFile createFileHandle ( IPath filePath ) { } protected void createLinkTarget ( ) { } public IFile createNewFile ( ) { } public IPath getContainerFullPath ( ) { } public String getFileName ( ) { } protected InputStream getInitialContents ( ) { } protected String getNewFileLabel ( ) { } protected void handleAdvancedButtonSelect ( ) { } public void handleEvent ( Event event ) { } protected void initialPopulateContainerNameField ( ) { } public void setContainerFullPath ( IPath path ) { } public void setFileName ( String value ) { } protected IStatus validateLinkedResource ( ) { } protected boolean validatePage ( ) { boolean valid = true ; IWorkspace workspace = WorkbenchPlugin . getPluginWorkspace ( ) ; String fileName = getFileName ( ) ; IStatus nameStatus = workspace . validateName ( fileName , IResource . FILE ) ; if ( ! ( nameStatus . isOK ( ) ) ) { setErrorMessage ( nameStatus . getMessage ( ) ) ; return false ; } if ( ! ( resourceGroup . areAllValuesValid ( ) ) ) { if ( ( ( resourceGroup . getProblemType ( ) ) == ( ResourceAndContainerGroup . PROBLEM_RESOURCE_EMPTY ) ) || ( ( resourceGroup . getProblemType ( ) ) == ( ResourceAndContainerGroup . PROBLEM_CONTAINER_EMPTY ) ) ) { setMessage ( resourceGroup . getProblemMessage ( ) ) ; setErrorMessage ( null ) ; } else setErrorMessage ( resourceGroup . getProblemMessage ( ) ) ; valid = false ; } IPath container = workspace . getRoot ( ) . getLocation ( ) . append ( getContainerFullPath ( ) ) ; File systemFile = new File ( container . toOSString ( ) , fileName ) ; if ( systemFile . exists ( ) ) { setErrorMessage ( WorkbenchMessages . format ( "WizardNewFileCreationPage.fileExistsMessage" , new String [ ] { systemFile . getPath ( ) } ) ) ; valid = false ; } IStatus linkedResourceStatus = null ; if ( valid && ( ( linkedResourceGroup ) != null ) ) { linkedResourceStatus = validateLinkedResource ( ) ; <START_BUG> if ( ( linkedResourceStatus . getCode ( ) ) == ( IStatus . ERROR ) ) <END_BUG> valid = false ; } if ( valid && ( ( linkedResourceStatus == null ) || ( linkedResourceStatus . isOK ( ) ) ) ) { setMessage ( null ) ; setErrorMessage ( null ) ; } return valid ; } public void setVisible ( boolean visible ) { } } 
public class MethodDeclaration extends BodyDeclaration { private static final int LEGAL_MODIFIERS = ( ( ( ( ( ( ( ( Modifier . PUBLIC ) | ( Modifier . PRIVATE ) ) | ( Modifier . PROTECTED ) ) | ( Modifier . STATIC ) ) | ( Modifier . FINAL ) ) | ( Modifier . SYNCHRONIZED ) ) | ( Modifier . NATIVE ) ) | ( Modifier . ABSTRACT ) ) | ( Modifier . STRICTFP ) ; private boolean isConstructor = false ; private int modifiers = Modifier . NONE ; private SimpleName methodName = null ; private ASTNode . NodeList parameters = new ASTNode . NodeList ( true , SingleVariableDeclaration . class ) ; private Type returnType = null ; private ASTNode . NodeList thrownExceptions = new ASTNode . NodeList ( false , Name . class ) ; private Block optionalBody = null ; MethodDeclaration ( AST ast ) { } ASTNode clone ( AST target ) { } boolean equalSubtrees ( Object other ) { } void accept0 ( ASTVisitor visitor ) { } public boolean isConstructor ( ) { } public void setConstructor ( boolean isConstructor ) { } public int getModifiers ( ) { } public void setModifiers ( int modifiers ) { <START_BUG> modifiers &= ~ ( IConstants . AccDeprecated ) ; <END_BUG> if ( ( modifiers & ( ~ ( MethodDeclaration . LEGAL_MODIFIERS ) ) ) != 0 ) { throw new IllegalArgumentException ( ) ; } modifying ( ) ; this . modifiers = modifiers ; } public SimpleName getName ( ) { } public void setName ( SimpleName methodName ) { } public List parameters ( ) { } public List thrownExceptions ( ) { } public Type getReturnType ( ) { } public void setReturnType ( Type type ) { } public Block getBody ( ) { } public void setBody ( Block body ) { } public IMethodBinding resolveBinding ( ) { } int memSize ( ) { } int treeSize ( ) { } } 
public Shell ( Display display , int style ) { } Shell ( Display display , Shell parent , int style , int handle , boolean embedded ) { } public Shell ( Shell parent ) { } public Shell ( Shell parent , int style ) { } public static Shell internal_new ( Display display , int handle ) { } public static Shell cocoa_new ( Display display , int handle ) { } static int checkStyle ( int style ) { } boolean accessibilityIsIgnored ( int id , int sel ) { } public void addShellListener ( ShellListener listener ) { } void bringToTop ( boolean force ) { } boolean canBecomeKeyWindow ( int id , int sel ) { } void checkOpen ( ) { } public void close ( ) { } void closeWidget ( ) { } public Rectangle computeTrim ( int x , int y , int width , int height ) { } void createHandle ( ) { } void deregister ( ) { } void destroyWidget ( ) { } void drawBackground ( int id , NSGraphicsContext context , NSRect rect ) { } Control findBackgroundControl ( ) { } Composite findDeferredControl ( ) { } Cursor findCursor ( ) { } boolean fixResize ( ) { } void fixShell ( Shell newShell , Control control ) { } public void forceActive ( ) { } public int getAlpha ( ) { } public Rectangle getBounds ( ) { } public Rectangle getClientArea ( ) { } public boolean getFullScreen ( ) { } public int getImeInputMode ( ) { } public Point getLocation ( ) { } public boolean getMaximized ( ) { } Shell getModalShell ( ) { } public boolean getModified ( ) { } public boolean getMinimized ( ) { } public Point getMinimumSize ( ) { } float [ ] getParentBackground ( ) { } public Region getRegion ( ) { } public Shell getShell ( ) { } public Shell [ ] getShells ( ) { } public Point getSize ( ) { } float getThemeAlpha ( ) { } boolean hasBorder ( ) { } void helpRequested ( int id , int sel , int theEvent ) { } void invalidateVisibleRegion ( ) { } boolean isDrawing ( ) { } public boolean isEnabled ( ) { } boolean isEnabledCursor ( ) { } public boolean isVisible ( ) { } boolean makeFirstResponder ( int id , int sel , int notification ) { } void noResponderFor ( int id , int sel , int selector ) { } public void open ( ) { } public boolean print ( GC gc ) { } void register ( ) { } void releaseChildren ( boolean destroy ) { } void releaseHandle ( ) { } void releaseParent ( ) { } void releaseWidget ( ) { } public void removeShellListener ( ShellListener listener ) { } void sendToolTipEvent ( boolean enter ) { } public void setActive ( ) { } void setActiveControl ( Control control ) { } public void setAlpha ( int alpha ) { } void setBounds ( int x , int y , int width , int height , boolean move , boolean resize ) { if ( ( window ) == null ) return ; if ( fullScreen ) setFullScreen ( false ) ; int screenHeight = ( ( int ) ( display . getPrimaryFrame ( ) . height ) ) ; NSRect frame = window . frame ( ) ; if ( ! move ) { x = ( ( int ) ( frame . x ) ) ; y = screenHeight - ( ( int ) ( ( frame . y ) + ( frame . height ) ) ) ; } if ( ! resize ) { width = ( ( int ) ( frame . width ) ) ; height = ( ( int ) ( frame . height ) ) ; } frame . x = x ; frame . y = screenHeight - ( ( int ) ( y + height ) ) ; frame . width = width ; frame . height = height ; <START_BUG> window . setFrame ( frame , true ) ; <END_BUG> } void setClipRegion ( float x , float y ) { } public void setEnabled ( boolean enabled ) { } public void setFullScreen ( boolean fullScreen ) { } public void setMenuBar ( Menu menu ) { } public void setImeInputMode ( int mode ) { } public void setMaximized ( boolean maximized ) { } public void setMinimized ( boolean minimized ) { } public void setMinimumSize ( int width , int height ) { } public void setMinimumSize ( Point size ) { } public void setModified ( boolean modified ) { } public void setRegion ( Region region ) { } public void setText ( String string ) { } public void setVisible ( boolean visible ) { } void setWindowVisible ( boolean visible , boolean key ) { } void setZOrder ( ) { } void setZOrder ( Control control , boolean above ) { } boolean traverseEscape ( ) { } void updateModal ( ) { } void updateParent ( boolean visible ) { } void updateSystemUIMode ( ) { } int view_stringForToolTip_point_userData ( int id , int sel , int view , int tag , int point , int userData ) { } void windowDidBecomeKey ( int id , int sel , int notification ) { } void windowDidMove ( int id , int sel , int notification ) { } void windowDidResize ( int id , int sel , int notification ) { } void windowDidResignKey ( int id , int sel , int notification ) { } void windowSendEvent ( int id , int sel , int event ) { } boolean windowShouldClose ( int id , int sel , int window ) { } } 
public class ColumnFamilyStoreTest extends CleanupHelper { static byte [ ] bytes1 ; static byte [ ] bytes2 ; @ Test public void testGetColumnWithWrongBF ( ) throws IOException , InterruptedException , ExecutionException { } @ Test public void testEmptyRow ( ) throws Exception { } @ Test public void testSkipStartKey ( ) throws IOException , InterruptedException , ExecutionException { } @ Test public void testIndexScan ( ) throws IOException { } @ Test public void testLargeScan ( ) throws IOException { } @ Test public void testIndexDeletions ( ) throws IOException { } @ Test public void testIndexUpdate ( ) throws IOException { } @ Test public void testIndexCreate ( ) throws IOException , InterruptedException , ExecutionException , ConfigurationException { Table table = Table . open ( "Keyspace1" ) ; RowMutation rm ; rm = new RowMutation ( "Keyspace1" , ByteBufferUtil . bytes ( "k1" ) ) ; rm . add ( new QueryPath ( "Indexed2" , null , ByteBufferUtil . bytes ( "birthdate" ) ) , ByteBufferUtil . bytes ( 1L ) , 1 ) ; rm . apply ( ) ; ColumnFamilyStore cfs = table . getColumnFamilyStore ( "Indexed2" ) ; ColumnDefinition old = cfs . metadata . getColumn_metadata ( ) . get ( ByteBufferUtil . bytes ( "birthdate" ) ) ; <START_BUG> ColumnDefinition cd = new ColumnDefinition ( old . name , old . validator , IndexType . KEYS , "birthdate_index" ) ; <END_BUG> Future < ? > future = cfs . addIndex ( cd ) ; future . get ( ) ; assert ( cfs . getIndexedColumnFamilyStore ( cd . name ) . getSSTables ( ) . size ( ) ) > 0 ; queryBirthdate ( table ) ; ColumnFamilyStore indexedCfs = cfs . getIndexedColumnFamilyStore ( ByteBufferUtil . bytes ( "birthdate" ) ) ; cfs . removeIndex ( ByteBufferUtil . bytes ( "birthdate" ) ) ; assert ! ( indexedCfs . isIndexBuilt ( ) ) ; future = cfs . addIndex ( cd ) ; future . get ( ) ; queryBirthdate ( table ) ; } private void queryBirthdate ( Table table ) throws CharacterCodingException { } @ Test public void testDeleteSuperRowSticksAfterFlush ( ) throws Throwable { } private static void assertRowAndColCount ( int rowCount , int colCount , ByteBuffer sc , boolean isDeleted , Collection < Row > rows ) { } private static String str ( ColumnFamily cf ) { } private static void putColsSuper ( ColumnFamilyStore cfs , DecoratedKey key , ByteBuffer scfName , Column ... cols ) throws Throwable { } private static void putColsStandard ( ColumnFamilyStore cfs , DecoratedKey key , Column ... cols ) throws Throwable { } @ Test public void testDeleteStandardRowSticksAfterFlush ( ) throws Throwable { } private ColumnFamilyStore insertKey1Key2 ( ) throws IOException , InterruptedException , ExecutionException { } @ Test public void testBackupAfterFlush ( ) throws Throwable { } } 
public class Stream implements IAggregatableStream { Node _node ; TridentTopology _topology ; String _name ; protected Stream ( TridentTopology topology , String name , Node node ) { } public Stream name ( String name ) { } public Stream parallelismHint ( int hint ) { } public Stream project ( Fields keepFields ) { } public GroupedStream groupBy ( Fields fields ) { } public Stream partitionBy ( Fields fields ) { } public Stream partition ( CustomStreamGrouping partitioner ) { } public Stream shuffle ( ) { } public Stream global ( ) { } public Stream batchGlobal ( ) { } public Stream broadcast ( ) { } public Stream identityPartition ( ) { } public Stream partition ( Grouping grouping ) { } public Stream applyAssembly ( Assembly assembly ) { } @ Override public Stream each ( Fields inputFields , Function function , Fields functionFields ) { } @ Override public Stream partitionAggregate ( Fields inputFields , Aggregator agg , Fields functionFields ) { } public Stream stateQuery ( TridentState state , Fields inputFields , QueryFunction function , Fields functionFields ) { } public TridentState partitionPersist ( StateFactory stateFactory , Fields inputFields , StateUpdater updater , Fields functionFields ) { } public TridentState partitionPersist ( StateSpec stateSpec , Fields inputFields , StateUpdater updater , Fields functionFields ) { } public TridentState partitionPersist ( StateFactory stateFactory , Fields inputFields , StateUpdater updater ) { } public TridentState partitionPersist ( StateSpec stateSpec , Fields inputFields , StateUpdater updater ) { } public Stream each ( Function function , Fields functionFields ) { } public Stream each ( Fields inputFields , Filter filter ) { } public ChainedAggregatorDeclarer chainedAgg ( ) { } public Stream partitionAggregate ( Aggregator agg , Fields functionFields ) { } public Stream partitionAggregate ( CombinerAggregator agg , Fields functionFields ) { } public Stream partitionAggregate ( Fields inputFields , CombinerAggregator agg , Fields functionFields ) { } public Stream partitionAggregate ( ReducerAggregator agg , Fields functionFields ) { } public Stream partitionAggregate ( Fields inputFields , ReducerAggregator agg , Fields functionFields ) { } public Stream aggregate ( Aggregator agg , Fields functionFields ) { } public Stream aggregate ( Fields inputFields , Aggregator agg , Fields functionFields ) { } public Stream aggregate ( CombinerAggregator agg , Fields functionFields ) { } public Stream aggregate ( Fields inputFields , CombinerAggregator agg , Fields functionFields ) { } public Stream aggregate ( ReducerAggregator agg , Fields functionFields ) { } public Stream aggregate ( Fields inputFields , ReducerAggregator agg , Fields functionFields ) { } public TridentState partitionPersist ( StateFactory stateFactory , StateUpdater updater , Fields functionFields ) { } public TridentState partitionPersist ( StateSpec stateSpec , StateUpdater updater , Fields functionFields ) { } public TridentState partitionPersist ( StateFactory stateFactory , StateUpdater updater ) { } public TridentState partitionPersist ( StateSpec stateSpec , StateUpdater updater ) { } public TridentState persistentAggregate ( StateFactory stateFactory , CombinerAggregator agg , Fields functionFields ) { } public TridentState persistentAggregate ( StateSpec spec , CombinerAggregator agg , Fields functionFields ) { } public TridentState persistentAggregate ( StateFactory stateFactory , Fields inputFields , CombinerAggregator agg , Fields functionFields ) { } public TridentState persistentAggregate ( StateSpec spec , Fields inputFields , CombinerAggregator agg , Fields functionFields ) { } public TridentState persistentAggregate ( StateFactory stateFactory , ReducerAggregator agg , Fields functionFields ) { } public TridentState persistentAggregate ( StateSpec spec , ReducerAggregator agg , Fields functionFields ) { } public TridentState persistentAggregate ( StateFactory stateFactory , Fields inputFields , ReducerAggregator agg , Fields functionFields ) { } public TridentState persistentAggregate ( StateSpec spec , Fields inputFields , ReducerAggregator agg , Fields functionFields ) { } public Stream stateQuery ( TridentState state , QueryFunction function , Fields functionFields ) { } @ Override public Stream toStream ( ) { } @ Override public Fields getOutputFields ( ) { } static class BatchGlobalAggScheme implements GlobalAggregationScheme < Stream > { @ Override public IAggregatableStream aggPartition ( Stream s ) { } @ Override public BatchToPartition singleEmitPartitioner ( ) { } } static class GlobalAggScheme implements GlobalAggregationScheme < Stream > { @ Override public IAggregatableStream aggPartition ( Stream s ) { } @ Override public BatchToPartition singleEmitPartitioner ( ) { } } private void projectionValidation ( Fields projFields ) { if ( projFields == null ) { return ; } Fields allFields = this . getOutputFields ( ) ; for ( String field : projFields ) { if ( ! ( allFields . contains ( field ) ) ) { <START_BUG> throw new IllegalArgumentException ( ( ( ( ( "Trying<seq2seq4repair_space>to<seq2seq4repair_space>select<seq2seq4repair_space>non-existent<seq2seq4repair_space>field:<seq2seq4repair_space>'" + field ) + "'<seq2seq4repair_space>from<seq2seq4repair_space>all<seq2seq4repair_space>fields:<seq2seq4repair_space>" ) + allFields ) + "!" ) ) ; <END_BUG> } } } } 
public class ShowBugDatabaseAction extends FrameAction { public ShowBugDatabaseAction ( AbstractFrameController frameController ) { } public void actionPerformed ( ActionEvent evt ) { URLController c = new URLController ( ) ; try { <START_BUG> c . open ( new URL ( "http://www.sourceforge.net/projects/columba/bugs" ) ) ; <END_BUG> } catch ( MalformedURLException mue ) { } } } 
public class CheckableListEditor extends DefaultCellEditor implements ActionListener { private JCheckBox checkbox ; private Boolean selected ; public CheckableListEditor ( ) { } public Component getTableCellEditorComponent ( JTable table , Object value , boolean isSelected , int row , int column ) { } public Object getCellEditorValue ( ) { } public void actionPerformed ( ActionEvent e ) { <START_BUG> selected = new Boolean ( checkbox . isSelected ( ) ) ; <END_BUG> fireEditingStopped ( ) ; } public Component getComponent ( ) { } } 
public class NormValueSource extends ValueSource { protected final String field ; public NormValueSource ( String field ) { } public String name ( ) { } @ Override public String description ( ) { } @ Override public void createWeight ( Map context , IndexSearcher searcher ) throws IOException { } @ Override public FunctionValues getValues ( Map context , AtomicReaderContext readerContext ) throws IOException { IndexSearcher searcher = ( ( IndexSearcher ) ( context . get ( "searcher" ) ) ) ; final TFIDFSimilarity similarity = IDFValueSource . asTFIDF ( searcher . getSimilarity ( ) , field ) ; if ( similarity == null ) { throw new UnsupportedOperationException ( "requires<seq2seq4repair_space>a<seq2seq4repair_space>TFIDFSimilarity<seq2seq4repair_space>(such<seq2seq4repair_space>as<seq2seq4repair_space>DefaultSimilarity)" ) ; } <START_BUG> final NumericDocValues norms = readerContext . reader ( ) . simpleNormValues ( field ) ; <END_BUG> if ( norms == null ) { return new ConstDoubleDocValues ( 0.0 , this ) ; } return new FloatDocValues ( this ) { @ Override public float floatVal ( int doc ) { return similarity . decodeNormValue ( ( ( byte ) ( norms . get ( doc ) ) ) ) ; } } ; } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } } 
public class ServletWebRequest extends WebRequest { private final HttpServletRequest httpServletRequest ; private final Url url ; private final String filterPrefix ; private final ErrorAttributes errorAttributes ; public ServletWebRequest ( HttpServletRequest httpServletRequest , String filterPrefix ) { } public ServletWebRequest ( HttpServletRequest httpServletRequest , String filterPrefix , Url url ) { } @ Override public Url getClientUrl ( ) { } private Url setParameters ( Url url ) { } private Url getUrl ( HttpServletRequest request , String filterPrefix ) { } public String getFilterPrefix ( ) { } @ Override public List < Cookie > getCookies ( ) { } @ Override public Locale getLocale ( ) { } @ Override public Time getDateHeader ( String name ) { long value = httpServletRequest . getDateHeader ( name ) ; if ( value == ( - 1 ) ) { return null ; } <START_BUG> return Time . valueOf ( value ) ; <END_BUG> } @ Override public String getHeader ( String name ) { } @ SuppressWarnings ( "unchecked" ) @ Override public List < String > getHeaders ( String name ) { } private Map < String , List < StringValue > > postParameters = null ; private static boolean isMultiPart ( ServletRequest request ) { } protected Map < String , List < StringValue > > generatePostParameters ( ) { } private Map < String , List < StringValue > > getPostRequestParameters ( ) { } private final IRequestParameters postRequestParameters = new IWritableRequestParameters ( ) { public void reset ( ) { } public void setParameterValues ( String key , List < StringValue > values ) { } public Set < String > getParameterNames ( ) { } public StringValue getParameterValue ( String name ) { } public List < StringValue > getParameterValues ( String name ) { } } ; @ Override public IRequestParameters getPostParameters ( ) { } @ Override public Url getUrl ( ) { } @ Override public ServletWebRequest cloneWithUrl ( Url url ) { } public MultipartServletWebRequest newMultipartWebRequest ( Bytes maxSize ) throws FileUploadException { } public MultipartServletWebRequest newMultipartWebRequest ( Bytes maxSize , FileItemFactory factory ) throws FileUploadException { } private static final Logger logger = LoggerFactory . getLogger ( ServletWebRequest . class ) ; @ Override public String getPrefixToContextPath ( ) { } @ Override public Charset getCharset ( ) { } @ Override public HttpServletRequest getContainerRequest ( ) { } @ Override public String getContextPath ( ) { } @ Override public String getFilterPath ( ) { } @ Override public boolean shouldPreserveClientUrl ( ) { } } 
public void providedShortField ( PersistenceCapable pc , int field , short curVal ) { } public void providedStringField ( PersistenceCapable pc , int field , String curVal ) { } public boolean replaceBooleanField ( PersistenceCapable pc , int field ) { } public byte replaceByteField ( PersistenceCapable pc , int field ) { } public char replaceCharField ( PersistenceCapable pc , int field ) { } public double replaceDoubleField ( PersistenceCapable pc , int field ) { } public float replaceFloatField ( PersistenceCapable pc , int field ) { } public int replaceIntField ( PersistenceCapable pc , int field ) { } public long replaceLongField ( PersistenceCapable pc , int field ) { } public Object replaceObjectField ( PersistenceCapable pc , int field ) { } public short replaceShortField ( PersistenceCapable pc , int field ) { } public String replaceStringField ( PersistenceCapable pc , int field ) { } public boolean fetchBoolean ( int field ) { } public boolean fetchBooleanField ( int field ) { } public byte fetchByte ( int field ) { } public byte fetchByteField ( int field ) { } public char fetchChar ( int field ) { } public char fetchCharField ( int field ) { } public double fetchDouble ( int field ) { } public double fetchDoubleField ( int field ) { } public float fetchFloat ( int field ) { } public float fetchFloatField ( int field ) { } public int fetchInt ( int field ) { } public int fetchIntField ( int field ) { } public long fetchLong ( int field ) { } public long fetchLongField ( int field ) { } public Object fetchObject ( int field ) { } public Object fetchObjectField ( int field ) { } public short fetchShort ( int field ) { } public short fetchShortField ( int field ) { } public String fetchString ( int field ) { } public String fetchStringField ( int field ) { } public void storeBoolean ( int field , boolean externalVal ) { } public void storeBooleanField ( int field , boolean curVal ) { } public void storeByte ( int field , byte externalVal ) { } public void storeByteField ( int field , byte curVal ) { } public void storeChar ( int field , char externalVal ) { } public void storeCharField ( int field , char curVal ) { } public void storeDouble ( int field , double externalVal ) { } public void storeDoubleField ( int field , double curVal ) { } public void storeFloat ( int field , float externalVal ) { } public void storeFloatField ( int field , float curVal ) { } public void storeInt ( int field , int externalVal ) { } public void storeIntField ( int field , int curVal ) { } public void storeLong ( int field , long externalVal ) { } public void storeLongField ( int field , long curVal ) { } public void storeObject ( int field , Object externalVal ) { } public void storeObjectField ( int field , Object curVal ) { } public void storeShort ( int field , short externalVal ) { } public void storeShortField ( int field , short curVal ) { } public void storeString ( int field , String externalVal ) { } public void storeStringField ( int field , String curVal ) { } private void storeField ( int field , Object val , FieldManager fm ) { } void eraseFlush ( ) { } void setLoaded ( boolean val ) { } void setDirty ( boolean val ) { } void clearFields ( ) { fireLifecycleEvent ( BEFORE_CLEAR ) ; unproxyFields ( ) ; lock ( ) ; try { FieldMetaData [ ] fmds = _meta . getFields ( ) ; for ( int i = 0 ; i < ( fmds . length ) ; i ++ ) { if ( ( ! ( fmds [ i ] . isPrimaryKey ( ) ) ) && ( ( fmds [ i ] . getManagement ( ) ) == ( FieldMetaData . MANAGE_PERSISTENT ) ) ) replaceField ( _pc , ClearFieldManager . getInstance ( ) , i ) ; } setLoaded ( false ) ; <START_BUG> assignVersionField ( null ) ; <END_BUG> _loadVersion = null ; if ( ( _fieldImpl ) != null ) Arrays . fill ( _fieldImpl , null ) ; } finally { unlock ( ) ; } fireLifecycleEvent ( AFTER_CLEAR ) ; } void saveFields ( boolean immediate ) { } private void saveField ( int field ) { } void clearSavedFields ( ) { } void restoreFields ( ) { } void proxyFields ( boolean reset , boolean replaceNull ) { } void unproxyFields ( ) { } void preFlush ( boolean logical , OpCallbacks call ) { } void preDelete ( ) { } void cascadeDelete ( OpCallbacks call ) { } void cascadePersist ( OpCallbacks call ) { } boolean loadFields ( BitSet fields , FetchConfiguration fetch , int lockLevel , Object sdata , boolean forWrite ) { } protected void loadField ( int field , int lockLevel , boolean forWrite , boolean fgs ) { } void provideField ( PersistenceCapable pc , FieldManager store , int field ) { } void replaceField ( PersistenceCapable pc , FieldManager load , int field ) { } private void setLoaded ( int field , boolean isLoaded ) { } private void postLoad ( int field , FetchConfiguration fetch ) { } private boolean postLoad ( String fgName , FetchConfiguration fetch ) { } private boolean syncVersion ( Object sdata ) { } public boolean isVersionCheckRequired ( ) { } void setCheckVersion ( boolean versionCheck ) { } public boolean isVersionUpdateRequired ( ) { } void setUpdateVersion ( boolean versionUpdate ) { } protected RuntimeException translate ( RuntimeException re ) { } protected void lock ( ) { } protected void unlock ( ) { } } 
public abstract class AbstractServicePublicationTest extends TestCase implements RemoteServicePublication , IDistributionConstants { protected static void assertStringsEqual ( final String [ ] s1 , final String [ ] s2 ) { } protected IContainer container ; protected String [ ] ifaces ; protected ServiceRegistration registration ; protected abstract IContainer createContainer ( ) throws Exception { } protected abstract String [ ] createInterfaces ( ) throws Exception { } protected ServiceReference reference ; public ServiceReference getReference ( ) { } protected void setUp ( ) throws Exception { } void removeFromContainerManager ( IContainer container ) { } protected void tearDown ( ) throws Exception { } public IContainer getContainer ( ) { } public String [ ] getInterfaces ( ) { } public void setContainer ( IContainer container ) { } public void testServicePublication ( ) throws InterruptedException { final BundleContext context = Activator . getDefault ( ) . getContext ( ) ; final Dictionary props = new Hashtable ( ) ; <START_BUG> props . put ( REMOTE_INTERFACES , getInterfaces ( ) ) ; <END_BUG> final ServiceTracker tracker = new ServiceTracker ( context , TestServiceInterface1 . class . getName ( ) , null ) ; tracker . open ( ) ; registration = context . registerService ( TestServiceInterface1 . class . getName ( ) , new TestService1 ( ) , props ) ; tracker . waitForService ( 10000 ) ; final ServiceReference ref = context . getServiceReference ( ServicePublication . class . getName ( ) ) ; assertTrue ( ( ref != null ) ) ; final Object o = ref . getProperty ( SERVICE_INTERFACE_NAME ) ; assertTrue ( ( o instanceof Collection ) ) ; final Collection refIfaces = ( ( Collection ) ( o ) ) ; AbstractServicePublicationTest . assertStringsEqual ( getInterfaces ( ) , ( ( String [ ] ) ( refIfaces . toArray ( new String [ ] { } ) ) ) ) ; Thread . sleep ( 10000 ) ; } public void setInterfaces ( String [ ] interfaces ) { } } 
public class TestExplanations extends LuceneTestCase { protected IndexSearcher searcher ; public static final String KEY = "KEY" ; public static final String FIELD = "field" ; public static final QueryParser qp = new QueryParser ( TestExplanations . FIELD , new WhitespaceAnalyzer ( ) ) ; public void tearDown ( ) throws Exception { } public void setUp ( ) throws Exception { super . setUp ( ) ; RAMDirectory directory = new RAMDirectory ( ) ; IndexWriter writer = new IndexWriter ( directory , new WhitespaceAnalyzer ( ) , true , MaxFieldLength . LIMITED ) ; for ( int i = 0 ; i < ( docFields . length ) ; i ++ ) { Document doc = new Document ( ) ; doc . add ( new org . apache . lucene . document . Field ( TestExplanations . KEY , ( "" + i ) , Store . NO , Index . NOT_ANALYZED ) ) ; doc . add ( new org . apache . lucene . document . Field ( TestExplanations . FIELD , docFields [ i ] , Store . NO , Index . ANALYZED ) ) ; writer . addDocument ( doc ) ; } writer . close ( ) ; <START_BUG> searcher = new IndexSearcher ( directory ) ; <END_BUG> } protected String [ ] docFields = new String [ ] { "w1<seq2seq4repair_space>w2<seq2seq4repair_space>w3<seq2seq4repair_space>w4<seq2seq4repair_space>w5" , "w1<seq2seq4repair_space>w3<seq2seq4repair_space>w2<seq2seq4repair_space>w3<seq2seq4repair_space>zz" , "w1<seq2seq4repair_space>xx<seq2seq4repair_space>w2<seq2seq4repair_space>yy<seq2seq4repair_space>w3" , "w1<seq2seq4repair_space>w3<seq2seq4repair_space>xx<seq2seq4repair_space>w2<seq2seq4repair_space>yy<seq2seq4repair_space>w3<seq2seq4repair_space>zz" } ; public Query makeQuery ( String queryText ) throws ParseException { } public void qtest ( String queryText , int [ ] expDocNrs ) throws Exception { } public void qtest ( Query q , int [ ] expDocNrs ) throws Exception { } public void bqtest ( Query q , int [ ] expDocNrs ) throws Exception { } public void bqtest ( String queryText , int [ ] expDocNrs ) throws Exception { } public static class ItemizedFilter extends FieldCacheTermsFilter { private static String [ ] int2str ( int [ ] terms ) { } public ItemizedFilter ( String keyField , int [ ] keys ) { } public ItemizedFilter ( int [ ] keys ) { } } public static Term [ ] ta ( String [ ] s ) { } public SpanTermQuery st ( String s ) { } public SpanNotQuery snot ( SpanQuery i , SpanQuery e ) { } public SpanOrQuery sor ( String s , String e ) { } public SpanOrQuery sor ( SpanQuery s , SpanQuery e ) { } public SpanOrQuery sor ( String s , String m , String e ) { } public SpanOrQuery sor ( SpanQuery s , SpanQuery m , SpanQuery e ) { } public SpanNearQuery snear ( String s , String e , int slop , boolean inOrder ) { } public SpanNearQuery snear ( SpanQuery s , SpanQuery e , int slop , boolean inOrder ) { } public SpanNearQuery snear ( String s , String m , String e , int slop , boolean inOrder ) { } public SpanNearQuery snear ( SpanQuery s , SpanQuery m , SpanQuery e , int slop , boolean inOrder ) { } public SpanFirstQuery sf ( String s , int b ) { } public Query optB ( String q ) throws Exception { } public Query optB ( Query q ) throws Exception { } public Query reqB ( String q ) throws Exception { } public Query reqB ( Query q ) throws Exception { } public void testNoop ( ) { } } 
public class ExternalFoldersManager { private static final boolean DEBUG = false ; private static final String EXTERNAL_PROJECT_NAME = ".org.eclipse.jdt.core.external.folders" ; private static final String LINKED_FOLDER_NAME = ".link" ; private HashMap folders ; private int counter = 0 ; public static HashSet getExternalFolders ( IClasspathEntry [ ] classpath ) { } public static boolean isExternalFolderPath ( IPath externalPath ) { } public static boolean isInternalPathForExternalFolder ( IPath resourcePath ) { } public IFolder addFolder ( IPath externalFolderPath ) { } private synchronized IFolder addFolder ( IPath externalFolderPath , IProject externalFoldersProject ) { } public IFolder createLinkFolder ( IPath externalFolderPath , boolean refreshIfExistAlready , IProgressMonitor monitor ) throws CoreException { } public synchronized void cleanUp ( IProgressMonitor monitor ) throws CoreException { } public IProject getExternalFoldersProject ( ) { } private IProject createExternalFoldersProject ( IProgressMonitor monitor ) { } public synchronized IFolder getFolder ( IPath externalFolderPath ) { } private HashMap getFolders ( ) { } public void refreshReferences ( IProject source , IProgressMonitor monitor ) { IProject externalProject = getExternalFoldersProject ( ) ; if ( source . equals ( externalProject ) ) return ; if ( ! ( JavaProject . hasJavaNature ( source ) ) ) return ; try { <START_BUG> HashSet externalFolders = ExternalFoldersManager . getExternalFolders ( JavaCore . create ( source ) . getResolvedClasspath ( true ) ) ; <END_BUG> if ( externalFolders == null ) return ; final Iterator iterator = externalFolders . iterator ( ) ; Job refreshJob = new Job ( Messages . refreshing_external_folders ) { public boolean belongsTo ( Object family ) { return family == ( ResourcesPlugin . FAMILY_MANUAL_REFRESH ) ; } protected IStatus run ( IProgressMonitor pm ) { try { while ( iterator . hasNext ( ) ) { IPath externalPath = ( ( IPath ) ( iterator . next ( ) ) ) ; IFolder folder = getFolder ( externalPath ) ; if ( folder != null ) folder . refreshLocal ( IResource . DEPTH_INFINITE , pm ) ; } } catch ( CoreException e ) { return e . getStatus ( ) ; } return Status . OK_STATUS ; } } ; refreshJob . schedule ( ) ; } catch ( CoreException e ) { Util . log ( e , "Exception<seq2seq4repair_space>while<seq2seq4repair_space>refreshing<seq2seq4repair_space>external<seq2seq4repair_space>project" ) ; } return ; } public synchronized IFolder removeFolder ( IPath externalFolderPath ) { } } 
public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor { public RequestResponseBodyMethodProcessor ( List < HttpMessageConverter < ? > > messageConverters ) { } public boolean supportsParameter ( MethodParameter parameter ) { } public boolean supportsReturnType ( MethodParameter returnType ) { } public Object resolveArgument ( MethodParameter parameter , ModelAndViewContainer mavContainer , NativeWebRequest webRequest , WebDataBinderFactory binderFactory ) throws Exception { Object arg = readWithMessageConverters ( webRequest , parameter , parameter . getParameterType ( ) ) ; Annotation [ ] annotations = parameter . getParameterAnnotations ( ) ; for ( Annotation annot : annotations ) { <START_BUG> if ( "Valid" . equals ( annot . annotationType ( ) . getSimpleName ( ) ) ) { <END_BUG> String name = Conventions . getVariableNameForParameter ( parameter ) ; WebDataBinder binder = binderFactory . createBinder ( webRequest , arg , name ) ; Object hints = AnnotationUtils . getValue ( annot ) ; binder . validate ( ( hints instanceof Object [ ] ? ( ( Object [ ] ) ( hints ) ) : new Object [ ] { hints } ) ) ; BindingResult bindingResult = binder . getBindingResult ( ) ; if ( bindingResult . hasErrors ( ) ) { throw new org . springframework . web . method . annotation . support . MethodArgumentNotValidException ( parameter , bindingResult ) ; } } } return arg ; } public void handleReturnValue ( Object returnValue , MethodParameter returnType , ModelAndViewContainer mavContainer , NativeWebRequest webRequest ) throws IOException , HttpMediaTypeNotAcceptableException { } } 
public class ProgressFeedbackDialog extends Dialog { private IStructuredContentProvider provider ; ListViewer viewer ; public ProgressFeedbackDialog ( IStructuredContentProvider contentProvider ) { } private ILabelProvider getLabelProvider ( ) { } public void refreshViewer ( ) { } protected void configureShell ( Shell newShell ) { } protected Control createDialogArea ( Composite parent ) { setBlockOnOpen ( false ) ; Composite mainArea = ( ( Composite ) ( super . createDialogArea ( parent ) ) ) ; viewer = new ListViewer ( mainArea , SWT . BORDER ) ; GridData data = new GridData ( ( ( ( GridData . FILL_BOTH ) | ( GridData . GRAB_HORIZONTAL ) ) | ( GridData . GRAB_VERTICAL ) ) ) ; <START_BUG> data . widthHint = convertHorizontalDLUsToPixels ( 200 ) ; <END_BUG> data . heightHint = convertVerticalDLUsToPixels ( 100 ) ; viewer . getControl ( ) . setLayoutData ( data ) ; viewer . setContentProvider ( provider ) ; viewer . setLabelProvider ( getLabelProvider ( ) ) ; viewer . setInput ( ProgressFeedbackManager . getFeedbackManager ( ) ) ; viewer . addDoubleClickListener ( new IDoubleClickListener ( ) { public void doubleClick ( DoubleClickEvent event ) { ISelection selection = event . getSelection ( ) ; if ( selection instanceof IStructuredSelection ) { IStructuredSelection structured = ( ( IStructuredSelection ) ( selection ) ) ; if ( ( structured . size ( ) ) > 0 ) { AwaitingFeedbackInfo info = ( ( AwaitingFeedbackInfo ) ( structured . getFirstElement ( ) ) ) ; info . getJob ( ) . schedule ( ) ; } } } } ) ; return mainArea ; } protected void createButtonsForButtonBar ( Composite parent ) { } } 
public class ParameterizedTypeBinding extends ReferenceBinding implements Substitution { public ReferenceBinding type ; public TypeBinding [ ] arguments ; public LookupEnvironment environment ; public char [ ] genericTypeSignature ; public ReferenceBinding superclass ; public ReferenceBinding [ ] superInterfaces ; public FieldBinding [ ] fields ; public ReferenceBinding [ ] memberTypes ; public MethodBinding [ ] methods ; public ReferenceBinding enclosingType ; public ParameterizedTypeBinding ( ReferenceBinding type , TypeBinding [ ] arguments , ReferenceBinding enclosingType , LookupEnvironment environment ) { } public void collectSubstitutes ( TypeBinding otherType , Map substitutes ) { } public void computeId ( ) { } public char [ ] constantPoolName ( ) { } public ParameterizedMethodBinding createParameterizedMethod ( MethodBinding originalMethod ) { <START_BUG> return new ParameterizedMethodBinding ( this , originalMethod ) ; <END_BUG> } public String debugName ( ) { } public ReferenceBinding enclosingType ( ) { } public TypeBinding erasure ( ) { } public int fieldCount ( ) { } public FieldBinding [ ] fields ( ) { } public char [ ] genericTypeSignature ( ) { } public MethodBinding getExactConstructor ( TypeBinding [ ] argumentTypes ) { } public MethodBinding getExactMethod ( char [ ] selector , TypeBinding [ ] argumentTypes , CompilationUnitScope refScope ) { } public FieldBinding getField ( char [ ] fieldName , boolean needResolve ) { } public ReferenceBinding getMemberType ( char [ ] typeName ) { } public MethodBinding [ ] getMethods ( char [ ] selector ) { } public boolean hasMemberTypes ( ) { } public boolean implementsMethod ( MethodBinding method ) { } void initialize ( ReferenceBinding someType , TypeBinding [ ] someArguments ) { } protected void initializeArguments ( ) { } public boolean isEquivalentTo ( TypeBinding otherType ) { } public boolean isParameterizedType ( ) { } public ReferenceBinding [ ] memberTypes ( ) { } public MethodBinding [ ] methods ( ) { } public char [ ] qualifiedSourceName ( ) { } public char [ ] readableName ( ) { } ReferenceBinding resolve ( ) { } public char [ ] shortReadableName ( ) { } public char [ ] signature ( ) { } public char [ ] sourceName ( ) { } public TypeBinding substitute ( TypeBinding originalType ) { } public ReferenceBinding superclass ( ) { } public ReferenceBinding [ ] superInterfaces ( ) { } public void swapUnresolved ( UnresolvedReferenceBinding unresolvedType , ReferenceBinding resolvedType , LookupEnvironment env ) { } public ReferenceBinding [ ] syntheticEnclosingInstanceTypes ( ) { } public SyntheticArgumentBinding [ ] syntheticOuterLocalVariables ( ) { } public char [ ] qualifiedPackageName ( ) { } public String toString ( ) { } public TypeVariableBinding [ ] typeVariables ( ) { } } 
public class Jaxb2MarshallerTests extends AbstractMarshallerTests { private static final String CONTEXT_PATH = "org.springframework.oxm.jaxb.test" ; private Jaxb2Marshaller marshaller ; private Flights flights ; @ Override public Marshaller createMarshaller ( ) throws Exception { } @ Override protected Object createFlights ( ) { FlightType flight = new FlightType ( ) ; flight . setNumber ( 42L ) ; flights = new Flights ( ) ; <START_BUG> flights . getFlight ( ) . configureBinding ( flight ) ; <END_BUG> return flights ; } @ Test public void marshalSAXResult ( ) throws Exception { } @ Test public void laxyInit ( ) throws Exception { } @ Test public void properties ( ) throws Exception { } @ Test ( expected = IllegalArgumentException . class ) public void noContextPathOrClassesToBeBound ( ) throws Exception { } @ Test ( expected = UncategorizedMappingException . class ) public void testInvalidContextPath ( ) throws Exception { } @ Test ( expected = XmlMappingException . class ) public void marshalInvalidClass ( ) throws Exception { } @ Test public void supportsContextPath ( ) throws Exception { } @ Test public void supportsClassesToBeBound ( ) throws Exception { } @ Test public void marshalAttachments ( ) throws Exception { } } 
public class Spinner extends Composite { public static final int LIMIT ; public Spinner ( Composite parent , int style ) { } static int checkStyle ( int style ) { } protected void checkSubclass ( ) { } void createHandle ( int index ) { } public void addModifyListener ( ModifyListener listener ) { } public void addSelectionListener ( SelectionListener listener ) { } void addVerifyListener ( VerifyListener listener ) { } public Point computeSize ( int wHint , int hHint , boolean changed ) { } public Rectangle computeTrim ( int x , int y , int width , int height ) { } public void copy ( ) { } public void cut ( ) { } void deregister ( ) { } int defaultBackground ( ) { } int defaultForeground ( ) { } public int getDigits ( ) { } public int getIncrement ( ) { } public int getMaximum ( ) { } public int getMinimum ( ) { } public int getPageIncrement ( ) { } public int getSelection ( ) { } public String getText ( ) { } public int getTextLimit ( ) { checkWidget ( ) ; <START_BUG> return 0 ; <END_BUG> } boolean hasFocus ( ) { } void hookEvents ( ) { } public void paste ( ) { } int Pt_CB_NUMERIC_CHANGED ( int widget , int info ) { } void register ( ) { } public void removeModifyListener ( ModifyListener listener ) { } public void removeSelectionListener ( SelectionListener listener ) { } void removeVerifyListener ( VerifyListener listener ) { } public void setDigits ( int value ) { } public void setIncrement ( int value ) { } public void setMaximum ( int value ) { } public void setMinimum ( int value ) { } public void setPageIncrement ( int value ) { } public void setSelection ( int value ) { } public void setTextLimit ( int limit ) { } public void setValues ( int selection , int minimum , int maximum , int digits , int increment , int pageIncrement ) { } boolean translateTraversal ( int key_sym , PhKeyEvent_t phEvent ) { } int widgetClass ( ) { } } 
public class FieldInfo extends ClassFileStruct implements Comparable , AttributeNamesConstants , IBinaryField , TypeIds { private int accessFlags ; private int attributeBytes ; private Constant constant ; private int [ ] constantPoolOffsets ; private char [ ] descriptor ; private char [ ] name ; private char [ ] signature ; private int signatureUtf8Offset ; private long tagBits ; private Object wrappedConstantValue ; public FieldInfo ( byte [ ] classFileBytes , int [ ] offsets , int offset ) { } public int compareTo ( Object o ) { } private int decodeAnnotation ( int offset ) { } private int decodeElementValue ( int offset ) { } private void decodeStandardAnnotations ( int offset ) { } public Constant getConstant ( ) { } public char [ ] getGenericSignature ( ) { } public int getModifiers ( ) { } public char [ ] getName ( ) { } public long getTagBits ( ) { } public char [ ] getTypeName ( ) { } public Object getWrappedConstantValue ( ) { if ( ( this . wrappedConstantValue ) == null ) { if ( hasConstant ( ) ) { Constant fieldConstant = getConstant ( ) ; switch ( fieldConstant . typeID ( ) ) { case TypeIds . T_int : this . wrappedConstantValue = new Integer ( fieldConstant . intValue ( ) ) ; break ; case TypeIds . T_byte : this . wrappedConstantValue = new Byte ( fieldConstant . byteValue ( ) ) ; break ; case TypeIds . T_short : this . wrappedConstantValue = new Short ( fieldConstant . shortValue ( ) ) ; break ; case TypeIds . T_char : this . wrappedConstantValue = new Character ( fieldConstant . charValue ( ) ) ; break ; case TypeIds . T_float : this . wrappedConstantValue = new Float ( fieldConstant . floatValue ( ) ) ; break ; case TypeIds . T_double : this . wrappedConstantValue = new Double ( fieldConstant . doubleValue ( ) ) ; break ; case TypeIds . T_boolean : this . wrappedConstantValue = Util . toBoolean ( fieldConstant . booleanValue ( ) ) ; break ; case TypeIds . T_long : this . wrappedConstantValue = new Long ( fieldConstant . longValue ( ) ) ; break ; <START_BUG> case T_String : <END_BUG> this . wrappedConstantValue = fieldConstant . stringValue ( ) ; } } } return this . wrappedConstantValue ; } public boolean hasConstant ( ) { } void initialize ( ) { } public boolean isSynthetic ( ) { } private void readConstantAttribute ( ) { } private void readModifierRelatedAttributes ( ) { } protected void reset ( ) { } public int sizeInBytes ( ) { } public void throwFormatException ( ) throws ClassFormatException { } public String toString ( ) { } } 
public class ModClusterEnableContext implements OperationStepHandler { static final ModClusterEnableContext INSTANCE = new ModClusterEnableContext ( ) ; static OperationDefinition getDefinition ( ResourceDescriptionResolver descriptionResolver ) { } @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { if ( ( context . isNormalServer ( ) ) && ( ( context . getServiceRegistry ( false ) . getService ( SERVICE_NAME ) ) != null ) ) { context . addStep ( new OperationStepHandler ( ) { @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { ServiceController < ? > controller = context . getServiceRegistry ( false ) . getService ( SERVICE_NAME ) ; final ModClusterServiceMBean service = ( ( ModClusterServiceMBean ) ( controller . getValue ( ) ) ) ; ModClusterLogger . ROOT_LOGGER . debugf ( "enable-context:<seq2seq4repair_space>%s" , operation ) ; final String webHost = ModClusterSubsystemResourceDefinition . VIRTUAL_HOST . resolveModelAttribute ( context , operation ) . asString ( ) ; final String webContext = ModClusterSubsystemResourceDefinition . CONTEXT . resolveModelAttribute ( context , operation ) . asString ( ) ; try { service . enableContext ( webHost , webContext ) ; } catch ( IllegalArgumentException e ) { <START_BUG> throw new OperationFailedException ( new ModelNode ( ) . set ( ROOT_LOGGER . contextOrHostNotFound ( webHost , webContext ) ) ) ; <END_BUG> } context . completeStep ( new OperationContext . RollbackHandler ( ) { @ Override public void handleRollback ( OperationContext context , ModelNode operation ) { service . disableContext ( webHost , webContext ) ; } } ) ; } } , RUNTIME ) ; } context . stepCompleted ( ) ; } } 
public class ConstantInitializer < T > implements ConcurrentInitializer < T > { private static final String FMT_TO_STRING = "ConstantInitializer@%d<seq2seq4repair_space>[<seq2seq4repair_space>object<seq2seq4repair_space>=<seq2seq4repair_space>%s<seq2seq4repair_space>]" ; private final T object ; public ConstantInitializer ( final T obj ) { } public final T getObject ( ) { } @ Override public T get ( ) throws ConcurrentException { } @ Override public int hashCode ( ) { } @ Override public boolean equals ( final Object obj ) { if ( ( this ) == obj ) { return true ; } if ( ! ( obj instanceof ConstantInitializer < ? > ) ) { return false ; } <START_BUG> ConstantInitializer < ? > c = ( ( ConstantInitializer < ? > ) ( obj ) ) ; <END_BUG> return ObjectUtils . equals ( getObject ( ) , c . getObject ( ) ) ; } @ Override public String toString ( ) { } } 
public class WriteAttributeHandlers { public static class WriteAttributeOperationHandler implements ModelUpdateOperationHandler { public static OperationHandler INSTANCE = new WriteAttributeHandlers . WriteAttributeOperationHandler ( ) ; final ParameterValidator validator ; private WriteAttributeOperationHandler ( ) { } protected WriteAttributeOperationHandler ( ParameterValidator validator ) { } @ Override public Cancellable execute ( final NewOperationContext context , final ModelNode operation , final ResultHandler resultHandler ) { Cancellable cancellable = Cancellable . NULL ; try { final String name = operation . require ( NAME ) . asString ( ) ; final ModelNode value = operation . get ( VALUE ) ; String error = validateValue ( name , value ) ; if ( error != null ) { resultHandler . handleFailed ( new ModelNode ( ) . set ( error ) ) ; } else { <START_BUG> context . getSubModel ( ) . require ( name ) . set ( value ) ; <END_BUG> resultHandler . handleResultComplete ( null ) ; } } catch ( final Exception e ) { resultHandler . handleFailed ( new ModelNode ( ) . set ( e . getMessage ( ) ) ) ; } return cancellable ; } protected String validateValue ( String name , ModelNode value ) { } } public static class ModelTypeValidatingHandler extends WriteAttributeHandlers . WriteAttributeOperationHandler { public ModelTypeValidatingHandler ( final ModelType type ) { } public ModelTypeValidatingHandler ( final ModelType type , final boolean nullable ) { } public ModelTypeValidatingHandler ( final ModelType type , final boolean nullable , final boolean allowExpressions ) { } public ModelTypeValidatingHandler ( final boolean nullable , final boolean allowExpressions , ModelType firstValidType , ModelType ... otherValidTypes ) { } } public static class StringLengthValidatingHandler extends WriteAttributeHandlers . WriteAttributeOperationHandler { public StringLengthValidatingHandler ( final int min ) { } public StringLengthValidatingHandler ( final int min , final boolean nullable ) { } public StringLengthValidatingHandler ( final int min , final int max , final boolean nullable , final boolean allowExpressions ) { } } public static class IntRangeValidatingHandler extends WriteAttributeHandlers . WriteAttributeOperationHandler { public IntRangeValidatingHandler ( final int min ) { } public IntRangeValidatingHandler ( final int min , final boolean nullable ) { } public IntRangeValidatingHandler ( final int min , final int max , final boolean nullable , final boolean allowExpressions ) { } } public static class InetAddressValidatingHandler extends WriteAttributeHandlers . WriteAttributeOperationHandler { public InetAddressValidatingHandler ( final boolean nullable , final boolean allowExpressions ) { } } public static class ListValidatatingHandler extends WriteAttributeHandlers . WriteAttributeOperationHandler { public ListValidatatingHandler ( ParameterValidator elementValidator ) { } public ListValidatatingHandler ( ParameterValidator elementValidator , boolean nullable ) { } public ListValidatatingHandler ( ParameterValidator elementValidator , boolean nullable , int minSize , int maxSize ) { } } } 
public class EJB3SubsystemXMLPersister implements XMLElementWriter < SubsystemMarshallingContext > { public static final EJB3SubsystemXMLPersister INSTANCE = new EJB3SubsystemXMLPersister ( ) ; @ Override public void writeContent ( final XMLExtendedStreamWriter writer , final SubsystemMarshallingContext context ) throws XMLStreamException { <START_BUG> context . startSubsystemElement ( EJB3_1_5 . getUriString ( ) , false ) ; <END_BUG> writeElements ( writer , context ) ; writer . writeEndElement ( ) ; } protected void writeElements ( final XMLExtendedStreamWriter writer , final SubsystemMarshallingContext context ) throws XMLStreamException { } private void writeIIOP ( final XMLExtendedStreamWriter writer , final ModelNode model ) throws XMLStreamException { } private void writeThreadPools ( final XMLExtendedStreamWriter writer , final ModelNode threadPoolsModel ) throws XMLStreamException { } protected void writeRemote ( final XMLExtendedStreamWriter writer , final ModelNode model ) throws XMLStreamException { } private void writeAsync ( final XMLExtendedStreamWriter writer , final ModelNode model ) throws XMLStreamException { } private void writeMDB ( final XMLExtendedStreamWriter writer , final ModelNode mdbModelNode ) throws XMLStreamException { } private void writeEntityBean ( final XMLExtendedStreamWriter writer , final ModelNode entityModelNode ) throws XMLStreamException { } private void writeSingletonBean ( final XMLExtendedStreamWriter writer , final ModelNode singletonBeanModel ) throws XMLStreamException { } private void writeStatefulBean ( final XMLExtendedStreamWriter writer , final ModelNode statefulBeanModel ) throws XMLStreamException { } private void writeDefaultSLSBPool ( final XMLExtendedStreamWriter writer , final ModelNode model ) throws XMLStreamException { } private void writeBeanInstancePools ( final XMLExtendedStreamWriter writer , final ModelNode beanInstancePoolModelNode ) throws XMLStreamException { } private void writeStrictMaxPoolConfig ( final XMLExtendedStreamWriter writer , final Property strictMaxPoolModel ) throws XMLStreamException { } private void writeCaches ( XMLExtendedStreamWriter writer , ModelNode model ) throws XMLStreamException { } private void writeClusterPassivationStores ( XMLExtendedStreamWriter writer , ModelNode model ) throws XMLStreamException { } private void writeFilePassivationStores ( XMLExtendedStreamWriter writer , ModelNode model ) throws XMLStreamException { } private void writeTimerService ( final XMLExtendedStreamWriter writer , final ModelNode timerServiceModel ) throws XMLStreamException { } private void writeDatabaseDataStores ( final XMLExtendedStreamWriter writer , final ModelNode timerServiceModel ) throws XMLStreamException { } private void writeFileDataStores ( final XMLExtendedStreamWriter writer , final ModelNode timerServiceModel ) throws XMLStreamException { } private void writeChannelCreationOptions ( final XMLExtendedStreamWriter writer , final ModelNode node ) throws XMLStreamException { } } 
public class SingleNameReference extends NameReference implements OperatorIds { public char [ ] token ; public MethodBinding [ ] syntheticAccessors ; public static final int READ = 0 ; public static final int WRITE = 1 ; public SingleNameReference ( char [ ] source , long pos ) { } public FlowInfo analyseAssignment ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , Assignment assignment , boolean isCompound ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo , boolean valueRequired ) { } public TypeBinding checkFieldAccess ( BlockScope scope ) { FieldBinding fieldBinding = ( ( FieldBinding ) ( binding ) ) ; bits &= ~ ( ASTNode . RestrictiveFlagMASK ) ; bits |= FIELD ; if ( ! ( ( ( FieldBinding ) ( binding ) ) . isStatic ( ) ) ) { if ( scope . methodScope ( ) . isStatic ) { scope . problemReporter ( ) . staticFieldAccessToNonStaticVariable ( this , fieldBinding ) ; constant = NotAConstant ; return null ; } } <START_BUG> constant = FieldReference . getConstantFor ( fieldBinding , true , this , 0 ) ; <END_BUG> if ( isFieldUseDeprecated ( fieldBinding , scope ) ) scope . problemReporter ( ) . deprecatedField ( fieldBinding , this ) ; MethodScope ms = scope . methodScope ( ) ; if ( ( ( ( ms . enclosingSourceType ( ) ) == ( fieldBinding . declaringClass ) ) && ( ( ms . fieldDeclarationIndex ) != ( ms . NotInFieldDecl ) ) ) && ( ( fieldBinding . id ) >= ( ms . fieldDeclarationIndex ) ) ) { if ( ( ! ( fieldBinding . isStatic ( ) ) ) || ( ms . isStatic ) ) scope . problemReporter ( ) . forwardReference ( this , 0 , scope . enclosingSourceType ( ) ) ; } return fieldBinding . type ; } public void generateAssignment ( BlockScope currentScope , CodeStream codeStream , Assignment assignment , boolean valueRequired ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { } public void generateCompoundAssignment ( BlockScope currentScope , CodeStream codeStream , Expression expression , int operator , int assignmentImplicitConversion , boolean valueRequired ) { } public void generateCompoundAssignment ( BlockScope currentScope , CodeStream codeStream , MethodBinding writeAccessor , Expression expression , int operator , int assignmentImplicitConversion , boolean valueRequired ) { } public void generatePostIncrement ( BlockScope currentScope , CodeStream codeStream , CompoundAssignment postIncrement , boolean valueRequired ) { } public void generateReceiver ( CodeStream codeStream ) { } public void manageEnclosingInstanceAccessIfNecessary ( BlockScope currentScope ) { } public void manageSyntheticReadAccessIfNecessary ( BlockScope currentScope ) { } public void manageSyntheticWriteAccessIfNecessary ( BlockScope currentScope ) { } public TypeBinding reportError ( BlockScope scope ) { } public TypeBinding resolveType ( BlockScope scope ) { } public String toStringExpression ( ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope scope ) { } public String unboundReferenceErrorName ( ) { } } 
public abstract class Session implements IClusterable , IEventSink { private static final long serialVersionUID = 1L ; private static final Logger log = LoggerFactory . getLogger ( Session . class ) ; public static final String SESSION_ATTRIBUTE_NAME = "session" ; private int sequence = 1 ; private int pageId = 0 ; public static boolean exists ( ) { } public static Session get ( ) { } protected ClientInfo clientInfo ; private transient boolean dirty = false ; private final FeedbackMessages feedbackMessages = new FeedbackMessages ( ) ; private String id = null ; private Locale locale ; private MetaDataEntry < ? > [ ] metaData ; private transient boolean sessionInvalidated = false ; private transient ISessionStore sessionStore ; private String style ; private transient Map < String , Serializable > temporarySessionAttributes ; public Session ( Request request ) { } public final void bind ( ) { } public abstract void cleanupFeedbackMessages ( ) { } public final void clear ( ) { } public final void error ( final String message ) { } public final Application getApplication ( ) { } public IAuthorizationStrategy getAuthorizationStrategy ( ) { } public final IClassResolver getClassResolver ( ) { } public abstract ClientInfo getClientInfo ( ) { } public final FeedbackMessages getFeedbackMessages ( ) { } public final String getId ( ) { } public Locale getLocale ( ) { } public final < M extends Serializable > M getMetaData ( final MetaDataKey < M > key ) { } protected boolean isCurrentRequestValid ( RequestCycle lockedRequestCycle ) { } public final IPageFactory getPageFactory ( ) { } public final long getSizeInBytes ( ) { } public final String getStyle ( ) { } public final void info ( final String message ) { } public void invalidate ( ) { if ( ( sessionInvalidated ) == false ) { RequestCycle . get ( ) . getListeners ( ) . add ( new AbstractRequestCycleListener ( ) { @ Override public void onDetach ( final RequestCycle cycle ) { <START_BUG> destroy ( ) ; <END_BUG> } } ) ; } sessionInvalidated = true ; } private void destroy ( ) { } public void invalidateNow ( ) { } public void replaceSession ( ) { } public final boolean isSessionInvalidated ( ) { } public final boolean isTemporary ( ) { } public final void setClientInfo ( ClientInfo clientInfo ) { } public void setLocale ( final Locale locale ) { } public final void setMetaData ( final MetaDataKey < ? > key , final Serializable object ) { } public final Session setStyle ( final String style ) { } public final void warn ( final String message ) { } private void addFeedbackMessage ( String message , int level ) { } protected void detach ( ) { } public final void dirty ( ) { } public final Serializable getAttribute ( final String name ) { } protected final List < String > getAttributeNames ( ) { } protected ISessionStore getSessionStore ( ) { } protected final void removeAttribute ( String name ) { } public final void setAttribute ( String name , Serializable value ) { } public synchronized int nextSequenceValue ( ) { } public synchronized int nextPageId ( ) { } public final IPageManager getPageManager ( ) { } public void onEvent ( IEvent < ? > event ) { } } 
public class CommitWorkingCopyOperation extends JavaModelOperation { public CommitWorkingCopyOperation ( ICompilationUnit element , boolean force ) { } protected void executeOperation ( ) throws JavaModelException { try { beginTask ( Util . bind ( "workingCopy.commit" ) , 2 ) ; CompilationUnit workingCopy = ( ( CompilationUnit ) ( getCompilationUnit ( ) ) ) ; IFile resource = ( ( IFile ) ( workingCopy . getResource ( ) ) ) ; ICompilationUnit primary = workingCopy . getPrimary ( ) ; boolean isPrimary = workingCopy . isPrimary ( ) ; JavaElementDeltaBuilder deltaBuilder = null ; PackageFragmentRoot root = ( ( PackageFragmentRoot ) ( workingCopy . getAncestor ( IJavaElement . PACKAGE_FRAGMENT_ROOT ) ) ) ; <START_BUG> if ( isPrimary || ( ( root . isOnClasspath ( ) ) && ( resource . isAccessible ( ) ) ) ) { <END_BUG> if ( ( ! isPrimary ) && ( ! ( primary . isOpen ( ) ) ) ) { primary . open ( null ) ; } if ( ( ! ( Util . isExcluded ( workingCopy ) ) ) && ( ( ! isPrimary ) || ( ! ( workingCopy . isConsistent ( ) ) ) ) ) { deltaBuilder = new JavaElementDeltaBuilder ( primary ) ; } IBuffer primaryBuffer = primary . getBuffer ( ) ; if ( ! isPrimary ) { if ( primaryBuffer == null ) return ; char [ ] primaryContents = primaryBuffer . getCharacters ( ) ; boolean hasSaved = false ; try { IBuffer workingCopyBuffer = workingCopy . getBuffer ( ) ; if ( workingCopyBuffer == null ) return ; primaryBuffer . setContents ( workingCopyBuffer . getCharacters ( ) ) ; primaryBuffer . save ( fMonitor , fForce ) ; primary . makeConsistent ( this ) ; hasSaved = true ; } finally { if ( ! hasSaved ) { primaryBuffer . setContents ( primaryContents ) ; } } } else { primaryBuffer . save ( fMonitor , fForce ) ; primary . makeConsistent ( this ) ; } } else { String encoding = workingCopy . getJavaProject ( ) . getOption ( JavaCore . CORE_ENCODING , true ) ; String contents = workingCopy . getSource ( ) ; if ( contents == null ) return ; try { byte [ ] bytes = ( encoding == null ) ? contents . getBytes ( ) : contents . getBytes ( encoding ) ; ByteArrayInputStream stream = new ByteArrayInputStream ( bytes ) ; if ( resource . exists ( ) ) { resource . setContents ( stream , ( fForce ? ( IResource . FORCE ) | ( IResource . KEEP_HISTORY ) : IResource . KEEP_HISTORY ) , null ) ; } else { resource . create ( stream , fForce , fMonitor ) ; } } catch ( CoreException e ) { throw new JavaModelException ( e ) ; } catch ( UnsupportedEncodingException e ) { throw new JavaModelException ( e , IJavaModelStatusConstants . IO_EXCEPTION ) ; } } JavaModelOperation . setAttribute ( JavaModelOperation . HAS_MODIFIED_RESOURCE_ATTR , JavaModelOperation . TRUE ) ; workingCopy . updateTimeStamp ( ( ( CompilationUnit ) ( primary ) ) ) ; workingCopy . makeConsistent ( this ) ; worked ( 1 ) ; if ( deltaBuilder != null ) { deltaBuilder . buildDeltas ( ) ; if ( ( deltaBuilder . delta ) != null ) { addDelta ( deltaBuilder . delta ) ; } } worked ( 1 ) ; } finally { done ( ) ; } } protected ICompilationUnit getCompilationUnit ( ) { } public IJavaModelStatus verify ( ) { } } 
public class Shell extends Decorations { int shellHandle ; int tooltipsHandle ; boolean mapped ; boolean moved ; boolean resized ; boolean opened ; int oldX ; int oldY ; int oldWidth ; int oldHeight ; int minWidth ; int minHeight ; Control lastActive ; Region region ; public Shell ( ) { } public Shell ( int style ) { } public Shell ( Display display ) { } public Shell ( Display display , int style ) { } Shell ( Display display , Shell parent , int style , int handle ) { } public Shell ( Shell parent ) { } public Shell ( Shell parent , int style ) { } public static Shell gtk_new ( Display display , int handle ) { } static int checkStyle ( int style ) { } public void addShellListener ( ShellListener listener ) { } void adjustTrim ( ) { } void bringToTop ( boolean force ) { if ( ! ( OS . GTK_WIDGET_VISIBLE ( shellHandle ) ) ) return ; Display display = this . display ; Shell activeShell = display . activeShell ; if ( activeShell == ( this ) ) return ; if ( ! force ) { if ( activeShell == null ) return ; int focusHandle = OS . gtk_window_get_focus ( activeShell . shellHandle ) ; if ( focusHandle != 0 ) { if ( ! ( OS . GTK_WIDGET_HAS_FOCUS ( focusHandle ) ) ) return ; } } if ( activeShell != null ) display . activeShell = null ; int window = OS . GTK_WIDGET_WINDOW ( shellHandle ) ; if ( ( ( ( style ) & ( SWT . ON_TOP ) ) != 0 ) && ( OS . GDK_WINDOWING_X11 ( ) ) ) { int xDisplay = OS . gdk_x11_drawable_get_xdisplay ( window ) ; int xWindow = OS . gdk_x11_drawable_get_xid ( window ) ; OS . gdk_error_trap_push ( ) ; OS . XSetInputFocus ( xDisplay , xWindow , RevertToParent , CurrentTime ) ; OS . gdk_error_trap_pop ( ) ; } else { <START_BUG> OS . gdk_window_focus ( window , OS . gtk_get_current_event_time ( ) ) ; <END_BUG> } display . activeShell = this ; } void checkBorder ( ) { } void checkOpen ( ) { } public void close ( ) { } void closeWidget ( ) { } public Rectangle computeTrim ( int x , int y , int width , int height ) { } void createHandle ( int index ) { } boolean hasBorder ( ) { } void hookEvents ( ) { } public boolean isEnabled ( ) { } public boolean isLayoutDeferred ( ) { } public boolean isVisible ( ) { } void register ( ) { } void releaseChild ( ) { } int topHandle ( ) { } int filterProc ( int xEvent , int gdkEvent , int data ) { } void fixShell ( Shell newShell , Control control ) { } void forceResize ( ) { } public Point getLocation ( ) { } public Point getMinimumSize ( ) { } public Point getSize ( ) { } public boolean getVisible ( ) { } public Region getRegion ( ) { } public int getImeInputMode ( ) { } Shell _getShell ( ) { } public Shell [ ] getShells ( ) { } int gtk_configure_event ( int widget , int event ) { } int gtk_delete_event ( int widget , int event ) { } int gtk_enter_notify_event ( int widget , int event ) { } int gtk_focus ( int widget , int directionType ) { } int gtk_move_focus ( int widget , int directionType ) { } int gtk_focus_in_event ( int widget , int event ) { } int gtk_focus_out_event ( int widget , int event ) { } int gtk_map_event ( int widget , int event ) { } int gtk_size_allocate ( int widget , int allocation ) { } int gtk_realize ( int widget ) { } int gtk_unmap_event ( int widget , int event ) { } int gtk_window_state_event ( int widget , int event ) { } public void open ( ) { } public void removeShellListener ( ShellListener listener ) { } public void setActive ( ) { } void setActiveControl ( Control control ) { } void resizeBounds ( int width , int height , boolean notify ) { } int setBounds ( int x , int y , int width , int height , boolean move , boolean resize ) { } void setCursor ( int cursor ) { } public void setEnabled ( boolean enabled ) { } public void setImeInputMode ( int mode ) { } void setInitialBounds ( ) { } public void setMaximized ( boolean maximized ) { } public void setMenuBar ( Menu menu ) { } public void setMinimized ( boolean minimized ) { } public void setMinimumSize ( int width , int height ) { } public void setMinimumSize ( Point size ) { } public void setRegion ( Region region ) { } public void setText ( String string ) { } public void setVisible ( boolean visible ) { } void setZOrder ( Control sibling , boolean above ) { } int shellMapProc ( int handle , int arg0 , int user_data ) { } void showWidget ( ) { } boolean traverseEscape ( ) { } int trimHeight ( ) { } int trimWidth ( ) { } void deregister ( ) { } public void dispose ( ) { } public void forceActive ( ) { } public Rectangle getBounds ( ) { } void releaseHandle ( ) { } void releaseShells ( ) { } void releaseWidget ( ) { } void setToolTipText ( int widget , String string ) { } } 
public class HostControllerBootstrap { private static final Logger log = Logger . getLogger ( "org.jboss.as.host.controller" ) ; static final ServiceName SERVICE_NAME_BASE = JBOSS . append ( "host" , "controller" ) ; static final int DEFAULT_POOL_SIZE = 20 ; private final ServiceContainer serviceContainer = Factory . create ( "host-controller" ) ; private final HostControllerEnvironment environment ; private final byte [ ] authCode ; public HostControllerBootstrap ( final HostControllerEnvironment environment , final byte [ ] authCode ) { } public void start ( ) throws Exception { final File configDir = environment . getDomainConfigurationDir ( ) ; final ConfigurationFile configurationFile = environment . getHostConfigurationFile ( ) ; final ExtensibleConfigurationPersister configurationPersister = HostControllerBootstrap . createHostConfigurationPersister ( configDir , configurationFile ) ; final List < ModelNode > operations = configurationPersister . load ( ) ; final ServiceTarget serviceTarget = serviceContainer ; serviceTarget . addListener ( new org . jboss . msc . service . AbstractServiceListener < Object > ( ) { @ Override public void transition ( final ServiceController < ? extends Object > controller , final ServiceController . Transition transition ) { if ( transition == ( Transition . STARTING_to_START_FAILED ) ) { HostControllerBootstrap . log . errorf ( controller . getStartException ( ) , "Service<seq2seq4repair_space>[%s]<seq2seq4repair_space>failed." , controller . getName ( ) ) ; } } } ) ; registerBaseServices ( serviceTarget ) ; HostControllerBootstrap . DomainModelProxyImpl domainModelProxy = new HostControllerBootstrap . DomainModelProxyImpl ( ) ; final ModelNodeRegistration hostRegistry = HostModelUtil . createHostRegistry ( configurationPersister , environment , domainModelProxy ) ; final ModelNodeRegistration rootRegistration = HostModelUtil . createBootstrapHostRegistry ( hostRegistry , domainModelProxy ) ; DomainModelImpl domainModel = new DomainModelImpl ( rootRegistration , serviceContainer , configurationPersister ) ; domainModelProxy . setDomainModel ( domainModel ) ; final AtomicInteger count = new AtomicInteger ( 1 ) ; final ResultHandler resultHandler = new ResultHandler ( ) { @ Override public void handleResultFragment ( final String [ ] location , final ModelNode result ) { } @ Override public void handleResultComplete ( ) { if ( ( count . decrementAndGet ( ) ) == 0 ) { } } @ Override public void handleFailed ( final ModelNode failureDescription ) { if ( ( count . decrementAndGet ( ) ) == 0 ) { } } @ Override public void handleCancellation ( ) { if ( ( count . decrementAndGet ( ) ) == 0 ) { } } } ; for ( final ModelNode operation : operations ) { count . incrementAndGet ( ) ; operation . get ( OPERATION_HEADERS , ROLLBACK_ON_RUNTIME_FAILURE ) . set ( false ) ; domainModel . execute ( OperationBuilder . Factory . create ( operation ) . build ( ) , resultHandler ) ; } if ( ( count . decrementAndGet ( ) ) == 0 ) { } final String hostName = domainModel . getLocalHostName ( ) ; final ModelNode hostModelNode = domainModel . getHostModel ( ) ; final String mgmtNetwork = hostModelNode . get ( MANAGEMENT_INTERFACE , NATIVE_INTERFACE , INTERFACE ) . asString ( ) ; final int mgmtPort = hostModelNode . get ( MANAGEMENT_INTERFACE , NATIVE_INTERFACE , PORT ) . asInt ( ) ; final ServerInventoryService inventory = new ServerInventoryService ( environment , mgmtPort ) ; serviceTarget . addService ( SERVICE_NAME , inventory ) . addDependency ( ProcessControllerConnectionService . SERVICE_NAME , ProcessControllerConnectionService . class , inventory . getClient ( ) ) . addDependency ( JBOSS_NETWORK_INTERFACE . append ( mgmtNetwork ) , NetworkInterfaceBinding . class , inventory . getInterface ( ) ) . install ( ) ; final HostControllerService hc = new HostControllerService ( hostName , hostModelNode , configurationPersister , hostRegistry ) ; serviceTarget . addService ( HostController . SERVICE_NAME , hc ) . addDependency ( SERVICE_NAME , ServerInventory . class , hc . getServerInventory ( ) ) . addDependency ( ServerToHostOperationHandler . SERVICE_NAME ) . setInitialMode ( ACTIVE ) . install ( ) ; final ServerToHostOperationHandler serverToHost = new ServerToHostOperationHandler ( ) ; serviceTarget . addService ( ServerToHostOperationHandler . SERVICE_NAME , serverToHost ) . addDependency ( SERVICE_NAME , ManagedServerLifecycleCallback . class , serverToHost . getCallbackInjector ( ) ) . install ( ) ; <START_BUG> RemotingServices . installChannelOpenListenerService ( serviceTarget , "server" , ServerToHostOperationHandler . SERVICE_NAME , null ) ; <END_BUG> } private void registerBaseServices ( final ServiceTarget serviceTarget ) { } static ExtensibleConfigurationPersister createHostConfigurationPersister ( final File configDir , final ConfigurationFile configurationFile ) { } static final class HostControllerExecutorService implements Service < Executor > { final InjectedValue < ThreadFactory > threadFactoryValue = new InjectedValue < ThreadFactory > ( ) ; private ScheduledExecutorService executorService ; @ Override public synchronized void start ( final StartContext context ) throws StartException { } @ Override public synchronized void stop ( final StopContext context ) { } @ Override public synchronized ScheduledExecutorService getValue ( ) throws IllegalStateException { } } static final class DomainModelProxyImpl implements DomainModelProxy { private DomainModelImpl domainModel ; public void setDomainModel ( final DomainModelImpl domainModel ) { } @ Override public DomainModelImpl getDomainModel ( ) { } } } 
public abstract class FilteredPreferenceDialog extends PreferenceDialog { protected TreeViewer filteredViewer ; protected TreeViewer unfilteredViewer ; private StackLayout stackLayout ; private Composite stackComposite ; private Button showAllCheck ; public FilteredPreferenceDialog ( Shell parentShell , PreferenceManager manager ) { } protected Control createTreeAreaContents ( Composite composite ) { Composite treeArea = new Composite ( composite , SWT . None ) ; GridLayout layout = new GridLayout ( ) ; layout . marginHeight = 0 ; layout . marginWidth = 0 ; treeArea . setLayout ( layout ) ; stackComposite = new Composite ( treeArea , SWT . NONE ) ; stackLayout = new StackLayout ( ) ; stackComposite . setLayout ( stackLayout ) ; stackComposite . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; stackComposite . setFont ( composite . getFont ( ) ) ; layoutTreeAreaControl ( treeArea ) ; filteredViewer = createTreeViewer ( stackComposite , true ) ; if ( WorkbenchActivityHelper . showAll ( ) ) { unfilteredViewer = createTreeViewer ( stackComposite , false ) ; showAllCheck = new Button ( treeArea , SWT . CHECK ) ; showAllCheck . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; showAllCheck . setText ( ActivityMessages . getString ( "ActivityFiltering.showAll" ) ) ; showAllCheck . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { if ( ! ( showAllCheck . getSelection ( ) ) ) { filteredViewer . setExpandedElements ( unfilteredViewer . getExpandedElements ( ) ) ; filteredViewer . setSelection ( unfilteredViewer . getSelection ( ) ) ; stackLayout . topControl = filteredViewer . getControl ( ) ; stackComposite . layout ( ) ; showPage ( getSingleSelection ( filteredViewer . getSelection ( ) ) ) ; } else { unfilteredViewer . setExpandedElements ( filteredViewer . getExpandedElements ( ) ) ; unfilteredViewer . setSelection ( filteredViewer . getSelection ( ) ) ; stackLayout . topControl = unfilteredViewer . getControl ( ) ; stackComposite . layout ( ) ; showPage ( getSingleSelection ( unfilteredViewer . getSelection ( ) ) ) ; } } } ) ; } stackLayout . topControl = filteredViewer . getControl ( ) ; <START_BUG> return stackComposite ; <END_BUG> } private TreeViewer createTreeViewer ( Composite parent , boolean filtering ) { } protected IPreferenceNode findNodeMatching ( String nodeId ) { } protected TreeViewer getTreeViewer ( ) { } protected void updateTreeFont ( Font dialogFont ) { } } 
public class HashCodeBuilder implements Builder < Integer > { private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) ; static Set < IDKey > getRegistry ( ) { } static boolean isRegistered ( Object value ) { } private static void reflectionAppend ( Object object , Class < ? > clazz , HashCodeBuilder builder , boolean useTransients , String [ ] excludeFields ) { } public static int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , Object object ) { } public static int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , Object object , boolean testTransients ) { } public static < T > int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , T object , boolean testTransients , Class < ? super T > reflectUpToClass ) { } public static < T > int reflectionHashCode ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber , T object , boolean testTransients , Class < ? super T > reflectUpToClass , String [ ] excludeFields ) { } public static int reflectionHashCode ( Object object ) { } public static int reflectionHashCode ( Object object , boolean testTransients ) { } public static int reflectionHashCode ( Object object , Collection < String > excludeFields ) { } public static int reflectionHashCode ( Object object , String [ ] excludeFields ) { } static void register ( Object value ) { } static void unregister ( Object value ) { } private final int iConstant ; private int iTotal = 0 ; public HashCodeBuilder ( ) { } public HashCodeBuilder ( int initialNonZeroOddNumber , int multiplierNonZeroOddNumber ) { } public HashCodeBuilder append ( boolean value ) { } public HashCodeBuilder append ( boolean [ ] array ) { } public HashCodeBuilder append ( byte value ) { } public HashCodeBuilder append ( byte [ ] array ) { } public HashCodeBuilder append ( char value ) { } public HashCodeBuilder append ( char [ ] array ) { } public HashCodeBuilder append ( double value ) { } public HashCodeBuilder append ( double [ ] array ) { } public HashCodeBuilder append ( float value ) { } public HashCodeBuilder append ( float [ ] array ) { } public HashCodeBuilder append ( int value ) { } public HashCodeBuilder append ( int [ ] array ) { } public HashCodeBuilder append ( long value ) { } public HashCodeBuilder append ( long [ ] array ) { } public HashCodeBuilder append ( Object object ) { } public HashCodeBuilder append ( Object [ ] array ) { } public HashCodeBuilder append ( short value ) { } public HashCodeBuilder append ( short [ ] array ) { } public HashCodeBuilder appendSuper ( int superHashCode ) { } public int toHashCode ( ) { } public Integer build ( ) { <START_BUG> return toHashCode ( ) ; <END_BUG> } @ Override public int hashCode ( ) { } } 
public class ManagedBeanDependencyProcessor implements DeploymentUnitProcessor { private static final DotName MANAGED_BEAN_ANNOTATION_NAME = DotName . createSimple ( ManagedBean . class . getName ( ) ) ; private static final ModuleIdentifier JAVASSIST_ID = ModuleIdentifier . create ( "org.javassist" ) ; private static ModuleIdentifier JAVAEE_API_ID = ModuleIdentifier . create ( "javaee.api" ) ; private static ModuleIdentifier JBOSS_LOGGING_ID = ModuleIdentifier . create ( "org.jboss.logging" ) ; public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final Index index = phaseContext . getAttachment ( ANNOTATION_INDEX ) ; if ( index == null ) { return ; } <START_BUG> if ( ( index . getAnnotationTargets ( ManagedBeanDependencyProcessor . MANAGED_BEAN_ANNOTATION_NAME ) ) == null ) { <END_BUG> return ; } phaseContext . addToAttachmentList ( MODULE_DEPENDENCIES , new org . jboss . as . deployment . module . ModuleDependency ( ManagedBeanDependencyProcessor . JAVAEE_API_ID , false , false ) ) ; phaseContext . addToAttachmentList ( MODULE_DEPENDENCIES , new org . jboss . as . deployment . module . ModuleDependency ( ManagedBeanDependencyProcessor . JBOSS_LOGGING_ID , false , false ) ) ; phaseContext . addToAttachmentList ( MODULE_DEPENDENCIES , new org . jboss . as . deployment . module . ModuleDependency ( ManagedBeanDependencyProcessor . JAVASSIST_ID , false , false ) ) ; } public void undeploy ( final DeploymentUnitContext context ) { } } 
@ RunWith ( Arquillian . class ) @ RunAsClient public class EJBClientClusterConfigurationTestCase { private static final Logger logger = Logger . getLogger ( EJBClientClusterConfigurationTestCase . class ) ; private static final String MODULE_NAME = "server-to-server-clustered-ejb-invocation" ; private static final String DEFAULT_JBOSSAS = "default-jbossas" ; private static final String JBOSSAS_WITH_REMOTE_OUTBOUND_CONNECTION = "jbossas-with-remote-outbound-connection" ; private static final String DEFAULT_AS_DEPLOYMENT = "default-jbossas-deployment" ; private static final String DEPLOYMENT_WITH_JBOSS_EJB_CLIENT_XML = "other-deployment" ; private static final String DEFAULT_JBOSSAS_NODE_NAME = "default-jbossas" ; private static final String JBOSSAS_WITH_OUTBOUND_CONNECTION_NODE_NAME = "jbossas-with-remote-outbound-connection" ; @ ArquillianResource private ContainerController container ; @ ArquillianResource private Deployer deployer ; private static Context context ; private static ContextSelector < EJBClientContext > previousClientContextSelector ; @ BeforeClass public static void beforeClass ( ) throws Exception { } @ AfterClass public static void afterClass ( ) { } @ Deployment ( name = EJBClientClusterConfigurationTestCase . DEFAULT_AS_DEPLOYMENT , managed = false , testable = false ) @ TargetsContainer ( EJBClientClusterConfigurationTestCase . DEFAULT_JBOSSAS ) public static Archive createContainer1Deployment ( ) { } @ Deployment ( name = EJBClientClusterConfigurationTestCase . DEPLOYMENT_WITH_JBOSS_EJB_CLIENT_XML , managed = false , testable = false ) @ TargetsContainer ( EJBClientClusterConfigurationTestCase . JBOSSAS_WITH_REMOTE_OUTBOUND_CONNECTION ) public static Archive createContainer2Deployment ( ) { final JavaArchive ejbJar = ShrinkWrap . create ( JavaArchive . class , ( ( EJBClientClusterConfigurationTestCase . MODULE_NAME ) + ".jar" ) ) ; <START_BUG> ejbJar . addClasses ( ClusteredStatefulNodeNameEcho . class , NonClusteredStatefulNodeNameEcho . class , NodeNameEcho . class ) ; <END_BUG> ejbJar . addAsManifestResource ( NonClusteredStatefulNodeNameEcho . class . getPackage ( ) , "jboss-ejb-client.xml" , "jboss-ejb-client.xml" ) ; return ejbJar ; } @ Test public void testServerToServerClusterFormation ( ) throws Exception { } private static ContextSelector < EJBClientContext > setupEJBClientContextSelector ( ) throws IOException { } } 
public final class SingleMemberAnnotation extends Annotation { public static final ChildPropertyDescriptor TYPE_NAME_PROPERTY = Annotation . internalTypeNamePropertyFactory ( SingleMemberAnnotation . class ) ; public static final ChildPropertyDescriptor VALUE_PROPERTY = new ChildPropertyDescriptor ( SingleMemberAnnotation . class , "value" , Expression . class , ASTNode . MANDATORY , ASTNode . CYCLE_RISK ) ; private static final List PROPERTY_DESCRIPTORS ; public static List propertyDescriptors ( int apiLevel ) { } private Expression value = null ; SingleMemberAnnotation ( AST ast ) { } final List internalStructuralPropertiesForType ( int apiLevel ) { } final ASTNode internalGetSetChildProperty ( ChildPropertyDescriptor property , boolean get , ASTNode child ) { } final ChildPropertyDescriptor internalTypeNameProperty ( ) { } final int getNodeType0 ( ) { } ASTNode clone0 ( AST target ) { SingleMemberAnnotation result = new SingleMemberAnnotation ( target ) ; <START_BUG> result . setSourceRange ( this . getStartPosition ( ) , this . getLength ( ) ) ; <END_BUG> result . setTypeName ( ( ( Name ) ( ASTNode . copySubtree ( target , getTypeName ( ) ) ) ) ) ; result . setValue ( ( ( Expression ) ( ASTNode . copySubtree ( target , getValue ( ) ) ) ) ) ; return result ; } final boolean subtreeMatch0 ( ASTMatcher matcher , Object other ) { } void accept0 ( ASTVisitor visitor ) { } public Expression getValue ( ) { } public void setValue ( Expression value ) { } int memSize ( ) { } int treeSize ( ) { } } 
public class BindingTypePattern extends ExactTypePattern implements BindingPattern { private int formalIndex ; public BindingTypePattern ( TypeX type , int index , boolean isVarArgs ) { } public BindingTypePattern ( FormalBinding binding , boolean isVarArgs ) { } public int getFormalIndex ( ) { } public boolean equals ( Object other ) { } public int hashCode ( ) { } public void write ( DataOutputStream out ) throws IOException { } public static TypePattern read ( DataInputStream s , ISourceContext context ) throws IOException { } public TypePattern remapAdviceFormals ( IntMap bindings ) { } public String toString ( ) { <START_BUG> return ( ( ( "BindingTypePattern(" + ( type . toString ( ) ) ) + ",<seq2seq4repair_space>" ) + ( formalIndex ) ) + ")" ; <END_BUG> } } 
public class DeleteResourceElementsOperation extends MultiOperation { protected DeleteResourceElementsOperation ( IJavaElement [ ] elementsToProcess , boolean force ) { } private void deletePackageFragment ( IPackageFragment frag ) throws JavaModelException { IResource res = frag . getResource ( ) ; if ( ( res != null ) && ( ( res . getType ( ) ) == ( IResource . FOLDER ) ) ) { IJavaElement [ ] childrenOfInterest = frag . getChildren ( ) ; if ( ( childrenOfInterest . length ) > 0 ) { IResource [ ] resources = new IResource [ childrenOfInterest . length ] ; for ( int i = 0 ; i < ( childrenOfInterest . length ) ; i ++ ) { <START_BUG> resources [ i ] = childrenOfInterest [ i ] . getCorrespondingResource ( ) ; <END_BUG> } deleteResources ( resources , fForce ) ; } Object [ ] nonJavaResources = frag . getNonJavaResources ( ) ; int actualResourceCount = 0 ; for ( int i = 0 , max = nonJavaResources . length ; i < max ; i ++ ) { if ( ( nonJavaResources [ i ] ) instanceof IResource ) actualResourceCount ++ ; } IResource [ ] actualNonJavaResources = new IResource [ actualResourceCount ] ; for ( int i = 0 , max = nonJavaResources . length , index = 0 ; i < max ; i ++ ) { if ( ( nonJavaResources [ i ] ) instanceof IResource ) actualNonJavaResources [ ( index ++ ) ] = ( ( IResource ) ( nonJavaResources [ i ] ) ) ; } deleteResources ( actualNonJavaResources , fForce ) ; IResource [ ] remainingFiles ; try { remainingFiles = ( ( IFolder ) ( res ) ) . members ( ) ; } catch ( CoreException ce ) { throw new JavaModelException ( ce ) ; } boolean isEmpty = true ; for ( int i = 0 , length = remainingFiles . length ; i < length ; i ++ ) { IResource file = remainingFiles [ i ] ; if ( file instanceof IFile ) { this . deleteResource ( file , ( ( IResource . FORCE ) | ( IResource . KEEP_HISTORY ) ) ) ; } else { isEmpty = false ; } } if ( isEmpty ) { deleteEmptyPackageFragment ( frag , false , frag . getParent ( ) . getResource ( ) ) ; } } } protected String getMainTaskName ( ) { } protected void processElement ( IJavaElement element ) throws JavaModelException { } protected void verify ( IJavaElement element ) throws JavaModelException { } } 
public class PackageTest extends JMeterTestCase { private static final transient Logger log = LoggingManager . getLoggerForClass ( ) ; public PackageTest ( String arg0 ) { } private static CSVRead setParams ( String p1 , String p2 ) throws Exception { } private static StringFromFile SFFParams ( String p1 , String p2 , String p3 , String p4 ) throws Exception { } private static SplitFunction SplitParams ( String p1 , String p2 , String p3 ) throws Exception { } private static BeanShell BSHFParams ( String p1 , String p2 , String p3 ) throws Exception { } private static Collection MakeParams ( String p1 , String p2 , String p3 ) { } public static Test suite ( ) throws Exception { <START_BUG> TestSuite allsuites = new TestSuite ( ) ; <END_BUG> TestSuite bsh = new TestSuite ( "BeanShell" ) ; bsh . addTest ( new PackageTest ( "BSH1" ) ) ; allsuites . addTest ( bsh ) ; TestSuite suite = new TestSuite ( "SingleThreaded" ) ; suite . addTest ( new PackageTest ( "CSVParams" ) ) ; suite . addTest ( new PackageTest ( "CSVNoFile" ) ) ; suite . addTest ( new PackageTest ( "CSVSetup" ) ) ; suite . addTest ( new PackageTest ( "CSVRun" ) ) ; suite . addTest ( new PackageTest ( "CSValias" ) ) ; suite . addTest ( new PackageTest ( "CSVBlankLine" ) ) ; allsuites . addTest ( suite ) ; suite . addTest ( new PackageTest ( "CSVSetup" ) ) ; TestSuite par = new ActiveTestSuite ( "Parallel" ) ; par . addTest ( new PackageTest ( "CSVThread1" ) ) ; par . addTest ( new PackageTest ( "CSVThread2" ) ) ; allsuites . addTest ( par ) ; TestSuite sff = new TestSuite ( "StringFromFile" ) ; sff . addTest ( new PackageTest ( "SFFTest1" ) ) ; sff . addTest ( new PackageTest ( "SFFTest2" ) ) ; sff . addTest ( new PackageTest ( "SFFTest3" ) ) ; sff . addTest ( new PackageTest ( "SFFTest4" ) ) ; sff . addTest ( new PackageTest ( "SFFTest5" ) ) ; allsuites . addTest ( sff ) ; TestSuite split = new TestSuite ( "SplitFunction" ) ; split . addTest ( new PackageTest ( "SplitTest1" ) ) ; allsuites . addTest ( split ) ; TestSuite xpath = new TestSuite ( "XPath" ) ; xpath . addTest ( new PackageTest ( "XPathtestColumns" ) ) ; xpath . addTest ( new PackageTest ( "XPathtestDefault" ) ) ; xpath . addTest ( new PackageTest ( "XPathtestNull" ) ) ; xpath . addTest ( new PackageTest ( "XPathtestrowNum" ) ) ; xpath . addTest ( new PackageTest ( "XPathEmpty" ) ) ; xpath . addTest ( new PackageTest ( "XPathFile1" ) ) ; xpath . addTest ( new PackageTest ( "XPathFile2" ) ) ; xpath . addTest ( new PackageTest ( "XPathNoFile" ) ) ; allsuites . addTest ( xpath ) ; TestSuite random = new TestSuite ( "Random" ) ; random . addTest ( new PackageTest ( "RandomTest1" ) ) ; allsuites . addTest ( random ) ; allsuites . addTest ( new PackageTest ( "XPathSetup1" ) ) ; TestSuite par2 = new ActiveTestSuite ( "ParallelXPath1" ) ; par2 . addTest ( new PackageTest ( "XPathThread1" ) ) ; par2 . addTest ( new PackageTest ( "XPathThread2" ) ) ; allsuites . addTest ( par2 ) ; allsuites . addTest ( new PackageTest ( "XPathSetup2" ) ) ; TestSuite par3 = new ActiveTestSuite ( "ParallelXPath2" ) ; par3 . addTest ( new PackageTest ( "XPathThread1" ) ) ; par3 . addTest ( new PackageTest ( "XPathThread2" ) ) ; allsuites . addTest ( par3 ) ; return allsuites ; } private JMeterContext jmctx = null ; private JMeterVariables vars = null ; public void setUp ( ) { } public void BSH1 ( ) throws Exception { } public void SplitTest1 ( ) throws Exception { } public void SFFTest1 ( ) throws Exception { } public void SFFTest2 ( ) throws Exception { } public void SFFTest3 ( ) throws Exception { } public void SFFTest4 ( ) throws Exception { } public void SFFTest5 ( ) throws Exception { } private static CSVRead cr1 ; private static CSVRead cr2 ; private static CSVRead cr3 ; private static CSVRead cr4 ; private static CSVRead cr5 ; private static CSVRead cr6 ; private static class Baton { void pass ( ) { } void done ( ) { } } private static PackageTest . Baton baton = new PackageTest . Baton ( ) ; public void CSVThread1 ( ) throws Exception { } public void CSVThread2 ( ) throws Exception { } public void CSVRun ( ) throws Exception { } public void CSVParams ( ) throws Exception { } public void CSVSetup ( ) throws Exception { } public void CSValias ( ) throws Exception { } public void CSVNoFile ( ) throws Exception { } public void CSVBlankLine ( ) throws Exception { } public void XPathtestNull ( ) throws Exception { } public void XPathtestrowNum ( ) throws Exception { } public void XPathtestColumns ( ) throws Exception { } public void XPathtestDefault ( ) throws Exception { } public void XPathEmpty ( ) throws Exception { } public void XPathNoFile ( ) throws Exception { } public void XPathFile1 ( ) throws Exception { } public void XPathFile2 ( ) throws Exception { } private static XPath sxp1 ; private static XPath sxp2 ; public void XPathSetup1 ( ) throws Exception { } public void XPathSetup2 ( ) throws Exception { } public void XPathThread1 ( ) throws Exception { } public void XPathThread2 ( ) throws Exception { } private XPath setupXPath ( String file , String expr ) throws Exception { } public void RandomTest1 ( ) throws Exception { } } 
public abstract class RequestCycle { private static final ThreadLocal current = new ThreadLocal ( ) ; private static final int DETACH_REQUEST = 6 ; private static final int DONE = 7 ; private static final int HANDLE_EXCEPTION = 5 ; private static final Logger log = LoggerFactory . getLogger ( RequestCycle . class ) ; private static final int NOT_STARTED = 0 ; private static final int PREPARE_REQUEST = 1 ; private static final int PROCESS_EVENTS = 3 ; private static final int RESOLVE_TARGET = 2 ; private static final int RESPOND = 4 ; public static RequestCycle get ( ) { } protected static void set ( RequestCycle cycle ) { } private boolean automaticallyClearFeedbackMessages = true ; private int currentStep = RequestCycle . NOT_STARTED ; private final Response originalResponse ; private boolean redirect ; private final transient ArrayListStack requestTargets = new ArrayListStack ( 3 ) ; private PageParameters pageParameters ; private Session session ; private final long startTime = System . currentTimeMillis ( ) ; protected final Application application ; protected final IRequestCycleProcessor processor ; protected Request request ; protected Response response ; protected RequestCycle ( final Application application , final Request request , final Response response ) { } public final Application getApplication ( ) { } public final ClientInfo getClientInfo ( ) { } public final Response getOriginalResponse ( ) { } public final PageParameters getPageParameters ( ) { } public abstract IRequestCycleProcessor getProcessor ( ) { } public final boolean getRedirect ( ) { } public final Request getRequest ( ) { } public final IRequestTarget getRequestTarget ( ) { } public final Response getResponse ( ) { } public final Page getResponsePage ( ) { } public final Class getResponsePageClass ( ) { } public final Session getSession ( ) { } public final long getStartTime ( ) { } public boolean isRedirect ( ) { } public Page onRuntimeException ( Page page , RuntimeException e ) { } public abstract void redirectTo ( final Page page ) { } public final void request ( ) { } public final void request ( final Component component ) { } public final void request ( IRequestTarget target ) { } public void setAutomaticallyClearFeedbackMessages ( boolean automaticallyClearFeedbackMessages ) { } public final void setRedirect ( final boolean redirect ) { } public final void setRequest ( Request request ) { } public final void setRequestTarget ( IRequestTarget requestTarget ) { } public final Response setResponse ( final Response response ) { } public final void setResponsePage ( final Class pageClass ) { } public final void setResponsePage ( final Class pageClass , final PageParameters pageParameters ) { } public final void setResponsePage ( final Page page ) { } public String toString ( ) { } public final CharSequence urlFor ( final Class pageClass , final PageParameters parameters ) { } public final CharSequence urlFor ( final Component component , final IBehavior behaviour , final RequestListenerInterface listener ) { } public final CharSequence urlFor ( final Component component , final RequestListenerInterface listener ) { } public final CharSequence urlFor ( final IPageMap pageMap , final Class pageClass , final PageParameters parameters ) { } public final CharSequence urlFor ( final IRequestTarget requestTarget ) { } public final CharSequence urlFor ( final Page page ) { } public final CharSequence urlFor ( final ResourceReference resourceReference ) { } public final CharSequence urlFor ( final ResourceReference resourceReference , ValueMap parameters ) { } private void checkReuse ( ) { } private void detach ( ) { } private void prepare ( ) { } private final void processEventsAndRespond ( ) { } private final void respond ( ) { } private final IRequestCycleProcessor safeGetRequestProcessor ( ) { } private boolean sessionExists ( ) { } private final void step ( ) { } private final void steps ( ) { try { IRequestCycleProcessor processor = safeGetRequestProcessor ( ) ; <START_BUG> final int maxSteps = Short . MAX_VALUE ; <END_BUG> for ( int totalSteps = 0 ; ( currentStep ) < ( RequestCycle . DONE ) ; totalSteps ++ ) { if ( totalSteps >= maxSteps ) { throw new IllegalStateException ( ( ( "Request<seq2seq4repair_space>processing<seq2seq4repair_space>executed<seq2seq4repair_space>" + maxSteps ) + "<seq2seq4repair_space>steps,<seq2seq4repair_space>which<seq2seq4repair_space>means<seq2seq4repair_space>it<seq2seq4repair_space>is<seq2seq4repair_space>probably<seq2seq4repair_space>in<seq2seq4repair_space>an<seq2seq4repair_space>infinite<seq2seq4repair_space>loop." ) ) ; } try { step ( ) ; ( currentStep ) ++ ; } catch ( AbstractRestartResponseException e ) { currentStep = RequestCycle . RESPOND ; } } } finally { currentStep = RequestCycle . DETACH_REQUEST ; detach ( ) ; currentStep = RequestCycle . DONE ; } } private final void threadDetach ( ) { } final void setPageParameters ( PageParameters parameters ) { } protected void logRuntimeException ( RuntimeException e ) { } protected abstract ClientInfo newClientInfo ( ) { } protected void onBeginRequest ( ) { } protected void onEndRequest ( ) { } } 
public class LocalEjbReceiver extends EJBReceiver implements RegistryCollector . Listener < String , List < ClientMapping > > , Service < LocalEjbReceiver > { public static final ServiceName DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME = JBOSS . append ( "ejb" ) . append ( "default-local-ejb-receiver-service" ) ; public static final ServiceName BY_VALUE_SERVICE_NAME = JBOSS . append ( "ejb3" , "localEjbReceiver" , "value" ) ; public static final ServiceName BY_REFERENCE_SERVICE_NAME = JBOSS . append ( "ejb3" , "localEjbReceiver" , "reference" ) ; private static final Object [ ] EMPTY_OBJECT_ARRAY = new Object [ ] { } ; private final List < EJBReceiverContext > contexts = new CopyOnWriteArrayList < EJBReceiverContext > ( ) ; private final InjectedValue < DeploymentRepository > deploymentRepository = new InjectedValue < DeploymentRepository > ( ) ; @ SuppressWarnings ( "rawtypes" ) private final InjectedValue < RegistryCollector > clusterRegistryCollector = new InjectedValue < RegistryCollector > ( ) ; private final LocalEjbReceiver . Listener deploymentListener = new LocalEjbReceiver . Listener ( ) ; private final boolean allowPassByReference ; public LocalEjbReceiver ( final String nodeName , final boolean allowPassByReference ) { } @ Override protected void associate ( final EJBReceiverContext context ) { } @ Override protected void processInvocation ( final EJBClientInvocationContext invocation , final EJBReceiverInvocationContext receiverContext ) throws Exception { } @ Override protected < T > StatefulEJBLocator < T > openSession ( EJBReceiverContext context , Class < T > viewType , String appName , String moduleName , String distinctName , String beanName ) throws IllegalArgumentException { final EjbDeploymentInformation ejbInfo = findBean ( appName , moduleName , distinctName , beanName ) ; final EJBComponent component = ejbInfo . getEjbComponent ( ) ; if ( ! ( component instanceof StatefulSessionComponent ) ) { throw new IllegalArgumentException ( ( ( ( ( ( ( ( "EJB<seq2seq4repair_space>" + beanName ) + "<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>a<seq2seq4repair_space>Stateful<seq2seq4repair_space>Session<seq2seq4repair_space>bean<seq2seq4repair_space>in<seq2seq4repair_space>app:<seq2seq4repair_space>" ) + appName ) + "<seq2seq4repair_space>module:<seq2seq4repair_space>" ) + moduleName ) + "<seq2seq4repair_space>distinct<seq2seq4repair_space>name:" ) + distinctName ) ) ; } final StatefulSessionComponent statefulComponent = ( ( StatefulSessionComponent ) ( component ) ) ; final SessionID sessionID = statefulComponent . createSession ( ) ; <START_BUG> return new StatefulEJBLocator < T > ( viewType , appName , moduleName , beanName , distinctName , sessionID , statefulComponent . getCache ( ) . getStrictAffinity ( ) ) ; <END_BUG> } private Object clone ( final Class < ? > target , final ObjectCloner cloner , final Object object , final boolean allowPassByReference ) { } private Object clone ( final ObjectCloner cloner , final Object object ) { } @ Override protected boolean exists ( final String appName , final String moduleName , final String distinctName , final String beanName ) { } @ Override protected int sendPrepare ( EJBReceiverContext context , TransactionID transactionID ) throws XAException { } @ Override protected void sendCommit ( EJBReceiverContext context , TransactionID transactionID , boolean onePhase ) throws XAException { } @ Override protected void sendRollback ( EJBReceiverContext context , TransactionID transactionID ) throws XAException { } @ Override protected void sendForget ( EJBReceiverContext context , TransactionID transactionID ) throws XAException { } @ Override protected void beforeCompletion ( EJBReceiverContext context , TransactionID transactionID ) { } private EjbDeploymentInformation findBean ( final String appName , final String moduleName , final String distinctName , final String beanName ) { } @ Override public void start ( final StartContext context ) throws StartException { } @ Override public void stop ( final StopContext context ) { } @ Override public LocalEjbReceiver getValue ( ) throws IllegalArgumentException , IllegalStateException { } public InjectedValue < DeploymentRepository > getDeploymentRepository ( ) { } @ Override public void registryAdded ( Registry < String , List < ClientMapping > > registry ) { } @ Override public void registryRemoved ( Registry < String , List < ClientMapping > > registry ) { } @ SuppressWarnings ( "rawtypes" ) public Injector < RegistryCollector > getClusterRegistryCollectorInjector ( ) { } private static class ImmediateResultProducer implements EJBReceiverInvocationContext . ResultProducer { private final Object clonedResult ; public ImmediateResultProducer ( final Object clonedResult ) { } @ Override public Object getResult ( ) throws Exception { } @ Override public void discardResult ( ) { } } private class Listener implements DeploymentRepositoryListener { @ Override public void listenerAdded ( final DeploymentRepository repository ) { } @ Override public void deploymentAvailable ( final DeploymentModuleIdentifier deployment , final ModuleDeployment moduleDeployment ) { } @ Override public void deploymentRemoved ( final DeploymentModuleIdentifier deployment ) { } } private class LocalClusterNodeManager implements ClusterNodeManager { @ Override public String getNodeName ( ) { } @ Override public EJBReceiver getEJBReceiver ( ) { } } } 
public class SystemMenuSizeFastView extends ContributionItem { private FastViewPane fastViewPane ; public SystemMenuSizeFastView ( FastViewPane fastViewPane ) { } public void dispose ( ) { } public void fill ( Menu menu , int index ) { <START_BUG> MenuItem item = new MenuItem ( menu , SWT . NONE ) ; <END_BUG> item . setText ( WorkbenchMessages . getString ( "PartPane.size" ) ) ; item . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { fastViewPane . moveSash ( ) ; } } ) ; item . setEnabled ( ( ( fastViewPane . getCurrentPane ( ) ) != null ) ) ; } public boolean isDynamic ( ) { } } 
public class ComplexPropertiesParseUtils { public static Properties commonDsProperties ( String jndiName ) { } public static Properties xaDsProperties ( String jndiName ) { } public static Properties nonXaDsProperties ( String jndiName ) { } public static Properties raCommonProperties ( ) { } public static Properties raConnectionProperties ( ) { Properties params = new Properties ( ) ; params . put ( "use-java-context" , "false" ) ; params . put ( "class-name" , "Class1" ) ; params . put ( "use-ccm" , "true" ) ; params . put ( "jndi-name" , "java:jboss/name1" ) ; params . put ( "enabled" , "false" ) ; params . put ( "min-pool-size" , "1" ) ; params . put ( "max-pool-size" , "5" ) ; params . put ( "pool-prefill" , "true" ) ; params . put ( "pool-use-strict-min" , "true" ) ; params . put ( "flush-strategy" , "IdleConnections" ) ; params . put ( "same-rm-override" , "true" ) ; params . put ( "interleaving" , "true" ) ; params . put ( "no-tx-separate-pool" , "true" ) ; params . put ( "pad-xid" , "true" ) ; params . put ( "wrap-xa-resource" , "true" ) ; <START_BUG> params . put ( "application" , "true" ) ; <END_BUG> params . put ( "background-validation" , "true" ) ; params . put ( "background-validation-millis" , "5000" ) ; params . put ( "use-fast-fail" , "true" ) ; params . put ( "blocking-timeout-wait-millis" , "5000" ) ; params . put ( "idle-timeout-minutes" , "4" ) ; params . put ( "allocation-retry" , "2" ) ; params . put ( "allocation-retry-wait-millis" , "3000" ) ; params . put ( "xa-resource-timeout" , "300" ) ; params . put ( "no-recovery" , "false" ) ; params . put ( "recovery-plugin-class-name" , "someClass2" ) ; params . put ( "recovery-username" , "sa" ) ; params . put ( "recovery-password" , "sa-pass" ) ; params . put ( "recovery-security-domain" , "HsqlDbRealm" ) ; return params ; } public static Properties raAdminProperties ( ) { } public static void setOperationParams ( ModelNode operation , Properties params ) { } public static void addExtensionProperties ( ModelNode operation ) { } public static boolean checkModelParams ( ModelNode node , Properties params ) { } } 
public class JmxMonitoredMap < K , V > extends ConcurrentHashMap < String , SolrInfoMBean > { private static final Logger LOG = LoggerFactory . getLogger ( JmxMonitoredMap . class . getName ( ) ) ; private MBeanServer server = null ; private String jmxRootName ; private String coreHashCode ; public JmxMonitoredMap ( String coreName , String coreHashCode , final JmxConfiguration jmxConfig ) { } @ Override public void clear ( ) { } @ Override public SolrInfoMBean put ( String key , SolrInfoMBean infoBean ) { } @ Override public SolrInfoMBean remove ( Object key ) { } private void unregister ( String key , SolrInfoMBean infoBean ) { } private ObjectName getObjectName ( String key , SolrInfoMBean infoBean ) throws MalformedObjectNameException { } public MBeanServer getServer ( ) { } static class SolrDynamicMBean implements DynamicMBean { private SolrInfoMBean infoBean ; private HashSet < String > staticStats ; private String coreHashCode ; public SolrDynamicMBean ( String coreHashCode , SolrInfoMBean managedResource ) { } @ Override public MBeanInfo getMBeanInfo ( ) { } private OpenType determineType ( Class type ) { } @ Override public Object getAttribute ( String attribute ) throws AttributeNotFoundException , MBeanException , ReflectionException { } @ Override public AttributeList getAttributes ( String [ ] attributes ) { AttributeList list = new AttributeList ( ) ; for ( String attribute : attributes ) { try { list . add ( new Attribute ( attribute , getAttribute ( attribute ) ) ) ; } catch ( Exception e ) { <START_BUG> JmxMonitoredMap . LOG . warn ( ( "Could<seq2seq4repair_space>not<seq2seq4repair_space>get<seq2seq4repair_space>attibute<seq2seq4repair_space>" + attribute ) ) ; <END_BUG> } } return list ; } @ Override public void setAttribute ( Attribute attribute ) throws AttributeNotFoundException , InvalidAttributeValueException , MBeanException , ReflectionException { } @ Override public AttributeList setAttributes ( AttributeList attributes ) { } @ Override public Object invoke ( String actionName , Object [ ] params , String [ ] signature ) throws MBeanException , ReflectionException { } } } 
public class TestExternalValues extends SingleEMFTestCase { public void setUp ( ) { <START_BUG> super . setUp ( CLEAR_TABLES , EntityA . class ) ; <END_BUG> } public void testExternalValues ( ) { } public void testUnrecognizedExternalValue ( ) { } } 
public class PropertyColumn extends AbstractColumn { private static final long serialVersionUID = 1L ; private final String propertyExpression ; public PropertyColumn ( IModel displayModel , String sortProperty , String propertyExpression ) { } public PropertyColumn ( IModel displayModel , String propertyExpressions ) { } public void populateItem ( Item item , String componentId , IModel model ) { <START_BUG> item . add ( new wicket . markup . html . basic . Label ( item , componentId , createLabelModel ( model ) ) ) ; <END_BUG> } protected IModel createLabelModel ( IModel embeddedModel ) { } public String getPropertyExpression ( ) { } } 
final class SortedBytesMergeUtils { private SortedBytesMergeUtils ( ) { } static SortedBytesMergeUtils . MergeContext init ( ValueType type , IndexDocValues [ ] docValues , Comparator < BytesRef > comp , MergeState mergeState ) { } public static final class MergeContext { private final Comparator < BytesRef > comp ; private final BytesRef missingValue = new BytesRef ( ) ; final int sizePerValues ; final ValueType type ; final int [ ] docToEntry ; long [ ] offsets ; public MergeContext ( Comparator < BytesRef > comp , MergeState mergeState , int size , ValueType type ) { } } static List < SortedBytesMergeUtils . SortedSourceSlice > buildSlices ( MergeState mergeState , IndexDocValues [ ] docValues , SortedBytesMergeUtils . MergeContext ctx ) throws IOException { } private static void createOrdMapping ( MergeState mergeState , SortedBytesMergeUtils . SortedSourceSlice currentSlice ) { } static int mergeRecords ( SortedBytesMergeUtils . MergeContext ctx , IndexOutput datOut , List < SortedBytesMergeUtils . SortedSourceSlice > slices ) throws IOException { } private static final class RecordMerger { private final SortedBytesMergeUtils . MergeQueue queue ; private final SortedBytesMergeUtils . SortedSourceSlice [ ] top ; private int numTop ; BytesRef current ; int currentOrd = - 1 ; RecordMerger ( SortedBytesMergeUtils . MergeQueue queue , SortedBytesMergeUtils . SortedSourceSlice [ ] top ) { } private void pullTop ( ) { } private void pushTop ( ) throws IOException { } } static class SortedSourceSlice { final SortedSource source ; final int readerIdx ; final int [ ] docIDToRelativeOrd ; final int [ ] ordMapping ; final int docToOrdStart ; final int docToOrdEnd ; BytesRef current = new BytesRef ( ) ; int relativeOrd = - 1 ; SortedSourceSlice ( int readerIdx , SortedSource source , MergeState state , int [ ] docToOrd ) { } private static int numDocs ( MergeState state , int readerIndex ) { } BytesRef next ( ) { } void writeOrds ( PackedInts . Writer writer ) throws IOException { } } private static final class MissingValueSource extends SortedSource { private BytesRef missingValue ; public MissingValueSource ( SortedBytesMergeUtils . MergeContext ctx ) { } @ Override public int ord ( int docID ) { } @ Override public BytesRef getByOrd ( int ord , BytesRef bytesRef ) { <START_BUG> bytesRef . copy ( missingValue ) ; <END_BUG> return bytesRef ; } @ Override public Reader getDocToOrd ( ) { } @ Override public int getValueCount ( ) { } } private static final class MergeQueue extends PriorityQueue < SortedBytesMergeUtils . SortedSourceSlice > { final Comparator < BytesRef > comp ; public MergeQueue ( int maxSize , Comparator < BytesRef > comp ) { } @ Override protected boolean lessThan ( SortedBytesMergeUtils . SortedSourceSlice a , SortedBytesMergeUtils . SortedSourceSlice b ) { } } } 
public class OddEvenListItem < T > extends ListItem < T > { private static final long serialVersionUID = 1L ; private static final String CLASS_EVEN = "even" ; private static final String CLASS_ODD = "odd" ; public OddEvenListItem ( int index , IModel < T > model ) { } @ Override protected void onComponentTag ( ComponentTag tag ) { super . onComponentTag ( tag ) ; <START_BUG> tag . put ( "class" , ( ( ( OddEvenListItem . getIndex ( ) ) % 2 ) == 0 ? OddEvenListItem . CLASS_EVEN : OddEvenListItem . CLASS_ODD ) ) ; <END_BUG> } } 
public class CommandlineJava implements Cloneable { private Commandline vmCommand = new Commandline ( ) ; private Commandline javaCommand = new Commandline ( ) ; private CommandlineJava . SysProperties sysProperties = new CommandlineJava . SysProperties ( ) ; private Path classpath = null ; private String vmVersion ; public static class SysProperties extends Environment implements Cloneable { Properties sys = null ; public String [ ] getVariables ( ) throws BuildException { } public int size ( ) { } public void setSystem ( ) throws BuildException { } public void restoreSystem ( ) throws BuildException { } public Object clone ( ) { } } public CommandlineJava ( ) { } public Argument createArgument ( ) { } public Argument createVmArgument ( ) { } public void addSysproperty ( Environment . Variable sysp ) { } public void setVm ( String vm ) { } public void setVmversion ( String value ) { } public void setClassname ( String classname ) { } public String getClassname ( ) { } public Path createClasspath ( Project p ) { } public String getVmversion ( ) { } public String [ ] getCommandline ( ) { Path fullClasspath = ( ( classpath ) != null ) ? classpath . concatSystemClasspath ( "ignore" ) : null ; int size = ( ( vmCommand . size ( ) ) + ( javaCommand . size ( ) ) ) + ( sysProperties . size ( ) ) ; if ( ( fullClasspath != null ) && ( ( fullClasspath . size ( ) ) > 0 ) ) { size += 2 ; } String [ ] result = new String [ size ] ; System . arraycopy ( vmCommand . getCommandline ( ) , 0 , result , 0 , vmCommand . size ( ) ) ; int pos = vmCommand . size ( ) ; if ( ( sysProperties . size ( ) ) > 0 ) { System . arraycopy ( sysProperties . getVariables ( ) , 0 , result , pos , sysProperties . size ( ) ) ; pos += sysProperties . size ( ) ; } <START_BUG> if ( ( fullClasspath != null ) && ( ( fullClasspath . size ( ) ) > 0 ) ) { <END_BUG> result [ ( pos ++ ) ] = "-classpath" ; result [ ( pos ++ ) ] = fullClasspath . toString ( ) ; } System . arraycopy ( javaCommand . getCommandline ( ) , 0 , result , pos , javaCommand . size ( ) ) ; return result ; } public String toString ( ) { } public int size ( ) { } public Commandline getJavaCommand ( ) { } public Commandline getVmCommand ( ) { } public Path getClasspath ( ) { } public void setSystemProperties ( ) throws BuildException { } public void restoreSystemProperties ( ) throws BuildException { } public CommandlineJava . SysProperties getSystemProperties ( ) { } public Object clone ( ) { } public void clearJavaArgs ( ) { } } 
public class ConstructorDeclaration extends AbstractMethodDeclaration { public ExplicitConstructorCall constructorCall ; public static final char [ ] ConstantPoolName = "<init>" . toCharArray ( ) ; public boolean isDefaultConstructor = false ; public ConstructorDeclaration ( CompilationResult compilationResult ) { } public void analyseCode ( ClassScope classScope , InitializationFlowContext initializerFlowContext , FlowInfo flowInfo ) { } public void generateCode ( ClassScope classScope , ClassFile classFile ) { } public void generateSyntheticFieldInitializationsIfNecessary ( MethodScope methodScope , CodeStream codeStream , ReferenceBinding declaringClass ) { } private void internalGenerateCode ( ClassScope classScope , ClassFile classFile ) { classFile . generateMethodInfoHeader ( binding ) ; int methodAttributeOffset = classFile . contentsOffset ; int attributeNumber = classFile . generateMethodInfoAttribute ( binding ) ; if ( ( ! ( binding . isNative ( ) ) ) && ( ! ( binding . isAbstract ( ) ) ) ) { TypeDeclaration declaringType = classScope . referenceContext ; int codeAttributeOffset = classFile . contentsOffset ; classFile . generateCodeAttributeHeader ( ) ; CodeStream codeStream = classFile . codeStream ; codeStream . reset ( this , classFile ) ; ReferenceBinding declaringClass = binding . declaringClass ; int argSlotSize = 1 ; if ( declaringClass . isNestedType ( ) ) { NestedTypeBinding nestedType = ( ( NestedTypeBinding ) ( declaringClass ) ) ; this . scope . extraSyntheticArguments = nestedType . syntheticOuterLocalVariables ( ) ; scope . computeLocalVariablePositions ( ( ( nestedType . enclosingInstancesSlotSize ) + 1 ) , codeStream ) ; argSlotSize += nestedType . enclosingInstancesSlotSize ; argSlotSize += nestedType . outerLocalVariablesSlotSize ; } else { scope . computeLocalVariablePositions ( 1 , codeStream ) ; } if ( ( arguments ) != null ) { for ( int i = 0 , max = arguments . length ; i < max ; i ++ ) { LocalVariableBinding argBinding ; codeStream . addVisibleLocalVariable ( ( argBinding = arguments [ i ] . binding ) ) ; argBinding . recordInitializationStartPC ( 0 ) ; TypeBinding argType ; if ( ( ( argType = argBinding . type ) == ( LongBinding ) ) || ( argType == ( DoubleBinding ) ) ) { argSlotSize += 2 ; } else { argSlotSize ++ ; } } } MethodScope initializerScope = declaringType . initializerScope ; initializerScope . computeLocalVariablePositions ( argSlotSize , codeStream ) ; boolean needFieldInitializations = ( ( constructorCall ) == null ) || ( ( constructorCall . accessMode ) != ( ExplicitConstructorCall . This ) ) ; boolean preInitSyntheticFields = ( scope . environment ( ) . options . targetJDK ) >= ( ClassFileConstants . JDK1_4 ) ; if ( needFieldInitializations && preInitSyntheticFields ) { generateSyntheticFieldInitializationsIfNecessary ( scope , codeStream , declaringClass ) ; } if ( ( constructorCall ) != null ) { constructorCall . generateCode ( scope , codeStream ) ; } if ( needFieldInitializations ) { if ( ! preInitSyntheticFields ) { generateSyntheticFieldInitializationsIfNecessary ( scope , codeStream , declaringClass ) ; } if ( ( declaringType . fields ) != null ) { for ( int i = 0 , max = declaringType . fields . length ; i < max ; i ++ ) { FieldDeclaration fieldDecl ; if ( ! ( ( fieldDecl = declaringType . fields [ i ] ) . isStatic ( ) ) ) { fieldDecl . generateCode ( initializerScope , codeStream ) ; } } } } if ( ( statements ) != null ) { for ( int i = 0 , max = statements . length ; i < max ; i ++ ) { statements [ i ] . generateCode ( scope , codeStream ) ; } } if ( this . needFreeReturn ) { codeStream . return_ ( ) ; } codeStream . exitUserScope ( scope ) ; codeStream . recordPositionsFrom ( 0 , this . bodyEnd ) ; classFile . completeCodeAttribute ( codeAttributeOffset ) ; attributeNumber ++ ; } classFile . completeMethodInfo ( methodAttributeOffset , attributeNumber ) ; if ( ignoreFurtherInvestigation ) { <START_BUG> throw new org . eclipse . jdt . internal . compiler . problem . AbortMethod ( scope . referenceCompilationUnit ( ) . compilationResult ) ; <END_BUG> } } public boolean isConstructor ( ) { } public boolean isDefaultConstructor ( ) { } public boolean isInitializationMethod ( ) { } public boolean isRecursive ( ArrayList visited ) { } public void parseStatements ( Parser parser , CompilationUnitDeclaration unit ) { } public StringBuffer printBody ( int indent , StringBuffer output ) { } public void resolveJavadoc ( ) { } public void resolveStatements ( ) { } public void traverse ( ASTVisitor visitor , ClassScope classScope ) { } } 
@ RunWith ( Arquillian . class ) public class PureTestCase extends AbstractMgmtTestBase { public static void setUp ( ) throws Exception { } @ AfterClass public static void tearDown ( ) throws Exception { } @ Deployment public static ResourceAdapterArchive createDeployment ( ) throws Exception { } @ Inject public ServiceContainer serviceContainer ; @ Test public void testRegistryConfiguration ( ) throws Throwable { <START_BUG> ServiceController < ? > controller = serviceContainer . getService ( RA_REPOSISTORY_SERVICE ) ; <END_BUG> assertNotNull ( controller ) ; ResourceAdapterRepository repository = ( ( ResourceAdapterRepository ) ( controller . getValue ( ) ) ) ; assertNotNull ( repository ) ; Set < String > ids = repository . getResourceAdapters ( ) ; assertNotNull ( ids ) ; assertEquals ( 2 , ids . size ( ) ) ; for ( String piId : ids ) { assertNotNull ( piId ) ; System . out . println ( ( "PID:" + piId ) ) ; assertNotNull ( repository . getResourceAdapter ( piId ) ) ; } } @ Test public void testMetadataConfiguration ( ) throws Throwable { } } 
class MemoryManagerMXBeanAttributeHandler extends AbstractPlatformMBeanAttributeHandler { static final MemoryManagerMXBeanAttributeHandler INSTANCE = new MemoryManagerMXBeanAttributeHandler ( ) ; private MemoryManagerMXBeanAttributeHandler ( ) { } @ Override protected void executeReadAttribute ( OperationContext context , ModelNode operation ) throws OperationFailedException { final String mmName = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) . getLastElement ( ) . getValue ( ) ; final String name = operation . require ( NAME ) . asString ( ) ; MemoryManagerMXBean memoryManagerMXBean = null ; for ( MemoryManagerMXBean mbean : ManagementFactory . getMemoryManagerMXBeans ( ) ) { if ( mmName . equals ( PlatformMBeanUtil . escapeMBeanName ( mbean . getName ( ) ) ) ) { memoryManagerMXBean = mbean ; } } if ( memoryManagerMXBean == null ) { throw ROOT_LOGGER . unknownMemoryManager ( mmName ) ; } <START_BUG> if ( OBJECT_NAME . getName ( ) . equals ( name ) ) { <END_BUG> final String objName = PlatformMBeanUtil . getObjectNameStringWithNameKey ( ManagementFactory . MEMORY_MANAGER_MXBEAN_DOMAIN_TYPE , mmName ) ; context . getResult ( ) . set ( objName ) ; } else if ( NAME . equals ( name ) ) { context . getResult ( ) . set ( PlatformMBeanUtil . escapeMBeanName ( memoryManagerMXBean . getName ( ) ) ) ; } else if ( VALID . getName ( ) . equals ( name ) ) { context . getResult ( ) . set ( memoryManagerMXBean . isValid ( ) ) ; } else if ( MEMORY_POOL_NAMES . equals ( name ) ) { final ModelNode result = context . getResult ( ) ; result . setEmptyList ( ) ; for ( String pool : memoryManagerMXBean . getMemoryPoolNames ( ) ) { result . add ( PlatformMBeanUtil . escapeMBeanName ( pool ) ) ; } } else if ( MEMORY_MANAGER_READ_ATTRIBUTES . contains ( name ) ) { throw ROOT_LOGGER . badReadAttributeImpl ( name ) ; } else { throw unknownAttribute ( operation ) ; } } @ Override protected void executeWriteAttribute ( OperationContext context , ModelNode operation ) throws OperationFailedException { } } 
public class PathExtensionContentNegotiationStrategyTests { private NativeWebRequest webRequest ; private MockHttpServletRequest servletRequest ; @ Before public void setup ( ) { } @ Test public void resolveMediaTypesFromMapping ( ) { this . servletRequest . setRequestURI ( "test.html" ) ; PathExtensionContentNegotiationStrategy strategy = new PathExtensionContentNegotiationStrategy ( ) ; List < MediaType > mediaTypes = strategy . resolveMediaTypes ( this . webRequest ) ; assertEquals ( Arrays . asList ( new MediaType ( "text" , "html" ) ) , mediaTypes ) ; <START_BUG> strategy = new PathExtensionContentNegotiationStrategy ( Collections . singletonMap ( "HTML" , "application/xhtml+xml" ) ) ; <END_BUG> mediaTypes = strategy . resolveMediaTypes ( this . webRequest ) ; assertEquals ( Arrays . asList ( new MediaType ( "application" , "xhtml+xml" ) ) , mediaTypes ) ; } @ Test public void resolveMediaTypesFromJaf ( ) { } @ Test public void getMediaTypeFromFilenameNoJaf ( ) { } @ Test public void getMediaTypeFilenameWithContextPath ( ) { } @ Test public void getMediaTypeFilenameWithEncodedURI ( ) { } } 
public class StatisticalSampleSender extends AbstractSampleSender implements Serializable { private static final long serialVersionUID = 240L ; private static final Logger log = LoggingManager . getLoggerForClass ( ) ; private static final int DEFAULT_NUM_SAMPLE_THRESHOLD = 100 ; private static final long DEFAULT_TIME_THRESHOLD = 60000L ; private static final int NUM_SAMPLES_THRESHOLD = JMeterUtils . getPropDefault ( "num_sample_threshold" , StatisticalSampleSender . DEFAULT_NUM_SAMPLE_THRESHOLD ) ; private static final long TIME_THRESHOLD_MS = JMeterUtils . getPropDefault ( "time_threshold" , StatisticalSampleSender . DEFAULT_TIME_THRESHOLD ) ; private static boolean KEY_ON_THREADNAME = JMeterUtils . getPropDefault ( "key_on_threadname" , false ) ; private final int clientConfiguredNumSamplesThreshold = JMeterUtils . getPropDefault ( "num_sample_threshold" , StatisticalSampleSender . DEFAULT_NUM_SAMPLE_THRESHOLD ) ; private final long clientConfiguredTimeThresholdMs = JMeterUtils . getPropDefault ( "time_threshold" , StatisticalSampleSender . DEFAULT_TIME_THRESHOLD ) ; private final boolean clientConfiguredKeyOnThreadName = JMeterUtils . getPropDefault ( "key_on_threadname" , false ) ; private final RemoteSampleListener listener ; private final List < SampleEvent > sampleStore = new ArrayList < SampleEvent > ( ) ; private final Map < String , StatisticalSampleResult > sampleTable = new HashMap < String , StatisticalSampleResult > ( ) ; private volatile transient int numSamplesThreshold ; private volatile transient long timeThresholdMs ; private volatile transient boolean keyOnThreadName ; private transient int sampleCount ; private transient long batchSendTime = - 1 ; @ Deprecated public StatisticalSampleSender ( ) { } StatisticalSampleSender ( RemoteSampleListener listener ) { } @ Override public void testEnded ( String host ) { } @ Override public void sampleOccurred ( SampleEvent e ) { synchronized ( sampleStore ) { String key = StatisticalSampleResult . getKey ( e , keyOnThreadName ) ; StatisticalSampleResult statResult = sampleTable . get ( key ) ; if ( statResult == null ) { <START_BUG> statResult = new StatisticalSampleResult ( e . getResult ( ) , keyOnThreadName ) ; <END_BUG> sampleTable . put ( key , statResult ) ; sampleStore . add ( new SampleEvent ( statResult , e . getThreadGroup ( ) ) ) ; } statResult . add ( e . getResult ( ) ) ; ( sampleCount ) ++ ; boolean sendNow = false ; if ( ( numSamplesThreshold ) != ( - 1 ) ) { if ( ( sampleCount ) >= ( numSamplesThreshold ) ) { sendNow = true ; } } long now = 0 ; if ( ( timeThresholdMs ) != ( - 1 ) ) { now = System . currentTimeMillis ( ) ; if ( ( batchSendTime ) == ( - 1 ) ) { this . batchSendTime = now + ( timeThresholdMs ) ; } if ( ( batchSendTime ) < now ) { sendNow = true ; } } if ( sendNow ) { try { if ( StatisticalSampleSender . log . isDebugEnabled ( ) ) { StatisticalSampleSender . log . debug ( "Firing<seq2seq4repair_space>sample" ) ; } sendBatch ( ) ; if ( ( timeThresholdMs ) != ( - 1 ) ) { this . batchSendTime = now + ( timeThresholdMs ) ; } } catch ( RemoteException err ) { StatisticalSampleSender . log . warn ( "sampleOccurred" , err ) ; } } } } private void sendBatch ( ) throws RemoteException { } private Object readResolve ( ) throws ObjectStreamException { } } 
public abstract class AbstractTestComparator < T > extends AbstractTestObject { public AbstractTestComparator ( String testName ) { } public abstract List < T > getComparableObjectsOrdered ( ) { } public abstract Comparator < T > makeObject ( ) { } public boolean supportsEmptyCollections ( ) { } public boolean supportsFullCollections ( ) { } public String getCompatibilityVersion ( ) { } protected void reverseObjects ( List < ? > list ) { } protected void randomizeObjects ( List < ? > list ) { } protected void sortObjects ( List < T > list , Comparator < ? super T > comparator ) { } public void testEmptyListSort ( ) { } public void testReverseListSort ( ) { } public void testRandomListSort ( ) { } public void testComparatorIsSerializable ( ) { } public String getCanonicalComparatorName ( Object object ) { <START_BUG> StringBuffer retval = new StringBuffer ( ) ; <END_BUG> retval . append ( "data/test/" ) ; String colName = object . getClass ( ) . getName ( ) ; colName = colName . substring ( ( ( colName . lastIndexOf ( "." ) ) + 1 ) , colName . length ( ) ) ; retval . append ( colName ) ; retval . append ( ".version" ) ; retval . append ( getCompatibilityVersion ( ) ) ; retval . append ( ".obj" ) ; return retval . toString ( ) ; } @ SuppressWarnings ( "unchecked" ) public void testComparatorCompatibility ( ) throws IOException , ClassNotFoundException { } } 
public abstract class AbstractAutoCompleteBehavior extends AbstractDefaultAjaxBehavior { private static final CompressedResourceReference AUTOCOMPLETE_JS = new CompressedResourceReference ( AutoCompleteBehavior . class , "wicket-autocomplete.js" ) ; private static final long serialVersionUID = 1L ; @ Override public void renderHead ( IHeaderResponse response ) { } @ Override protected void onComponentRendered ( ) { Response response = getComponent ( ) . getResponse ( ) ; final String id = getComponent ( ) . getMarkupId ( ) ; response . write ( SCRIPT_OPEN_TAG ) ; <START_BUG> response . write ( ( ( ( ( "new<seq2seq4repair_space>Wicket.Ajax.AutoComplete('" + id ) + "','" ) + ( getCallbackUrl ( ) ) ) + "');" ) ) ; <END_BUG> response . write ( SCRIPT_CLOSE_TAG ) ; } @ Override protected void respond ( AjaxRequestTarget target ) { } protected abstract void onRequest ( String input , RequestCycle requestCycle ) { } } 
public class RAttributeAttributeGroup extends org . tigris . scarab . om . BaseRAttributeAttributeGroup implements UnsecurePersistent { public void delete ( ScarabUser user ) throws Exception { <START_BUG> ModuleEntity module = getAttributeGroup ( ) . getScarabModule ( ) ; <END_BUG> ScarabSecurity security = SecurityFactory . getInstance ( ) ; if ( security . hasPermission ( ITEM__APPROVE , user , module ) ) { Criteria c = new Criteria ( ) . add ( GROUP_ID , getGroupId ( ) ) . add ( ATTRIBUTE_ID , getAttributeId ( ) ) ; RAttributeAttributeGroupPeer . doDelete ( c ) ; } else { throw new org . tigris . scarab . util . ScarabException ( ScarabConstants . NO_PERMISSION_MESSAGE ) ; } } } 
public class ParsedRaDeploymentProcessor implements DeploymentUnitProcessor { public ParsedRaDeploymentProcessor ( ) { } public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final ConnectorXmlDescriptor connectorXmlDescriptor = phaseContext . getDeploymentUnit ( ) . getAttachment ( ATTACHMENT_KEY ) ; final ManagementResourceRegistration registration ; final ManagementResourceRegistration baseRegistration = phaseContext . getDeploymentUnit ( ) . getAttachment ( MUTABLE_REGISTRATION_ATTACHMENT ) ; final Resource deploymentResource = phaseContext . getDeploymentUnit ( ) . getAttachment ( DEPLOYMENT_RESOURCE ) ; if ( connectorXmlDescriptor == null ) { return ; } final ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; if ( ( deploymentUnit . getParent ( ) ) != null ) { registration = baseRegistration . getSubModel ( PathAddress . pathAddress ( PathElement . pathElement ( "subdeployment" ) ) ) ; } else { registration = baseRegistration ; } final IronJacamarXmlDescriptor ironJacamarXmlDescriptor = deploymentUnit . getAttachment ( IronJacamarXmlDescriptor . ATTACHMENT_KEY ) ; final Module module = deploymentUnit . getAttachment ( MODULE ) ; if ( module == null ) throw ROOT_LOGGER . failedToGetModuleAttachment ( phaseContext . getDeploymentUnit ( ) ) ; DEPLOYMENT_CONNECTOR_LOGGER . debugf ( "ParsedRaDeploymentProcessor:<seq2seq4repair_space>Processing=%s" , deploymentUnit ) ; final ClassLoader classLoader = module . getClassLoader ( ) ; Map < ResourceRoot , Index > annotationIndexes = AnnotationIndexUtils . getAnnotationIndexes ( deploymentUnit ) ; ServiceBuilder builder = ParsedRaDeploymentProcessor . process ( connectorXmlDescriptor , ironJacamarXmlDescriptor , classLoader , serviceTarget , annotationIndexes , deploymentUnit . getServiceName ( ) ) ; if ( builder != null ) { String bootstrapCtx = null ; if ( ( ( ironJacamarXmlDescriptor != null ) && ( ( ironJacamarXmlDescriptor . getIronJacamar ( ) ) != null ) ) && ( ( ironJacamarXmlDescriptor . getIronJacamar ( ) . getBootstrapContext ( ) ) != null ) ) bootstrapCtx = ironJacamarXmlDescriptor . getIronJacamar ( ) . getBootstrapContext ( ) ; if ( bootstrapCtx == null ) bootstrapCtx = "default" ; if ( ( registration . isAllowsOverride ( ) ) && ( ( registration . getOverrideModel ( deploymentUnit . getName ( ) ) ) == null ) ) { registration . registerOverrideModel ( deploymentUnit . getName ( ) , new OverrideDescriptionProvider ( ) { @ Override public Map < String , ModelNode > getAttributeOverrideDescriptions ( Locale locale ) { return Collections . emptyMap ( ) ; } @ Override public Map < String , ModelNode > getChildTypeOverrideDescriptions ( Locale locale ) { return Collections . emptyMap ( ) ; } } ) ; } <START_BUG> builder . addListener ( new AbstractResourceAdapterDeploymentServiceListener ( registration , deploymentUnit . getName ( ) , deploymentResource , bootstrapCtx , deploymentUnit . getName ( ) ) { <END_BUG> @ Override protected void registerIronjacamar ( final ServiceController < ? extends Object > controller , final ManagementResourceRegistration subRegistration , final Resource subsystemResource ) { try { subRegistration . registerSubModel ( new IronJacamarResourceDefinition ( ) ) ; } catch ( IllegalArgumentException iae ) { } AS7MetadataRepository mdr = ( ( org . jboss . as . connector . services . resourceadapters . deployment . ResourceAdapterDeploymentService ) ( controller . getService ( ) ) ) . getMdr ( ) ; INSTANCE . execute ( subsystemResource , mdr ) ; } @ Override protected CommonDeployment getDeploymentMetadata ( final ServiceController < ? extends Object > controller ) { return ( ( org . jboss . as . connector . services . resourceadapters . deployment . ResourceAdapterDeploymentService ) ( controller . getService ( ) ) ) . getRaDeployment ( ) ; } } ) ; builder . setInitialMode ( ACTIVE ) . install ( ) ; } } public static ServiceBuilder process ( final ConnectorXmlDescriptor connectorXmlDescriptor , final IronJacamarXmlDescriptor ironJacamarXmlDescriptor , final ClassLoader classLoader , final ServiceTarget serviceTarget , final Map < ResourceRoot , Index > annotationIndexes , final ServiceName duServiceName ) throws DeploymentUnitProcessingException { } public void undeploy ( final DeploymentUnit context ) { } } 
public class SendAllMessagesCommand extends FolderCommand { protected SendListManager sendListManager = new SendListManager ( ) ; protected OutboxFolder outboxFolder ; public SendAllMessagesCommand ( FrameController frameController , DefaultCommandReference [ ] references ) { } public void execute ( Worker worker ) throws Exception { FolderCommandReference [ ] r = ( ( FolderCommandReference [ ] ) ( getReferences ( ) ) ) ; outboxFolder = ( ( OutboxFolder ) ( r [ 0 ] . getFolder ( ) ) ) ; Object [ ] uids = outboxFolder . getUids ( worker ) ; for ( int i = 0 ; i < ( uids . length ) ; i ++ ) { <START_BUG> if ( ( outboxFolder . exists ( uids [ i ] ) ) == true ) { <END_BUG> SendableMessage message = ( ( SendableMessage ) ( outboxFolder . getMessage ( uids [ i ] , worker ) ) ) ; sendListManager . add ( message ) ; } } int actAccountUid = - 1 ; Vector sentList = new Vector ( ) ; boolean open = false ; SMTPServer smtpServer = null ; Folder sentFolder = null ; while ( sendListManager . hasMoreMessages ( ) ) { SendableMessage message = sendListManager . getNextMessage ( ) ; if ( ( message . getAccountUid ( ) ) != actAccountUid ) { if ( ( sentList . size ( ) ) != 0 ) { sentList . clear ( ) ; } actAccountUid = message . getAccountUid ( ) ; AccountItem accountItem = MailConfig . getAccountList ( ) . uidGet ( actAccountUid ) ; sentFolder = ( ( Folder ) ( treeModel . getFolder ( Integer . parseInt ( accountItem . getSpecialFoldersItem ( ) . getSent ( ) ) ) ) ) ; smtpServer = new SMTPServer ( accountItem ) ; open = smtpServer . openConnection ( ) ; } if ( open ) { smtpServer . sendMessage ( message ) ; sentList . add ( message . getHeader ( ) . get ( "columba.uid" ) ) ; } } if ( ( sentList . size ( ) ) > 0 ) { moveToSentFolder ( sentList , sentFolder ) ; } } protected void moveToSentFolder ( Vector v , Folder sentFolder ) { } } 
public class ContentConflictsUnitTestCase extends AbstractTaskTestCase { @ Test public void testApply ( ) throws Exception { } @ Test public void testRollback ( ) throws Exception { } protected void assertConflicts ( CommandLineException e , String ... conflicts ) { final StringBuilder buf = new StringBuilder ( ) ; buf . append ( "Conflicts<seq2seq4repair_space>detected:<seq2seq4repair_space>" ) ; int i = 0 ; while ( i < ( conflicts . length ) ) { <START_BUG> buf . append ( conflicts [ ( i ++ ) ] ) ; <END_BUG> if ( i < ( conflicts . length ) ) { buf . append ( ",<seq2seq4repair_space>" ) ; } } assertEquals ( e . getMessage ( ) , buf . toString ( ) ) ; } } 
@ RunWith ( Arquillian . class ) public class RestEasyIntegrationTestCase { static final String DEPLOYMENT_NAME = "resteasy-osgi-client.war" ; @ ArquillianResource public Deployer deployer ; @ Inject public Bundle bundle ; @ Deployment public static JavaArchive createDeployment ( ) { } @ Deployment ( name = RestEasyIntegrationTestCase . DEPLOYMENT_NAME , managed = false , testable = false ) public static WebArchive endpointWar ( ) { final WebArchive archive = ShrinkWrap . create ( WebArchive . class , RestEasyIntegrationTestCase . DEPLOYMENT_NAME ) ; archive . addClass ( SimpleRestEndpoint . class ) ; <START_BUG> archive . setWebXML ( "osgi/jaxrs/web.xml" ) ; <END_BUG> archive . add ( new Asset ( ) { public InputStream openStream ( ) { ManifestBuilder builder = ManifestBuilder . newInstance ( ) ; builder . addManifestHeader ( "Dependencies" , "org.osgi.core,deployment.jaxrs-osgi-target:0.0.0" ) ; return builder . openStream ( ) ; } } , JarFile . MANIFEST_NAME ) ; return archive ; } @ Test public void testServiceAccess ( ) throws Exception { } private String getHttpResponse ( String message ) throws IOException , ExecutionException , TimeoutException { } public static String formatPossibleIpv6Address ( String address ) { } } 
public class TreeView extends JTree { private TreePath selectedPathBeforeDrag ; private TreePath dropTargetPath ; private boolean isInDndMode = false ; private Timer dndAutoExpanderTimer ; public TreeView ( TreeModel model ) { } public final void expand ( AbstractFolder parent ) { <START_BUG> FolderItem item = parent . getFolderItem ( ) ; <END_BUG> XmlElement property = item . getElement ( "property" ) ; if ( property != null ) { String expanded = property . getAttribute ( "expanded" ) ; if ( expanded == null ) { expanded = "true" ; } int row = getRowForPath ( new TreePath ( parent . getPath ( ) ) ) ; if ( expanded . equals ( "true" ) ) { expandRow ( row ) ; } } for ( int i = 0 ; i < ( parent . getChildCount ( ) ) ; i ++ ) { AbstractFolder child = ( ( AbstractFolder ) ( parent . getChildAt ( i ) ) ) ; expand ( child ) ; } } public AbstractFolder getDropTargetFolder ( ) { } void resetDropTargetFolder ( ) { } public AbstractFolder getSelectedNodeBeforeDragAction ( ) { } public boolean isInDndAction ( ) { } private void setUpDndAction ( ) { } private void resetDndAction ( ) { } private class DropHandler extends DropTarget { private boolean canImport ; private Point location ; public void dragOver ( DropTargetDragEvent e ) { } public void dragEnter ( DropTargetDragEvent e ) { } public void dragExit ( DropTargetEvent e ) { } public void drop ( DropTargetDropEvent e ) { } public void dropActionChanged ( DropTargetDragEvent e ) { } } private class TreeLeafActionListener implements ActionListener { private JTree treeParent ; public TreeLeafActionListener ( JTree parent ) { } public void actionPerformed ( ActionEvent e ) { } } } 
public class ExampleRunner { public static void main ( String [ ] args ) throws Exception { final ModelControllerClient client = Factory . create ( "localhost" , 9999 ) ; try { final ModelNode domainOp = new ModelNode ( ) ; domainOp . get ( OP ) . set ( READ_RESOURCE_OPERATION ) ; domainOp . get ( OP_ADDR ) . setEmptyList ( ) ; domainOp . get ( RECURSIVE ) . set ( true ) ; domainOp . get ( "proxies" ) . set ( false ) ; ModelNode result = client . execute ( domainOp ) ; if ( ! ( SUCCESS . equals ( result . get ( OUTCOME ) . asString ( ) ) ) ) { throw new org . jboss . as . controller . OperationFailedException ( result . get ( FAILURE_DESCRIPTION ) ) ; } System . out . println ( "--<seq2seq4repair_space>domain<seq2seq4repair_space>configuration" ) ; final ModelNode domainResult = result . get ( RESULT ) . clone ( ) ; System . out . println ( domainResult ) ; System . out . println ( "--" ) ; final ModelNode hostOp = new ModelNode ( ) ; hostOp . get ( OP ) . set ( READ_RESOURCE_OPERATION ) ; hostOp . get ( OP_ADDR ) . setEmptyList ( ) . add ( HOST , "local" ) ; hostOp . get ( RECURSIVE ) . set ( true ) ; hostOp . get ( "proxies" ) . set ( false ) ; result = client . execute ( hostOp ) ; if ( ! ( SUCCESS . equals ( result . get ( OUTCOME ) . asString ( ) ) ) ) { throw new org . jboss . as . controller . OperationFailedException ( result . get ( FAILURE_DESCRIPTION ) ) ; } System . out . println ( "--<seq2seq4repair_space>host<seq2seq4repair_space>configuration" ) ; final ModelNode hostResult = result . get ( RESULT ) . clone ( ) ; <START_BUG> System . out . println ( ) ; <END_BUG> System . out . println ( "--" ) ; } finally { StreamUtils . safeClose ( client ) ; } } } 
public class TarArchiveInputStream extends ArchiveInputStream { private static final int SMALL_BUFFER_SIZE = 256 ; private final byte [ ] SMALL_BUF = new byte [ TarArchiveInputStream . SMALL_BUFFER_SIZE ] ; private final int recordSize ; private final int blockSize ; private boolean hasHitEOF ; private long entrySize ; private long entryOffset ; private final InputStream is ; private TarArchiveEntry currEntry ; private final ZipEncoding encoding ; public TarArchiveInputStream ( InputStream is ) { } public TarArchiveInputStream ( InputStream is , String encoding ) { } public TarArchiveInputStream ( InputStream is , int blockSize ) { } public TarArchiveInputStream ( InputStream is , int blockSize , String encoding ) { } public TarArchiveInputStream ( InputStream is , int blockSize , int recordSize ) { } public TarArchiveInputStream ( InputStream is , int blockSize , int recordSize , String encoding ) { } @ Override public void close ( ) throws IOException { } public int getRecordSize ( ) { } @ Override public int available ( ) throws IOException { } @ Override public long skip ( long numToSkip ) throws IOException { } @ Override public synchronized void reset ( ) { } public TarArchiveEntry getNextTarEntry ( ) throws IOException { } private void skipRecordPadding ( ) throws IOException { } protected byte [ ] getLongNameData ( ) throws IOException { } private byte [ ] getRecord ( ) throws IOException { } protected boolean isEOFRecord ( byte [ ] record ) { } protected byte [ ] readRecord ( ) throws IOException { } private void paxHeaders ( ) throws IOException { } Map < String , String > parsePaxHeaders ( InputStream i ) throws IOException { Map < String , String > headers = new HashMap < String , String > ( ) ; while ( true ) { int ch ; int len = 0 ; int read = 0 ; while ( ( ch = i . read ( ) ) != ( - 1 ) ) { read ++ ; if ( ch == '<seq2seq4repair_space>' ) { ByteArrayOutputStream coll = new ByteArrayOutputStream ( ) ; while ( ( ch = i . read ( ) ) != ( - 1 ) ) { read ++ ; if ( ch == '=' ) { String keyword = coll . toString ( UTF_8 ) ; byte [ ] rest = new byte [ len - read ] ; <START_BUG> int got = i . read ( rest ) ; <END_BUG> if ( got != ( len - read ) ) { throw new IOException ( ( ( ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>read<seq2seq4repair_space>" + "Paxheader.<seq2seq4repair_space>Expected<seq2seq4repair_space>" ) + ( len - read ) ) + "<seq2seq4repair_space>bytes,<seq2seq4repair_space>read<seq2seq4repair_space>" ) + got ) ) ; } String value = new String ( rest , 0 , ( ( len - read ) - 1 ) , CharsetNames . UTF_8 ) ; headers . put ( keyword , value ) ; break ; } coll . write ( ( ( byte ) ( ch ) ) ) ; } break ; } len *= 10 ; len += ch - '0' ; } if ( ch == ( - 1 ) ) { break ; } } return headers ; } private void applyPaxHeadersToCurrentEntry ( Map < String , String > headers ) { } private void readGNUSparse ( ) throws IOException { } @ Override public ArchiveEntry getNextEntry ( ) throws IOException { } private void tryToConsumeSecondEOFRecord ( ) throws IOException { } @ Override public int read ( byte [ ] buf , int offset , int numToRead ) throws IOException { } @ Override public boolean canReadEntryData ( ArchiveEntry ae ) { } public TarArchiveEntry getCurrentEntry ( ) { } protected final void setCurrentEntry ( TarArchiveEntry e ) { } protected final boolean isAtEOF ( ) { } protected final void setAtEOF ( boolean b ) { } private void consumeRemainderOfLastBlock ( ) throws IOException { } public static boolean matches ( byte [ ] signature , int length ) { } } 
public class ChannelInstanceResourceDefinition extends SimpleResourceDefinition { static PathElement pathElement ( String name ) { } private final boolean runtimeRegistration ; ChannelInstanceResourceDefinition ( String channelName , boolean runtimeRegistration ) { } @ Override public void registerAttributes ( ManagementResourceRegistration registration ) { } public static void addChannelProtocolMetricsRegistrationStep ( OperationContext context , String channelName , String stackName ) { } public static void registerChannelProtocolMetrics ( OperationContext context , String channelName , String stackName ) throws OperationFailedException { if ( stackName == null ) { stackName = ChannelInstanceResourceDefinition . getDefaultStack ( context ) ; } PathAddress address = PathAddress . pathAddress ( PATH ) ; PathAddress stackAddress = address . append ( StackResourceDefinition . pathElement ( stackName ) ) ; ModelNode stack = Tools . readModel ( context . readResourceFromRoot ( stackAddress , true ) ) ; ModelNode transport = stack . get ( TRANSPORT , TRANSPORT_NAME ) . clone ( ) ; <START_BUG> String transportName = transport . get ( TYPE ) . asString ( ) ; <END_BUG> ResourceDefinition transportDefinition = ChannelInstanceResourceDefinition . getProtocolMetricResourceDefinition ( context , channelName , transportName ) ; List < ModelNode > protocolOrdering = stack . get ( PROTOCOLS ) . clone ( ) . asList ( ) ; final List < ResourceDefinition > protocolDefinitions = new ArrayList < ResourceDefinition > ( ) ; for ( ModelNode protocolNameModelNode : protocolOrdering ) { String protocolName = protocolNameModelNode . asString ( ) ; ResourceDefinition protocolDefinition = ChannelInstanceResourceDefinition . getProtocolMetricResourceDefinition ( context , channelName , protocolName ) ; protocolDefinitions . add ( protocolDefinition ) ; } ResourceDefinition relayDefinition = null ; if ( stack . hasDefined ( RELAY ) ) { relayDefinition = ChannelInstanceResourceDefinition . getProtocolMetricResourceDefinition ( context , channelName , "relay.RELAY2" ) ; } ManagementResourceRegistration subsystemRootRegistration = context . getResourceRegistrationForUpdate ( ) ; ManagementResourceRegistration channelRegistration = subsystemRootRegistration . registerSubModel ( new ChannelInstanceResourceDefinition ( channelName , true ) ) ; channelRegistration . registerSubModel ( transportDefinition ) ; for ( ResourceDefinition protocolDefinition : protocolDefinitions ) { channelRegistration . registerSubModel ( protocolDefinition ) ; } if ( stack . hasDefined ( RELAY ) ) { channelRegistration . registerSubModel ( relayDefinition ) ; } } public static void addChannelProtocolMetricsDeregistrationStep ( OperationContext context , String channelName ) { } private static String getDefaultStack ( OperationContext context ) throws OperationFailedException { } private static ResourceDefinition getProtocolMetricResourceDefinition ( OperationContext context , String channelName , String protocolName ) throws OperationFailedException { } private static void addAttributeDefinition ( List < AttributeDefinition > attributes , Map < String , String > map , String protocolName , String name , ModelType type , String description ) { } public static boolean isEquivalentModelTypeAvailable ( Class < ? > type ) { } private static ModelType getEquivalentModelType ( Class < ? > typeClass ) { } private static Field [ ] getProtocolFields ( Class < ? > clazz ) { } public static class ProtocolResources extends ResourceBundle { private static Map < String , String > resources = new HashMap < String , String > ( ) ; public static void addProtocolMapEntries ( Map < String , String > map ) { } @ Override public Object handleGetObject ( String key ) { } @ Override public Enumeration < String > getKeys ( ) { } @ Override protected Set < String > handleKeySet ( ) { } } } 
private int cacheUserCount ; private String [ ] [ ] cachedChunks ; private HashtableOfObject categoryTables ; private char [ ] cachedCategoryName ; public static final String SIGNATURE = "INDEX<seq2seq4repair_space>VERSION<seq2seq4repair_space>1.107" ; public static boolean DEBUG = false ; private static final int RE_INDEXED = - 1 ; private static final int DELETED = - 2 ; private static final int CHUNK_SIZE = 100 ; class IntList { int size ; int [ ] elements ; IntList ( int [ ] elements ) { } void add ( int newElement ) { } int [ ] asArray ( ) { } } DiskIndex ( String fileName ) { } SimpleSet addDocumentNames ( String substring , MemoryIndex memoryIndex ) throws IOException { } private HashtableOfObject addQueryResult ( HashtableOfObject results , char [ ] word , HashtableOfObject wordsToDocNumbers , MemoryIndex memoryIndex ) throws IOException { } HashtableOfObject addQueryResults ( char [ ] [ ] categories , char [ ] key , int matchRule , MemoryIndex memoryIndex ) throws IOException { } private void cacheDocumentNames ( ) throws IOException { } private String [ ] computeDocumentNames ( String [ ] onDiskNames , int [ ] positions , SimpleLookupTable indexedDocuments , MemoryIndex memoryIndex ) { } private void copyQueryResults ( HashtableOfObject categoryToWords , int newPosition ) { } File getIndexFile ( ) { } void initialize ( boolean reuseExistingFile ) throws IOException { } private void initializeFrom ( DiskIndex diskIndex , File newIndexFile ) throws IOException { } private void mergeCategories ( DiskIndex onDisk , int [ ] positions , DataOutputStream stream ) throws IOException { } private void mergeCategory ( char [ ] categoryName , DiskIndex onDisk , int [ ] positions , DataOutputStream stream ) throws IOException { } DiskIndex mergeWith ( MemoryIndex memoryIndex ) throws IOException { } private synchronized String [ ] readAllDocumentNames ( ) throws IOException { } private synchronized HashtableOfObject readCategoryTable ( char [ ] categoryName , boolean readDocNumbers ) throws IOException { int offset = this . categoryOffsets . get ( categoryName ) ; if ( offset == ( HashtableOfIntValues . NO_VALUE ) ) return null ; if ( ( this . categoryTables ) == null ) { this . categoryTables = new HashtableOfObject ( 3 ) ; } else { HashtableOfObject cachedTable = ( ( HashtableOfObject ) ( this . categoryTables . get ( categoryName ) ) ) ; if ( cachedTable != null ) { if ( readDocNumbers ) { Object [ ] arrayOffsets = cachedTable . valueTable ; for ( int i = 0 , l = arrayOffsets . length ; i < l ; i ++ ) if ( ( arrayOffsets [ i ] ) instanceof Integer ) arrayOffsets [ i ] = readDocumentNumbers ( arrayOffsets [ i ] ) ; } return cachedTable ; } } DataInputStream stream = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( getIndexFile ( ) ) , 2048 ) ) ; HashtableOfObject categoryTable = null ; char [ ] [ ] matchingWords = null ; int count = 0 ; int firstOffset = - 1 ; try { stream . skip ( offset ) ; int size = stream . readInt ( ) ; categoryTable = new HashtableOfObject ( size ) ; int largeArraySize = 256 ; for ( int i = 0 ; i < size ; i ++ ) { char [ ] word = org . eclipse . jdt . internal . core . util . Util . readUTF ( stream ) ; int arrayOffset = stream . readInt ( ) ; if ( arrayOffset <= 0 ) { categoryTable . put ( word , new int [ ] { - arrayOffset } ) ; } else if ( arrayOffset < largeArraySize ) { categoryTable . put ( word , readDocumentArray ( stream , arrayOffset ) ) ; } else { arrayOffset = stream . readInt ( ) ; if ( readDocNumbers ) { if ( matchingWords == null ) matchingWords = new char [ size ] [ ] ; if ( count == 0 ) firstOffset = arrayOffset ; matchingWords [ ( count ++ ) ] = word ; } categoryTable . put ( word , new Integer ( arrayOffset ) ) ; } } this . categoryTables . put ( categoryName , categoryTable ) ; this . cachedCategoryName = ( ( categoryTable . elementSize ) < 10000 ) ? categoryName : null ; } finally { stream . close ( ) ; } <START_BUG> if ( count > 0 ) { <END_BUG> stream = new DataInputStream ( new BufferedInputStream ( new FileInputStream ( getIndexFile ( ) ) , 2048 ) ) ; try { stream . skip ( firstOffset ) ; for ( int i = 0 ; i < count ; i ++ ) categoryTable . put ( matchingWords [ i ] , readDocumentArray ( stream , stream . readInt ( ) ) ) ; } finally { stream . close ( ) ; } } return categoryTable ; } private void readChunk ( String [ ] docNames , DataInputStream stream , int index , int size ) throws IOException { } private int [ ] readDocumentArray ( DataInputStream stream , int arraySize ) throws IOException { } synchronized String readDocumentName ( int docNumber ) throws IOException { } synchronized int [ ] readDocumentNumbers ( Object arrayOffset ) throws IOException { } private void readHeaderInfo ( RandomAccessFile file ) throws IOException { } synchronized void startQuery ( ) { } synchronized void stopQuery ( ) { } private void writeAllDocumentNames ( String [ ] sortedDocNames , DataOutputStream stream ) throws IOException { } private void writeCategories ( DataOutputStream stream ) throws IOException { } private void writeCategoryTable ( char [ ] categoryName , HashtableOfObject wordsToDocs , DataOutputStream stream ) throws IOException { } private void writeDocumentNumbers ( int [ ] documentNumbers , DataOutputStream stream ) throws IOException { } private void writeHeaderInfo ( DataOutputStream stream ) throws IOException { } private void writeOffsetToHeader ( int offsetToHeader ) throws IOException { } } 
class OperationTransformationOverrideBuilderImpl extends AttributeTransformationDescriptionBuilderImpl implements OperationTransformationOverrideBuilder { private boolean inherit = false ; private DiscardPolicy discardPolicy = DiscardPolicy . NEVER ; private OperationTransformer transformer = OperationTransformer . DEFAULT ; private String newName ; protected OperationTransformationOverrideBuilderImpl ( ResourceTransformationDescriptionBuilder builder ) { } @ Override public OperationTransformationOverrideBuilder inherit ( ) { } public OperationTransformationOverrideBuilder setOperationTransformer ( OperationTransformer transformer ) { } @ Override public OperationTransformationOverrideBuilder rename ( String newName ) { } protected OperationTransformer createTransformer ( final AttributeTransformationDescriptionBuilderRegistry resourceRegistry ) { final AttributeTransformationDescriptionBuilderRegistry registry = resultingRegistry ( resourceRegistry ) ; final AttributeTransformationRule first = new AttributeTransformationRule ( registry . buildAttributes ( ) ) ; return new OperationTransformer ( ) { @ Override public TransformedOperation transformOperation ( final TransformationContext ctx , final PathAddress address , final ModelNode operation ) throws OperationFailedException { if ( discardPolicy . discard ( operation , address , ctx ) ) { return DISCARD . transformOperation ( ctx , address , operation ) ; } final Iterator < TransformationRule > iterator = Collections . < TransformationRule > emptyList ( ) . iterator ( ) ; final ModelNode originalModel = operation . clone ( ) ; originalModel . protect ( ) ; <START_BUG> final TransformationRule . OperationContext context = new TransformationRule . OperationContext ( ctx ) { <END_BUG> @ Override void invokeNext ( OperationTransformer . TransformedOperation transformedOperation ) throws OperationFailedException { recordTransformedOperation ( transformedOperation ) ; if ( iterator . hasNext ( ) ) { final TransformationRule next = iterator . next ( ) ; next . transformOperation ( transformedOperation . getTransformedOperation ( ) , address , this ) ; } else { if ( ( newName ) != null ) { transformedOperation . getTransformedOperation ( ) . get ( OP ) . set ( newName ) ; } final TransformationContext ctx = getContext ( ) ; transformer . transformOperation ( ctx , address , transformedOperation . getTransformedOperation ( ) ) ; } } } ; operation . get ( OP_ADDR ) . set ( address . toModelNode ( ) ) ; first . transformOperation ( operation , address , context ) ; return context . createOp ( ) ; } } ; } protected AttributeTransformationDescriptionBuilderRegistry resultingRegistry ( final AttributeTransformationDescriptionBuilderRegistry resourceRegistry ) { } } 
public final class ServerCommunicationHandlerFactory { private static final ServerCommunicationHandlerFactory INSTANCE = new ServerCommunicationHandlerFactory ( ) ; public static ServerCommunicationHandlerFactory getInstance ( ) { } public ServerCommunicationHandler getServerCommunicationHandler ( ServerEnvironment environment , MessageHandler handler ) { <START_BUG> return new ServerCommunicationHandler ( environment . getProcessName ( ) , environment . getProcessManagerAddress ( ) , environment . getProcessManagerPort ( ) , handler ) ; <END_BUG> } private ServerCommunicationHandlerFactory ( ) { } } 
public abstract class IndexReaderFactory implements NamedListInitializedPlugin { protected int termInfosIndexDivisor = 1 ; public void init ( NamedList args ) { <START_BUG> Integer v = ( ( Integer ) ( args . get ( "setTermIndexInterval" ) ) ) ; <END_BUG> if ( v != null ) { termInfosIndexDivisor = v . intValue ( ) ; } } public int getTermInfosIndexDivisor ( ) { } public abstract IndexReader newReader ( Directory indexDir , boolean readOnly ) throws IOException { } } 
public class CopyElementsOperation extends MultiOperation implements SuffixConstants { private Map sources = new HashMap ( ) ; public CopyElementsOperation ( IJavaElement [ ] elementsToCopy , IJavaElement [ ] destContainers , boolean force ) { } public CopyElementsOperation ( IJavaElement [ ] elementsToCopy , IJavaElement destContainer , boolean force ) { } protected String getMainTaskName ( ) { <START_BUG> return org . eclipse . jdt . internal . compiler . util . Util . bind ( "operation.copyElementProgress" ) ; <END_BUG> } protected JavaModelOperation getNestedOperation ( IJavaElement element ) { } private String getSourceFor ( IJavaElement element ) throws JavaModelException { } protected boolean isRenamingMainType ( IJavaElement element , IJavaElement dest ) throws JavaModelException { } protected void processElement ( IJavaElement element ) throws JavaModelException { } private IJavaElement resolveRenameAnchor ( IJavaElement element ) throws JavaModelException { } protected IJavaModelStatus verify ( ) { } protected void verify ( IJavaElement element ) throws JavaModelException { } } 
public class ImageFigure extends AttributeFigure implements ImageObserver { private String fFileName ; private transient Image fImage ; private Rectangle fDisplayBox ; private static final long serialVersionUID = 148012030121282439L ; private int imageFigureSerializedDataVersion = 1 ; public ImageFigure ( ) { } public ImageFigure ( Image image , String fileName , Point origin ) { } public void basicDisplayBox ( Point origin , Point corner ) { } public HandleEnumeration handles ( ) { } public Rectangle displayBox ( ) { } protected void basicMoveBy ( int x , int y ) { } public void draw ( Graphics g ) { if ( ( fImage ) == null ) { <START_BUG> fImage = Iconkit . instance ( ) . getImage ( fFileName ) ; <END_BUG> } if ( ( fImage ) != null ) { g . drawImage ( fImage , fDisplayBox . x , fDisplayBox . y , fDisplayBox . width , fDisplayBox . height , this ) ; } else { drawGhost ( g ) ; } } private void drawGhost ( Graphics g ) { } public boolean imageUpdate ( Image img , int flags , int x , int y , int w , int h ) { } public void release ( ) { } public void write ( StorableOutput dw ) { } public void read ( StorableInput dr ) throws IOException { } private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { } } 
public class JcaExtension implements Extension { public static String SUBSYSTEM_NAME = "jca" ; private static final int MANAGEMENT_API_MAJOR_VERSION = 1 ; private static final int MANAGEMENT_API_MINOR_VERSION = 1 ; private static final int MANAGEMENT_API_MICRO_VERSION = 0 ; private static final String RESOURCE_NAME = ( JcaExtension . class . getPackage ( ) . getName ( ) ) + ".LocalDescriptions" ; protected static final PathElement PATH_SUBSYSTEM = PathElement . pathElement ( SUBSYSTEM , JcaExtension . SUBSYSTEM_NAME ) ; protected static final PathElement PATH_ARCHIVE_VALIDATION = PathElement . pathElement ( Constants . ARCHIVE_VALIDATION , Constants . ARCHIVE_VALIDATION ) ; static StandardResourceDescriptionResolver getResourceDescriptionResolver ( final String ... keyPrefix ) { } @ Override public void initialize ( final ExtensionContext context ) { ROOT_LOGGER . debugf ( "Initializing<seq2seq4repair_space>Connector<seq2seq4repair_space>Extension" ) ; final boolean registerRuntimeOnly = context . isRuntimeOnlyRegistrationValid ( ) ; final SubsystemRegistration subsystem = context . registerSubsystem ( JcaExtension . SUBSYSTEM_NAME , JcaExtension . MANAGEMENT_API_MAJOR_VERSION , JcaExtension . MANAGEMENT_API_MINOR_VERSION , JcaExtension . MANAGEMENT_API_MICRO_VERSION ) ; final ManagementResourceRegistration registration = subsystem . registerSubsystemModel ( INSTANCE ) ; <START_BUG> registration . registerOperationHandler ( DESCRIBE , GenericSubsystemDescribeHandler . INSTANCE , GenericSubsystemDescribeHandler . INSTANCE , false , PRIVATE ) ; <END_BUG> final ManagementResourceRegistration archiveValidation = registration . registerSubModel ( JcaArchiveValidationDefinition . INSTANCE ) ; final ManagementResourceRegistration beanValidation = registration . registerSubModel ( PathElement . pathElement ( Constants . BEAN_VALIDATION , Constants . BEAN_VALIDATION ) , BEAN_VALIDATION_DESC ) ; beanValidation . registerOperationHandler ( ADD , BeanValidationAdd . INSTANCE , ADD_BEAN_VALIDATION_DESC , false ) ; beanValidation . registerOperationHandler ( REMOVE , ReloadRequiredRemoveStepHandler . INSTANCE , REMOVE_BEAN_VALIDATION_DESC , false ) ; for ( final BeanValidationAdd . BeanValidationParameters parameter : BeanValidationParameters . values ( ) ) { beanValidation . registerReadWriteAttribute ( parameter . getAttribute ( ) , null , JcaAttributeWriteHandler . INSTANCE ) ; } final ManagementResourceRegistration cachedConnectionManager = registration . registerSubModel ( PathElement . pathElement ( Constants . CACHED_CONNECTION_MANAGER , Constants . CACHED_CONNECTION_MANAGER ) , CACHED_CONNECTION_MANAGER_DESC ) ; cachedConnectionManager . registerOperationHandler ( ADD , CachedConnectionManagerAdd . INSTANCE , ADD_CACHED_CONNECTION_MANAGER_DESC , false ) ; cachedConnectionManager . registerOperationHandler ( REMOVE , ReloadRequiredRemoveStepHandler . INSTANCE , REMOVE_CACHED_CONNECTION_MANAGER_DESC , false ) ; for ( final CachedConnectionManagerAdd . CcmParameters parameter : CcmParameters . values ( ) ) { if ( parameter != ( CcmParameters . INSTALL ) ) { cachedConnectionManager . registerReadWriteAttribute ( parameter . getAttribute ( ) , null , JcaAttributeWriteHandler . INSTANCE ) ; } else { cachedConnectionManager . registerReadWriteAttribute ( parameter . getAttribute ( ) , null , new ReloadRequiredWriteAttributeHandler ( ) ) ; } } final ManagementResourceRegistration workManager = registration . registerSubModel ( PathElement . pathElement ( Constants . WORKMANAGER ) , WORKMANAGER_DESC ) ; workManager . registerOperationHandler ( ADD , WorkManagerAdd . INSTANCE , ADD_WORKMANAGER_DESC , false ) ; workManager . registerOperationHandler ( REMOVE , ReloadRequiredRemoveStepHandler . INSTANCE , REMOVE_WORKMANAGER_DESC , false ) ; for ( final WorkManagerAdd . WmParameters parameter : WmParameters . values ( ) ) { workManager . registerReadWriteAttribute ( parameter . getAttribute ( ) , null , new ReloadRequiredWriteAttributeHandler ( ) ) ; } workManager . registerSubModel ( BoundedQueueThreadPoolResourceDefinition . create ( Constants . WORKMANAGER_SHORT_RUNNING , STANDARD_THREAD_FACTORY_RESOLVER , STANDARD_HANDOFF_EXECUTOR_RESOLVER , EXECUTOR . append ( Constants . WORKMANAGER_SHORT_RUNNING ) , registerRuntimeOnly ) ) ; workManager . registerSubModel ( BoundedQueueThreadPoolResourceDefinition . create ( Constants . WORKMANAGER_LONG_RUNNING , STANDARD_THREAD_FACTORY_RESOLVER , STANDARD_HANDOFF_EXECUTOR_RESOLVER , EXECUTOR . append ( Constants . WORKMANAGER_LONG_RUNNING ) , registerRuntimeOnly ) ) ; final ManagementResourceRegistration bootstrapContext = registration . registerSubModel ( PathElement . pathElement ( Constants . BOOTSTRAP_CONTEXT ) , BOOTSTRAP_CONTEXT_DESC ) ; bootstrapContext . registerOperationHandler ( ADD , BootstrapContextAdd . INSTANCE , ADD_BOOTSTRAP_CONTEXT_DESC , false ) ; bootstrapContext . registerOperationHandler ( REMOVE , ReloadRequiredRemoveStepHandler . INSTANCE , REMOVE_BOOTSTRAP_CONTEXT_DESC , false ) ; for ( final BootstrapContextAdd . BootstrapCtxParameters parameter : BootstrapCtxParameters . values ( ) ) { bootstrapContext . registerReadWriteAttribute ( parameter . getAttribute ( ) , null , new ReloadRequiredWriteAttributeHandler ( ) ) ; } subsystem . registerXMLElementWriter ( JcaExtension . ConnectorSubsystemParser . INSTANCE ) ; } @ Override public void initializeParsers ( final ExtensionParsingContext context ) { } static final class ConnectorSubsystemParser implements XMLStreamConstants , XMLElementReader < List < ModelNode > > , XMLElementWriter < SubsystemMarshallingContext > { static final JcaExtension . ConnectorSubsystemParser INSTANCE = new JcaExtension . ConnectorSubsystemParser ( ) ; @ Override public void writeContent ( XMLExtendedStreamWriter writer , SubsystemMarshallingContext context ) throws XMLStreamException { } private void writeArchiveValidation ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } private void writeBeanValidation ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } private void writeCachedConnectionManager ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } private void writeWorkManagers ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } private void writeBootstrapContexts ( XMLExtendedStreamWriter writer , ModelNode parentNode ) throws XMLStreamException { } @ Override public void readElement ( final XMLExtendedStreamReader reader , final List < ModelNode > list ) throws XMLStreamException { } private ModelNode parseArchiveValidation ( final XMLExtendedStreamReader reader , final ModelNode parentOperation ) throws XMLStreamException { } private void parseWorkManager ( final XMLExtendedStreamReader reader , final ModelNode parentAddress , final List < ModelNode > list , final ModelNode node , boolean defaultWm ) throws XMLStreamException { } private ModelNode parseBeanValidation ( final XMLExtendedStreamReader reader , final ModelNode parentOperation ) throws XMLStreamException { } private ModelNode parseCcm ( final XMLExtendedStreamReader reader , final ModelNode parentOperation ) throws XMLStreamException { } private void parseBootstrapContexts ( final XMLExtendedStreamReader reader , final ModelNode parentAddress , final List < ModelNode > list ) throws XMLStreamException { } public String rawAttributeText ( XMLStreamReader reader , String attributeName ) { } } } 
class LRSProxyMap extends AbstractLRSProxyMap { private static final Localizer _loc = Localizer . forPackage ( LRSProxyMap . class ) ; private final LRSMapFieldStrategy _strat ; public LRSProxyMap ( LRSMapFieldStrategy strat ) { } protected synchronized int count ( ) { } protected boolean hasKey ( Object key ) { } protected boolean hasValue ( Object value ) { } private boolean has ( final Object obj , final boolean key ) { } protected Collection keys ( final Object obj ) { } protected Object value ( final Object obj ) { final OpenJPAStateManager sm = assertOwner ( ) ; final JDBCStore store = getStore ( ) ; if ( ( _strat . getFieldMapping ( ) . getElement ( ) . getValueMappedBy ( ) ) != null ) { Object val = _strat . deriveValue ( store , obj ) ; if ( hasValue ( val ) ) return val ; return null ; } final JDBCFetchConfiguration fetch = store . getFetchConfiguration ( ) ; final ClassMapping [ ] clss = _strat . getIndependentValueMappings ( true ) ; final Joins [ ] resJoins = new Joins [ Math . max ( 1 , clss . length ) ] ; Union union = store . getSQLFactory ( ) . newUnion ( Math . max ( 1 , clss . length ) ) ; <START_BUG> union . setSingleResult ( true ) ; <END_BUG> if ( ( fetch . getSubclassFetchMode ( _strat . getFieldMapping ( ) . getElementMapping ( ) . getTypeMapping ( ) ) ) != ( JDBCFetchConfiguration . EAGER_JOIN ) ) union . abortUnion ( ) ; union . select ( new Union . Selector ( ) { public void select ( Select sel , int idx ) { ClassMapping cls = ( ( clss . length ) == 0 ) ? null : clss [ idx ] ; sel . whereForeignKey ( _strat . getJoinForeignKey ( cls ) , sm . getObjectId ( ) , _strat . getFieldMapping ( ) . getDefiningMapping ( ) , store ) ; if ( ( _strat . getFieldMapping ( ) . getKey ( ) . getValueMappedBy ( ) ) != null ) resJoins [ idx ] = _strat . joinValueRelation ( sel . newJoins ( ) , cls ) ; Object key = _strat . toKeyDataStoreValue ( obj , store ) ; Column [ ] cols = _strat . getKeyColumns ( cls ) ; Object [ ] vals = ( ( cols . length ) == 1 ) ? null : ( ( Object [ ] ) ( key ) ) ; SQLBuffer sql = new SQLBuffer ( store . getDBDictionary ( ) ) ; for ( int i = 0 ; i < ( cols . length ) ; i ++ ) { if ( i > 0 ) sql . append ( "<seq2seq4repair_space>AND<seq2seq4repair_space>" ) ; sql . append ( sel . getColumnAlias ( cols [ i ] , resJoins [ idx ] ) ) ; if ( vals == null ) sql . append ( ( key == null ? "<seq2seq4repair_space>IS<seq2seq4repair_space>" : "<seq2seq4repair_space>=<seq2seq4repair_space>" ) ) . appendValue ( key , cols [ i ] ) ; else sql . append ( ( ( vals [ i ] ) == null ? "<seq2seq4repair_space>IS<seq2seq4repair_space>" : "<seq2seq4repair_space>=<seq2seq4repair_space>" ) ) . appendValue ( vals [ i ] , cols [ i ] ) ; } sel . where ( sql , resJoins [ idx ] ) ; if ( ( resJoins [ idx ] ) == null ) resJoins [ idx ] = _strat . joinValueRelation ( sel . newJoins ( ) , cls ) ; _strat . selectValue ( sel , cls , sm , store , fetch , resJoins [ idx ] ) ; } } ) ; Result res = null ; try { res = union . execute ( store , fetch ) ; if ( res . next ( ) ) return _strat . loadValue ( sm , store , fetch , res , resJoins [ res . indexOf ( ) ] ) ; return null ; } catch ( SQLException se ) { throw SQLExceptions . getStore ( se , store . getDBDictionary ( ) ) ; } finally { if ( res != null ) res . close ( ) ; } } protected Iterator itr ( ) { } private OpenJPAStateManager assertOwner ( ) { } private JDBCStore getStore ( ) { } private class ResultIterator implements Iterator , Closeable { private final OpenJPAStateManager _sm ; private final JDBCStore _store ; private final JDBCFetchConfiguration _fetch ; private final Result [ ] _res ; private final Joins [ ] _joins ; private Boolean _next = null ; public ResultIterator ( OpenJPAStateManager sm , JDBCStore store , JDBCFetchConfiguration fetch , Result [ ] res , Joins [ ] joins ) { } public boolean hasNext ( ) { } public Object next ( ) { } public void remove ( ) { } public void close ( ) { } } private static class Entry implements Map . Entry { public Object key ; public Object val ; public Object getKey ( ) { } public Object getValue ( ) { } public Object setValue ( Object val ) { } } } 
public abstract class DefaultCompilerAdapter extends AbstractLogEnabled implements CompilerAdapter { protected boolean m_debug ; protected boolean m_optimize ; protected boolean m_deprecation ; protected boolean m_depend ; protected boolean m_verbose ; protected Javac m_attributes ; protected Path m_bootclasspath ; protected Path m_compileClasspath ; protected File [ ] m_compileList ; protected File m_destDir ; protected String m_encoding ; protected Path m_extdirs ; protected boolean m_includeAntRuntime ; protected boolean m_includeJavaRuntime ; protected String m_memoryInitialSize ; protected String m_memoryMaximumSize ; protected File m_baseDir ; protected Path src ; protected String target ; public void setJavac ( Javac attributes ) { } public Javac getJavac ( ) { } protected Commandline setupJavacCommand ( ) throws TaskException { } protected Commandline setupJavacCommand ( boolean debugLevelCheck ) throws TaskException { } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd , boolean useDebugLevel ) throws TaskException { } protected Commandline setupModernJavacCommand ( ) throws TaskException { } protected Commandline setupModernJavacCommandlineSwitches ( Commandline cmd ) throws TaskException { } protected Path getCompileClasspath ( ) throws TaskException { } protected void addCurrentCompilerArgs ( Commandline cmd ) { } protected int executeExternalCompile ( String [ ] args , int firstFileName ) throws TaskException { String [ ] commandArray = null ; File tmpFile = null ; try { <START_BUG> if ( ( Commandline . toString ( args ) . length ( ) ) > 4096 ) { <END_BUG> PrintWriter out = null ; try { tmpFile = File . createTempFile ( "jikes" , "" , new File ( "." ) ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = firstFileName ; i < ( args . length ) ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ firstFileName + 1 ] ; System . arraycopy ( args , 0 , commandArray , 0 , firstFileName ) ; commandArray [ firstFileName ] = "@" + ( tmpFile . getAbsolutePath ( ) ) ; } catch ( IOException e ) { throw new TaskException ( "Error<seq2seq4repair_space>creating<seq2seq4repair_space>temporary<seq2seq4repair_space>file" , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = args ; } try { final Execute2 exe = new Execute2 ( ) ; setupLogger ( exe ) ; exe . setWorkingDirectory ( m_baseDir ) ; exe . setCommandline ( commandArray ) ; return exe . execute ( ) ; } catch ( IOException e ) { throw new TaskException ( ( ( "Error<seq2seq4repair_space>running<seq2seq4repair_space>" + ( args [ 0 ] ) ) + "<seq2seq4repair_space>compiler" ) , e ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } protected void logAndAddFilesToCompile ( Commandline cmd ) { } } 
public class CastExpression extends Expression { public Expression expression ; public Expression type ; public TypeBinding expectedType ; public CastExpression ( Expression expression , Expression type ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public static void checkNeedForAssignedCast ( BlockScope scope , TypeBinding expectedType , CastExpression rhs ) { } public static void checkNeedForEnclosingInstanceCast ( BlockScope scope , Expression enclosingInstance , TypeBinding enclosingInstanceType , TypeBinding memberType ) { } public static void checkNeedForArgumentCast ( BlockScope scope , int operator , int operatorSignature , Expression expression , int expressionTypeId ) { } public static void checkNeedForArgumentCasts ( BlockScope scope , Expression receiver , TypeBinding receiverType , MethodBinding binding , Expression [ ] arguments , TypeBinding [ ] argumentTypes , final InvocationSite invocationSite ) { } public static void checkNeedForArgumentCasts ( BlockScope scope , int operator , int operatorSignature , Expression left , int leftTypeId , boolean leftIsCast , Expression right , int rightTypeId , boolean rightIsCast ) { } private static void checkAlternateBinding ( BlockScope scope , Expression receiver , TypeBinding receiverType , MethodBinding binding , Expression [ ] arguments , TypeBinding [ ] originalArgumentTypes , TypeBinding [ ] alternateArgumentTypes , final InvocationSite invocationSite ) { } public boolean checkUnsafeCast ( Scope scope , TypeBinding castType , TypeBinding expressionType , TypeBinding match , boolean isNarrowing ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { int pc = codeStream . position ; boolean needRuntimeCheckcast = ( ( this . bits ) & ( ASTNode . GenerateCheckcast ) ) != 0 ; if ( ( constant ) != ( Constant . NotAConstant ) ) { if ( valueRequired || needRuntimeCheckcast ) { codeStream . generateConstant ( constant , implicitConversion ) ; if ( needRuntimeCheckcast ) { codeStream . checkcast ( this . resolvedType ) ; } if ( ! valueRequired ) { codeStream . pop ( ) ; } } codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; return ; } expression . generateCode ( currentScope , codeStream , ( valueRequired || needRuntimeCheckcast ) ) ; <START_BUG> if ( needRuntimeCheckcast && ( ( this . expression . postConversionType ( currentScope ) ) != ( this . resolvedType ) ) ) { <END_BUG> codeStream . checkcast ( this . resolvedType ) ; } if ( valueRequired ) { codeStream . generateImplicitConversion ( implicitConversion ) ; } else if ( needRuntimeCheckcast ) { codeStream . pop ( ) ; } codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; } public Expression innermostCastedExpression ( ) { } public LocalVariableBinding localVariableBinding ( ) { } public int nullStatus ( FlowInfo flowInfo ) { } public Constant optimizedBooleanConstant ( ) { } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveType ( BlockScope scope ) { } public void setExpectedType ( TypeBinding expectedType ) { } private boolean isIndirectlyUsed ( ) { } public void tagAsNeedCheckCast ( ) { } public void tagAsUnnecessaryCast ( Scope scope , TypeBinding castType ) { } public void traverse ( ASTVisitor visitor , BlockScope blockScope ) { } } 
public class ParameterData extends ItemData { Method method ; int parameter ; public ParameterData ( Method method , int parameter , String str ) { } public static String [ ] getAllFlags ( ) { <START_BUG> return new String [ ] { FLAG_NO_IN , FLAG_NO_OUT , FLAG_CRITICAL , FLAG_INIT , FLAG_STRUCT , FLAG_UNICODE , FLAG_SENTINEL } ; <END_BUG> } public String getCast ( ) { } public Method getMethod ( ) { } public int getParameter ( ) { } public void setCast ( String str ) { } } 
public class Sort { public static final Sort RELEVANCE = new Sort ( ) ; public static final Sort INDEXORDER = new Sort ( SortField . FIELD_DOC ) ; SortField [ ] fields ; public Sort ( ) { } public Sort ( SortField field ) { } public Sort ( SortField ... fields ) { } public void setSort ( SortField field ) { } public void setSort ( SortField ... fields ) { } public SortField [ ] getSort ( ) { } public Sort rewrite ( IndexSearcher searcher ) throws IOException { } @ Override public String toString ( ) { } @ Override public boolean equals ( Object o ) { } @ Override public int hashCode ( ) { } boolean needsScores ( ) { for ( SortField sortField : fields ) { <START_BUG> if ( ( sortField . getType ( ) ) == ( Type . SCORE ) ) { <END_BUG> return true ; } } return false ; } } 
public class ServiceActivatorDependencyProcessor implements DeploymentUnitProcessor { private static final String SERVICE_ACTIVATOR_PATH = "META-INF/services/" + ( ServiceActivator . class . getName ( ) ) ; private static final ModuleDependency MSC_DEP = new ModuleDependency ( null , ModuleIdentifier . create ( "org.jboss.msc" ) , false , false , false ) ; public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { <START_BUG> final ResourceRoot deploymentRoot = phaseContext . getAttachment ( DEPLOYMENT_ROOT ) ; <END_BUG> if ( deploymentRoot == null ) return ; if ( deploymentRoot . getRoot ( ) . getChild ( ServiceActivatorDependencyProcessor . SERVICE_ACTIVATOR_PATH ) . exists ( ) ) { phaseContext . putAttachment ( ATTACHMENT_KEY , new ServiceActivatorMarker ( ) ) ; phaseContext . addToAttachmentList ( MODULE_DEPENDENCIES , ServiceActivatorDependencyProcessor . MSC_DEP ) ; } } public void undeploy ( final DeploymentUnit context ) { } } 
public class SendMessageCommand extends Command { private SendMessageDialog sendMessageDialog ; private boolean showComposer = false ; private ComposerController composerController ; public SendMessageCommand ( ICommandReference reference ) { } private void showInvalidRecipientMessage ( String recipient ) { } private boolean validArguments ( ComposerCommandReference reference ) { } public void execute ( IWorkerStatusController worker ) throws Exception { ComposerCommandReference r = ( ( ComposerCommandReference ) ( getReference ( ) ) ) ; if ( ! ( validArguments ( r ) ) ) return ; worker . setDisplayText ( MailResourceLoader . getString ( "statusbar" , "message" , "send_message_compose" ) ) ; composerController = r . getComposerController ( ) ; if ( ( composerController . getView ( ) . getFrame ( ) ) != null ) { composerController . getView ( ) . getFrame ( ) . setVisible ( false ) ; } sendMessageDialog = new SendMessageDialog ( worker ) ; ComposerModel model = ( ( ComposerModel ) ( composerController . getModel ( ) ) ) ; AccountItem item = model . getAccountItem ( ) ; AbstractMessageFolder sentFolder = ( ( AbstractMessageFolder ) ( FolderTreeModel . getInstance ( ) . getFolder ( item . getSpecialFoldersItem ( ) . getInteger ( "sent" ) ) ) ) ; SendableMessage message = null ; try { <START_BUG> message = new org . columba . mail . composer . MessageComposer ( model ) . compose ( worker ) ; <END_BUG> } catch ( JSCFException e1 ) { if ( e1 instanceof CancelledException ) { showComposer = true ; return ; } else { JOptionPane . showMessageDialog ( null , e1 . getMessage ( ) ) ; showComposer = true ; return ; } } worker . setDisplayText ( MailResourceLoader . getString ( "statusbar" , "message" , "send_message_connect" ) ) ; final SMTPServer server = new SMTPServer ( item ) ; try { worker . setDisplayText ( MailResourceLoader . getString ( "statusbar" , "message" , "send_message" ) ) ; IWorkerStatusChangeListener listener = new IWorkerStatusChangeListener ( ) { public void workerStatusChanged ( WorkerStatusChangedEvent e ) { if ( e . getSource ( ) . cancelled ( ) ) { try { server . dropConnection ( ) ; } catch ( IOException e1 ) { } } } } ; worker . addWorkerStatusChangeListener ( listener ) ; server . sendMessage ( message , worker ) ; worker . removeWorkerStatusChangeListener ( listener ) ; if ( worker . cancelled ( ) ) { showComposer = true ; return ; } Flags flags = new Flags ( ) ; flags . setSeen ( true ) ; message . getHeader ( ) . setFlags ( flags ) ; ComposerCommandReference ref = new ComposerCommandReference ( composerController , sentFolder ) ; ref . setMessage ( message ) ; SaveMessageCommand c = new SaveMessageCommand ( ref ) ; CommandProcessor . getInstance ( ) . addOp ( c ) ; MailFolderCommandReference ref2 = model . getSourceReference ( ) ; if ( ( ref2 != null ) && ( ( ( IMailbox ) ( ref2 . getSourceFolder ( ) ) ) . exists ( ref2 . getUids ( ) [ 0 ] ) ) ) { ref2 . setMarkVariant ( MARK_AS_ANSWERED ) ; MarkMessageCommand c1 = new MarkMessageCommand ( ref2 ) ; CommandProcessor . getInstance ( ) . addOp ( c1 ) ; } worker . setDisplayText ( MailResourceLoader . getString ( "statusbar" , "message" , "send_message_closing" ) ) ; server . closeConnection ( ) ; worker . setDisplayText ( MailResourceLoader . getString ( "statusbar" , "message" , "send_message_success" ) ) ; } catch ( Exception e ) { showComposer = true ; throw e ; } } public void updateGUI ( ) throws Exception { } } 
public class SendMessageDialog extends JDialog implements ActionListener , WorkerStatusChangeListener { private JProgressBar progressBar ; private JButton cancelButton ; private JLabel label ; private WorkerStatusController worker ; public SendMessageDialog ( WorkerStatusController worker ) throws HeadlessException { } protected void initComponents ( ) { } protected void layoutComponents ( ) { } public void workerStatusChanged ( WorkerStatusChangedEvent e ) { } public void actionPerformed ( ActionEvent arg0 ) { <START_BUG> if ( arg0 . equals ( "CANCEL" ) ) { <END_BUG> worker . cancel ( ) ; setVisible ( false ) ; } } public void setWorker ( WorkerStatusController worker ) { } } 
public class ForStatement extends Statement { public Statement [ ] initializations ; public Expression condition ; public Statement [ ] increments ; public Statement action ; public boolean neededScope ; public BlockScope scope ; private Label breakLabel ; private Label continueLabel ; int preCondInitStateIndex = - 1 ; int condIfTrueInitStateIndex = - 1 ; int mergedInitStateIndex = - 1 ; public ForStatement ( Statement [ ] initializations , Expression condition , Statement [ ] increments , Statement action , boolean neededScope , int s , int e ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { breakLabel = new Label ( ) ; continueLabel = new Label ( ) ; if ( ( initializations ) != null ) { int count = initializations . length ; int i = 0 ; while ( i < count ) { flowInfo = initializations [ ( i ++ ) ] . analyseCode ( scope , flowContext , flowInfo ) ; } } preCondInitStateIndex = currentScope . methodScope ( ) . recordInitializationStates ( flowInfo ) ; boolean conditionIsInlinedToTrue = ( ( condition ) == null ) || ( ( ( condition . constant ) != ( NotAConstant ) ) && ( ( condition . constant . booleanValue ( ) ) == true ) ) ; boolean conditionIsInlinedToFalse = ( ! conditionIsInlinedToTrue ) && ( ( ( condition . constant ) != ( NotAConstant ) ) && ( ( condition . constant . booleanValue ( ) ) == false ) ) ; LoopingFlowContext condLoopContext = null ; if ( ( condition ) != null ) { if ( ! conditionIsInlinedToTrue ) { flowInfo = condition . analyseCode ( scope , ( condLoopContext = new LoopingFlowContext ( flowContext , this , null , null , scope ) ) , flowInfo ) ; } } LoopingFlowContext loopingContext ; FlowInfo actionInfo ; if ( ( ( action ) == null ) || ( action . isEmptyBlock ( ) ) ) { if ( condLoopContext != null ) condLoopContext . complainOnFinalAssignmentsInLoop ( scope , flowInfo ) ; if ( conditionIsInlinedToTrue ) { return DeadEnd ; } else { if ( conditionIsInlinedToFalse ) { continueLabel = null ; } actionInfo = flowInfo . initsWhenTrue ( ) . copy ( ) ; loopingContext = new LoopingFlowContext ( flowContext , this , breakLabel , continueLabel , scope ) ; } } else { loopingContext = new LoopingFlowContext ( flowContext , this , breakLabel , continueLabel , scope ) ; FlowInfo initsWhenTrue = flowInfo . initsWhenTrue ( ) ; condIfTrueInitStateIndex = currentScope . methodScope ( ) . recordInitializationStates ( initsWhenTrue ) ; actionInfo = ( conditionIsInlinedToFalse ) ? DeadEnd : initsWhenTrue . copy ( ) ; <START_BUG> if ( ! ( actionInfo . complainIfUnreachable ( action , scope ) ) ) { <END_BUG> actionInfo = action . analyseCode ( scope , loopingContext , actionInfo ) ; } if ( ( ( actionInfo == ( DeadEnd ) ) || ( actionInfo . isFakeReachable ( ) ) ) && ( ( ( loopingContext . initsOnContinue ) == ( DeadEnd ) ) || ( loopingContext . initsOnContinue . isFakeReachable ( ) ) ) ) { continueLabel = null ; } else { if ( condLoopContext != null ) condLoopContext . complainOnFinalAssignmentsInLoop ( scope , flowInfo ) ; loopingContext . complainOnFinalAssignmentsInLoop ( scope , actionInfo ) ; actionInfo = actionInfo . mergedWith ( loopingContext . initsOnContinue . unconditionalInits ( ) ) ; } } if ( ( ( continueLabel ) != null ) && ( ( increments ) != null ) ) { LoopingFlowContext loopContext = new LoopingFlowContext ( flowContext , this , null , null , scope ) ; int i = 0 ; int count = increments . length ; while ( i < count ) actionInfo = increments [ ( i ++ ) ] . analyseCode ( scope , loopContext , actionInfo ) ; loopContext . complainOnFinalAssignmentsInLoop ( scope , flowInfo ) ; } FlowInfo mergedInfo ; if ( conditionIsInlinedToTrue ) { mergedInitStateIndex = currentScope . methodScope ( ) . recordInitializationStates ( ( mergedInfo = loopingContext . initsOnBreak ) ) ; return mergedInfo ; } mergedInfo = flowInfo . initsWhenFalse ( ) . unconditionalInits ( ) . mergedWith ( loopingContext . initsOnBreak . unconditionalInits ( ) ) ; mergedInitStateIndex = currentScope . methodScope ( ) . recordInitializationStates ( mergedInfo ) ; return mergedInfo ; } public void generateCode ( BlockScope currentScope , CodeStream codeStream ) { } public void resetStateForCodeGeneration ( ) { } public void resolve ( BlockScope upperScope ) { } public String toString ( int tab ) { } public void traverse ( IAbstractSyntaxTreeVisitor visitor , BlockScope blockScope ) { } } 
public class CollectionProperty extends MultiProperty { protected Collection value ; private Collection savedValue ; public CollectionProperty ( String name , Collection value ) { } public CollectionProperty ( ) { } public boolean equals ( Object o ) { } public void remove ( String prop ) { } public void set ( int index , String prop ) { } public void set ( int index , JMeterProperty prop ) { } public JMeterProperty get ( int row ) { } public void remove ( int index ) { } public void setObjectValue ( Object v ) { } public PropertyIterator iterator ( ) { <START_BUG> return new PropertyIteratorImpl ( value ) ; <END_BUG> } public String getStringValue ( ) { } public Object getObjectValue ( ) { } public int size ( ) { } public Object clone ( ) { } private Collection cloneCollection ( ) { } public void setCollection ( Collection coll ) { } public void clear ( ) { } public void addProperty ( JMeterProperty prop ) { } public void addItem ( Object item ) { } protected Class getPropertyType ( ) { } public void recoverRunningVersion ( TestElement owner ) { } public static class Test extends JMeterTestCase { public Test ( String name ) { } public void testAddingProperties ( ) throws Exception { } } public void setRunningVersion ( boolean running ) { } } 
final class Behaviors implements IDetachable { private static final long serialVersionUID = 1L ; private final Component component ; public Behaviors ( Component component ) { } public void add ( Behavior ... behaviors ) { } private void internalAdd ( final Behavior behavior ) { component . data_add ( behavior ) ; <START_BUG> if ( behavior . isStateless ( component ) ) { <END_BUG> getBehaviorId ( behavior ) ; } } @ SuppressWarnings ( "unchecked" ) public < M extends Behavior > List < M > getBehaviors ( Class < M > type ) { } public void remove ( Behavior behavior ) { } public final void detach ( ) { } private boolean internalRemove ( final Behavior behavior ) { } private void removeBehaviorsIdList ( ) { } private Behaviors . BehaviorIdList getBehaviorsIdList ( boolean createIfNotFound ) { } private static class BehaviorIdList extends ArrayList < Behavior > { private static final long serialVersionUID = 1L ; public BehaviorIdList ( ) { } } public final int getBehaviorId ( Behavior behavior ) { } public final Behavior getBehaviorById ( int id ) { } } 
public class CoreContainer { protected static Logger log = Logger . getLogger ( CoreContainer . class . getName ( ) ) ; protected final Map < String , SolrCore > cores = new LinkedHashMap < String , SolrCore > ( ) ; protected boolean persistent = false ; protected String adminPath = null ; protected String managementPath = null ; protected CoreAdminHandler coreAdminHandler = null ; protected File configFile = null ; protected String libDir = null ; protected ClassLoader libLoader = null ; protected SolrResourceLoader loader = null ; protected WeakReference < SolrCore > adminCore = null ; protected Properties containerProperties ; public CoreContainer ( ) { } public Properties getContainerProperties ( ) { } public static class Initializer { protected String solrConfigFilename = null ; protected boolean abortOnConfigurationError = true ; public boolean isAbortOnConfigurationError ( ) { } public void setAbortOnConfigurationError ( boolean abortOnConfigurationError ) { } public String getSolrConfigFilename ( ) { } public void setSolrConfigFilename ( String solrConfigFilename ) { } public CoreContainer initialize ( ) throws IOException , ParserConfigurationException , SAXException { CoreContainer cores = null ; String instanceDir = SolrResourceLoader . locateInstanceDir ( ) ; File fconf = new File ( instanceDir , ( ( solrConfigFilename ) == null ? "solr.xml" : solrConfigFilename ) ) ; CoreContainer . log . info ( ( "looking<seq2seq4repair_space>for<seq2seq4repair_space>solr.xml:<seq2seq4repair_space>" + ( fconf . getAbsolutePath ( ) ) ) ) ; if ( fconf . exists ( ) ) { cores = new CoreContainer ( ) ; cores . load ( instanceDir , fconf ) ; abortOnConfigurationError = false ; for ( SolrCore c : cores . getCores ( ) ) { if ( c . getSolrConfig ( ) . getBool ( "abortOnConfigurationError" , false ) ) { abortOnConfigurationError = true ; break ; } } solrConfigFilename = cores . getConfigFile ( ) . getName ( ) ; } else { cores = new CoreContainer ( new SolrResourceLoader ( instanceDir ) ) ; SolrConfig cfg = ( ( solrConfigFilename ) == null ) ? new SolrConfig ( ) : new SolrConfig ( solrConfigFilename ) ; <START_BUG> CoreDescriptor dcore = new CoreDescriptor ( cores , "" , cfg . getResourceLoader ( ) . getInstanceDir ( ) ) ; <END_BUG> SolrCore singlecore = new SolrCore ( null , null , cfg , null , dcore ) ; abortOnConfigurationError = cfg . getBool ( "abortOnConfigurationError" , abortOnConfigurationError ) ; cores . register ( "" , singlecore , false ) ; cores . setPersistent ( false ) ; solrConfigFilename = cfg . getName ( ) ; } return cores ; } } public CoreContainer ( String dir , File configFile ) throws IOException , ParserConfigurationException , SAXException { } public CoreContainer ( SolrResourceLoader loader ) { } public void load ( String dir , File configFile ) throws IOException , ParserConfigurationException , SAXException { } private Properties readProperties ( Config cfg , Node node ) throws XPathExpressionException { } public void shutdown ( ) { } @ Override protected void finalize ( ) { } public SolrCore register ( String name , SolrCore core , boolean returnPrev ) { } public SolrCore create ( CoreDescriptor dcore ) throws IOException , ParserConfigurationException , SAXException { } public Collection < SolrCore > getCores ( ) { } public Collection < String > getCoreNames ( ) { } public Collection < String > getCoreNames ( SolrCore core ) { } public void reload ( String name ) throws IOException , ParserConfigurationException , SAXException { } public void swap ( String n0 , String n1 ) { } public SolrCore remove ( String name ) { } public SolrCore getCore ( String name ) { } public void setAdminCore ( SolrCore core ) { } public SolrCore getAdminCore ( ) { } protected CoreAdminHandler createMultiCoreHandler ( ) { } public CoreAdminHandler getMultiCoreHandler ( ) { } public boolean isPersistent ( ) { } public void setPersistent ( boolean persistent ) { } public String getAdminPath ( ) { } public void setAdminPath ( String adminPath ) { } public String getManagementPath ( ) { } public void setManagementPath ( String path ) { } public File getConfigFile ( ) { } public void persist ( ) { } public void persistFile ( File file ) { } void persist ( Writer writer ) throws IOException { } void persist ( Writer writer , List < String > aliases , CoreDescriptor dcore ) throws IOException { } private void writeProperties ( Writer writer , Properties props ) throws IOException { } public static void fileCopy ( File src , File dest ) throws IOException { } } 
public class ArrayInitializer extends Expression { public Expression [ ] expressions ; public ArrayBinding binding ; public ArrayInitializer ( ) { } public FlowInfo analyseCode ( BlockScope currentScope , FlowContext flowContext , FlowInfo flowInfo ) { } public void generateCode ( BlockScope currentScope , CodeStream codeStream , boolean valueRequired ) { int pc = codeStream . position ; int expressionLength = ( ( expressions ) == null ) ? 0 : expressions . length ; codeStream . generateInlinedValue ( expressionLength ) ; <START_BUG> codeStream . newArray ( currentScope , binding ) ; <END_BUG> if ( ( expressions ) != null ) { int elementsTypeID = ( ( binding . dimensions ) > 1 ) ? - 1 : binding . leafComponentType . id ; for ( int i = 0 ; i < expressionLength ; i ++ ) { Expression expr ; if ( ( ( expr = expressions [ i ] ) . constant ) != ( NotAConstant ) ) { switch ( elementsTypeID ) { case TypeIds . T_int : case TypeIds . T_short : case TypeIds . T_byte : case TypeIds . T_char : case TypeIds . T_long : if ( ( expr . constant . longValue ( ) ) != 0 ) { codeStream . dup ( ) ; codeStream . generateInlinedValue ( i ) ; expr . generateCode ( currentScope , codeStream , true ) ; codeStream . arrayAtPut ( elementsTypeID , false ) ; } break ; case TypeIds . T_float : case TypeIds . T_double : double constantValue = expr . constant . doubleValue ( ) ; if ( ( constantValue == ( - 0.0 ) ) || ( constantValue != 0 ) ) { codeStream . dup ( ) ; codeStream . generateInlinedValue ( i ) ; expr . generateCode ( currentScope , codeStream , true ) ; codeStream . arrayAtPut ( elementsTypeID , false ) ; } break ; case TypeIds . T_boolean : if ( ( expr . constant . booleanValue ( ) ) != false ) { codeStream . dup ( ) ; codeStream . generateInlinedValue ( i ) ; expr . generateCode ( currentScope , codeStream , true ) ; codeStream . arrayAtPut ( elementsTypeID , false ) ; } break ; default : if ( ! ( expr instanceof NullLiteral ) ) { codeStream . dup ( ) ; codeStream . generateInlinedValue ( i ) ; expr . generateCode ( currentScope , codeStream , true ) ; codeStream . arrayAtPut ( elementsTypeID , false ) ; } } } else if ( ! ( expr instanceof NullLiteral ) ) { codeStream . dup ( ) ; codeStream . generateInlinedValue ( i ) ; expr . generateCode ( currentScope , codeStream , true ) ; codeStream . arrayAtPut ( elementsTypeID , false ) ; } } } if ( ! valueRequired ) { codeStream . pop ( ) ; } codeStream . recordPositionsFrom ( pc , this . sourceStart ) ; } public StringBuffer printExpression ( int indent , StringBuffer output ) { } public TypeBinding resolveTypeExpecting ( BlockScope scope , TypeBinding expectedTb ) { } public void traverse ( ASTVisitor visitor , BlockScope scope ) { } } 
public class ReferencePointcut extends Pointcut { public TypeX onType ; public TypePattern onTypeSymbolic ; public String name ; public TypePatternList arguments ; public ReferencePointcut ( TypePattern onTypeSymbolic , String name , TypePatternList arguments ) { } public ReferencePointcut ( TypeX onType , String name , TypePatternList arguments ) { } public boolean fastMatch ( JavaClass jc ) { } public FuzzyBoolean match ( Shadow shadow ) { } public String toString ( ) { } public void write ( DataOutputStream s ) throws IOException { } public static Pointcut read ( DataInputStream s , ISourceContext context ) throws IOException { } public void resolveBindings ( IScope scope , Bindings bindings ) { if ( ( onTypeSymbolic ) != null ) { onType = onTypeSymbolic . resolveExactType ( scope , bindings ) ; } ResolvedTypeX searchType ; if ( ( onType ) != null ) { searchType = scope . getWorld ( ) . resolve ( onType ) ; } else { searchType = scope . getEnclosingType ( ) ; } arguments . resolveBindings ( scope , bindings , true , true ) ; ResolvedPointcutDefinition pointcutDef = searchType . findPointcut ( name ) ; <START_BUG> if ( ( onType ) == null ) { <END_BUG> while ( true ) { TypeX declaringType = searchType . getDeclaringType ( ) ; if ( declaringType == null ) break ; searchType = declaringType . resolve ( scope . getWorld ( ) ) ; pointcutDef = searchType . findPointcut ( name ) ; if ( pointcutDef != null ) { onType = searchType ; break ; } } } if ( pointcutDef == null ) { scope . message ( ERROR , this , "can't<seq2seq4repair_space>find<seq2seq4repair_space>referenced<seq2seq4repair_space>pointcut" ) ; return ; } if ( ! ( pointcutDef . isVisible ( scope . getEnclosingType ( ) ) ) ) { scope . message ( ERROR , this , ( ( "pointcut<seq2seq4repair_space>declaration<seq2seq4repair_space>" + pointcutDef ) + "<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>accessible" ) ) ; return ; } if ( Modifier . isAbstract ( pointcutDef . getModifiers ( ) ) ) { if ( ( onType ) != null ) { scope . message ( ERROR , this , "can't<seq2seq4repair_space>make<seq2seq4repair_space>static<seq2seq4repair_space>reference<seq2seq4repair_space>to<seq2seq4repair_space>abstract<seq2seq4repair_space>pointcut" ) ; return ; } else if ( ! ( searchType . isAbstract ( ) ) ) { scope . message ( ERROR , this , "can't<seq2seq4repair_space>use<seq2seq4repair_space>abstract<seq2seq4repair_space>pointcut<seq2seq4repair_space>in<seq2seq4repair_space>concrete<seq2seq4repair_space>context" ) ; return ; } } ResolvedTypeX [ ] parameterTypes = scope . getWorld ( ) . resolve ( pointcutDef . getParameterTypes ( ) ) ; if ( ( parameterTypes . length ) != ( arguments . size ( ) ) ) { scope . message ( ERROR , this , ( ( ( "incompatible<seq2seq4repair_space>number<seq2seq4repair_space>of<seq2seq4repair_space>arguments<seq2seq4repair_space>to<seq2seq4repair_space>pointcut,<seq2seq4repair_space>expected<seq2seq4repair_space>" + ( parameterTypes . length ) ) + "<seq2seq4repair_space>found<seq2seq4repair_space>" ) + ( arguments . size ( ) ) ) ) ; return ; } for ( int i = 0 , len = arguments . size ( ) ; i < len ; i ++ ) { TypePattern p = arguments . get ( i ) ; if ( p == ( TypePattern . NO ) ) { scope . message ( ERROR , this , "bad<seq2seq4repair_space>parameter<seq2seq4repair_space>to<seq2seq4repair_space>pointcut<seq2seq4repair_space>reference" ) ; return ; } if ( ( ! ( p . matchesSubtypes ( parameterTypes [ i ] ) ) ) && ( ! ( p . getExactType ( ) . equals ( OBJECT ) ) ) ) { scope . message ( ERROR , p , ( ( ( "incompatible<seq2seq4repair_space>type,<seq2seq4repair_space>expected<seq2seq4repair_space>" + ( parameterTypes [ i ] . getName ( ) ) ) + "<seq2seq4repair_space>found<seq2seq4repair_space>" ) + p ) ) ; return ; } } } public void postRead ( ResolvedTypeX enclosingType ) { } public Test findResidue ( Shadow shadow , ExposedState state ) { } private boolean concretizing = false ; public Pointcut concretize1 ( ResolvedTypeX searchStart , IntMap bindings ) { } public boolean equals ( Object other ) { } public int hashCode ( ) { } } 
public class PathFileList implements FileList { private String m_path ; public void setPath ( final String path ) { } public FileObject [ ] listFiles ( final TaskContext context ) throws TaskException { FileSystemManager fileSystemManager = ( ( FileSystemManager ) ( context . getService ( FileSystemManager . class ) ) ) ; final String [ ] elements = FileUtils . parsePath ( m_path ) ; final FileObject [ ] result = new FileObject [ elements . length ] ; for ( int i = 0 ; i < ( elements . length ) ; i ++ ) { String element = elements [ i ] ; try { <START_BUG> result [ i ] = fileSystemManager . resolveFile ( element ) ; <END_BUG> } catch ( FileSystemException e ) { throw new TaskException ( e . getMessage ( ) , e ) ; } } return result ; } } 
public class SessionManagerAdapterTestCase { private final SessionManager < LocalSessionContext > manager = mock ( SessionManager . class ) ; private final SessionListener listener = mock ( SessionListener . class ) ; private SessionManagerAdapter adapter = new SessionManagerAdapter ( this . manager ) ; @ Before public void init ( ) { } @ Test public void parse ( ) { } @ Test public void format ( ) { } @ Test public void start ( ) { } @ Test public void stop ( ) { } @ Test public void setDefaultSessionTimeout ( ) { } @ Test public void createSessionNoSessionId ( ) { } @ Test public void createSessionSpecifiedSessionId ( ) { } @ Test public void createSessionAlreadyExists ( ) { } @ Test public void getSession ( ) { } @ Test public void getSessionNoSessionId ( ) { } @ Test public void getSessionNotExists ( ) { HttpServerExchange exchange = new HttpServerExchange ( null ) ; Batcher batcher = mock ( Batcher . class ) ; Batch batch = mock ( Batch . class ) ; SessionConfig config = mock ( SessionConfig . class ) ; String requestedSessionId = "session.route1" ; String sessionId = "session" ; when ( config . findSessionId ( exchange ) ) . thenReturn ( requestedSessionId ) ; when ( this . manager . findSession ( sessionId ) ) . thenReturn ( null ) ; when ( this . manager . getBatcher ( ) ) . thenReturn ( batcher ) ; when ( batcher . startBatch ( ) ) . thenReturn ( batch ) ; Session sessionAdapter = this . adapter . getSession ( exchange , config ) ; assertNull ( sessionAdapter ) ; <START_BUG> verify ( batch ) . discard ( ) ; <END_BUG> } @ Test public void activeSessions ( ) { } @ Test public void getTransientSessions ( ) { } @ Test public void getActiveSessions ( ) { } @ Test public void getAllSessions ( ) { } @ Test public void getSessionByIdentifier ( ) { } @ Test public void getSessionByIdentifierNotExists ( ) { } } 
public class RunTestNotifier extends Notifier { private final Statement fNext ; public RunTestNotifier ( Statement next ) { } @ Override public void run ( EachTestNotifier context ) { context . fireTestStarted ( ) ; try { fNext . evaluate ( ) ; } catch ( AssumptionViolatedException e ) { <START_BUG> context . addIgnorance ( e ) ; <END_BUG> } catch ( Throwable e ) { context . addFailure ( e ) ; } finally { context . fireTestFinished ( ) ; } } } 
public class FormInputTest extends WebTestCase { public FormInputTest ( String name ) { } public void setUp ( ) throws Exception { } public void testHelloWorld ( ) { beginAt ( "/forminput" ) ; <START_BUG> assertTitleEquals ( "Wicket<seq2seq4repair_space>-<seq2seq4repair_space>Form<seq2seq4repair_space>Input<seq2seq4repair_space>Example" ) ; <END_BUG> } public static Test suite ( ) { } } 
public class FileSet extends DataType implements Cloneable { private PatternSet defaultPatterns = new PatternSet ( ) ; private Vector additionalPatterns = new Vector ( ) ; private File dir ; private boolean useDefaultExcludes = true ; private boolean isCaseSensitive = true ; private String dataTypeName = "fileset" ; public FileSet ( ) { } protected FileSet ( FileSet fileset ) { } public void setRefid ( Reference r ) throws BuildException { } public void setDir ( File dir ) throws BuildException { } public File getDir ( Project p ) { } public PatternSet createPatternSet ( ) { } public NameEntry createInclude ( ) { } public NameEntry createIncludesFile ( ) { } public NameEntry createExclude ( ) { } public NameEntry createExcludesFile ( ) { } public void setIncludes ( String includes ) { } public void setExcludes ( String excludes ) { } public void setIncludesfile ( File incl ) throws BuildException { } public void setExcludesfile ( File excl ) throws BuildException { } public void setDefaultexcludes ( boolean useDefaultExcludes ) { } public void setCaseSensitive ( boolean isCaseSensitive ) { } protected final void setDataTypeName ( String name ) { } public DirectoryScanner getDirectoryScanner ( Project p ) { } public void setupDirectoryScanner ( FileScanner ds , Project p ) { } protected FileSet getRef ( Project p ) { if ( ! ( checked ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; <START_BUG> if ( ! ( o . getClass ( ) . equals ( getClass ( ) ) ) ) { <END_BUG> String msg = ( ( ref . getRefId ( ) ) + "<seq2seq4repair_space>doesn\'t<seq2seq4repair_space>denote<seq2seq4repair_space>a<seq2seq4repair_space>" ) + ( dataTypeName ) ; throw new BuildException ( msg ) ; } else { return ( ( FileSet ) ( o ) ) ; } } public Object clone ( ) { } } 
public class CustomResourceLoadingApplication extends WicketExampleApplication { private static final Log log = LogFactory . getLog ( CustomResourceLoadingApplication . class ) ; private final class CustomResourceStreamLocator extends AbstractResourceStreamLocator { private ClassLoaderResourceStreamLocator classLoaderLocator = new ClassLoaderResourceStreamLocator ( ) ; protected IResourceStream locate ( Class clazz , String path ) { if ( CustomResourceLoadingApplication . log . isDebugEnabled ( ) ) { CustomResourceLoadingApplication . log . debug ( ( ( "Attempting<seq2seq4repair_space>to<seq2seq4repair_space>locate<seq2seq4repair_space>resource<seq2seq4repair_space>'" + path ) + "'<seq2seq4repair_space>using<seq2seq4repair_space>classloader<seq2seq4repair_space>the<seq2seq4repair_space>servlet<seq2seq4repair_space>context" ) ) ; } String location ; if ( clazz == ( AlternativePageFromWebContext . class ) ) { String extension = path . substring ( ( ( path . lastIndexOf ( '.' ) ) + 1 ) ) ; String simpleFileName = Strings . lastPathComponent ( clazz . getName ( ) , '.' ) ; location = ( ( "/WEB-INF/templates/" + simpleFileName ) + "." ) + extension ; } else { location = "/WEB-INF/templates/" + path ; } URL url ; try { <START_BUG> url = getWicketServlet ( ) . getServletContext ( ) . getResource ( location ) ; <END_BUG> if ( url != null ) { return new UrlResourceStream ( url ) ; } } catch ( MalformedURLException e ) { throw new WicketRuntimeException ( e ) ; } return classLoaderLocator . locate ( clazz , path ) ; } } public CustomResourceLoadingApplication ( ) { } public Class getHomePage ( ) { } protected void init ( ) { } } 
public class ResourceAvailableCondition extends AbstractAvailableCondition implements Condition { private String m_resource ; public void setResource ( final String resource ) { } public boolean evaluate ( final TaskContext context ) throws TaskException { if ( ( m_resource ) == null ) { throw new TaskException ( "Resource<seq2seq4repair_space>was<seq2seq4repair_space>not<seq2seq4repair_space>specified." ) ; } <START_BUG> final ClassLoader classLoader = buildClassLoader ( ) ; <END_BUG> final InputStream instr = classLoader . getResourceAsStream ( m_resource ) ; if ( instr != null ) { IOUtil . shutdownStream ( instr ) ; return true ; } return false ; } } 
public class RuntimeMXBeanReadResourceHandler implements OperationStepHandler { public static final RuntimeMXBeanReadResourceHandler INSTANCE = new RuntimeMXBeanReadResourceHandler ( ) ; private RuntimeMXBeanReadResourceHandler ( ) { } @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { final ModelNode result = context . getResult ( ) ; for ( String attribute : PlatformMBeanConstants . RUNTIME_READ_ATTRIBUTES ) { final ModelNode store = result . get ( attribute ) ; try { RuntimeMXBeanAttributeHandler . storeResult ( attribute , store ) ; } catch ( SecurityException ignored ) { } catch ( UnsupportedOperationException ignored ) { } } for ( String attribute : PlatformMBeanConstants . RUNTIME_METRICS ) { final ModelNode store = result . get ( attribute ) ; try { RuntimeMXBeanAttributeHandler . storeResult ( attribute , store ) ; } catch ( SecurityException ignored ) { } catch ( UnsupportedOperationException ignored ) { } } if ( ( PlatformMBeanUtil . JVM_MAJOR_VERSION ) > 6 ) { final ModelNode store = result . get ( OBJECT_NAME ) ; RuntimeMXBeanAttributeHandler . storeResult ( OBJECT_NAME , store ) ; } <START_BUG> context . completeStep ( NOOP_ROLLBACK_HANDLER ) ; <END_BUG> } } 
final class Behaviors implements IDetachable { private static final long serialVersionUID = 1L ; private final Component component ; public Behaviors ( Component component ) { } public void add ( Behavior ... behaviors ) { } private void internalAdd ( final Behavior behavior ) { component . data_add ( behavior ) ; <START_BUG> if ( ! ( behavior . getStatelessHint ( component ) ) ) { <END_BUG> getBehaviorId ( behavior ) ; } } @ SuppressWarnings ( "unchecked" ) public < M extends Behavior > List < M > getBehaviors ( Class < M > type ) { } public void remove ( Behavior behavior ) { } public final void detach ( ) { } private boolean internalRemove ( final Behavior behavior ) { } private void removeBehaviorsIdList ( ) { } private Behaviors . BehaviorIdList getBehaviorsIdList ( boolean createIfNotFound ) { } private static class BehaviorIdList extends ArrayList < Behavior > { private static final long serialVersionUID = 1L ; public BehaviorIdList ( ) { } } public final int getBehaviorId ( Behavior behavior ) { } public final Behavior getBehaviorById ( int id ) { } } 
public class PackageDeclaration extends ASTNode { public static final ChildPropertyDescriptor JAVADOC_PROPERTY = new ChildPropertyDescriptor ( PackageDeclaration . class , "javadoc" , Javadoc . class , ASTNode . OPTIONAL , ASTNode . NO_CYCLE_RISK ) ; public static final ChildListPropertyDescriptor ANNOTATIONS_PROPERTY = new ChildListPropertyDescriptor ( PackageDeclaration . class , "annotations" , Annotation . class , ASTNode . CYCLE_RISK ) ; public static final ChildPropertyDescriptor NAME_PROPERTY = new ChildPropertyDescriptor ( PackageDeclaration . class , "name" , Name . class , ASTNode . MANDATORY , ASTNode . NO_CYCLE_RISK ) ; private static final List PROPERTY_DESCRIPTORS_2_0 ; private static final List PROPERTY_DESCRIPTORS_3_0 ; public static List propertyDescriptors ( int apiLevel ) { } Javadoc optionalDocComment = null ; private ASTNode . NodeList annotations = null ; private Name packageName = null ; PackageDeclaration ( AST ast ) { } final List internalStructuralPropertiesForType ( int apiLevel ) { } final ASTNode internalGetSetChildProperty ( ChildPropertyDescriptor property , boolean get , ASTNode child ) { } final List internalGetChildListProperty ( ChildListPropertyDescriptor property ) { } final int getNodeType0 ( ) { } ASTNode clone0 ( AST target ) { } final boolean subtreeMatch0 ( ASTMatcher matcher , Object other ) { } void accept0 ( ASTVisitor visitor ) { } public List annotations ( ) { } public Javadoc getJavadoc ( ) { } public void setJavadoc ( Javadoc docComment ) { } public Name getName ( ) { if ( ( this . packageName ) == null ) { <START_BUG> synchronized ( this . ast ) { <END_BUG> if ( ( this . packageName ) == null ) { preLazyInit ( ) ; this . packageName = new SimpleName ( this . ast ) ; postLazyInit ( this . packageName , PackageDeclaration . NAME_PROPERTY ) ; } } } return this . packageName ; } public void setName ( Name name ) { } public IPackageBinding resolveBinding ( ) { } int memSize ( ) { } int treeSize ( ) { } } 
public class AddNamespaceHandler implements ModelUpdateOperationHandler , DescriptionProvider { public static final String OPERATION_NAME = "add-namespace" ; public static final AddNamespaceHandler INSTANCE = new AddNamespaceHandler ( ) ; public static ModelNode getAddNamespaceOperation ( ModelNode address , ModelNode namespace ) { } private final ParameterValidator typeValidator = new org . jboss . as . controller . operations . validation . ModelTypeValidator ( ModelType . PROPERTY ) ; private AddNamespaceHandler ( ) { } @ Override public Cancellable execute ( NewOperationContext context , ModelNode operation , ResultHandler resultHandler ) { } @ Override public ModelNode getModelDescription ( Locale locale ) { } private String validate ( ModelNode param , ModelNode namespaces ) { String failure = typeValidator . validateParameter ( NAMESPACE , param ) ; String name = param . asProperty ( ) . getName ( ) ; <START_BUG> if ( ( failure == null ) && ( ! ( namespaces . isDefined ( ) ) ) ) { <END_BUG> for ( ModelNode node : namespaces . asList ( ) ) { if ( name . equals ( node . asProperty ( ) . getName ( ) ) ) { failure = ( ( "Namespace<seq2seq4repair_space>with<seq2seq4repair_space>prefix<seq2seq4repair_space>" + name ) + "<seq2seq4repair_space>already<seq2seq4repair_space>registered<seq2seq4repair_space>with<seq2seq4repair_space>schema<seq2seq4repair_space>URI<seq2seq4repair_space>" ) + ( node . asProperty ( ) . getValue ( ) . asString ( ) ) ; } } } return failure ; } } 
public class XQDTUriResolver implements IXQDTUriResolver { public URI resolveModuleImport ( URI baseUri , String uri , String [ ] hints ) { } public URI resolveUri ( URI baseUri , String uriString ) { } public ISourceModule locateSourceModule ( URI uri , IScriptProject project ) { IPath projectLoc = project . getProject ( ) . getLocation ( ) ; IPath path = new Path ( uri . getPath ( ) ) ; if ( projectLoc . isPrefixOf ( path ) ) { IPath packageAbolutePath = path . removeLastSegments ( 1 ) ; IPath packageRelativePath = packageAbolutePath . removeFirstSegments ( projectLoc . segmentCount ( ) ) . makeRelative ( ) . setDevice ( null ) ; IModelElement folder = null ; if ( ( packageRelativePath . segmentCount ( ) ) == 0 ) { folder = project ; } else { try { <START_BUG> folder = project . findScriptFolder ( packageRelativePath . makeAbsolute ( ) ) ; <END_BUG> } catch ( ModelException e ) { e . printStackTrace ( ) ; } } if ( folder != null ) { File f = new File ( path . toOSString ( ) ) ; if ( f . exists ( ) ) { return DLTKCore . createSourceModuleFrom ( ( ( IContainer ) ( folder . getResource ( ) ) ) . getFile ( new Path ( path . lastSegment ( ) ) ) ) ; } } } return null ; } } 
public final class XpandBackendFacade { private final String _xpandFile ; private final MiddleEnd _middleEnd ; private final String _fileEncoding ; private final Collection < MetaModel > _mms ; private final Collection < Outlet > _outlets ; private static Log log = LogFactory . getLog ( XpandBackendFacade . class ) ; public static Object executeStatement ( String code , Collection < MetaModel > mms , Map < String , Object > variables , Collection < Outlet > outlets , XpandProtectedRegionResolver resolver ) { } public static Object executeStatement ( String code , String fileEncoding , Collection < MetaModel > mms , Map < String , Object > variables , Collection < Outlet > outlets , XpandProtectedRegionResolver resolver ) { } public static Object executeStatement ( String code , String fileEncoding , Collection < MetaModel > mms , Map < String , Object > variables , Collection < Outlet > outlets , List < String > advice , XpandProtectedRegionResolver resolver ) { } public Object executeStatement ( String code , Map < String , Object > variables , List < String > advice , XpandProtectedRegionResolver resolver ) { } public static void registerOutlets ( ExecutionContext ctx , Collection < Outlet > outlets ) { } public static void registerProtectedRegionResolver ( ExecutionContext ctx , XpandProtectedRegionResolver resolver ) { } private static class InMemoryPpAdapter implements InMemoryPostprocessor { private final PostProcessor _oldPp ; private final Outlet _outlet ; public InMemoryPpAdapter ( PostProcessor oldPp , Outlet outlet ) { } public CharSequence process ( CharSequence unprocessed , String uri ) { } } private static class FileHandleImpl implements FileHandle { private CharSequence _buffer ; private final Outlet _outlet ; private final File _file ; public FileHandleImpl ( CharSequence buffer , Outlet outlet , File file ) { } public CharSequence getBuffer ( ) { } public String getFileEncoding ( ) { } public Outlet getOutlet ( ) { } public File getTargetFile ( ) { } public boolean isAppend ( ) { } public boolean isOverwrite ( ) { } public void setBuffer ( CharSequence buffer ) { } public void writeAndClose ( ) { } } private static class UriBasedPpAdapter implements UriBasedPostprocessor { private final PostProcessor _oldPp ; private final Outlet _outlet ; public UriBasedPpAdapter ( PostProcessor oldPp , Outlet outlet ) { } public void process ( String uri ) { } } public static XpandBackendFacade createForFile ( String xpandFilename , String fileEncoding , Collection < MetaModel > mms , Collection < Outlet > outlets ) { } private XpandExecutionContext createXpandExecutionContext ( String fileEncoding , Collection < MetaModel > mms , Collection < Outlet > outlets ) { fileEncoding = OldHelper . normalizedFileEncoding ( fileEncoding ) ; final Output output = new OutputImpl ( ) ; for ( Outlet outlet : outlets ) output . addOutlet ( outlet ) ; final XpandExecutionContextImpl ctx = new XpandExecutionContextImpl ( output , null ) ; for ( MetaModel mm : mms ) ctx . registerMetaModel ( mm ) ; <START_BUG> ctx . setFileEncoding ( fileEncoding ) ; <END_BUG> return ctx ; } private Map < Class < ? > , Object > createSpecificParameters ( String fileEncoding , Collection < MetaModel > mms , Collection < Outlet > outlets ) { } private XpandBackendFacade ( String xpandFilename , String fileEncoding , Collection < MetaModel > mms , Collection < Outlet > outlets ) { } public Collection < NamedFunction > getContributedFunctions ( ) { } public FunctionDefContext getFunctionDefContext ( ) { } } 
public class ActionExit extends UMLAction { public static ActionExit SINGLETON = new ActionExit ( ) ; private boolean active = false ; protected ActionExit ( ) { } public void actionPerformed ( ActionEvent ae ) { <START_BUG> ProjectBrowser pb = ProjectBrowser . TheInstance ; <END_BUG> Project p = ProjectManager . getManager ( ) . getCurrentProject ( ) ; if ( ( ( p != null ) && ( p . needsSave ( ) ) ) && ( ! ( active ) ) ) { active = true ; String t = MessageFormat . format ( Argo . localize ( "Actions" , "template.exit.save_changes_to" ) , new Object [ ] { p . getName ( ) } ) ; int response = JOptionPane . showConfirmDialog ( pb , t , t , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( response == ( JOptionPane . CANCEL_OPTION ) ) { active = false ; return ; } if ( response == ( JOptionPane . YES_OPTION ) ) { boolean safe = false ; if ( ActionSaveProject . SINGLETON . shouldBeEnabled ( ) ) { safe = ActionSaveProject . SINGLETON . trySave ( true ) ; } if ( ! safe ) { safe = ActionSaveProjectAs . SINGLETON . trySave ( false ) ; } if ( ! safe ) { active = false ; return ; } } active = false ; } if ( ! ( active ) ) { Configuration . save ( ) ; ArgoSecurityManager . getInstance ( ) . setAllowExit ( true ) ; System . exit ( 0 ) ; } } } 
public final class WorkbenchKeyboard { private static final boolean DEBUG = Policy . DEBUG_KEY_BINDINGS ; private static final boolean DEBUG_VERBOSE = Policy . DEBUG_KEY_BINDINGS_VERBOSE ; private static final int MULTI_KEY_ASSIST_SHELL_MAX_HEIGHT = 175 ; private static final int MULTI_KEY_ASSIST_SHELL_MAX_WIDTH = 300 ; static final String OUT_OF_ORDER_KEYS = "OutOfOrderKeys" ; static KeySequence outOfOrderKeys ; private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle . getBundle ( WorkbenchKeyboard . class . getName ( ) ) ; public static List generatePossibleKeyStrokes ( Event event ) { } private static void initializeOutOfOrderKeys ( ) { } private static boolean isOutOfOrderKey ( List keyStrokes ) { } private final IActivityManager activityManager ; private final ICommandManager commandManager ; private final Listener keyDownFilter = new Listener ( ) { public void handleEvent ( Event event ) { } } ; private Shell multiKeyAssistShell = null ; private long startTime = Long . MAX_VALUE ; private final KeyBindingState state ; private final IWindowListener windowListener = new IWindowListener ( ) { public void windowActivated ( IWorkbenchWindow window ) { } public void windowClosed ( IWorkbenchWindow window ) { } public void windowDeactivated ( IWorkbenchWindow window ) { } public void windowOpened ( IWorkbenchWindow window ) { } } ; private final IWorkbench workbench ; public WorkbenchKeyboard ( Workbench associatedWorkbench , IActivityManager associatedActivityManager , ICommandManager associatedCommandManager ) { } private void checkActiveWindow ( IWorkbenchWindow window ) { } private void closeMultiKeyAssistShell ( ) { } private static boolean isEnabled ( ICommand command ) { } private boolean executeCommand ( String commandId ) throws CommandException { } private void filterKeySequenceBindings ( Event event ) { } public Listener getKeyDownFilter ( ) { } private String getPerfectMatch ( KeySequence keySequence ) { } private void incrementState ( KeySequence sequence ) { } private boolean isPartialMatch ( KeySequence keySequence ) { } private boolean isPerfectMatch ( KeySequence keySequence ) { } private final void logException ( CommandException e ) { } private void openMultiKeyAssistShell ( final Display display ) { } public boolean press ( List potentialKeyStrokes , Event event ) throws CommandException { } void processKeyEvent ( List keyStrokes , Event event ) { boolean eatKey = false ; if ( ! ( keyStrokes . isEmpty ( ) ) ) { try { eatKey = press ( keyStrokes , event ) ; } catch ( CommandException e ) { logException ( e ) ; eatKey = true ; } } if ( eatKey ) { switch ( event . type ) { case SWT . KeyDown : event . doit = false ; break ; case SWT . Traverse : event . detail = SWT . TRAVERSE_NONE ; <START_BUG> event . doit = true ; <END_BUG> break ; default : } event . type = SWT . NONE ; } } private void resetState ( ) { } } 
public class TableJDBCSeq extends AbstractJDBCSeq implements Configurable { public static final String ACTION_DROP = "drop" ; public static final String ACTION_ADD = "add" ; public static final String ACTION_GET = "get" ; public static final String ACTION_SET = "set" ; public static final String DEFAULT_TABLE = "OPENJPA_SEQUENCE_TABLE" ; private static final Localizer _loc = Localizer . forPackage ( TableJDBCSeq . class ) ; private transient JDBCConfiguration _conf = null ; private transient Log _log = null ; private int _alloc = 50 ; private int _intValue = 1 ; private final HashMap < ClassMapping , TableJDBCSeq . Status > _stat = new HashMap < ClassMapping , TableJDBCSeq . Status > ( ) ; private String _table = TableJDBCSeq . DEFAULT_TABLE ; private String _seqColumnName = "SEQUENCE_VALUE" ; private String _pkColumnName = "ID" ; private String [ ] _uniqueColumnNames ; private String _uniqueConstraintName ; private Column _seqColumn = null ; private Column _pkColumn = null ; public String getTable ( ) { } public void setTable ( String name ) { } public void setTableName ( String name ) { } public String getSequenceColumn ( ) { } public void setSequenceColumn ( String sequenceColumn ) { } public String getPrimaryKeyColumn ( ) { } public void setPrimaryKeyColumn ( String primaryKeyColumn ) { } public int getAllocate ( ) { } public void setAllocate ( int alloc ) { } public int getInitialValue ( ) { } public void setInitialValue ( int intValue ) { } public void setUniqueColumns ( String columnNames ) { } public String getUniqueColumns ( ) { } public void setIncrement ( int inc ) { } public JDBCConfiguration getConfiguration ( ) { } public void setConfiguration ( Configuration conf ) { } public void startConfiguration ( ) { } public void endConfiguration ( ) { } public void addSchema ( ClassMapping mapping , SchemaGroup group ) { Schema [ ] schemas = group . getSchemas ( ) ; for ( int i = 0 ; i < ( schemas . length ) ; i ++ ) { String schemaName = Strings . getPackageName ( _table ) ; if ( ( schemaName . length ( ) ) == 0 ) schemaName = Schemas . getNewTableSchema ( _conf ) ; if ( schemaName == null ) schemaName = schemas [ i ] . getName ( ) ; Schema schema = group . getSchema ( schemaName ) ; if ( schema == null ) schema = group . addSchema ( schemaName ) ; Table copy = schema . importTable ( _pkColumn . getTable ( ) ) ; Unique [ ] uniques = _pkColumn . getTable ( ) . getUniques ( ) ; for ( Unique u : uniques ) { <START_BUG> copy . importUnique ( u , _conf . getDBDictionaryInstance ( ) ) ; <END_BUG> } _pkColumn . resetTableName ( ( ( schemaName + "." ) + ( _pkColumn . getTableName ( ) ) ) ) ; _conf . getDBDictionaryInstance ( ) . createIndexIfNecessary ( schema , _table , _pkColumn ) ; } } protected Object nextInternal ( JDBCStore store , ClassMapping mapping ) throws Exception { } protected Object currentInternal ( JDBCStore store , ClassMapping mapping ) throws Exception { } protected void allocateInternal ( int count , JDBCStore store , ClassMapping mapping ) throws SQLException { } protected TableJDBCSeq . Status getStatus ( ClassMapping mapping ) { } protected Column addPrimaryKeyColumn ( Table table ) { } protected Object getPrimaryKey ( ClassMapping mapping ) { } private void buildTable ( ) { } private void allocateSequence ( JDBCStore store , ClassMapping mapping , TableJDBCSeq . Status stat , int alloc , boolean updateStatSeq ) throws SQLException { } private void insertSequence ( ClassMapping mapping , Connection conn ) throws SQLException { } protected long getSequence ( ClassMapping mapping , Connection conn ) throws SQLException { } protected boolean setSequence ( ClassMapping mapping , TableJDBCSeq . Status stat , int inc , boolean updateStatSeq , Connection conn ) throws SQLException { } public String resolveTableName ( ClassMapping mapping , Table table ) { } public void refreshTable ( ) throws SQLException { } public void dropTable ( ) throws SQLException { } public static void main ( String [ ] args ) throws Exception { } public static boolean run ( JDBCConfiguration conf , String [ ] args , Options opts ) throws Exception { } public static boolean run ( JDBCConfiguration conf , String [ ] args , String action ) throws Exception { } protected static class Status implements Serializable { public long seq = 1L ; public long max = 0L ; } protected PreparedStatement prepareStatement ( Connection conn , SQLBuffer buf ) throws SQLException { } protected int executeUpdate ( JDBCConfiguration conf , Connection conn , PreparedStatement stmnt , SQLBuffer buf , int opcode ) throws SQLException { } protected ResultSet executeQuery ( JDBCConfiguration conf , Connection conn , PreparedStatement stmnt , SQLBuffer buf ) throws SQLException { } protected long getSequence ( ResultSet rs , DBDictionary dict ) throws SQLException { } public void setUniqueConstraintName ( String _uniqueConstraintName ) { } public String getUniqueConstraintName ( ) { } protected class AllocateSequenceRunnable implements Runnable { JDBCStore store = null ; ClassMapping mapping = null ; TableJDBCSeq . Status stat = null ; int alloc ; boolean updateStatSeq ; AllocateSequenceRunnable ( JDBCStore store , ClassMapping mapping , TableJDBCSeq . Status stat , int alloc , boolean updateStatSeq ) { } public void run ( ) throws RuntimeException { } } protected class CurrentSequenceRunnable implements Runnable { private JDBCStore _store ; private ClassMapping _mapping ; CurrentSequenceRunnable ( JDBCStore store , ClassMapping mapping ) { } public void run ( ) throws RuntimeException { } } } 
public class ShowInMenu extends ContributionItem implements IWorkbenchContribution { private static final String NO_TARGETS_MSG = WorkbenchMessages . Workbench_showInNoTargets ; private IWorkbenchWindow window ; private Map actions = new HashMap ( 21 ) ; private boolean dirty = true ; private IMenuListener menuListener = new IMenuListener ( ) { public void menuAboutToShow ( IMenuManager manager ) { } } ; private IServiceLocator locator ; private MenuManager currentManager ; public ShowInMenu ( ) { } public ShowInMenu ( IWorkbenchWindow window , String id ) { } public boolean isDirty ( ) { } public boolean isDynamic ( ) { } public void fill ( Menu menu , int index ) { } private void fillMenu ( IMenuManager innerMgr ) { } private IAction getAction ( IViewDescriptor desc ) { } private ArrayList getShowInPartIds ( IWorkbenchPart sourcePart ) { } private IWorkbenchPart getSourcePart ( ) { } private IShowInSource getShowInSource ( IWorkbenchPart sourcePart ) { } private IShowInTargetList getShowInTargetList ( IWorkbenchPart sourcePart ) { } private ShowInContext getContext ( IWorkbenchPart sourcePart ) { } private IViewDescriptor [ ] getViewDescriptors ( IWorkbenchPart sourcePart ) { } public void initialize ( IServiceLocator serviceLocator ) { } protected IWorkbenchWindow getWindow ( ) { } public void dispose ( ) { <START_BUG> if ( ( currentManager . getSize ( ) ) > 0 ) { <END_BUG> IMenuService service = ( ( IMenuService ) ( locator . getService ( IMenuService . class ) ) ) ; service . releaseContributions ( currentManager ) ; currentManager . removeAll ( ) ; } } } 
public class CreateFilterOnToAction extends AbstractColumbaAction implements SelectionListener { public CreateFilterOnToAction ( FrameMediator frameMediator ) { } public void actionPerformed ( ActionEvent evt ) { FolderCommandReference [ ] r = ( ( org . columba . mail . gui . frame . MailFrameMediator ) ( getFrameMediator ( ) ) ) . getTableSelection ( ) ; <START_BUG> CreateFilterOnMessageCommand c = new CreateFilterOnMessageCommand ( r , CreateFilterOnMessageCommand . FILTER_ON_TO ) ; <END_BUG> processor . addOp ( c ) ; } public void selectionChanged ( SelectionChangedEvent e ) { } } 
public abstract class Scrollable extends Control { int scrolledHandle ; ScrollBar horizontalBar ; ScrollBar verticalBar ; Scrollable ( ) { } public Scrollable ( Composite parent , int style ) { } int clientHandle ( ) { } public Rectangle computeTrim ( int x , int y , int width , int height ) { } ScrollBar createScrollBar ( int style ) { } void createWidget ( int index ) { } void deregister ( ) { } public int getBorderWidth ( ) { } public Rectangle getClientArea ( ) { } public ScrollBar getHorizontalBar ( ) { } public ScrollBar getVerticalBar ( ) { } int gtk_scroll_event ( int widget , int eventPtr ) { } int hScrollBarWidth ( ) { } void setOrientation ( ) { } boolean setScrollBarVisible ( ScrollBar bar , boolean visible ) { } void redrawBackgroundImage ( ) { } void redrawWidget ( int x , int y , int width , int height , boolean redrawAll , boolean all , boolean trim ) { } void register ( ) { } void releaseHandle ( ) { } void releaseChildren ( boolean destroy ) { } void resizeHandle ( int width , int height ) { } void showWidget ( ) { } int topHandle ( ) { } void updateScrollBarValue ( ScrollBar bar ) { <START_BUG> parent . redrawBackgroundImage ( ) ; <END_BUG> } int vScrollBarWidth ( ) { } } 
public class Launcher { public static final String ANTHOME_PROPERTY = MagicNames . ANT_HOME ; public static final String ANTLIBDIR_PROPERTY = "ant.library.dir" ; public static final String ANT_PRIVATEDIR = ".ant" ; public static final String ANT_PRIVATELIB = "lib" ; public static final String USER_LIBDIR = ( ( Launcher . ANT_PRIVATEDIR ) + ( File . separatorChar ) ) + ( Launcher . ANT_PRIVATELIB ) ; public static final String MAIN_CLASS = "org.apache.tools.ant.Main" ; public static final String USER_HOMEDIR = "user.home" ; private static final String JAVA_CLASS_PATH = "java.class.path" ; public static void main ( String [ ] args ) { } private void addPath ( String path , boolean getJars , List libPathURLs ) throws MalformedURLException { StringTokenizer tokenizer = new StringTokenizer ( path , File . pathSeparator ) ; while ( tokenizer . hasMoreElements ( ) ) { String elementName = tokenizer . nextToken ( ) ; File element = new File ( elementName ) ; if ( ( ( elementName . indexOf ( "%" ) ) != ( - 1 ) ) && ( ! ( element . exists ( ) ) ) ) { continue ; } if ( getJars && ( element . isDirectory ( ) ) ) { URL [ ] dirURLs = Locator . getLocationURLs ( element ) ; for ( int j = 0 ; j < ( dirURLs . length ) ; ++ j ) { libPathURLs . add ( dirURLs [ j ] ) ; } } try { <START_BUG> libPathURLs . add ( new URL ( Locator . encodeUri ( element . toURL ( ) . toString ( ) ) ) ) ; <END_BUG> } catch ( UnsupportedEncodingException ex ) { throw new MalformedURLException ( ex . toString ( ) ) ; } } } private void run ( String [ ] args ) throws MalformedURLException , LaunchException { } } 
protected void fireWindowDeactivated ( IWorkbenchWindow window ) { } private void addAdapters ( ) { } private boolean busyClose ( final boolean force ) { } public boolean saveAllEditors ( boolean confirm ) { } private IWorkbenchWindow busyOpenWorkbenchWindow ( String perspID , IAdaptable input ) throws WorkbenchException { } private void checkUpdates ( String [ ] commandLineArgs ) { } public boolean close ( ) { } public boolean close ( Object returnCode ) { } public boolean close ( Object returnCode , final boolean force ) { } protected WorkbenchActionBuilder createActionBuilder ( IWorkbenchWindow window ) { } private void connectToWorkspace ( ) { } private void disconnectFromWorkspace ( ) { } public IWorkbenchWindow getActiveWorkbenchWindow ( ) { } public String [ ] getCommandLineArgs ( ) { } public EditorHistory getEditorHistory ( ) { } public PerspectiveHistory getPerspectiveHistory ( ) { } public IEditorRegistry getEditorRegistry ( ) { } protected int getNewWindowNumber ( ) { } public IPerspectiveRegistry getPerspectiveRegistry ( ) { } public PreferenceManager getPreferenceManager ( ) { } public IPreferenceStore getPreferenceStore ( ) { } public ISharedImages getSharedImages ( ) { } public IMarkerHelpRegistry getMarkerHelpRegistry ( ) { } protected WindowManager getWindowManager ( ) { } public WorkbenchConfigurationInfo getConfigurationInfo ( ) { } private File getWorkbenchStateFile ( ) { } public int getWorkbenchWindowCount ( ) { } public IWorkbenchWindow [ ] getWorkbenchWindows ( ) { } public IWorkingSetManager getWorkingSetManager ( ) { } public void updateKeys ( ) { } private boolean init ( String [ ] commandLineArgs ) { } private void refreshFromLocal ( String [ ] commandLineArgs ) { } private void forceOpenPerspective ( String [ ] commandLineArgs ) { } private void initializeSingleClickOption ( ) { } private void initializeFonts ( ) { } private void initializeFont ( String fontKey , FontRegistry registry , IPreferenceStore store ) { } private void initializeProductImage ( ) { } public boolean isClosing ( ) { } public boolean isStarting ( ) { } protected WorkbenchWindow newWorkbenchWindow ( ) { } private void openFirstTimeWindow ( ) { } private int openPreviousWorkbenchState ( ) { } public IWorkbenchWindow openWorkbenchWindow ( IAdaptable input ) throws WorkbenchException { } public IWorkbenchWindow openWorkbenchWindow ( final String perspID , final IAdaptable input ) throws WorkbenchException { } private XMLMemento recordWorkbenchState ( ) { } public boolean restart ( ) { } private IStatus restoreState ( IMemento memento ) { MultiStatus result = new MultiStatus ( PlatformUI . PLUGIN_ID , IStatus . OK , WorkbenchMessages . getString ( "Workbench.problemsRestoring" ) , null ) ; IMemento childMem ; try { UIStats . start ( RESTORE_WORKBENCH , "PerspectiveHistory" ) ; childMem = memento . getChild ( TAG_PERSPECTIVE_HISTORY ) ; if ( childMem != null ) result . add ( getPerspectiveHistory ( ) . restoreState ( childMem ) ) ; } finally { UIStats . end ( RESTORE_WORKBENCH , "PerspectiveHistory" ) ; } try { UIStats . start ( RESTORE_WORKBENCH , "MRUList" ) ; IMemento mruMemento = memento . getChild ( TAG_MRU_LIST ) ; if ( mruMemento != null ) { result . add ( getEditorHistory ( ) . restoreState ( mruMemento ) ) ; } } finally { UIStats . end ( RESTORE_WORKBENCH , "MRUList" ) ; } IMemento [ ] children = memento . getChildren ( TAG_WINDOW ) ; IPerspectiveRegistry reg = WorkbenchPlugin . getDefault ( ) . getPerspectiveRegistry ( ) ; AboutInfo [ ] newFeaturesWithPerspectives = getConfigurationInfo ( ) . collectNewFeaturesWithPerspectives ( ) ; for ( int x = 0 ; x < ( children . length ) ; x ++ ) { childMem = children [ x ] ; WorkbenchWindow newWindow = newWorkbenchWindow ( ) ; newWindow . create ( ) ; IPerspectiveDescriptor desc = null ; if ( x < ( newFeaturesWithPerspectives . length ) ) desc = reg . findPerspectiveWithId ( newFeaturesWithPerspectives [ x ] . getWelcomePerspective ( ) ) ; result . merge ( newWindow . restoreState ( childMem , desc ) ) ; if ( desc != null ) { IWorkbenchPage page = newWindow . getActivePage ( ) ; if ( page == null ) { IWorkbenchPage [ ] pages = newWindow . getPages ( ) ; if ( ( pages != null ) && ( ( pages . length ) > 0 ) ) page = pages [ 0 ] ; } if ( page == null ) { IContainer root = WorkbenchPlugin . getPluginWorkspace ( ) . getRoot ( ) ; try { <START_BUG> page = ( ( WorkbenchPage ) ( getActiveWorkbenchWindow ( ) . openPage ( newFeaturesWithPerspectives [ x ] . getWelcomePerspective ( ) , root ) ) ) ; <END_BUG> } catch ( WorkbenchException e ) { result . add ( e . getStatus ( ) ) ; } } else { page . setPerspective ( desc ) ; } newWindow . setActivePage ( page ) ; try { page . openEditor ( new org . eclipse . ui . internal . dialogs . WelcomeEditorInput ( newFeaturesWithPerspectives [ x ] ) , Workbench . WELCOME_EDITOR_ID , true ) ; } catch ( PartInitException e ) { result . add ( e . getStatus ( ) ) ; } } windowManager . add ( newWindow ) ; newWindow . open ( ) ; } return result ; } public IPluginDescriptor [ ] getEarlyActivatedPlugins ( ) { } protected void startPlugins ( ) { } public Object run ( Object arg ) { } protected void runEventLoop ( Window . IExceptionHandler handler ) { } private IStatus saveState ( IMemento memento ) { } private boolean saveWorkbenchState ( XMLMemento memento ) { } public void setInitializationData ( IConfigurationElement configElement , String propertyName , Object data ) { } public IWorkbenchPage showPerspective ( String perspectiveId , IWorkbenchWindow window ) throws WorkbenchException { } public IWorkbenchPage showPerspective ( String perspectiveId , IWorkbenchWindow window , IAdaptable input ) throws WorkbenchException { } private void shutdown ( ) { } public void refreshPluginActions ( String pluginId ) { } public IDecoratorManager getDecoratorManager ( ) { } } 
public class ShutdownManager { Vector list ; public ShutdownManager ( ) { } public void register ( ShutdownPluginInterface plugin ) { } public void shutdown ( ) { for ( int i = 0 ; i < ( list . size ( ) ) ; i ++ ) { ShutdownPluginInterface plugin = ( ( ShutdownPluginInterface ) ( list . get ( i ) ) ) ; <START_BUG> plugin . run ( ) ; <END_BUG> } System . exit ( 1 ) ; } } 
public class StompMessageConverter { private static final Charset STOMP_CHARSET = Charset . forName ( "UTF-8" ) ; public static final byte LF = 10 ; public static final byte CR = 13 ; private static final byte COLON = ':' ; public Message < ? > toMessage ( Object stompContent ) { } private int findIndexOfPayload ( byte [ ] bytes ) { } public byte [ ] fromMessage ( Message < ? > message ) { byte [ ] payload ; if ( ( message . getPayload ( ) ) instanceof byte [ ] ) { payload = ( ( byte [ ] ) ( message . getPayload ( ) ) ) ; } else { throw new IllegalArgumentException ( ( "stompContent<seq2seq4repair_space>is<seq2seq4repair_space>not<seq2seq4repair_space>byte[]:<seq2seq4repair_space>" + ( message . getPayload ( ) . getClass ( ) ) ) ) ; } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; StompHeaderAccessor stompHeaders = StompHeaderAccessor . wrap ( message ) ; try { out . write ( stompHeaders . getCommand ( ) . toString ( ) . getBytes ( "UTF-8" ) ) ; out . write ( StompMessageConverter . LF ) ; <START_BUG> for ( Map . Entry < String , List < String > > entry : stompHeaders . toNativeHeaderMap ( ) . entrySet ( ) ) { <END_BUG> String key = entry . getKey ( ) ; key = replaceAllOutbound ( key ) ; for ( String value : entry . getValue ( ) ) { out . write ( key . getBytes ( "UTF-8" ) ) ; out . write ( StompMessageConverter . COLON ) ; value = replaceAllOutbound ( value ) ; out . write ( value . getBytes ( "UTF-8" ) ) ; out . write ( StompMessageConverter . LF ) ; } } out . write ( StompMessageConverter . LF ) ; out . write ( payload ) ; out . write ( 0 ) ; return out . toByteArray ( ) ; } catch ( IOException e ) { throw new StompConversionException ( ( "Failed<seq2seq4repair_space>to<seq2seq4repair_space>serialize<seq2seq4repair_space>" + message ) , e ) ; } } private String replaceAllOutbound ( String key ) { } private class Parser { private final String content ; private int offset ; public Parser ( String content ) { } public boolean hasNext ( ) { } public String nextToken ( byte delimiter ) { } } } 
public class ParseStuff { private static boolean useNodeParser ; public static void main ( String [ ] args ) throws RecognitionException { } public static void parseWithNodeParser ( String s ) throws RecognitionException { ANTLRStringStream stream = new ANTLRStringStream ( s ) ; Xpand3NodeLexer lexer = new Xpand3NodeLexer ( stream ) ; CommonTokenStream tokenStream = new CommonTokenStream ( lexer ) ; Xpand3NodeParser xpand3NodeParser = new Xpand3NodeParser ( tokenStream ) ; <START_BUG> Node rootNode = xpand3NodeParser . file ( ) ; <END_BUG> Node2AstTransformer node2AstTransformer = new Node2AstTransformer ( ) ; node2AstTransformer . doSwitch ( rootNode ) ; } private static void checkFor ( int extensions ) throws RecognitionException { } } 
public class Jdk14RegexpRegexp extends Jdk14RegexpMatcher implements Regexp { public Jdk14RegexpRegexp ( ) { } protected int getSubsOptions ( int options ) { } public String substitute ( String input , String argument , int options ) throws BuildException { StringBuffer subst = new StringBuffer ( ) ; for ( int i = 0 ; i < ( argument . length ( ) ) ; i ++ ) { char c = argument . charAt ( i ) ; if ( c == '\\' ) { if ( ( ++ i ) < ( argument . length ( ) ) ) { c = argument . charAt ( i ) ; int value = Character . digit ( c , 10 ) ; if ( value > ( - 1 ) ) { <START_BUG> subst . append ( "$(" ) . append ( value ) . append ( ")" ) ; <END_BUG> } else { subst . append ( c ) ; } } else { subst . append ( '\\' ) ; } } else { subst . append ( c ) ; } } argument = subst . toString ( ) ; int sOptions = getSubsOptions ( options ) ; Pattern p = getCompiledPattern ( options ) ; StringBuffer sb = new StringBuffer ( ) ; Matcher m = p . matcher ( input ) ; if ( RegexpUtil . hasFlag ( sOptions , REPLACE_ALL ) ) { sb . append ( m . replaceAll ( argument ) ) ; } else { boolean res = m . find ( ) ; if ( res ) { m . appendReplacement ( sb , argument ) ; m . appendTail ( sb ) ; } else { sb . append ( input ) ; } } return sb . toString ( ) ; } } 
